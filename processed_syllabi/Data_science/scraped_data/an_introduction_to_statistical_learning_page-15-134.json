{
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "text": "0 50 100 200 300 5 10 15 20 25 TV Sales 0 10 20 30 40 50 5 10 15 20 25 Radio Sales 0 20 40 60 80 100 5 10 15 20 25 Newspaper Sales FIGURE 2.1. The Advertising data set. The plot displays sales , in thousands of units, as a function of TV , radio , and newspaper budgets, in thousands of dollars, for 200 different markets. In each plot we show the simple least squares fit of sales to that variable, as described in Chapter 3 . In other words, each blue line represents a simple model that can be used to predict sales using TV , radio , and newspaper , respectively. Here f is some fixed but unknown function of X 1 , . . . , X p , and ϵ is a random error term , which is independent of X and has mean zero. In this formula- error term tion, f represents the systematic information that X provides about Y . systematic 10 12 14 16 18 20 22 20 30 40 50 60 70 80 Years of Education Income 10 12 14 16 18 20 22 20 30 40 50 60 70 80 Years of Education Income FIGURE 2.2. The Income data set. Left: The red dots are the observed values of income (in thousands of dollars) and years of education for 30 individuals. Right: The blue curve represents the true underlying relationship between income and years of education , which is generally unknown (but is known in this case because the data were simulated). The black lines represent the error associated with each observation. Note that some errors are positive (if an observation lies above the blue curve) and some are negative (if an observation lies below the curve). Overall, these errors have approximately mean zero. As another example, consider the left-hand panel of Figure 2.2 , a plot of income versus years of education for 30 individuals in the Income data set. The plot suggests that one might be able to predict income using years of education . However, the function f that connects the input variable to the \noutput variable is in general unknown. In this situation one must estimate f based on the observed points. Since Income is a simulated data set, f is known and is shown by the blue curve in the right-hand panel of Figure 2.2 . The vertical lines represent the error terms ϵ . We note that some of the 30 observations lie above the blue curve and some lie below it; overall, the errors have approximately mean zero. In general, the function f may involve more than one input variable. In Figure 2.3 we plot income as a function of years of education and seniority . Here f is a two-dimensional surface that must be estimated based on the observed data. In essence, statistical learning refers to a set of approaches for estimating f . In this chapter we outline some of the key theoretical concepts that arise in estimating f , as well as tools for evaluating the estimates obtained. 2.1.1 Why Estimate f ? There are two main reasons that we may wish to estimate f : prediction and inference . We discuss each in turn. Prediction In many situations, a set of inputs X are readily available, but the output Y cannot be easily obtained. In this setting, since the error term averages to zero, we can predict Y using ˆ Y = ˆ f ( X ) , (2.2) where ˆ f represents our estimate for f , and ˆ Y represents the resulting pre- diction for Y . In this setting, ˆ f is often treated as a black box , in the sense that one is not typically concerned with the exact form of ˆ f , provided that it yields accurate predictions for Y . As an example, suppose that X 1 , . . . , X p are characteristics of a patient’s blood sample that can be easily measured in a lab, and Y is a variable encoding the patient’s risk for a severe adverse reaction to a particular drug. It is natural to seek to predict Y using X , since we can then avoid giving the drug in question to patients who are at high risk of an adverse reaction—that is, patients for whom the estimate of Y is high. The accuracy of ˆ Y as a prediction for Y depends on two quantities, which we will call the reducible error and the irreducible error . In general, reducible error irreducible error ˆ f will not be a perfect estimate for f , and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracy of ˆ f by using the most appropriate statistical learning technique to estimate f . However, even if it were possible to form a perfect estimate for f , so that our estimated response took the form ˆ Y = f ( X ) , our prediction would still have some error in it! This is because Y is also a function of ϵ , which, by definition, cannot be predicted using X . Therefore, variability associated with ϵ also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate f , we cannot reduce the error introduced by ϵ . Why is the irreducible error larger than zero? The quantity ϵ may con- tain unmeasured variables that are useful in predicting Y : since we don’t \nYears of Education Seniority Income FIGURE 2.3. The plot displays income as a function of years of education and seniority in the Income data set. The blue surface represents the true underlying relationship between income and years of education and seniority , which is known since the data are simulated. The red dots indicate the observed values of these quantities for 30 individuals. measure them, f cannot use them for its prediction. The quantity ϵ may also contain unmeasurable variation. For example, the risk of an adverse reaction might vary for a given patient on a given day, depending on manufacturing variation in the drug itself or the patient’s general feeling of well-being on that day. Consider a given estimate ˆ f and a set of predictors X , which yields the prediction ˆ Y = ˆ f ( X ) . Assume for a moment that both ˆ f and X are fixed, so that the only variability comes from ϵ . Then, it is easy to show that E( Y − ˆ Y ) 2 = E[ f ( X ) + ϵ − ˆ f ( X )] 2 = [ f ( X ) − ˆ f ( X )] 2 , - . / Reducible + Var( ϵ ) , -. / Irreducible , (2.3) where E( Y − ˆ Y ) 2 represents the average, or expected value , of the squared expected value difference between the predicted and actual value of Y , and Var( ϵ ) repre- sents the variance associated with the error term ϵ . variance The focus of this book is on techniques for estimating f with the aim of minimizing the reducible error. It is important to keep in mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for Y . This bound is almost always unknown in practice. Inference We are often interested in understanding the association between Y and X 1 , . . . , X p . In this situation we wish to estimate f , but our goal is not necessarily to make predictions for Y . Now ˆ f cannot be treated as a black box, because we need to know its exact form. In this setting, one may be interested in answering the following questions: \n• Which predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with Y . Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application. • What is the relationship between the response and each predictor? Some predictors may have a positive relationship with Y , in the sense that larger values of the predictor are associated with larger values of Y . Other predictors may have the opposite relationship. Depending on the complexity of f , the relationship between the response and a given predictor may also depend on the values of the other predictors. • Can the relationship between Y and each predictor be adequately sum- marized using a linear equation, or is the relationship more compli- cated? Historically, most methods for estimating f have taken a linear form. In some situations, such an assumption is reasonable or even de- sirable. But often the true relationship is more complicated, in which case a linear model may not provide an accurate representation of the relationship between the input and output variables. In this book, we will see a number of examples that fall into the prediction setting, the inference setting, or a combination of the two. For instance, consider a company that is interested in conducting a direct-marketing campaign. The goal is to identify individuals who are likely to respond positively to a mailing, based on observations of demo- graphic variables measured on each individual. In this case, the demo- graphic variables serve as predictors, and response to the marketing cam- paign (either positive or negative) serves as the outcome. The company is not interested in obtaining a deep understanding of the relationships be- tween each individual predictor and the response; instead, the company simply wants to accurately predict the response using the predictors. This is an example of modeling for prediction. In contrast, consider the Advertising data illustrated in Figure 2.1 . One may be interested in answering questions such as: – Which media are associated with sales? – Which media generate the biggest boost in sales? or – How large of an increase in sales is associated with a given increase in TV advertising? This situation falls into the inference paradigm. Another example involves modeling the brand of a product that a customer might purchase based on variables such as price, store location, discount levels, competition price, and so forth. In this situation one might really be most interested in the association between each variable and the probability of purchase. For in- stance, to what extent is the product’s price associated with sales? This is an example of modeling for inference. Finally, some modeling could be conducted both for prediction and in- ference. For example, in a real estate setting, one may seek to relate values \nof homes to inputs such as crime rate, zoning, distance from a river, air quality, schools, income level of community, size of houses, and so forth. In this case one might be interested in the association between each individ- ual input variable and housing price—for instance, how much extra will a house be worth if it has a view of the river? This is an inference problem. Alternatively, one may simply be interested in predicting the value of a home given its characteristics: is this house under- or over-valued? This is a prediction problem. Depending on whether our ultimate goal is prediction, inference, or a combination of the two, different methods for estimating f may be ap- propriate. For example, linear models allow for relatively simple and in- linear model terpretable inference, but may not yield as accurate predictions as some other approaches. In contrast, some of the highly non-linear approaches that we discuss in the later chapters of this book can potentially provide quite accurate predictions for Y , but this comes at the expense of a less interpretable model for which inference is more challenging. 2.1.2 How Do We Estimate f ? Throughout this book, we explore many linear and non-linear approaches for estimating f . However, these methods generally share certain charac- teristics. We provide an overview of these shared characteristics in this section. We will always assume that we have observed a set of n different data points. For example in Figure 2.2 we observed n = 30 data points. These observations are called the training data because we will use these training data observations to train, or teach, our method how to estimate f . Let x ij represent the value of the j th predictor, or input, for observation i , where i = 1 , 2 , . . . , n and j = 1 , 2 , . . . , p . Correspondingly, let y i represent the response variable for the i th observation. Then our training data consist of { ( x 1 , y 1 ) , ( x 2 , y 2 ) , . . . , ( x n , y n ) } where x i = ( x i 1 , x i 2 , . . . , x ip ) T . Our goal is to apply a statistical learning method to the training data in order to estimate the unknown function f . In other words, we want to find a function ˆ f such that Y ≈ ˆ f ( X ) for any observation ( X, Y ) . Broadly speaking, most statistical learning methods for this task can be character- ized as either parametric or non-parametric . We now briefly discuss these parametric non- parametric two types of approaches. Parametric Methods Parametric methods involve a two-step model-based approach. 1. First, we make an assumption about the functional form, or shape, of f . For example, one very simple assumption is that f is linear in X : f ( X ) = β 0 + β 1 X 1 + β 2 X 2 + · · · + β p X p . (2.4) This is a linear model , which will be discussed extensively in Chap- ter 3 . Once we have assumed that f is linear, the problem of estimat- ing f is greatly simplified. Instead of having to estimate an entirely arbitrary p -dimensional function f ( X ) , one only needs to estimate the p + 1 coefficients β 0 , β 1 , . . . , β p . \nYears of Education Seniority Income FIGURE 2.4. A linear model fit by least squares to the Income data from Figure 2.3 . The observations are shown in red, and the yellow plane indicates the least squares fit to the data. 2. After a model has been selected, we need a procedure that uses the training data to fit or train the model. In the case of the linear model fit train ( 2.4 ), we need to estimate the parameters β 0 , β 1 , . . . , β p . That is, we want to find values of these parameters such that Y ≈ β 0 + β 1 X 1 + β 2 X 2 + · · · + β p X p . The most common approach to fitting the model ( 2.4 ) is referred to as (ordinary) least squares , which we discuss in Chapter 3 . However, least squares least squares is one of many possible ways to fit the linear model. In Chapter 6 , we discuss other approaches for estimating the parameters in ( 2.4 ). The model-based approach just described is referred to as parametric ; it reduces the problem of estimating f down to one of estimating a set of parameters. Assuming a parametric form for f simplifies the problem of estimating f because it is generally much easier to estimate a set of pa- rameters, such as β 0 , β 1 , . . . , β p in the linear model ( 2.4 ), than it is to fit an entirely arbitrary function f . The potential disadvantage of a paramet- ric approach is that the model we choose will usually not match the true unknown form of f . If the chosen model is too far from the true f , then our estimate will be poor. We can try to address this problem by choos- ing flexible models that can fit many different possible functional forms flexible for f . But in general, fitting a more flexible model requires estimating a greater number of parameters. These more complex models can lead to a phenomenon known as overfitting the data, which essentially means they overfitting follow the errors, or noise , too closely. These issues are discussed through- noise out this book. Figure 2.4 shows an example of the parametric approach applied to the Income data from Figure 2.3 . We have fit a linear model of the form income ≈ β 0 + β 1 × education + β 2 × seniority . \nYears of Education Seniority Income FIGURE 2.5. A smooth thin-plate spline fit to the Income data from Figure 2.3 is shown in yellow; the observations are displayed in red. Splines are discussed in Chapter 7 . Since we have assumed a linear relationship between the response and the two predictors, the entire fitting problem reduces to estimating β 0 , β 1 , and β 2 , which we do using least squares linear regression. Comparing Figure 2.3 to Figure 2.4 , we can see that the linear fit given in Figure 2.4 is not quite right: the true f has some curvature that is not captured in the linear fit. However, the linear fit still appears to do a reasonable job of capturing the positive relationship between years of education and income , as well as the slightly less positive relationship between seniority and income . It may be that with such a small number of observations, this is the best we can do. Non-Parametric Methods Non-parametric methods do not make explicit assumptions about the func- tional form of f . Instead they seek an estimate of f that gets as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric approaches: by avoiding the assumption of a particular functional form for f , they have the potential to accurately fit a wider range of possible shapes for f . Any parametric approach brings with it the possibility that the functional form used to estimate f is very different from the true f , in which case the resulting model will not fit the data well. In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form of f is made. But non-parametric approaches do suffer from a major disadvantage: since they do not reduce the problem of estimating f to a small number of parameters, a very large number of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for f . An example of a non-parametric approach to fitting the Income data is shown in Figure 2.5 . A thin-plate spline is used to estimate f . This ap- thin-plate spline proach does not impose any pre-specified model on f . It instead attempts \nYears of Education Seniority Income FIGURE 2.6. A rough thin-plate spline fit to the Income data from Figure 2.3 . This fit makes zero errors on the training data. to produce an estimate for f that is as close as possible to the observed data, subject to the fit—that is, the yellow surface in Figure 2.5 —being smooth . In this case, the non-parametric fit has produced a remarkably ac- curate estimate of the true f shown in Figure 2.3 . In order to fit a thin-plate spline, the data analyst must select a level of smoothness. Figure 2.6 shows the same thin-plate spline fit using a lower level of smoothness, allowing for a rougher fit. The resulting estimate fits the observed data perfectly! However, the spline fit shown in Figure 2.6 is far more variable than the true function f , from Figure 2.3 . This is an example of overfitting the data, which we discussed previously. It is an undesirable situation because the fit obtained will not yield accurate estimates of the response on new observations that were not part of the original training data set. We dis- cuss methods for choosing the correct amount of smoothness in Chapter 5 . Splines are discussed in Chapter 7 . As we have seen, there are advantages and disadvantages to parametric and non-parametric methods for statistical learning. We explore both types of methods throughout this book. 2.1.3 The Trade-Off Between Prediction Accuracy and Model Interpretability Of the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate f . For example, linear regression is a relatively inflexible approach, because it can only generate linear functions such as the lines shown in Figure 2.1 or the plane shown in Figure 2.4 . Other methods, such as the thin plate splines shown in Figures 2.5 and 2.6 , are considerably more flexible because they can generate a much wider range of possible shapes to estimate f . \nFlexibility Interpretability Low High Low High Subset Selection Lasso Least Squares Generalized Additive Models Trees Bagging, Boosting Support Vector Machines Deep Learning FIGURE 2.7. A representation of the tradeoff between flexibility and inter- pretability, using different statistical learning methods. In general, as the flexibility of a method increases, its interpretability decreases. One might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very flexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inference, then restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between Y and X 1 , X 2 , . . . , X p . In contrast, very flexible approaches, such as the splines discussed in Chapter 7 and displayed in Figures 2.5 and 2.6 , and the boosting methods discussed in Chapter 8 , can lead to such complicated estimates of f that it is difficult to understand how any individual predictor is associated with the response. Figure 2.7 provides an illustration of the trade-off between flexibility and interpretability for some of the methods that we cover in this book. Least squares linear regression, discussed in Chapter 3 , is relatively inflexible but is quite interpretable. The lasso , discussed in Chapter 6 , relies upon the lasso linear model ( 2.4 ) but uses an alternative fitting procedure for estimating the coefficients β 0 , β 1 , . . . , β p . The new procedure is more restrictive in es- timating the coefficients, and sets a number of them to exactly zero. Hence in this sense the lasso is a less flexible approach than linear regression. It is also more interpretable than linear regression, because in the final model the response variable will only be related to a small subset of the predictors—namely, those with nonzero coefficient estimates. Generalized additive models (GAMs), discussed in Chapter 7 , instead extend the lin- generalized additive model ear model ( 2.4 ) to allow for certain non-linear relationships. Consequently, GAMs are more flexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve. Finally, fully non-linear methods such as bagging , boosting , support vector machines bagging boosting with non-linear kernels, and neural networks (deep learning), discussed in support vector machine Chapters 8 , 9 , and 10 , are highly flexible approaches that are harder to interpret. \nWe have established that when inference is the goal, there are clear ad- vantages to using simple and relatively inflexible statistical learning meth- ods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is simply not of interest. For instance, if we seek to develop an algorithm to predict the price of a stock, our sole requirement for the algorithm is that it predict accurately— interpretability is not a concern. In this setting, we might expect that it will be best to use the most flexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a less flexible method. This phenomenon, which may seem counterintu- itive at first glance, has to do with the potential for overfitting in highly flexible methods. We saw an example of overfitting in Figure 2.6 . We will discuss this very important concept further in Section 2.2 and throughout this book. 2.1.4 Supervised Versus Unsupervised Learning Most statistical learning problems fall into one of two categories: supervised supervised or unsupervised . The examples that we have discussed so far in this chap- unsupervised ter all fall into the supervised learning domain. For each observation of the predictor measurement(s) x i , i = 1 , . . . , n there is an associated response measurement y i . We wish to fit a model that relates the response to the predictors, with the aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the response and the predictors (inference). Many classical statistical learn- ing methods such as linear regression and logistic regression (Chapter 4 ), as logistic regression well as more modern approaches such as GAM, boosting, and support vec- tor machines, operate in the supervised learning domain. The vast majority of this book is devoted to this setting. By contrast, unsupervised learning describes the somewhat more chal- lenging situation in which for every observation i = 1 , . . . , n , we observe a vector of measurements x i but no associated response y i . It is not pos- sible to fit a linear regression model, since there is no response variable to predict. In this setting, we are in some sense working blind; the sit- uation is referred to as unsupervised because we lack a response vari- able that can supervise our analysis. What sort of statistical analysis is possible? We can seek to understand the relationships between the variables or between the observations. One statistical learning tool that we may use in this setting is cluster analysis , or clustering. The goal of cluster analysis cluster analysis is to ascertain, on the basis of x 1 , . . . , x n , whether the observations fall into relatively distinct groups. For example, in a market segmentation study we might observe multiple characteristics (variables) for potential customers, such as zip code, family income, and shopping habits. We might believe that the customers fall into different groups, such as big spenders versus low spenders. If the information about each customer’s spending patterns were available, then a supervised analysis would be possible. However, this information is not available—that is, we do not know whether each poten- tial customer is a big spender or not. In this setting, we can try to cluster the customers on the basis of the variables measured, in order to identify \n0 2 4 6 8 10 12 2 4 6 8 10 12 0 2 4 6 2 4 6 8 X 1 X 1 X 2 X 2 FIGURE 2.8. A clustering data set involving three groups. Each group is shown using a different colored symbol. Left: The three groups are well-separated. In this setting, a clustering approach should successfully identify the three groups. Right: There is some overlap among the groups. Now the clustering task is more challenging. distinct groups of potential customers. Identifying such groups can be of interest because it might be that the groups differ with respect to some property of interest, such as spending habits. Figure 2.8 provides a simple illustration of the clustering problem. We have plotted 150 observations with measurements on two variables, X 1 and X 2 . Each observation corresponds to one of three distinct groups. For illustrative purposes, we have plotted the members of each group using different colors and symbols. However, in practice the group memberships are unknown, and the goal is to determine the group to which each obser- vation belongs. In the left-hand panel of Figure 2.8 , this is a relatively easy task because the groups are well-separated. By contrast, the right-hand panel illustrates a more challenging setting in which there is some overlap between the groups. A clustering method could not be expected to assign all of the overlapping points to their correct group (blue, green, or orange). In the examples shown in Figure 2.8 , there are only two variables, and so one can simply visually inspect the scatterplots of the observations in order to identify clusters. However, in practice, we often encounter data sets that contain many more than two variables. In this case, we cannot easily plot the observations. For instance, if there are p variables in our data set, then p ( p − 1) / 2 distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, automated clustering methods are important. We discuss clustering and other unsupervised learning approaches in Chapter 12 . Many problems fall naturally into the supervised or unsupervised learn- ing paradigms. However, sometimes the question of whether an analysis should be considered supervised or unsupervised is less clear-cut. For in- stance, suppose that we have a set of n observations. For m of the observa- tions, where m < n , we have both predictor measurements and a response \nmeasurement. For the remaining n − m observations, we have predictor measurements but no response measurement. Such a scenario can arise if the predictors can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as a semi-supervised learning problem. In this setting, we wish to use a sta- semi- supervised learning tistical learning method that can incorporate the m observations for which response measurements are available as well as the n − m observations for which they are not. Although this is an interesting topic, it is beyond the scope of this book. 2.1.5 Regression Versus Classification Problems Variables can be characterized as either quantitative or qualitative (also quantitative qualitative known as categorical ). Quantitative variables take on numerical values. Ex- categorical amples include a person’s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on values in one of K different classes , or categories. Examples of qualitative variables class include a person’s marital status (married or not), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lym- phoblastic Leukemia, or No Leukemia). We tend to refer to problems with a quantitative response as regression problems, while those involving a regression qualitative response are often referred to as classification problems. How- classification ever, the distinction is not always that crisp. Least squares linear regression (Chapter 3 ) is used with a quantitative response, whereas logistic regression (Chapter 4 ) is typically used with a qualitative (two-class, or binary ) re- binary sponse. Thus, despite its name, logistic regression is a classification method. But since it estimates class probabilities, it can be thought of as a regres- sion method as well. Some statistical methods, such as K -nearest neighbors (Chapters 2 and 4 ) and boosting (Chapter 8 ), can be used in the case of either quantitative or qualitative responses. We tend to select statistical learning methods on the basis of whether the response is quantitative or qualitative; i.e. we might use linear regres- sion when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or quantitative is generally consid- ered less important. Most of the statistical learning methods discussed in this book can be applied regardless of the predictor variable type, provided that any qualitative predictors are properly coded before the analysis is performed. This is discussed in Chapter 3 . 2.2 Assessing Model Accuracy One of the key aims of this book is to introduce the reader to a wide range of statistical learning methods that extend far beyond the standard linear regression approach. Why is it necessary to introduce so many different statistical learning approaches, rather than just a single best method? There is no free lunch in statistics: no one method dominates all others over all possible data sets. On a particular data set, one specific method may work \nbest, but some other method may work better on a similar but different data set. Hence it is an important task to decide for any given set of data which method produces the best results. Selecting the best approach can be one of the most challenging parts of performing statistical learning in practice. In this section, we discuss some of the most important concepts that arise in selecting a statistical learning procedure for a specific data set. As the book progresses, we will explain how the concepts presented here can be applied in practice. 2.2.1 Measuring the Quality of Fit In order to evaluate the performance of a statistical learning method on a given data set, we need some way to measure how well its predictions actually match the observed data. That is, we need to quantify the extent to which the predicted response value for a given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure is the mean squared error (MSE), given by mean squared error MSE = 1 n n 0 i =1 ( y i − ˆ f ( x i )) 2 , (2.5) where ˆ f ( x i ) is the prediction that ˆ f gives for the i th observation. The MSE will be small if the predicted responses are very close to the true responses, and will be large if for some of the observations, the predicted and true responses differ substantially. The MSE in ( 2.5 ) is computed using the training data that was used to fit the model, and so should more accurately be referred to as the training MSE . But in general, we do not really care how well the method works training MSE on the training data. Rather, we are interested in the accuracy of the pre- dictions that we obtain when we apply our method to previously unseen test data . Why is this what we care about? Suppose that we are interested test data in developing an algorithm to predict a stock’s price based on previous stock returns. We can train the method using stock returns from the past 6 months. But we don’t really care how well our method predicts last week’s stock price. We instead care about how well it will predict tomorrow’s price or next month’s price. On a similar note, suppose that we have clinical measurements (e.g. weight, blood pressure, height, age, family history of disease) for a number of patients, as well as information about whether each patient has diabetes. We can use these patients to train a statistical learn- ing method to predict risk of diabetes based on clinical measurements. In practice, we want this method to accurately predict diabetes risk for future patients based on their clinical measurements. We are not very interested in whether or not the method accurately predicts diabetes risk for patients used to train the model, since we already know which of those patients have diabetes. To state it more mathematically, suppose that we fit our statistical learn- ing method on our training observations { ( x 1 , y 1 ) , ( x 2 , y 2 ) , . . . , ( x n , y n ) } , and we obtain the estimate ˆ f . We can then compute ˆ f ( x 1 ) , ˆ f ( x 2 ) , . . . , ˆ f ( x n ) . \n0 20 40 60 80 100 2 4 6 8 10 12 X Y 2 5 10 20 0.0 0.5 1.0 1.5 2.0 2.5 Flexibility Mean Squared Error FIGURE 2.9. Left: Data simulated from f , shown in black. Three estimates of f are shown: the linear regression line (orange curve), and two smoothing spline fits (blue and green curves). Right: Training MSE (grey curve), test MSE (red curve), and minimum possible test MSE over all methods (dashed line). Squares represent the training and test MSEs for the three fits shown in the left-hand panel. If these are approximately equal to y 1 , y 2 , . . . , y n , then the training MSE given by ( 2.5 ) is small. However, we are really not interested in whether ˆ f ( x i ) ≈ y i ; instead, we want to know whether ˆ f ( x 0 ) is approximately equal to y 0 , where ( x 0 , y 0 ) is a previously unseen test observation not used to train the statistical learning method . We want to choose the method that gives the lowest test MSE , as opposed to the lowest training MSE. In other words, test MSE if we had a large number of test observations, we could compute Ave ( y 0 − ˆ f ( x 0 )) 2 , (2.6) the average squared prediction error for these test observations ( x 0 , y 0 ) . We’d like to select the model for which this quantity is as small as possible. How can we go about trying to select a method that minimizes the test MSE? In some settings, we may have a test data set available—that is, we may have access to a set of observations that were not used to train the statistical learning method. We can then simply evaluate ( 2.6 ) on the test observations, and select the learning method for which the test MSE is smallest. But what if no test observations are available? In that case, one might imagine simply selecting a statistical learning method that minimizes the training MSE ( 2.5 ). This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger. Figure 2.9 illustrates this phenomenon on a simple example. In the left- hand panel of Figure 2.9 , we have generated observations from ( 2.1 ) with \nthe true f given by the black curve. The orange, blue and green curves illus- trate three possible estimates for f obtained using methods with increasing levels of flexibility. The orange line is the linear regression fit, which is rela- tively inflexible. The blue and green curves were produced using smoothing splines , discussed in Chapter 7 , with different levels of smoothness. It is smoothing spline clear that as the level of flexibility increases, the curves fit the observed data more closely. The green curve is the most flexible and matches the data very well; however, we observe that it fits the true f (shown in black) poorly because it is too wiggly. By adjusting the level of flexibility of the smoothing spline fit, we can produce many different fits to this data. We now move on to the right-hand panel of Figure 2.9 . The grey curve displays the average training MSE as a function of flexibility, or more formally the degrees of freedom , for a number of smoothing splines. The degrees of freedom degrees of freedom is a quantity that summarizes the flexibility of a curve; it is discussed more fully in Chapter 7 . The orange, blue and green squares indicate the MSEs associated with the corresponding curves in the left- hand panel. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve—note that in Figure 2.9 , linear regression is at the most restrictive end, with two degrees of freedom. The training MSE declines monotonically as flexibility increases. In this example the true f is non-linear, and so the orange linear fit is not flexible enough to estimate f well. The green curve has the lowest training MSE of all three methods, since it corresponds to the most flexible of the three curves fit in the left-hand panel. In this example, we know the true function f , and so we can also com- pute the test MSE over a very large test set, as a function of flexibility. (Of course, in general f is unknown, so this will not be possible.) The test MSE is displayed using the red curve in the right-hand panel of Figure 2.9 . As with the training MSE, the test MSE initially declines as the level of flex- ibility increases. However, at some point the test MSE levels off and then starts to increase again. Consequently, the orange and green curves both have high test MSE. The blue curve minimizes the test MSE, which should not be surprising given that visually it appears to estimate f the best in the left-hand panel of Figure 2.9 . The horizontal dashed line indicates Var ( ϵ ) , the irreducible error in ( 2.3 ), which corresponds to the lowest achievable test MSE among all possible methods. Hence, the smoothing spline repre- sented by the blue curve is close to optimal. In the right-hand panel of Figure 2.9 , as the flexibility of the statistical learning method increases, we observe a monotone decrease in the training MSE and a U-shape in the test MSE. This is a fundamental property of statistical learning that holds regardless of the particular data set at hand and regardless of the statistical method being used. As model flexibility increases, the training MSE will decrease, but the test MSE may not. When a given method yields a small training MSE but a large test MSE, we are said to be overfitting the data. This happens because our statistical learning procedure is working too hard to find patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function f . When we overfit the training data, the test MSE will be very large because the supposed \n0 20 40 60 80 100 2 4 6 8 10 12 X Y 2 5 10 20 0.0 0.5 1.0 1.5 2.0 2.5 Flexibility Mean Squared Error FIGURE 2.10. Details are as in Figure 2.9 , using a different true f that is much closer to linear. In this setting, linear regression provides a very good fit to the data. patterns that the method found in the training data simply don’t exist in the test data. Note that regardless of whether or not overfitting has occurred, we almost always expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek to minimize the training MSE. Overfitting refers specifically to the case in which a less flexible model would have yielded a smaller test MSE. Figure 2.10 provides another example in which the true f is approxi- mately linear. Again we observe that the training MSE decreases mono- tonically as the model flexibility increases, and that there is a U-shape in the test MSE. However, because the truth is close to linear, the test MSE only decreases slightly before increasing again, so that the orange least squares fit is substantially better than the highly flexible green curve. Fi- nally, Figure 2.11 displays an example in which f is highly non-linear. The training and test MSE curves still exhibit the same general patterns, but now there is a rapid decrease in both curves before the test MSE starts to increase slowly. In practice, one can usually compute the training MSE with relative ease, but estimating the test MSE is considerably more difficult because usually no test data are available. As the previous three examples illustrate, the flexibility level corresponding to the model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a variety of approaches that can be used in practice to estimate this minimum point. One important method is cross-validation (Chapter 5 ), which is a cross- validation method for estimating the test MSE using the training data. 2.2.2 The Bias-Variance Trade-Off The U-shape observed in the test MSE curves (Figures 2.9 – 2.11 ) turns out to be the result of two competing properties of statistical learning methods. \n0 20 40 60 80 100 −10 0 10 20 X Y 2 5 10 20 0 5 10 15 20 Flexibility Mean Squared Error FIGURE 2.11. Details are as in Figure 2.9 , using a different f that is far from linear. In this setting, linear regression provides a very poor fit to the data. Though the mathematical proof is beyond the scope of this book, it is possible to show that the expected test MSE, for a given value x 0 , can always be decomposed into the sum of three fundamental quantities: the variance of ˆ f ( x 0 ) , the squared bias of ˆ f ( x 0 ) and the variance of the error variance bias terms ϵ . That is, E 1 y 0 − ˆ f ( x 0 ) 2 2 = Var ( ˆ f ( x 0 )) + [ Bias ( ˆ f ( x 0 ))] 2 + Var ( ϵ ) . (2.7) Here the notation E 1 y 0 − ˆ f ( x 0 ) 2 2 defines the expected test MSE at x 0 , expected test MSE and refers to the average test MSE that we would obtain if we repeatedly estimated f using a large number of training sets, and tested each at x 0 . The overall expected test MSE can be computed by averaging E 1 y 0 − ˆ f ( x 0 ) 2 2 over all possible values of x 0 in the test set. Equation 2.7 tells us that in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance and low bias . Note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. Hence, we see that the expected test MSE can never lie below Var ( ϵ ) , the irreducible error from ( 2.3 ). What do we mean by the variance and bias of a statistical learning method? Variance refers to the amount by which ˆ f would change if we estimated it using a different training data set. Since the training data are used to fit the statistical learning method, different training data sets will result in a different ˆ f . But ideally the estimate for f should not vary too much between training sets. However, if a method has high variance then small changes in the training data can result in large changes in ˆ f . In general, more flexible statistical methods have higher variance. Consider the green and orange curves in Figure 2.9 . The flexible green curve is following the observations very closely. It has high variance because changing any one of these data points may cause the estimate ˆ f to change considerably. \n2 5 10 20 0.0 0.5 1.0 1.5 2.0 2.5 Flexibility 2 5 10 20 0.0 0.5 1.0 1.5 2.0 2.5 Flexibility 2 5 10 20 0 5 10 15 20 Flexibility MSE Bias Var FIGURE 2.12. Squared bias (blue curve), variance (orange curve), Var ( ϵ ) (dashed line), and test MSE (red curve) for the three data sets in Figures 2.9 – 2.11 . The vertical dotted line indicates the flexibility level corresponding to the smallest test MSE. In contrast, the orange least squares line is relatively inflexible and has low variance, because moving any single observation will likely cause only a small shift in the position of the line. On the other hand, bias refers to the error that is introduced by approxi- mating a real-life problem, which may be extremely complicated, by a much simpler model. For example, linear regression assumes that there is a linear relationship between Y and X 1 , X 2 , . . . , X p . It is unlikely that any real-life problem truly has such a simple linear relationship, and so performing lin- ear regression will undoubtedly result in some bias in the estimate of f . In Figure 2.11 , the true f is substantially non-linear, so no matter how many training observations we are given, it will not be possible to produce an accurate estimate using linear regression. In other words, linear regression results in high bias in this example. However, in Figure 2.10 the true f is very close to linear, and so given enough data, it should be possible for linear regression to produce an accurate estimate. Generally, more flexible methods result in less bias. As a general rule, as we use more flexible methods, the variance will increase and the bias will decrease. The relative rate of change of these two quantities determines whether the test MSE increases or decreases. As we increase the flexibility of a class of methods, the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. When this happens the test MSE increases. Note that we observed this pattern of decreasing test MSE followed by increasing test MSE in the right-hand panels of Figures 2.9 – 2.11 . The three plots in Figure 2.12 illustrate Equation 2.7 for the examples in Figures 2.9 – 2.11 . In each case the blue solid curve represents the squared bias, for different levels of flexibility, while the orange curve corresponds to the variance. The horizontal dashed line represents Var ( ϵ ) , the irreducible error. Finally, the red curve, corresponding to the test set MSE, is the sum \nof these three quantities. In all three cases, the variance increases and the bias decreases as the method’s flexibility increases. However, the flexibility level corresponding to the optimal test MSE differs considerably among the three data sets, because the squared bias and variance change at different rates in each of the data sets. In the left-hand panel of Figure 2.12 , the bias initially decreases rapidly, resulting in an initial sharp decrease in the expected test MSE. On the other hand, in the center panel of Figure 2.12 the true f is close to linear, so there is only a small decrease in bias as flex- ibility increases, and the test MSE only declines slightly before increasing rapidly as the variance increases. Finally, in the right-hand panel of Fig- ure 2.12 , as flexibility increases, there is a dramatic decline in bias because the true f is very non-linear. There is also very little increase in variance as flexibility increases. Consequently, the test MSE declines substantially before experiencing a small increase as model flexibility increases. The relationship between bias, variance, and test set MSE given in Equa- tion 2.7 and displayed in Figure 2.12 is referred to as the bias-variance trade-off . Good test set performance of a statistical learning method re- bias-variance trade-off quires low variance as well as low squared bias. This is referred to as a trade-off because it is easy to obtain a method with extremely low bias but high variance (for instance, by drawing a curve that passes through every single training observation) or a method with very low variance but high bias (by fitting a horizontal line to the data). The challenge lies in finding a method for which both the variance and the squared bias are low. This trade-off is one of the most important recurring themes in this book. In a real-life situation in which f is unobserved, it is generally not pos- sible to explicitly compute the test MSE, bias, or variance for a statistical learning method. Nevertheless, one should always keep the bias-variance trade-off in mind. In this book we explore methods that are extremely flexible and hence can essentially eliminate bias. However, this does not guarantee that they will outperform a much simpler method such as linear regression. To take an extreme example, suppose that the true f is linear. In this situation linear regression will have no bias, making it very hard for a more flexible method to compete. In contrast, if the true f is highly non-linear and we have an ample number of training observations, then we may do better using a highly flexible approach, as in Figure 2.11 . In Chapter 5 we discuss cross-validation, which is a way to estimate the test MSE using the training data. 2.2.3 The Classification Setting Thus far, our discussion of model accuracy has been focused on the regres- sion setting. But many of the concepts that we have encountered, such as the bias-variance trade-off, transfer over to the classification setting with only some modifications due to the fact that y i is no longer quan- titative. Suppose that we seek to estimate f on the basis of training obser- vations { ( x 1 , y 1 ) , . . . , ( x n , y n ) } , where now y 1 , . . . , y n are qualitative. The most common approach for quantifying the accuracy of our estimate ˆ f is the training error rate , the proportion of mistakes that are made if we apply error rate \nour estimate ˆ f to the training observations: 1 n n 0 i =1 I ( y i ̸ = ˆ y i ) . (2.8) Here ˆ y i is the predicted class label for the i th observation using ˆ f . And I ( y i ̸ = ˆ y i ) is an indicator variable that equals 1 if y i ̸ = ˆ y i and zero if y i = ˆ y i . indicator variable If I ( y i ̸ = ˆ y i ) = 0 then the i th observation was classified correctly by our classification method; otherwise it was misclassified. Hence Equation 2.8 computes the fraction of incorrect classifications. Equation 2.8 is referred to as the training error rate because it is com- training error puted based on the data that was used to train our classifier. As in the regression setting, we are most interested in the error rates that result from applying our classifier to test observations that were not used in training. The test error rate associated with a set of test observations of the form test error ( x 0 , y 0 ) is given by Ave ( I ( y 0 ̸ = ˆ y 0 )) , (2.9) where ˆ y 0 is the predicted class label that results from applying the classifier to the test observation with predictor x 0 . A good classifier is one for which the test error ( 2.9 ) is smallest. The Bayes Classifier It is possible to show (though the proof is outside of the scope of this book) that the test error rate given in ( 2.9 ) is minimized, on average, by a very simple classifier that assigns each observation to the most likely class, given its predictor values . In other words, we should simply assign a test observation with predictor vector x 0 to the class j for which Pr( Y = j | X = x 0 ) (2.10) is largest. Note that ( 2.10 ) is a conditional probability : it is the probability conditional probability that Y = j , given the observed predictor vector x 0 . This very simple clas- sifier is called the Bayes classifier . In a two-class problem where there are Bayes classifier only two possible response values, say class 1 or class 2 , the Bayes classifier corresponds to predicting class one if Pr( Y = 1 | X = x 0 ) > 0 . 5 , and class two otherwise. Figure 2.13 provides an example using a simulated data set in a two- dimensional space consisting of predictors X 1 and X 2 . The orange and blue circles correspond to training observations that belong to two different classes. For each value of X 1 and X 2 , there is a different probability of the response being orange or blue. Since this is simulated data, we know how the data were generated and we can calculate the conditional probabilities for each value of X 1 and X 2 . The orange shaded region reflects the set of points for which Pr( Y = orange | X ) is greater than 50 % , while the blue shaded region indicates the set of points for which the probability is below 50 % . The purple dashed line represents the points where the probability is exactly 50 % . This is called the Bayes decision boundary . The Bayes Bayes decision boundary classifier’s prediction is determined by the Bayes decision boundary; an observation that falls on the orange side of the boundary will be assigned \no o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o X 1 X 2 FIGURE 2.13. A simulated data set consisting of 100 observations in each of two groups, indicated in blue and in orange. The purple dashed line represents the Bayes decision boundary. The orange background grid indicates the region in which a test observation will be assigned to the orange class, and the blue background grid indicates the region in which a test observation will be assigned to the blue class. to the orange class, and similarly an observation on the blue side of the boundary will be assigned to the blue class. The Bayes classifier produces the lowest possible test error rate, called the Bayes error rate . Since the Bayes classifier will always choose the class Bayes error rate for which ( 2.10 ) is largest, the error rate will be 1 − max j Pr( Y = j | X = x 0 ) at X = x 0 . In general, the overall Bayes error rate is given by 1 − E * max j Pr( Y = j | X ) + , (2.11) where the expectation averages the probability over all possible values of X . For our simulated data, the Bayes error rate is 0 . 133 . It is greater than zero, because the classes overlap in the true population, which implies that max j Pr( Y = j | X = x 0 ) < 1 for some values of x 0 . The Bayes error rate is analogous to the irreducible error, discussed earlier. K -Nearest Neighbors In theory we would always like to predict qualitative responses using the Bayes classifier. But for real data, we do not know the conditional distri- bution of Y given X , and so computing the Bayes classifier is impossi- ble. Therefore, the Bayes classifier serves as an unattainable gold standard against which to compare other methods. Many approaches attempt to estimate the conditional distribution of Y given X , and then classify a given observation to the class with highest estimated probability. One such method is the K -nearest neighbors (KNN) classifier. Given a positive in- K -nearest neighbors \nteger K and a test observation x 0 , the KNN classifier first identifies the K points in the training data that are closest to x 0 , represented by N 0 . It then estimates the conditional probability for class j as the fraction of points in N 0 whose response values equal j : Pr( Y = j | X = x 0 ) = 1 K 0 i ∈N 0 I ( y i = j ) . (2.12) Finally, KNN classifies the test observation x 0 to the class with the largest probability from ( 2.12 ). Figure 2.14 provides an illustrative example of the KNN approach. In the left-hand panel, we have plotted a small training data set consisting of six blue and six orange observations. Our goal is to make a prediction for the point labeled by the black cross. Suppose that we choose K = 3 . Then KNN will first identify the three observations that are closest to the cross. This neighborhood is shown as a circle. It consists of two blue points and one orange point, resulting in estimated probabilities of 2 / 3 for the blue class and 1 / 3 for the orange class. Hence KNN will predict that the black cross belongs to the blue class. In the right-hand panel of Figure 2.14 we have applied the KNN approach with K = 3 at all of the possible values for X 1 and X 2 , and have drawn in the corresponding KNN decision boundary. Despite the fact that it is a very simple approach, KNN can often pro- duce classifiers that are surprisingly close to the optimal Bayes classifier. Figure 2.15 displays the KNN decision boundary, using K = 10 , when ap- plied to the larger simulated data set from Figure 2.13 . Notice that even though the true distribution is not known by the KNN classifier, the KNN decision boundary is very close to that of the Bayes classifier. The test error rate using KNN is 0 . 1363 , which is close to the Bayes error rate of 0 . 1304 . The choice of K has a drastic effect on the KNN classifier obtained. Figure 2.16 displays two KNN fits to the simulated data from Figure 2.13 , using K = 1 and K = 100 . When K = 1 , the decision boundary is overly flexible and finds patterns in the data that don’t correspond to the Bayes decision boundary. This corresponds to a classifier that has low bias but very high variance. As K grows, the method becomes less flexible and produces a decision boundary that is close to linear. This corresponds to a low-variance but high-bias classifier. On this simulated data set, neither K = 1 nor K = 100 give good predictions: they have test error rates of 0 . 1695 and 0 . 1925 , respectively. Just as in the regression setting, there is not a strong relationship be- tween the training error rate and the test error rate. With K = 1 , the KNN training error rate is 0 , but the test error rate may be quite high. In general, as we use more flexible classification methods, the training error rate will decline but the test error rate may not. In Figure 2.17 , we have plotted the KNN test and training errors as a function of 1 /K . As 1 /K in- creases, the method becomes more flexible. As in the regression setting, the training error rate consistently declines as the flexibility increases. However, the test error exhibits a characteristic U-shape, declining at first (with a minimum at approximately K = 10 ) before increasing again when the method becomes excessively flexible and overfits. \no o o o o o o o o o o o o o o o o o o o o o o o FIGURE 2.14. The KNN approach, using K = 3 , is illustrated in a simple situation with six blue observations and six orange observations. Left: a test observation at which a predicted class label is desired is shown as a black cross. The three closest points to the test observation are identified, and it is predicted that the test observation belongs to the most commonly-occurring class, in this case blue. Right: The KNN decision boundary for this example is shown in black. The blue grid indicates the region in which a test observation will be assigned to the blue class, and the orange grid indicates the region in which it will be assigned to the orange class. o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o X 1 X 2 KNN: K=10 FIGURE 2.15. The black curve indicates the KNN decision boundary on the data from Figure 2.13 , using K = 10 . The Bayes decision boundary is shown as a purple dashed line. The KNN and Bayes decision boundaries are very similar. In both the regression and classification settings, choosing the correct level of flexibility is critical to the success of any statistical learning method. The bias-variance tradeoff, and the resulting U-shape in the test error, can make this a difficult task. In Chapter 5 , we return to this topic and discuss \no o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o KNN: K=1 KNN: K=100 FIGURE 2.16. A comparison of the KNN decision boundaries (solid black curves) obtained using K = 1 and K = 100 on the data from Figure 2.13 . With K = 1 , the decision boundary is overly flexible, while with K = 100 it is not sufficiently flexible. The Bayes decision boundary is shown as a purple dashed line. 0.01 0.02 0.05 0.10 0.20 0.50 1.00 0.00 0.05 0.10 0.15 0.20 1/K Error Rate Training Errors Test Errors FIGURE 2.17. The KNN training error rate (blue, 200 observations) and test error rate (orange, 5,000 observations) on the data from Figure 2.13 , as the level of flexibility (assessed using 1 /K on the log scale) increases, or equivalently as the number of neighbors K decreases. The black dashed line indicates the Bayes error rate. The jumpiness of the curves is due to the small size of the training data set. various methods for estimating test error rates and thereby choosing the optimal level of flexibility for a given statistical learning method. \n2.3 Lab: Introduction to Python 2.3.1 Getting Started To run the labs in this book, you will need two things: 1. An installation of Python3 , which is the specific version of Python used in the labs. 2. Access to Jupyter , a very popular Python interface that runs code through a file called a notebook . notebook You can download and install Python3 by following the instructions avail- able at anaconda.com . There are a number of ways to get access to Jupyter . Here are just a few: 1. Using Google’s Colaboratory service: colab.research.google.com/ . 2. Using JupyterHub , available at jupyter.org/hub . 3. Using your own jupyter installation. Installation instructions are available at jupyter.org/install . Please see the Python resources page on the book website statlearning.com for up-to-date information about getting Python and Jupyter working on your computer. You will need to install the ISLP package, which provides access to the datasets and custom-built functions that we provide. Inside a macOS or Linux terminal type pip install ISLP ; this also installs most other pack- ages needed in the labs. The Python resources page has a link to the ISLP documentation website. To run this lab, download the file Ch2-statlearn-lab.ipynb from the Python resources page. Now run the following code at the command line: jupyter lab Ch2-statlearn-lab.ipynb . If you’re using Windows, you can use the start menu to access anaconda , and follow the links. For example, to install ISLP and run this lab, you can run the same code above in an anaconda shell. 2.3.2 Basic Commands In this lab, we will introduce some simple Python commands. For more resources about Python in general, readers may want to consult the tutorial at docs.python.org/3/tutorial/ . Like most programming languages, Python uses functions to perform op- function erations. To run a function called fun , we type fun(input1,input2) , where the inputs (or arguments ) input1 and input2 tell Python how to run the function. A function can have any number of inputs. For example, the argument print() function outputs a text representation of all of its arguments to print() the console. In [1]: print( 'fit a model with' , 11, 'variables' ) \nfit a model with 11 variables The following command will provide information about the print() func- tion. In [2]: print? Adding two integers in Python is pretty intuitive. In [3]: 3 + 5 Out[3]: 8 In Python , textual data is handled using strings . For instance, \"hello\" and string 'hello' are strings. We can concatenate them using the addition + symbol. In [4]: \"hello\" + \" \" + \"world\" Out[4]: 'hello world' A string is actually a type of sequence : this is a generic term for an ordered sequence list. The three most important types of sequences are lists, tuples, and strings. We introduce lists now. The following command instructs Python to join together the numbers 3, 4, and 5, and to save them as a list named x . When we type x , it gives us list back the list. In [5]: x = [3, 4, 5] x Out[5]: [3, 4, 5] Note that we used the brackets [] to construct this list. We will often want to add two sets of numbers together. It is reasonable to try the following code, though it will not produce the desired results. In [6]: y = [4, 9, 7] x + y Out[6]: [3, 4, 5, 4, 9, 7] The result may appear slightly counterintuitive: why did Python not add the entries of the lists element-by-element? In Python , lists hold arbitrary objects, and are added using concatenation . In fact, concatenation is the concatenat- ion behavior that we saw earlier when we entered \"hello\" + \" \" + \"world\" . This example reflects the fact that Python is a general-purpose program- ming language. Much of Python ’s data-specific functionality comes from other packages, notably numpy and pandas . In the next section, we will intro- duce the numpy package. See docs.scipy.org/doc/numpy/user/quickstart.html for more information about numpy . \n2.3.3 Introduction to Numerical Python As mentioned earlier, this book makes use of functionality that is contained in the numpy library , or package . A package is a collection of modules that numpy package are not necessarily included in the base Python distribution. The name numpy is an abbreviation for numerical Python . To access numpy , we must first import it. import In [7]: import numpy as np In the previous line, we named the numpy module np ; an abbreviation for module easier referencing. In numpy , an array is a generic term for a multidimensional set of numbers. array We use the np.array() function to define x and y , which are one-dimensional np.array() arrays, i.e. vectors. In [8]: x = np.array([3, 4, 5]) y = np.array([4, 9, 7]) Note that if you forgot to run the import numpy as np command earlier, then you will encounter an error in calling the np.array() function in the previous line. The syntax np.array() indicates that the function be- ing called is part of the numpy package, which we have abbreviated as np . Since x and y have been defined using np.array() , we get a sensible result when we add them together. Compare this to our results in the previous section, when we tried to add two lists without using numpy . In [9]: x + y Out[9]: array([ 7, 13, 12]) In numpy , matrices are typically represented as two-dimensional arrays, and vectors as one-dimensional arrays. 1 We can create a two-dimensional array as follows. In [10]: x = np.array([[1, 2], [3, 4]]) x Out[10]: array([[1, 2], [3, 4]]) The object x has several attributes , or associated objects. To access an attribute attribute of x , we type x.attribute , where we replace attribute with the name of the attribute. For instance, we can access the ndim attribute of x ndim as follows. In [11]: x.ndim Out[11]: 2 The output indicates that x is a two-dimensional array. Similarly, x.dtype is the data type attribute of the object x . This indicates that x is comprised data type of 64-bit integers: 1 While it is also possible to create matrices using np.matrix() , we will use np.array() throughout the labs in this book. \nIn [12]: x.dtype Out[12]: dtype( 'int64' ) Why is x comprised of integers? This is because we created x by passing in exclusively integers to the np.array() function. If we had passed in any decimals, then we would have obtained an array of floating point numbers floating point (i.e. real-valued numbers). In [13]: np.array([[1, 2], [3.0, 4]]).dtype Out[13]: dtype( 'float64' ) Typing fun? will cause Python to display documentation associated with the function fun , if it exists. We can try this for np.array() . In [14]: np.array? This documentation indicates that we could create a floating point array by passing a dtype argument into np.array() . dtype In [15]: np.array([[1, 2], [3, 4]], float).dtype Out[15]: dtype( 'float64' ) The array x is two-dimensional. We can find out the number of rows and columns by looking at its shape attribute. shape In [16]: x.shape Out[16]: (2, 2) A method is a function that is associated with an object. For instance, method given an array x , the expression x.sum() sums all of its elements, using the sum() method for arrays. The call x.sum() automatically provides x as the .sum() first argument to its sum() method. In [17]: x = np.array([1, 2, 3, 4]) x.sum() Out[17]: 10 We could also sum the elements of x by passing in x as an argument to the np.sum() function. np.sum() In [18]: x = np.array([1, 2, 3, 4]) np.sum(x) Out[18]: 10 As another example, the reshape() method returns a new array with the .reshape() same elements as x , but a different shape. We do this by passing in a tuple tuple \nin our call to reshape() , in this case (2, 3) . This tuple specifies that we would like to create a two-dimensional array with 2 rows and 3 columns. 2 In what follows, the \\n character creates a new line . In [19]: x = np.array([1, 2, 3, 4, 5, 6]) print( 'beginning x:\\n' , x) x_reshape = x.reshape((2, 3)) print( 'reshaped x:\\n' , x_reshape) beginning x: [1 2 3 4 5 6] reshaped x: [[1 2 3] [4 5 6]] The previous output reveals that numpy arrays are specified as a sequence of rows . This is called row-major ordering , as opposed to column-major ordering . Python (and hence numpy ) uses 0-based indexing. This means that to access the top left element of x_reshape , we type in x_reshape[0,0] . In [20]: x_reshape[0, 0] Out[20]: 1 Similarly, x_reshape[1,2] yields the element in the second row and the third column of x_reshape . In [21]: x_reshape[1, 2] Out[21]: 6 Similarly, x[2] yields the third entry of x . Now, let’s modify the top left element of x_reshape . To our surprise, we discover that the first element of x has been modified as well! In [22]: print( 'x before we modify x_reshape:\\n' , x) print( 'x_reshape before we modify x_reshape:\\n' , x_reshape) x_reshape[0, 0] = 5 print( 'x_reshape after we modify its top left element:\\n' , x_reshape) print( 'x after we modify t op l e f t e lement of x_reshape:\\n' , x) Out[22]: x before we modify x_reshape: [1 2 3 4 5 6] x_reshape before we modify x_reshape: [[1 2 3] [4 5 6]] x_reshape after we modify its top left element: [[5 2 3] 2 Like lists, tuples represent a sequence of objects. Why do we need more than one way to create a sequence? There are a few differences between tuples and lists, but perhaps the most important is that elements of a tuple cannot be modified, whereas elements of a list can be. \n[4 5 6]] x after we modify top left element of x_reshape: [5 2 3 4 5 6] Modifying x_reshape also modified x because the two objects occupy the same space in memory. We just saw that we can modify an element of an array. Can we also mod- ify a tuple? It turns out that we cannot — and trying to do so introduces an exception , or error. exception In [23]: my_tuple = (3, 4, 5) my_tuple[0] = 2 TypeError: 'tuple' object does not support item assignment We now briefly mention some attributes of arrays that will come in handy. An array’s shape attribute contains its dimension; this is always a tuple. The ndim attribute yields the number of dimensions, and T provides its transpose. In [24]: x_reshape.shape, x_reshape.ndim, x_reshape.T Out[24]: ((2, 3), 2, array([[5, 4], [2, 5], [3, 6]])) Notice that the three individual outputs (2,3) , 2 , and array([[5, 4],[2, 5], [3,6]]) are themselves output as a tuple. We will often want to apply functions to arrays. For instance, we can compute the square root of the entries using the np.sqrt() function: np.sqrt() In [25]: np.sqrt(x) Out[25]: array([2.24, 1.41, 1.73, 2., 2.24, 2.45]) We can also square the elements: In [26]: x**2 Out[26]: array([25, 4, 9, 16, 25, 36]) We can compute the square roots using the same notation, raising to the power of 1 / 2 instead of 2. In [27]: x**0.5 Out[27]: array([2.24, 1.41, 1.73, 2., 2.24, 2.45]) Throughout this book, we will often want to generate random data. The np.random.normal() function generates a vector of random normal variables. np.random. normal() We can learn more about this function by looking at the help page, via a call to np.random.normal? . The first line of the help page reads normal(loc=0.0, scale=1.0, size=None) . This signature line tells us that the function’s ar- signature \nguments are loc , scale , and size . These are keyword arguments, which keyword means that when they are passed into the function, they can be referred to by name (in any order). 3 By default, this function will generate random normal variable(s) with mean ( loc ) 0 and standard deviation ( scale ) 1 ; fur- thermore, a single random variable will be generated unless the argument to size is changed. We now generate 50 independent random variables from a N (0 , 1) dis- tribution. In [28]: x = np.random.normal(size=50) x Out[28]: array([-1.19, 0.41, 0.9 , -0.44, -0.9 , -0.38, 0.13, 1.87, -0.35, 1.16, 0.79, -0.97, -1.21, 0.06, -1.62, -0.6 , -0.77, -2.12, 0.38, -1.22, -0.06, -1.97, -1.74, -0.56, 1.7 , -0.95, 0.56, 0.35, 0.87, 0.88, -1.66, -0.32, -0.3 , -1.36, 0.92, -0.31, 1.28, -1.94, 1.07, 0.07, 0.79, -0.46, 2.19, -0.27, -0.64, 0.85, 0.13, 0.46, -0.09, 0.7 ]) We create an array y by adding an independent N (50 , 1) random variable to each element of x . In [29]: y = x + np.random.normal(loc=50, scale=1, size=50) The np.corrcoef() function computes the correlation matrix between x and np.corrcoef() y . The off-diagonal elements give the correlation between x and y . In [30]: np.corrcoef(x, y) Out[30]: array([[1. , 0.69], [0.69, 1. ]]) If you’re following along in your own Jupyter notebook, then you probably noticed that you got a different set of results when you ran the past few commands. In particular, each time we call np.random.normal() , we will get a different answer, as shown in the following example. In [31]: print(np.random.normal(scale=5, size=2)) print(np.random.normal(scale=5, size=2)) Out[31]: [4.28 2.59] [4.62 -2.54] In order to ensure that our code provides exactly the same results each time it is run, we can set a random seed using the np.random.default_rng() random seed np.random. default_rng() function. This function takes an arbitrary, user-specified integer argument. If we set a random seed before generating random data, then re-running our code will yield the same results. The object rng has essentially all the 3 Python also uses positional arguments. Positional arguments do not need to use a keyword. To see an example, type in np.sum? . We see that a is a positional argument, i.e. this function assumes that the first unnamed argument that it receives is the array to be summed. By contrast, axis and dtype are keyword arguments: the position in which these arguments are entered into np.sum() does not matter. \nrandom number generating methods found in np.random . Hence, to generate normal data we use rng.normal() . In [32]: rng = np.random.default_rng(1303) print(rng.normal(scale=5, size=2)) rng2 = np.random.default_rng(1303) print(rng2.normal(scale=5, size=2)) Out[32]: [4.09 -1.07 ] [4.09 -1.07 ] Throughout the labs in this book, we use np.random.default_rng() when- ever we perform calculations involving random quantities within numpy . In principle, this should enable the reader to exactly reproduce the stated results. However, as new versions of numpy become available, it is possible that some small discrepancies may occur between the output in the labs and the output from numpy . The np.mean() , np.var() , and np.std() functions can be used to compute np.mean() np.var() np.std() the mean, variance, and standard deviation of arrays. These functions are also available as methods on the arrays. In [33]: rng = np.random.default_rng(3) y = rng.standard_normal(10) np.mean(y), y.mean() Out[33]: (-0.11, -0.11) In [34]: np.var(y), y.var(), np.mean((y - y.mean())**2) Out[34]: (2.72, 2.72, 2.72) Notice that by default np.var() divides by the sample size n rather than n − 1 ; see the ddof argument in np.var? . In [35]: np.sqrt(np.var(y)), np.std(y) Out[35]: (1.65, 1.65) The np.mean() , np.var() , and np.std() functions can also be applied to the rows and columns of a matrix. To see this, we construct a 10 × 3 matrix of N (0 , 1) random variables, and consider computing its row sums. In [36]: X = rng.standard_normal((10, 3)) X Out[36]: array([[ 0.23, -0.35, -0.28], [-0.67, -1.06, -0.39], [ 0.48, -0.24, 0.96], [-0.2 , 0.02, 1.55], [ 0.55, -0.51, -0.18], [ 0.54, 1.94, -0.27], [-0.24, 1. , -0.89], [-0.29, 0.88, 0.58], [ 0.09, 0.67, -2.83], [ 1.02, -0.96, -1.67]]) \nSince arrays are row-major ordered, the first axis, i.e. axis=0 , refers to its rows. We pass this argument into the mean() method for the object X . .mean() In [37]: X.mean(axis=0) Out[37]: array([0.15, 0.14, -0.34]) The following yields the same result. In [38]: X.mean(0) Out[38]: array([0.15, 0.14, -0.34]) 2.3.4 Graphics In Python , common practice is to use the library matplotlib for graphics. matplotlib However, since Python was not written with data analysis in mind, the no- tion of plotting is not intrinsic to the language. We will use the subplots() function from matplotlib.pyplot to create a figure and the axes onto which we plot our data. For many more examples of how to make plots in Python , readers are encouraged to visit matplotlib.org/stable/gallery/ . In matplotlib , a plot consists of a figure and one or more axes . You can figure axes think of the figure as the blank canvas upon which one or more plots will be displayed: it is the entire plotting window. The axes contain important information about each plot, such as its x - and y -axis labels, title, and more. (Note that in matplotlib , the word axes is not the plural of axis : a plot’s axes contains much more information than just the x -axis and the y -axis.) We begin by importing the subplots() function from matplotlib . We subplots() use this function throughout when creating figures. The function returns a tuple of length two: a figure object as well as the relevant axes object. We will typically pass figsize as a keyword argument. Having created our axes, we attempt our first plot using its plot() method. To learn more .plot() about it, type ax.plot? . In [39]: from matplotlib.pyplot import subplots fig, ax = subplots(figsize=(8, 8)) x = rng.standard_normal(100) y = rng.standard_normal(100) ax.plot(x, y); We pause here to note that we have unpacked the tuple of length two re- turned by subplots() into the two distinct variables fig and ax . Unpacking is typically preferred to the following equivalent but slightly more verbose code: In [40]: output = subplots(figsize=(8, 8)) fig = output[0] ax = output[1] We see that our earlier cell produced a line plot, which is the default. To create a scatterplot, we provide an additional argument to ax.plot() , indicating that circles should be displayed. \nIn [41]: fig, ax = subplots(figsize=(8, 8)) ax.plot(x, y, 'o' ); Different values of this additional argument can be used to produce different colored lines as well as different linestyles. As an alternative, we could use the ax.scatter() function to create a .scatter() scatterplot. In [42]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(x, y, marker= 'o' ); Notice that in the code blocks above, we have ended the last line with a semicolon. This prevents ax.plot(x, y) from printing text to the notebook. However, it does not prevent a plot from being produced. If we omit the trailing semi-colon, then we obtain the following output: In [43]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(x, y, marker= 'o' ) Out[43]: <matplotlib.collections.PathCollection at 0x7fb3d9c8f310 > Figure(432x288) In what follows, we will use trailing semicolons whenever the text that would be output is not germane to the discussion at hand. To label our plot, we make use of the set_xlabel() , set_ylabel() , and .set_xlabel() .set_ylabel() set_title() methods of ax . .set_title() In [44]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(x, y, marker= 'o' ) ax.set_xlabel( \"this is the x-axis\" ) ax.set_ylabel( \"this is the y-axis\" ) ax.set_title( \"Plot of X vs Y\" ); Having access to the figure object fig itself means that we can go in and change some aspects and then redisplay it. Here, we change the size from (8, 8) to (12, 3) . fig.set_size_inches(12,3) fig Occasionally we will want to create several plots within a figure. This can be achieved by passing additional arguments to subplots() . Below, we create a 2 × 3 grid of plots in a figure of size determined by the figsize argument. In such situations, there is often a relationship between the axes in the plots. For example, all plots may have a common x -axis. The subplots() function can automatically handle this situation when passed the keyword argument sharex=True . The axes object below is an array pointing to different plots in the figure. In [45]: fig, axes = subplots(nrows=2, ncols=3, figsize=(15, 5)) We now produce a scatter plot with 'o' in the second column of the first row and a scatter plot with '+' in the third column of the second row. \nIn [46]: axes[0,1].plot(x, y, 'o' ) axes[1,2].scatter(x, y, marker= '+' ) fig Type subplots? to learn more about subplots() . To save the output of fig , we call its savefig() method. The argument .savefig() dpi is the dots per inch, used to determine how large the figure will be in pixels. In [47]: fig.savefig( \"Figure.png\" , dpi=400) fig.savefig( \"Figure.pdf\" , dpi=200); We can continue to modify fig using step-by-step updates; for example, we can modify the range of the x -axis, re-save the figure, and even re-display it. In [48]: axes[0,1].set_xlim([-1,1]) fig.savefig( \"Figure_updated.jpg\" ) fig We now create some more sophisticated plots. The ax.contour() method .contour() produces a contour plot in order to represent three-dimensional data, similar contour plot to a topographical map. It takes three arguments: • A vector of x values (the first dimension), • A vector of y values (the second dimension), and • A matrix whose elements correspond to the z value (the third dimen- sion) for each pair of (x,y) coordinates. To create x and y , we’ll use the command np.linspace(a, b, n) , which np.linspace() returns a vector of n numbers starting at a and ending at b . In [49]: fig, ax = subplots(figsize=(8, 8)) x = np.linspace(-np.pi, np.pi, 50) y = x f = np.multiply.outer(np.cos(y), 1 / (1 + x**2)) ax.contour(x, y, f); We can increase the resolution by adding more levels to the image. In [50]: fig, ax = subplots(figsize=(8, 8)) ax.contour(x, y, f, levels=45); To fine-tune the output of the ax.contour() function, take a look at the help file by typing ?plt.contour . The ax.imshow() method is similar to ax.contour() , except that it pro- .imshow() duces a color-coded plot whose colors depend on the z value. This is known as a heatmap , and is sometimes used to plot temperature in weather fore- heatmap casts. In [51]: fig, ax = subplots(figsize=(8, 8)) ax.imshow(f); \n2.3.5 Sequences and Slice Notation As seen above, the function np.linspace() can be used to create a sequence of numbers. In [52]: seq1 = np.linspace(0, 10, 11) seq1 Out[52]: array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) The function np.arange() returns a sequence of numbers spaced out by np.arange() step . If step is not specified, then a default value of 1 is used. Let’s create a sequence that starts at 0 and ends at 10 . In [53]: seq2 = np.arange(0, 10) seq2 Out[53]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) Why isn’t 10 output above? This has to do with slice notation in Python . slice Slice notation is used to index sequences such as lists, tuples and arrays. Suppose we want to retrieve the fourth through sixth (inclusive) entries of a string. We obtain a slice of the string using the indexing notation [3:6] . In [54]: \"hello world\" [3:6] Out[54]: 'lo ' In the code block above, the notation 3:6 is shorthand for slice(3,6) when used inside [] . In [55]: \"hello world\" [slice(3,6)] Out[55]: 'lo ' You might have expected slice(3,6) to output the fourth through seventh characters in the text string (recalling that Python begins its indexing at zero), but instead it output the fourth through sixth. This also explains why the earlier np.arange(0, 10) command output only the integers from 0 to 9 . See the documentation slice? for useful options in creating slices. 2.3.6 Indexing Data To begin, we create a two-dimensional numpy array. In [56]: A = np.array(np.arange(16)).reshape((4, 4)) A Out[56]: array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) Typing A[1,2] retrieves the element corresponding to the second row and third column. (As usual, Python indexes from 0 . ) \nIn [57]: A[1,2] Out[57]: 6 The first number after the open-bracket symbol [ refers to the row, and the second number refers to the column. Indexing Rows, Columns, and Submatrices To select multiple rows at a time, we can pass in a list specifying our selection. For instance, [1,3] will retrieve the second and fourth rows: In [58]: A[[1,3]] Out[58]: array([[ 4, 5, 6, 7], [12, 13, 14, 15]]) To select the first and third columns, we pass in [0,2] as the second ar- gument in the square brackets. In this case we need to supply the first argument : which selects all rows. In [59]: A[:,[0,2]] Out[59]: array([[ 0, 2], [ 4, 6], [ 8, 10], [12, 14]]) Now, suppose that we want to select the submatrix made up of the second and fourth rows as well as the first and third columns. This is where index- ing gets slightly tricky. It is natural to try to use lists to retrieve the rows and columns: In [60]: A[[1,3],[0,2]] Out[60]: array([ 4, 14]) Oops — what happened? We got a one-dimensional array of length two identical to In [61]: np.array([A[1,0],A[3,2]]) Out[61]: array([ 4, 14]) Similarly, the following code fails to extract the submatrix comprised of the second and fourth rows and the first, third, and fourth columns: In [62]: A[[1,3],[0,2,3]] IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (3,) \nWe can see what has gone wrong here. When supplied with two indexing lists, the numpy interpretation is that these provide pairs of i, j indices for a series of entries. That is why the pair of lists must have the same length. However, that was not our intent, since we are looking for a submatrix. One easy way to do this is as follows. We first create a submatrix by subsetting the rows of A , and then on the fly we make a further submatrix by subsetting its columns. In [63]: A[[1,3]][:,[0,2]] Out[63]: array([[ 4, 6], [12, 14]]) There are more efficient ways of achieving the same result. The convenience function np.ix_() allows us to extract a submatrix using convenience function np.ix_() lists, by creating an intermediate mesh object. mesh In [64]: idx = np.ix_([1,3],[0,2,3]) A[idx] Out[64]: array([[ 4, 6, 7], [12, 14, 15]]) Alternatively, we can subset matrices efficiently using slices. The slice 1:4:2 captures the second and fourth items of a sequence, while the slice 0:3:2 captures the first and third items (the third element in a slice se- quence is the step size). In [65]: A[1:4:2,0:3:2] Out[65]: array([[ 4, 6], [12, 14]]) Why are we able to retrieve a submatrix directly using slices but not using lists? Its because they are different Python types, and are treated differently by numpy . Slices can be used to extract objects from arbitrary sequences, such as strings, lists, and tuples, while the use of lists for indexing is more limited. Boolean Indexing In numpy , a Boolean is a type that equals either True or False (also rep- Boolean resented as 1 and 0 , respectively). The next line creates a vector of 0 ’s, represented as Booleans, of length equal to the first dimension of A . In [66]: keep_rows = np.zeros(A.shape[0], bool) keep_rows Out[66]: array([False, False, False, False]) We now set two of the elements to True . In [67]: keep_rows[[1,3]] = True keep_rows \nOut[67]: array([False, True, False, True]) Note that the elements of keep_rows , when viewed as integers, are the same as the values of np.array([0,1,0,1]) . Below, we use == to verify their equal- ity. When applied to two arrays, the == operation is applied elementwise. In [68]: np.all(keep_rows == np.array([0,1,0,1])) Out[68]: True (Here, the function np.all() has checked whether all entries of an array np.all() are True . A similar function, np.any() , can be used to check whether any np.any() entries of an array are True .) However, even though np.array([0,1,0,1]) and keep_rows are equal ac- cording to == , they index different sets of rows! The former retrieves the first, second, first, and second rows of A . In [69]: A[np.array([0,1,0,1])] Out[69]: array([[0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 2, 3], [4, 5, 6, 7]]) By contrast, keep_rows retrieves only the second and fourth rows of A — i.e. the rows for which the Boolean equals TRUE . In [70]: A[keep_rows] Out[70]: array([[ 4, 5, 6, 7], [12, 13, 14, 15]]) This example shows that Booleans and integers are treated differently by numpy . We again make use of the np.ix_() function to create a mesh containing the second and fourth rows, and the first, third, and fourth columns. This time, we apply the function to Booleans, rather than lists. In [71]: keep_cols = np.zeros(A.shape[1], bool) keep_cols[[0, 2, 3]] = True idx_bool = np.ix_(keep_rows, keep_cols) A[idx_bool] Out[71]: array([[ 4, 6, 7], [12, 14, 15]]) We can also mix a list with an array of Booleans in the arguments to np.ix_() : In [72]: idx_mixed = np.ix_([1,3], keep_cols) A[idx_mixed] Out[72]: array([[ 4, 6, 7], [12, 14, 15]]) For more details on indexing in numpy , readers are referred to the numpy tutorial mentioned earlier. \n2.3.7 Loading Data Data sets often contain different types of data, and may have names as- sociated with the rows or columns. For these reasons, they typically are best accommodated using a data frame . We can think of a data frame as data frame a sequence of arrays of identical length; these are the columns. Entries in the different arrays can be combined to form a row. The pandas library can be used to create and work with data frame objects. Reading in a Data Set The first step of most analyses involves importing a data set into Python . Before attempting to load a data set, we must make sure that Python knows where to find the file containing it. If the file is in the same location as this notebook file, then we are all set. Otherwise, the command os.chdir() can os.chdir() be used to change directory . (You will need to call import os before calling os.chdir() .) We will begin by reading in Auto.csv , available on the book website. This is a comma-separated file, and can be read in using pd.read_csv() : pd.read_csv() In [73]: import pandas as pd Auto = pd.read_csv( 'Auto.csv' ) Auto The book website also has a whitespace-delimited version of this data, called Auto.data . This can be read in as follows: In [74]: Auto = pd.read_csv( 'Auto.data' , delim_whitespace=True ) Both Auto.csv and Auto.data are simply text files. Before loading data into Python , it is a good idea to view it using a text editor or other software, such as Microsoft Excel. We now take a look at the column of Auto corresponding to the variable horsepower : In [75]: Auto[ 'horsepower' ] Out[75]: 0 130.0 1 165.0 2 150.0 3 150.0 4 140.0 ... 392 86.00 393 52.00 394 84.00 395 79.00 396 82.00 Name: horsepower , Length: 397, dtype: object We see that the dtype of this column is object . It turns out that all values of the horsepower column were interpreted as strings when reading in the data. We can find out why by looking at the unique values. In [76]: np.unique(Auto[ 'horsepower' ]) \nTo save space, we have omitted the output of the previous code block. We see the culprit is the value ? , which is being used to encode missing values. To fix the problem, we must provide pd.read_csv() with an argument called na_values . Now, each instance of ? in the file is replaced with the value np.nan , which means not a number : In [77]: Auto = pd.read_csv( 'Auto.data' , na_values=[ '?' ], delim_whitespace=True) Auto[ 'horsepower' ].sum() Out[77]: 40952.0 The Auto.shape attribute tells us that the data has 397 observations, or rows, and nine variables, or columns. In [78]: Auto.shape Out[78]: (397, 9) There are various ways to deal with missing data. In this case, since only five of the rows contain missing observations, we choose to use the Auto.dropna() method to simply remove these rows. .dropna() In [79]: Auto_new = Auto.dropna() Auto_new.shape Out[79]: (392, 9) Basics of Selecting Rows and Columns We can use Auto.columns to check the variable names. In [80]: Auto = Auto_new # overwrite the previous value Auto.columns Out[80]: Index([ 'mpg' , 'cylinders' , 'displacement' , 'horsepower' , 'weight' , 'acceleration' , 'year' , 'origin' , 'name' ], dtype= 'object' ) Accessing the rows and columns of a data frame is similar, but not iden- tical, to accessing the rows and columns of an array. Recall that the first argument to the [] method is always applied to the rows of the array. Sim- ilarly, passing in a slice to the [] method creates a data frame whose rows are determined by the slice: In [81]: Auto[:3] Out[81]: mpg cylinders displacement horsepower weight ... 0 18.0 8 307.0 130.0 3504.0 ... 1 15.0 8 350.0 165.0 3693.0 ... 2 18.0 8 318.0 150.0 3436.0 ... Similarly, an array of Booleans can be used to subset the rows: \nIn [82]: idx_80 = Auto[ 'year' ] > 80 Auto[idx_80] However, if we pass in a list of strings to the [] method, then we obtain a data frame containing the corresponding set of columns . In [83]: Auto[[ 'mpg' , 'horsepower' ]] Out[83]: mpg horsepower 0 18.0 130.0 1 15.0 165.0 2 18.0 150.0 3 16.0 150.0 4 17.0 140.0 ... ... ... 392 27.0 86.0 393 44.0 52.0 394 32.0 84.0 395 28.0 79.0 396 31.0 82.0 392 rows x 2 columns Since we did not specify an index column when we loaded our data frame, the rows are labeled using integers 0 to 396. In [84]: Auto.index Out[84]: Int64Index([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ... 387, 388, 389, 390, 391, 392, 393, 394, 395, 396], dtype= 'int64' , length=392) We can use the set_index() method to re-name the rows using the contents .set_index() of Auto['name'] . In [85]: Auto_re = Auto.set_index( 'name' ) Auto_re Out[85]: mpg cylinders displacement ... name chevrolet chevelle malibu 18.0 8 307.0 ... buick skylark 32 15.0 8 350.0 ... plymouth satellite 18.0 8 318.0 ... amc rebel sst 16.0 8 304.0 ... In [86]: Auto_re.columns Out[86]: Index([ 'mpg' , 'cylinders' , 'displacement' , 'horsepower' , 'weight' , 'acceleration' , 'year' , 'origin' ], dtype= 'object' ) We see that the column 'name' is no longer there. Now that the index has been set to name , we can access rows of the data frame by name using the loc[] method of Auto : .loc[] \nIn [87]: rows = [ 'amc rebel sst' , 'ford torino' ] Auto_re.loc[rows] Out[87]: mpg cylinders displacement horsepower ... name amc rebel sst 16.0 8 304.0 150.0 ... ford torino 17.0 8 302.0 140.0 ... As an alternative to using the index name, we could retrieve the 4th and 5th rows of Auto using the iloc[] method: .iloc[] In [88]: Auto_re.iloc[[3,4]] We can also use it to retrieve the 1st, 3rd and and 4th columns of Auto_re : In [89]: Auto_re.iloc[:,[0,2,3]] We can extract the 4th and 5th rows, as well as the 1st, 3rd and 4th columns, using a single call to iloc[] : In [90]: Auto_re.iloc[[3,4],[0,2,3]] Out[90]: mpg displacement horsepower name amc rebel sst 16.0 304.0 150.0 ford torino 17.0 302.0 140.0 Index entries need not be unique: there are several cars in the data frame named ford galaxie 500 . In [91]: Auto_re.loc[ 'ford galaxie 500' , [ 'mpg' , 'origin' ]] Out[91]: mpg origin name ford galaxie 500 15.0 1 ford galaxie 500 14.0 1 ford galaxie 500 14.0 1 More on Selecting Rows and Columns Suppose now that we want to create a data frame consisting of the weight and origin of the subset of cars with year greater than 80 — i.e. those built after 1980. To do this, we first create a Boolean array that indexes the rows. The loc[] method allows for Boolean entries as well as strings: In [92]: idx_80 = Auto_re[ 'year' ] > 80 Auto_re.loc[idx_80, [ 'weight' , 'origin' ]] To do this more concisely, we can use an anonymous function called a lambda : lambda In [93]: Auto_re.loc[lambda df: df[ 'year' ] > 80, [ 'weight' , 'or i g i n' ] ] The lambda call creates a function that takes a single argument, here df , and returns df['year']>80 . Since it is created inside the loc[] method for \nthe dataframe Auto_re , that dataframe will be the argument supplied. As another example of using a lambda , suppose that we want all cars built after 1980 that achieve greater than 30 miles per gallon: In [94]: Auto_re.loc[lambda df: (df[ 'year' ] > 80) & (df[ 'mpg' ] > 30), [ 'weight' , 'origin' ] ] The symbol & computes an element-wise and operation. As another ex- ample, suppose that we want to retrieve all Ford and Datsun cars with displacement less than 300. We check whether each name entry contains either the string ford or datsun using the str.contains() method of the .str. contains() index attribute of of the dataframe: In [95]: Auto_re.loc[lambda df: (df[ 'displacement' ] < 300) & (df.index.str.contains( 'ford' ) | df.index.str.contains( 'datsun' )), [ 'weight' , 'origin' ] ] Here, the symbol | computes an element-wise or operation. In summary, a powerful set of operations is available to index the rows and columns of data frames. For integer based queries, use the iloc[] method. For string and Boolean selections, use the loc[] method. For functional queries that filter rows, use the loc[] method with a function (typically a lambda ) in the rows argument. 2.3.8 For Loops A for loop is a standard tool in many languages that repeatedly evaluates for some chunk of code while varying different values inside the code. For example, suppose we loop over elements of a list and compute their sum. In [96]: total = 0 for value in [3,2,19]: total += value print( 'Total is: {0}' .format(total)) Total is: 24 The indented code beneath the line with the for statement is run for each value in the sequence specified in the for statement. The loop ends either when the cell ends or when code is indented at the same level as the original for statement. We see that the final line above which prints the total is executed only once after the for loop has terminated. Loops can be nested by additional indentation. In [97]: total = 0 for value in [2,3,19]: for weight in [3, 2, 1]: total += value * weight print( 'Total is: {0}' .format(total)) Total is: 144 \nAbove, we summed over each combination of value and weight . We also took advantage of the increment notation in Python : the expression a += b increment is equivalent to a = a + b . Besides being a convenient notation, this can save time in computationally heavy tasks in which the intermediate value of a+b need not be explicitly created. Perhaps a more common task would be to sum over (value, weight) pairs. For instance, to compute the average value of a random variable that takes on possible values 2, 3 or 19 with probability 0.2, 0.3, 0.5 respec- tively we would compute the weighted sum. Tasks such as this can often be accomplished using the zip() function that loops over a sequence of tuples. zip() In [98]: total = 0 for value, weight in zip([2,3,19], [0.2,0.3,0.5]): total += weight * value print( 'Weighted average is: {0}' .format(total)) Weighted average is: 10.8 String Formatting In the code chunk above we also printed a string displaying the total. However, the object total is an integer and not a string. Inserting the value of something into a string is a common task, made simple using some of the powerful string formatting tools in Python . Many data cleaning tasks involve manipulating and programmatically producing strings. For example we may want to loop over the columns of a data frame and print the percent missing in each column. Let’s create a data frame D with columns in which 20% of the entries are missing i.e. set to np.nan . np.nan We’ll create the values in D from a normal distribution with mean 0 and variance 1 using rng.standard_normal() and then overwrite some random entries using rng.choice() . In [99]: rng = np.random.default_rng(1) A = rng.standard_normal((127, 5)) M = rng.choice([0, np.nan], p=[0.8,0.2], size=A.shape) A += M D = pd.DataFrame(A, columns=[ 'food' , 'bar' , 'pickle' , 'snack' , 'popcorn' ]) D[:3] Out[99]: food bar pickle snack popcorn 0 0.345584 0.821618 0.330437 -1.303157 NaN 1 NaN -0.536953 0.581118 0.364572 0.294132 2 NaN 0.546713 NaN -0.162910 -0.482119 In [100]: for col in D.columns: template = 'Column \"{0}\" has {1:.2%} missing values' print(template.format(col, np.isnan(D[col]).mean())) \nColumn \"food\" has 16.54% missing values Column \"bar\" has 25.98% missing values Column \"pickle\" has 29.13% missing values Column \"snack\" has 21.26% missing values Column \"popcorn\" has 22.83% missing values We see that the template.format() method expects two arguments {0} and {1:.2%} , and the latter includes some formatting information. In particular, it specifies that the second argument should be expressed as a percent with two decimal digits. The reference docs.python.org/3/library/string.html includes many help- ful and more complex examples. 2.3.9 Additional Graphical and Numerical Summaries We can use the ax.plot() or ax.scatter() functions to display the quan- titative variables. However, simply typing the variable names will produce an error message, because Python does not know to look in the Auto data set for those variables. In [101]: fig, ax = subplots(figsize=(8, 8)) ax.plot(horsepower, mpg, 'o' ); NameError: name 'horsepower' is not defined We can address this by accessing the columns directly: In [102]: fig, ax = subplots(figsize=(8, 8)) ax.plot(Auto[ 'horsepower' ], Auto[ 'mpg' ], 'o' ); Alternatively, we can use the plot() method with the call Auto.plot() . Us- .plot() ing this method, the variables can be accessed by name. The plot methods of a data frame return a familiar object: an axes. We can use it to update the plot as we did previously: In [103]: ax = Auto.plot.scatter( 'horsepower' , 'mpg' ); ax.set_title( 'Horsepower vs. MPG' ) If we want to save the figure that contains a given axes, we can find the relevant figure by accessing the figure attribute: In [104]: fig = ax.figure fig.savefig( 'horsepower_mpg.png' ); We can further instruct the data frame to plot to a particular axes object. In this case the corresponding plot() method will return the modified axes we passed in as an argument. Note that when we request a one-dimensional grid of plots, the object axes is similarly one-dimensional. We place our scatter plot in the middle plot of a row of three plots within a figure. In [105]: fig, axes = subplots(ncols=3, figsize=(15, 5)) Auto.plot.scatter( 'horsepower' , 'mpg' , ax=axes[1]); Note also that the columns of a data frame can be accessed as attributes: try typing in Auto.horsepower . \nWe now consider the cylinders variable. Typing in Auto.cylinders.dtype reveals that it is being treated as a quantitative variable. However, since there is only a small number of possible values for this variable, we may wish to treat it as qualitative. Below, we replace the cylinders column with a categorical version of Auto.cylinders . The function pd.Series() owes its pd.Series() name to the fact that pandas is often used in time series applications. In [106]: Auto.cylinders = pd.Series(Auto.cylinders, dtype= 'category' ) Auto.cylinders.dtype Now that cylinders is qualitative, we can display it using the boxplot() .boxplot() method. In [107]: fig, ax = subplots(figsize=(8, 8)) Auto.boxplot( 'mpg' , by= 'cylinders' , ax=ax); The hist() method can be used to plot a histogram . .hist() In [108]: fig, ax = subplots(figsize=(8, 8)) Auto.hist( 'mpg' , ax=ax); The color of the bars and the number of bins can be changed: In [109]: fig, ax = subplots(figsize=(8, 8)) Auto.hist( 'mpg' , color= 'red' , bins=12, ax=ax); See Auto.hist? for more plotting options. We can use the pd.plotting.scatter_matrix() function to create a scat- pd.plotting. scatter_ matrix() terplot matrix to visualize all of the pairwise relationships between the columns in a data frame. In [110]: pd.plotting.scatter_matrix(Auto); We can also produce scatterplots for a subset of the variables. In [111]: pd.plotting.scatter_matrix(Auto[[ 'mpg' , 'displacement' , 'weight' ]]); The describe() method produces a numerical summary of each column in .describe() a data frame. In [112]: Auto[[ 'mpg' , 'weight' ]].describe() We can also produce a summary of just a single column. In [113]: Auto[ 'cylinders' ].describe() Auto[ 'mpg' ].describe() To exit Jupyter , select File / Close and Halt . \n2.4 Exercises Conceptual 1. For each of parts (a) through (d), indicate whether we would generally expect the performance of a flexible statistical learning method to be better or worse than an inflexible method. Justify your answer. (a) The sample size n is extremely large, and the number of predic- tors p is small. (b) The number of predictors p is extremely large, and the number of observations n is small. (c) The relationship between the predictors and response is highly non-linear. (d) The variance of the error terms, i.e. σ 2 = Var ( ϵ ) , is extremely high. 2. Explain whether each scenario is a classification or regression prob- lem, and indicate whether we are most interested in inference or pre- diction. Finally, provide n and p . (a) We collect a set of data on the top 500 firms in the US. For each firm we record profit, number of employees, industry and the CEO salary. We are interested in understanding which factors affect CEO salary. (b) We are considering launching a new product and wish to know whether it will be a success or a failure . We collect data on 20 similar products that were previously launched. For each prod- uct we have recorded whether it was a success or failure, price charged for the product, marketing budget, competition price, and ten other variables. (c) We are interested in predicting the % change in the USD/Euro exchange rate in relation to the weekly changes in the world stock markets. Hence we collect weekly data for all of 2012. For each week we record the % change in the USD/Euro, the % change in the US market, the % change in the British market, and the % change in the German market. 3. We now revisit the bias-variance decomposition. (a) Provide a sketch of typical (squared) bias, variance, training er- ror, test error, and Bayes (or irreducible) error curves, on a sin- gle plot, as we go from less flexible statistical learning methods towards more flexible approaches. The x -axis should represent the amount of flexibility in the method, and the y -axis should represent the values for each curve. There should be five curves. Make sure to label each one. (b) Explain why each of the five curves has the shape displayed in part (a). \n4. You will now think of some real-life applications for statistical learn- ing. (a) Describe three real-life applications in which classification might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer. (b) Describe three real-life applications in which regression might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer. (c) Describe three real-life applications in which cluster analysis might be useful. 5. What are the advantages and disadvantages of a very flexible (versus a less flexible) approach for regression or classification? Under what circumstances might a more flexible approach be preferred to a less flexible approach? When might a less flexible approach be preferred? 6. Describe the differences between a parametric and a non-parametric statistical learning approach. What are the advantages of a para- metric approach to regression or classification (as opposed to a non- parametric approach)? What are its disadvantages? 7. The table below provides a training data set containing six observa- tions, three predictors, and one qualitative response variable. Obs. X 1 X 2 X 3 Y 1 0 3 0 Red 2 2 0 0 Red 3 0 1 3 Red 4 0 1 2 Green 5 − 1 0 1 Green 6 1 1 1 Red Suppose we wish to use this data set to make a prediction for Y when X 1 = X 2 = X 3 = 0 using K -nearest neighbors. (a) Compute the Euclidean distance between each observation and the test point, X 1 = X 2 = X 3 = 0 . (b) What is our prediction with K = 1 ? Why? (c) What is our prediction with K = 3 ? Why? (d) If the Bayes decision boundary in this problem is highly non- linear, then would we expect the best value for K to be large or small? Why? \nApplied 8. This exercise relates to the College data set, which can be found in the file College.csv on the book website. It contains a number of variables for 777 different universities and colleges in the US. The variables are • Private : Public/private indicator • Apps : Number of applications received • Accept : Number of applicants accepted • Enroll : Number of new students enrolled • Top10perc : New students from top 10 % of high school class • Top25perc : New students from top 25 % of high school class • F.Undergrad : Number of full-time undergraduates • P.Undergrad : Number of part-time undergraduates • Outstate : Out-of-state tuition • Room.Board : Room and board costs • Books : Estimated book costs • Personal : Estimated personal spending • PhD : Percent of faculty with Ph.D.s • Terminal : Percent of faculty with terminal degree • S.F.Ratio : Student/faculty ratio • perc.alumni : Percent of alumni who donate • Expend : Instructional expenditure per student • Grad.Rate : Graduation rate Before reading the data into Python , it can be viewed in Excel or a text editor. (a) Use the pd.read_csv() function to read the data into Python . Call the loaded data college . Make sure that you have the directory set to the correct location for the data. (b) Look at the data used in the notebook by creating and running a new cell with just the code college in it. You should notice that the first column is just the name of each university in a column named something like Unnamed: 0 . We don’t really want pandas to treat this as data. However, it may be handy to have these names for later. Try the following commands and similarly look at the resulting data frames: college2 = pd.read_csv( 'College.csv' , index_col=0) college3 = college.rename({ 'Unnamed: 0' : 'College' }, axis=1) college3 = college3.set_index( 'College' ) \nThis has used the first column in the file as an index for the data frame. This means that pandas has given each row a name corresponding to the appropriate university. Now you should see that the first data column is Private . Note that the names of the colleges appear on the left of the table. We also introduced a new python object above: a dictionary , which is specified by dictionary (key, value) pairs. Keep your modified version of the data with the following: college = college3 (c) Use the describe() method of to produce a numerical summary of the variables in the data set. (d) Use the pd.plotting.scatter_matrix() function to produce a scatterplot matrix of the first columns [Top10perc, Apps, Enroll] . Recall that you can reference a list C of columns of a data frame A using A[C] . (e) Use the boxplot() method of college to produce side-by-side boxplots of Outstate versus Private . (f) Create a new qualitative variable, called Elite , by binning the Top10perc variable into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%. college[ 'Elite' ] = pd.cut(college[ 'Top10perc' ], [0,0.5,1], labels=[ 'No' , 'Yes' ]) Use the value_counts() method of college['Elite'] to see how many elite universities there are. Finally, use the boxplot() method again to produce side-by-side boxplots of Outstate versus Elite . (g) Use the plot.hist() method of college to produce some his- tograms with differing numbers of bins for a few of the quanti- tative variables. The command plt.subplots(2, 2) may be use- ful: it will divide the plot window into four regions so that four plots can be made simultaneously. By changing the arguments you can divide the screen up in other combinations. (h) Continue exploring the data, and provide a brief summary of what you discover. 9. This exercise involves the Auto data set studied in the lab. Make sure that the missing values have been removed from the data. (a) Which of the predictors are quantitative, and which are quali- tative? (b) What is the range of each quantitative predictor? You can an- swer this using the min() and max() methods in numpy . .min() .max() (c) What is the mean and standard deviation of each quantitative predictor? \n(d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains? (e) Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some plots highlighting the relationships among the predictors. Comment on your findings. (f) Suppose that we wish to predict gas mileage ( mpg ) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg ? Justify your answer. 10. This exercise involves the Boston housing data set. (a) To begin, load in the Boston data set, which is part of the ISLP library. (b) How many rows are in this data set? How many columns? What do the rows and columns represent? (c) Make some pairwise scatterplots of the predictors (columns) in this data set. Describe your findings. (d) Are any of the predictors associated with per capita crime rate? If so, explain the relationship. (e) Do any of the suburbs of Boston appear to have particularly high crime rates? Tax rates? Pupil-teacher ratios? Comment on the range of each predictor. (f) How many of the suburbs in this data set bound the Charles river? (g) What is the median pupil-teacher ratio among the towns in this data set? (h) Which suburb of Boston has lowest median value of owner- occupied homes? What are the values of the other predictors for that suburb, and how do those values compare to the overall ranges for those predictors? Comment on your findings. (i) In this data set, how many of the suburbs average more than seven rooms per dwelling? More than eight rooms per dwelling? Comment on the suburbs that average more than eight rooms per dwelling. \n3 Linear Regression This chapter is about linear regression , a very simple approach for super- vised learning. In particular, linear regression is a useful tool for predicting a quantitative response. It has been around for a long time and is the topic of innumerable textbooks. Though it may seem somewhat dull compared to some of the more modern statistical learning approaches described in later chapters of this book, linear regression is still a useful and widely used sta- tistical learning method. Moreover, it serves as a good jumping-off point for newer approaches: as we will see in later chapters, many fancy statistical learning approaches can be seen as generalizations or extensions of linear regression. Consequently, the importance of having a good understanding of linear regression before studying more complex learning methods cannot be overstated. In this chapter, we review some of the key ideas underlying the linear regression model, as well as the least squares approach that is most commonly used to fit this model. Recall the Advertising data from Chapter 2 . Figure 2.1 displays sales (in thousands of units) for a particular product as a function of advertis- ing budgets (in thousands of dollars) for TV , radio , and newspaper media. Suppose that in our role as statistical consultants we are asked to suggest, on the basis of this data, a marketing plan for next year that will result in high product sales. What information would be useful in order to provide such a recommendation? Here are a few important questions that we might seek to address: 1. Is there a relationship between advertising budget and sales? Our first goal should be to determine whether the data provide evi- dence of an association between advertising expenditure and sales. If the evidence is weak, then one might argue that no money should be spent on advertising! 69 \n2. How strong is the relationship between advertising budget and sales? Assuming that there is a relationship between advertising and sales, we would like to know the strength of this relationship. Does knowl- edge of the advertising budget provide a lot of information about product sales? 3. Which media are associated with sales? Are all three media—TV, radio, and newspaper—associated with sales, or are just one or two of the media associated? To answer this question, we must find a way to separate out the individual contribu- tion of each medium to sales when we have spent money on all three media. 4. How large is the association between each medium and sales? For every dollar spent on advertising in a particular medium, by what amount will sales increase? How accurately can we predict this amount of increase? 5. How accurately can we predict future sales? For any given level of television, radio, or newspaper advertising, what is our prediction for sales, and what is the accuracy of this prediction? 6. Is the relationship linear? If there is approximately a straight-line relationship between advertis- ing expenditure in the various media and sales, then linear regression is an appropriate tool. If not, then it may still be possible to trans- form the predictor or the response so that linear regression can be used. 7. Is there synergy among the advertising media? Perhaps spending $50 , 000 on television advertising and $50 , 000 on ra- dio advertising is associated with higher sales than allocating $100 , 000 to either television or radio individually. In marketing, this is known as a synergy effect, while in statistics it is called an interaction effect. synergy interaction It turns out that linear regression can be used to answer each of these questions. We will first discuss all of these questions in a general context, and then return to them in this specific context in Section 3.4 . 3.1 Simple Linear Regression Simple linear regression lives up to its name: it is a very straightforward simple linear regression approach for predicting a quantitative response Y on the basis of a sin- gle predictor variable X . It assumes that there is approximately a linear relationship between X and Y . Mathematically, we can write this linear relationship as Y ≈ β 0 + β 1 X. (3.1) You might read “ ≈ ” as “is approximately modeled as” . We will sometimes describe ( 3.1 ) by saying that we are regressing Y on X (or Y onto X ). \nFor example, X may represent TV advertising and Y may represent sales . Then we can regress sales onto TV by fitting the model sales ≈ β 0 + β 1 × TV . In Equation 3.1 , β 0 and β 1 are two unknown constants that represent the intercept and slope terms in the linear model. Together, β 0 and β 1 are intercept slope known as the model coefficients or parameters . Once we have used our coefficient parameter training data to produce estimates ˆ β 0 and ˆ β 1 for the model coefficients, we can predict future sales on the basis of a particular value of TV advertising by computing ˆ y = ˆ β 0 + ˆ β 1 x, (3.2) where ˆ y indicates a prediction of Y on the basis of X = x . Here we use a hat symbol, ˆ , to denote the estimated value for an unknown parameter or coefficient, or to denote the predicted value of the response. 3.1.1 Estimating the Coefficients In practice, β 0 and β 1 are unknown. So before we can use ( 3.1 ) to make predictions, we must use data to estimate the coefficients. Let ( x 1 , y 1 ) , ( x 2 , y 2 ) , . . . , ( x n , y n ) represent n observation pairs, each of which consists of a measurement of X and a measurement of Y . In the Advertising example, this data set con- sists of the TV advertising budget and product sales in n = 200 different markets. (Recall that the data are displayed in Figure 2.1 .) Our goal is to obtain coefficient estimates ˆ β 0 and ˆ β 1 such that the linear model ( 3.1 ) fits the available data well—that is, so that y i ≈ ˆ β 0 + ˆ β 1 x i for i = 1 , . . . , n . In other words, we want to find an intercept ˆ β 0 and a slope ˆ β 1 such that the resulting line is as close as possible to the n = 200 data points. There are a number of ways of measuring closeness . However, by far the most com- mon approach involves minimizing the least squares criterion, and we take least squares that approach in this chapter. Alternative approaches will be considered in Chapter 6 . Let ˆ y i = ˆ β 0 + ˆ β 1 x i be the prediction for Y based on the i th value of X . Then e i = y i − ˆ y i represents the i th residual —this is the difference between residual the i th observed response value and the i th response value that is predicted by our linear model. We define the residual sum of squares (RSS) as residual sum of squares RSS = e 2 1 + e 2 2 + · · · + e 2 n , or equivalently as RSS = ( y 1 − ˆ β 0 − ˆ β 1 x 1 ) 2 +( y 2 − ˆ β 0 − ˆ β 1 x 2 ) 2 + · · · +( y n − ˆ β 0 − ˆ β 1 x n ) 2 . (3.3) The least squares approach chooses ˆ β 0 and ˆ β 1 to minimize the RSS. Using some calculus, one can show that the minimizers are ˆ β 1 = ) n i =1 ( x i − ¯ x )( y i − ¯ y ) ) n i =1 ( x i − ¯ x ) 2 , ˆ β 0 = ¯ y − ˆ β 1 ¯ x, (3.4) \n0 50 100 150 200 250 300 5 10 15 20 25 TV Sales FIGURE 3.1. For the Advertising data, the least squares fit for the regression of sales onto TV is shown. The fit is found by minimizing the residual sum of squares. Each grey line segment represents a residual. In this case a linear fit captures the essence of the relationship, although it overestimates the trend in the left of the plot. where ¯ y ≡ 1 n ) n i =1 y i and ¯ x ≡ 1 n ) n i =1 x i are the sample means. In other words, ( 3.4 ) defines the least squares coefficient estimates for simple linear regression. Figure 3.1 displays the simple linear regression fit to the Advertising data, where ˆ β 0 = 7 . 03 and ˆ β 1 = 0 . 0475 . In other words, according to this approximation, an additional $1 , 000 spent on TV advertising is asso- ciated with selling approximately 47 . 5 additional units of the product. In Figure 3.2 , we have computed RSS for a number of values of β 0 and β 1 , using the advertising data with sales as the response and TV as the predic- tor. In each plot, the red dot represents the pair of least squares estimates ( ˆ β 0 , ˆ β 1 ) given by ( 3.4 ). These values clearly minimize the RSS. 3.1.2 Assessing the Accuracy of the Coefficient Estimates Recall from ( 2.1 ) that we assume that the true relationship between X and Y takes the form Y = f ( X ) + ϵ for some unknown function f , where ϵ is a mean-zero random error term. If f is to be approximated by a linear function, then we can write this relationship as Y = β 0 + β 1 X + ϵ. (3.5) Here β 0 is the intercept term—that is, the expected value of Y when X = 0 , and β 1 is the slope—the average increase in Y associated with a one-unit increase in X . The error term is a catch-all for what we miss with this simple model: the true relationship is probably not linear, there may be other variables that cause variation in Y , and there may be measurement error. We typically assume that the error term is independent of X . \nFIGURE 3.2. Contour and three-dimensional plots of the RSS on the Advertising data, using sales as the response and TV as the predictor. The red dots correspond to the least squares estimates ˆ β 0 and ˆ β 1 , given by ( 3.4 ). The model given by ( 3.5 ) defines the population regression line , which population regression line is the best linear approximation to the true relationship between X and Y . 1 The least squares regression coefficient estimates ( 3.4 ) characterize the least squares line ( 3.2 ). The left-hand panel of Figure 3.3 displays these least squares line two lines in a simple simulated example. We created 100 random X s, and generated 100 corresponding Y s from the model Y = 2 + 3 X + ϵ, (3.6) where ϵ was generated from a normal distribution with mean zero. The red line in the left-hand panel of Figure 3.3 displays the true relationship, f ( X ) = 2 + 3 X , while the blue line is the least squares estimate based on the observed data. The true relationship is generally not known for real data, but the least squares line can always be computed using the coefficient estimates given in ( 3.4 ). In other words, in real applications, we have access to a set of observations from which we can compute the least squares line; however, the population regression line is unobserved. In the right-hand panel of Figure 3.3 we have generated ten different data sets from the model given by ( 3.6 ) and plotted the corresponding ten least squares lines. Notice that different data sets generated from the same true model result in slightly different least squares lines, but the unobserved population regression line does not change. At first glance, the difference between the population regression line and the least squares line may seem subtle and confusing. We only have one data set, and so what does it mean that two different lines describe the relationship between the predictor and the response? Fundamentally, the concept of these two lines is a natural extension of the standard statistical approach of using information from a sample to estimate characteristics of a large population. For example, suppose that we are interested in knowing 1 The assumption of linearity is often a useful working model. However, despite what many textbooks might tell us, we seldom believe that the true relationship is linear. β 0 β 1 2.11 2.15 2.2 2.3 2.5 2.5 3 3 5 6 7 8 9 0.03 0.04 0.05 0.06 RSS β 1 β 0 \n−2 −1 0 1 2 −10 −5 0 5 10 X Y −2 −1 0 1 2 −10 −5 0 5 10 X Y FIGURE 3.3. A simulated data set. Left: The red line represents the true relationship, f ( X ) = 2 + 3 X , which is known as the population regression line. The blue line is the least squares line; it is the least squares estimate for f ( X ) based on the observed data, shown in black. Right: The population regression line is again shown in red, and the least squares line in dark blue. In light blue, ten least squares lines are shown, each computed on the basis of a separate random set of observations. Each least squares line is different, but on average, the least squares lines are quite close to the population regression line. the population mean µ of some random variable Y . Unfortunately, µ is unknown, but we do have access to n observations from Y , y 1 , . . . , y n , which we can use to estimate µ . A reasonable estimate is ˆ µ = ¯ y , where ¯ y = 1 n ) n i =1 y i is the sample mean. The sample mean and the population mean are different, but in general the sample mean will provide a good estimate of the population mean. In the same way, the unknown coefficients β 0 and β 1 in linear regression define the population regression line. We seek to estimate these unknown coefficients using ˆ β 0 and ˆ β 1 given in ( 3.4 ). These coefficient estimates define the least squares line. The analogy between linear regression and estimation of the mean of a random variable is an apt one based on the concept of bias . If we use the bias sample mean ˆ µ to estimate µ , this estimate is unbiased , in the sense that unbiased on average, we expect ˆ µ to equal µ . What exactly does this mean? It means that on the basis of one particular set of observations y 1 , . . . , y n , ˆ µ might overestimate µ , and on the basis of another set of observations, ˆ µ might underestimate µ . But if we could average a huge number of estimates of µ obtained from a huge number of sets of observations, then this average would exactly equal µ . Hence, an unbiased estimator does not systematically over- or under-estimate the true parameter. The property of unbiasedness holds for the least squares coefficient estimates given by ( 3.4 ) as well: if we estimate β 0 and β 1 on the basis of a particular data set, then our estimates won’t be exactly equal to β 0 and β 1 . But if we could average the estimates obtained over a huge number of data sets, then the average of these estimates would be spot on! In fact, we can see from the right- hand panel of Figure 3.3 that the average of many least squares lines, each \nestimated from a separate data set, is pretty close to the true population regression line. We continue the analogy with the estimation of the population mean µ of a random variable Y . A natural question is as follows: how accurate is the sample mean ˆ µ as an estimate of µ ? We have established that the average of ˆ µ ’s over many data sets will be very close to µ , but that a single estimate ˆ µ may be a substantial underestimate or overestimate of µ . How far off will that single estimate of ˆ µ be? In general, we answer this question by computing the standard error of ˆ µ , written as SE(ˆ µ ) . We have standard error the well-known formula Var (ˆ µ ) = SE(ˆ µ ) 2 = σ 2 n , (3.7) where σ is the standard deviation of each of the realizations y i of Y . 2 Roughly speaking, the standard error tells us the average amount that this estimate ˆ µ differs from the actual value of µ . Equation 3.7 also tells us how this deviation shrinks with n —the more observations we have, the smaller the standard error of ˆ µ . In a similar vein, we can wonder how close ˆ β 0 and ˆ β 1 are to the true values β 0 and β 1 . To compute the standard errors associated with ˆ β 0 and ˆ β 1 , we use the following formulas: SE( ˆ β 0 ) 2 = σ 2 3 1 n + ¯ x 2 ) n i =1 ( x i − ¯ x ) 2 4 , SE( ˆ β 1 ) 2 = σ 2 ) n i =1 ( x i − ¯ x ) 2 , (3.8) where σ 2 = Var ( ϵ ) . For these formulas to be strictly valid, we need to assume that the errors ϵ i for each observation have common variance σ 2 and are uncorrelated. This is clearly not true in Figure 3.1 , but the formula still turns out to be a good approximation. Notice in the formula that SE( ˆ β 1 ) is smaller when the x i are more spread out; intuitively we have more leverage to estimate a slope when this is the case. We also see that SE( ˆ β 0 ) would be the same as SE(ˆ µ ) if ¯ x were zero (in which case ˆ β 0 would be equal to ¯ y ). In general, σ 2 is not known, but can be estimated from the data. This estimate of σ is kn own as the re sidual standard error , and is given by the formula residual standard error RSE = 5 RSS / ( n − 2) . Strictly speaking, when σ 2 is estimated from the data we should write 6 SE( ˆ β 1 ) to indicate that an estimate has been made, but for simplicity of notation we will drop this extra “hat”. Standard errors can be used to compute confidence intervals . A 95 % confidence interval confidence interval is defined as a range of values such that with 95 % probability, the range will contain the true unknown value of the param- eter. The range is defined in terms of lower and upper limits computed from the sample of data. A 95% confidence interval has the following prop- erty: if we take repeated samples and construct the confidence interval for each sample, 95% of the intervals will contain the true unknown value of the parameter. For linear regression, the 95 % confidence interval for β 1 approximately takes the form ˆ β 1 ± 2 · SE(ˆ β 1 ) . (3.9) 2 This formula holds provided that the n observations are uncorrelated. \nThat is, there is approximately a 95 % chance that the interval 7 ˆ β 1 − 2 · SE(ˆ β 1 ) , ˆ β 1 + 2 · SE(ˆ β 1 ) 8 (3.10) will contain the true value of β 1 . 3 Similarly, a confidence interval for β 0 approximately takes the form ˆ β 0 ± 2 · SE(ˆ β 0 ) . (3.11) In the case of the advertising data, the 95 % confidence interval for β 0 is [6 . 130 , 7 . 935] and the 95 % confidence interval for β 1 is [0 . 042 , 0 . 053] . Therefore, we can conclude that in the absence of any advertising, sales will, on average, fall somewhere between 6 , 130 and 7 , 935 units. Furthermore, for each $1 , 000 increase in television advertising, there will be an average increase in sales of between 42 and 53 units. Standard errors can also be used to perform hypothesis tests on the hypothesis test coefficients. The most common hypothesis test involves testing the null hypothesis of null hypothesis H 0 : There is no relationship between X and Y (3.12) versus the alternative hypothesis alternative hypothesis H a : There is some relationship between X and Y . (3.13) Mathematically, this corresponds to testing H 0 : β 1 = 0 versus H a : β 1 ̸ = 0 , since if β 1 = 0 then the model ( 3.5 ) reduces to Y = β 0 + ϵ , and X is not associated with Y . To test the null hypothesis, we need to determine whether ˆ β 1 , our estimate for β 1 , is sufficiently far from zero that we can be confident that β 1 is non-zero. How far is far enough? This of course depends on the accuracy of ˆ β 1 —that is, it depends on SE( ˆ β 1 ) . If SE( ˆ β 1 ) is small, then even relatively small values of ˆ β 1 may provide strong evidence that β 1 ̸ = 0 , and hence that there is a relationship between X and Y . In contrast, if SE( ˆ β 1 ) is large, then ˆ β 1 must be large in absolute value in order for us to reject the null hypothesis. In practice, we compute a t -statistic , t -statistic given by t = ˆ β 1 − 0 SE( ˆ β 1 ) , (3.14) 3 Approximately for several reasons. Equation 3.10 relies on the assumption that the errors are Gaussian. Also, the factor of 2 in front of the SE( ˆ β 1 ) term will vary slightly depending on the number of observations n in the linear regression. To be precise, rather than the number 2, ( 3.10 ) should contain the 97.5 % quantile of a t -distribution with n − 2 degrees of freedom. Details of how to compute the 95 % confidence interval precisely in R will be provided later in this chapter. \nCoef fi cient Std. error t -statistic p -value Intercept 7.0325 0.4578 15.36 < 0 . 0001 TV 0.0475 0.0027 17.67 < 0 . 0001 TABLE 3.1. For the Advertising data, coefficients of the least squares model for the regression of number of units sold on TV advertising budget. An increase of $1 , 000 in the TV advertising budget is associated with an increase in sales by around 50 units. (Recall that the sales variable is in thousands of units, and the TV variable is in thousands of dollars.) which measures the number of standard deviations that ˆ β 1 is away from 0 . If there really is no relationship between X and Y , then we expect that ( 3.14 ) will have a t -distribution with n − 2 degrees of freedom. The t -distribution has a bell shape and for values of n greater than approximately 30 it is quite similar to the standard normal distribution. Consequently, it is a simple matter to compute the probability of observing any number equal to | t | or larger in absolute value, assuming β 1 = 0 . We call this probability the p -value . Roughly speaking, we interpret the p -value as follows: a small p -value p -value indicates that it is unlikely to observe such a substantial association between the predictor and the response due to chance, in the absence of any real association between the predictor and the response. Hence, if we see a small p -value, then we can infer that there is an association between the predictor and the response. We reject the null hypothesis —that is, we declare a relationship to exist between X and Y —if the p -value is small enough. Typical p -value cutoffs for rejecting the null hypothesis are 5% or 1%, although this topic will be explored in much greater detail in Chap- ter 13 . When n = 30 , these correspond to t -statistics ( 3.14 ) of around 2 and 2.75, respectively. Table 3.1 provides details of the least squares model for the regression of number of units sold on TV advertising budget for the Advertising data. Notice that the coefficients for ˆ β 0 and ˆ β 1 are very large relative to their standard errors, so the t -statistics are also large; the probabilities of seeing such values if H 0 is true are virtually zero. Hence we can conclude that β 0 ̸ = 0 and β 1 ̸ = 0 . 4 3.1.3 Assessing the Accuracy of the Model Once we have rejected the null hypothesis ( 3.12 ) in favor of the alternative hypothesis ( 3.13 ), it is natural to want to quantify the extent to which the model fits the data . The quality of a linear regression fit is typically assessed using two related quantities: the residual standard error (RSE) and the R 2 R 2 statistic. 4 In Table 3.1 , a small p -value for the intercept indicates that we can reject the null hypothesis that β 0 = 0 , and a small p -value for TV indicates that we can reject the null hypothesis that β 1 = 0 . Rejecting the latter null hypothesis allows us to conclude that there is a relationship between TV and sales . Rejecting the former allows us to conclude that in the absence of TV expenditure, sales are non-zero. \nQuantity Value Residual standard error 3.26 R 2 0.612 F -statistic 312.1 TABLE 3.2. For the Advertising data, more information about the least squares model for the regression of number of units sold on TV advertising budget. Table 3.2 displays the RSE, the R 2 statistic, and the F -statistic (to be described in Section 3.2.2 ) for the linear regression of number of units sold on TV advertising budget. Residual Standard Error Recall from the model ( 3.5 ) that associated with each observation is an error term ϵ . Due to the presence of these error terms, even if we knew the true regression line (i.e. even if β 0 and β 1 were known), we would not be able to perfectly predict Y from X . The RSE is an estimate of the standard deviation of ϵ . Roughly speaking, it is the average amount that the response will deviate from the true regression line. It is computed using the formula RSE = 9 1 n − 2 RSS = : ; ; < 1 n − 2 n 0 i =1 ( y i − ˆ y i ) 2 . (3.15) Note that RSS was defined in Section 3.1.1 , and is given by the formula RSS = n 0 i =1 ( y i − ˆ y i ) 2 . (3.16) In the case of the advertising data, we see from the linear regression output in Table 3.2 that the RSE is 3 . 26 . In other words, actual sales in each market deviate from the true regression line by approximately 3 , 260 units, on average. Another way to think about this is that even if the model were correct and the true values of the unknown coefficients β 0 and β 1 were known exactly, any prediction of sales on the basis of TV advertising would still be off by about 3 , 260 units on average. Of course, whether or not 3 , 260 units is an acceptable prediction error depends on the problem context. In the advertising data set, the mean value of sales over all markets is approximately 14 , 000 units, and so the percentage error is 3 , 260 / 14 , 000 = 23 %. The RSE is considered a measure of the lack of fit of the model ( 3.5 ) to the data. If the predictions obtained using the model are very close to the true outcome values—that is, if ˆ y i ≈ y i for i = 1 , . . . , n —then ( 3.15 ) will be small, and we can conclude that the model fits the data very well. On the other hand, if ˆ y i is very far from y i for one or more observations, then the RSE may be quite large, indicating that the model doesn’t fit the data well. R 2 Statistic The RSE provides an absolute measure of lack of fit of the model ( 3.5 ) to the data. But since it is measured in the units of Y , it is not always \nclear what constitutes a good RSE. The R 2 statistic provides an alternative measure of fit. It takes the form of a proportion —the proportion of variance explained—and so it always takes on a value between 0 and 1 , and is independent of the scale of Y . To calculate R 2 , we use the formula R 2 = TSS − RSS TSS = 1 − RSS TSS (3.17) where TSS = ) ( y i − ¯ y ) 2 is the total sum of squares , and RSS is defined total sum of squares in ( 3.16 ). TSS measures the total variance in the response Y , and can be thought of as the amount of variability inherent in the response before the regression is performed. In contrast, RSS measures the amount of variability that is left unexplained after performing the regression. Hence, TSS − RSS measures the amount of variability in the response that is explained (or removed) by performing the regression, and R 2 measures the proportion of variability in Y that can be explained using X . An R 2 statistic that is close to 1 indicates that a large proportion of the variability in the response is explained by the regression. A number near 0 indicates that the regression does not explain much of the variability in the response; this might occur because the linear model is wrong, or the error variance σ 2 is high, or both. In Table 3.2 , the R 2 was 0 . 61 , and so just under two-thirds of the variability in sales is explained by a linear regression on TV . The R 2 statistic ( 3.17 ) has an interpretational advantage over the RSE ( 3.15 ), since unlike the RSE, it always lies between 0 and 1. However, it can still be challenging to determine what is a good R 2 value, and in general, this will depend on the application. For instance, in certain problems in physics, we may know that the data truly comes from a linear model with a small residual error. In this case, we would expect to see an R 2 value that is extremely close to 1 , and a substantially smaller R 2 value might indicate a serious problem with the experiment in which the data were generated. On the other hand, in typical applications in biology, psychology, marketing, and other domains, the linear model ( 3.5 ) is at best an extremely rough approximation to the data, and residual errors due to other unmeasured factors are often very large. In this setting, we would expect only a very small proportion of the variance in the response to be explained by the predictor, and an R 2 value well below 0 . 1 might be more realistic! The R 2 statistic is a measure of the linear relationship between X and Y . Recall that correlation , defined as correlation Cor ( X, Y ) = ) n i =1 ( x i − x )( y i − y ) 5 ) n i =1 ( x i − x ) 2 5 ) n i =1 ( y i − y ) 2 , (3.18) is also a measure of the linear relationship between X and Y . 5 This sug- gests that we might be able to use r = Cor ( X, Y ) instead of R 2 in order to assess the fit of the linear model. In fact, it can be shown that in the simple 5 We note that in fact, the right-hand side of ( 3.18 ) is the sample correlation; thus, it would be more correct to write ! Cor ( X, Y ) ; however, we omit the “hat” for ease of notation. \nSimple regression of sales on radio Coefficient Std. error t -statistic p -value Intercept 9.312 0.563 16.54 < 0 . 0001 radio 0.203 0.020 9.92 < 0 . 0001 Simple regression of sales on newspaper Coefficient Std. error t -statistic p -value Intercept 12.351 0.621 19.88 < 0 . 0001 newspaper 0.055 0.017 3.30 0 . 00115 TABLE 3.3. More simple linear regression models for the Advertising data. Coefficients of the simple linear regression model for number of units sold on Top: radio advertising budget and Bottom: newspaper advertising budget. A $ 1 , 000 in- crease in spending on radio advertising is associated with an average increase in sales by around 203 units, while the same increase in spending on newspaper ad- vertising is associated with an average increase in sales by around 55 units. (Note that the sales variable is in thousands of units, and the radio and newspaper variables are in thousands of dollars.) linear regression setting, R 2 = r 2 . In other words, the squared correlation and the R 2 statistic are identical. However, in the next section we will discuss the multiple linear regression problem, in which we use several pre- dictors simultaneously to predict the response. The concept of correlation between the predictors and the response does not extend automatically to this setting, since correlation quantifies the association between a single pair of variables rather than between a larger number of variables. We will see that R 2 fills this role. 3.2 Multiple Linear Regression Simple linear regression is a useful approach for predicting a response on the basis of a single predictor variable. However, in practice we often have more than one predictor. For example, in the Advertising data, we have examined the relationship between sales and TV advertising. We also have data for the amount of money spent advertising on the radio and in newspapers, and we may want to know whether either of these two media is associated with sales. How can we extend our analysis of the advertising data in order to accommodate these two additional predictors? One option is to run three separate simple linear regressions, each of which uses a different advertising medium as a predictor. For instance, we can fit a simple linear regression to predict sales on the basis of the amount spent on radio advertisements. Results are shown in Table 3.3 (top table). We find that a $ 1 , 000 increase in spending on radio advertising is associated with an increase in sales of around 203 units. Table 3.3 (bottom table) contains the least squares coefficients for a simple linear regression of sales onto newspaper advertising budget. A $1 , 000 increase in newspaper advertising budget is associated with an increase in sales of approximately 55 units. \nHowever, the approach of fitting a separate simple linear regression model for each predictor is not entirely satisfactory. First of all, it is unclear how to make a single prediction of sales given the three advertising media budgets, since each of the budgets is associated with a separate regression equation. Second, each of the three regression equations ignores the other two media in forming estimates for the regression coefficients. We will see shortly that if the media budgets are correlated with each other in the 200 markets in our data set, then this can lead to very misleading estimates of the association between each media budget and sales. Instead of fitting a separate simple linear regression model for each pre- dictor, a better approach is to extend the simple linear regression model ( 3.5 ) so that it can directly accommodate multiple predictors. We can do this by giving each predictor a separate slope coefficient in a single model. In general, suppose that we have p distinct predictors. Then the multiple linear regression model takes the form Y = β 0 + β 1 X 1 + β 2 X 2 + · · · + β p X p + ϵ, (3.19) where X j represents the j th predictor and β j quantifies the association between that variable and the response. We interpret β j as the average effect on Y of a one unit increase in X j , holding all other predictors fixed . In the advertising example, ( 3.19 ) becomes sales = β 0 + β 1 × TV + β 2 × radio + β 3 × newspaper + ϵ. (3.20) 3.2.1 Estimating the Regression Coefficients As was the case in the simple linear regression setting, the regression coef- ficients β 0 , β 1 , . . . , β p in ( 3.19 ) are unknown, and must be estimated. Given estimates ˆ β 0 , ˆ β 1 , . . . , ˆ β p , we can make predictions using the formula ˆ y = ˆ β 0 + ˆ β 1 x 1 + ˆ β 2 x 2 + · · · + ˆ β p x p . (3.21) The parameters are estimated using the same least squares approach that we saw in the context of simple linear regression. We choose β 0 , β 1 , . . . , β p to minimize the sum of squared residuals RSS = n 0 i =1 ( y i − ˆ y i ) 2 = n 0 i =1 ( y i − ˆ β 0 − ˆ β 1 x i 1 − ˆ β 2 x i 2 −· · · − ˆ β p x ip ) 2 . (3.22) The values ˆ β 0 , ˆ β 1 , . . . , ˆ β p that minimize ( 3.22 ) are the multiple least squares regression coefficient estimates. Unlike the simple linear regression esti- mates given in ( 3.4 ), the multiple regression coefficient estimates have somewhat complicated forms that are most easily represented using ma- trix algebra. For this reason, we do not provide them here. Any statistical software package can be used to compute these coefficient estimates, and later in this chapter we will show how this can be done in R . Figure 3.4 \nX 1 X 2 Y FIGURE 3.4. In a three-dimensional setting, with two predictors and one response, the least squares regression line becomes a plane. The plane is chosen to minimize the sum of the squared vertical distances between each observation (shown in red) and the plane. illustrates an example of the least squares fit to a toy data set with p = 2 predictors. Table 3.4 displays the multiple regression coefficient estimates when TV, radio, and newspaper advertising budgets are used to predict product sales using the Advertising data. We interpret these results as follows: for a given amount of TV and newspaper advertising, spending an additional $1 , 000 on radio advertising is associated with approximately 189 units of additional sales. Comparing these coefficient estimates to those displayed in Tables 3.1 and 3.3 , we notice that the multiple regression coefficient estimates for TV and radio are pretty similar to the simple linear regression coefficient estimates. However, while the newspaper regression coefficient estimate in Table 3.3 was significantly non-zero, the coefficient estimate for newspaper in the multiple regression model is close to zero, and the corresponding p - value is no longer significant, with a value around 0 . 86 . This illustrates that the simple and multiple regression coefficients can be quite different. This difference stems from the fact that in the simple regression case, the slope term represents the average increase in product sales associated with a $1 , 000 increase in newspaper advertising, ignoring other predictors such as TV and radio . By contrast, in the multiple regression setting, the coefficient for newspaper represents the average increase in product sales associated with increasing newspaper spending by $1 , 000 while holding TV and radio fixed. Does it make sense for the multiple regression to suggest no relationship between sales and newspaper while the simple linear regression implies the \nCoef fi cient Std. error t -statistic p -value Intercept 2.939 0.3119 9.42 < 0 . 0001 TV 0.046 0.0014 32.81 < 0 . 0001 radio 0.189 0.0086 21.89 < 0 . 0001 newspaper − 0.001 0.0059 − 0.18 0 . 8599 TABLE 3.4. For the Advertising data, least squares coefficient estimates of the multiple linear regression of number of units sold on TV, radio, and newspaper advertising budgets. TV radio newspaper sales TV 1.0000 0.0548 0.0567 0.7822 radio 1.0000 0.3541 0.5762 newspaper 1.0000 0.2283 sales 1.0000 TABLE 3.5. Correlation matrix for TV , radio , newspaper , and sales for the Advertising data. opposite? In fact it does. Consider the correlation matrix for the three predictor variables and response variable, displayed in Table 3.5 . Notice that the correlation between radio and newspaper is 0 . 35 . This indicates that markets with high newspaper advertising tend to also have high ra- dio advertising. Now suppose that the multiple regression is correct and newspaper advertising is not associated with sales, but radio advertising is associated with sales. Then in markets where we spend more on radio our sales will tend to be higher, and as our correlation matrix shows, we also tend to spend more on newspaper advertising in those same mar- kets. Hence, in a simple linear regression which only examines sales versus newspaper , we will observe that higher values of newspaper tend to be as- sociated with higher values of sales , even though newspaper advertising is not directly associated with sales. So newspaper advertising is a surrogate for radio advertising; newspaper gets “credit” for the association between radio on sales . This slightly counterintuitive result is very common in many real life situations. Consider an absurd example to illustrate the point. Running a regression of shark attacks versus ice cream sales for data collected at a given beach community over a period of time would show a positive relationship, similar to that seen between sales and newspaper . Of course no one has (yet) suggested that ice creams should be banned at beaches to reduce shark attacks. In reality, higher temperatures cause more people to visit the beach, which in turn results in more ice cream sales and more shark attacks. A multiple regression of shark attacks onto ice cream sales and temperature reveals that, as intuition implies, ice cream sales is no longer a significant predictor after adjusting for temperature. 3.2.2 Some Important Questions When we perform multiple linear regression, we usually are interested in answering a few important questions. \n1. Is at least one of the predictors X 1 , X 2 , . . . , X p useful in predicting the response? 2. Do all the predictors help to explain Y , or is only a subset of the predictors useful? 3. How well does the model fit the data? 4. Given a set of predictor values, what response value should we predict, and how accurate is our prediction? We now address each of these questions in turn. One: Is There a Relationship Between the Response and Predictors? Recall that in the simple linear regression setting, in order to determine whether there is a relationship between the response and the predictor we can simply check whether β 1 = 0 . In the multiple regression setting with p predictors, we need to ask whether all of the regression coefficients are zero, i.e. whether β 1 = β 2 = · · · = β p = 0 . As in the simple linear regression setting, we use a hypothesis test to answer this question. We test the null hypothesis, H 0 : β 1 = β 2 = · · · = β p = 0 versus the alternative H a : at least one β j is non-zero. This hypothesis test is performed by computing the F -statistic , F -statistic F = (TSS − RSS) /p RSS / ( n − p − 1) , (3.23) where, as with simple linear regression, TSS = ) ( y i − ¯ y ) 2 and RSS = ) ( y i − ˆ y i ) 2 . If the linear model assumptions are correct, one can show that E { RSS / ( n − p − 1) } = σ 2 and that, provided H 0 is true, E { (TSS − RSS) /p } = σ 2 . Hence, when there is no relationship between the response and predictors, one would expect the F -statistic to take on a value close to 1 . On the other hand, if H a is true, then E { (TSS − RSS) /p } > σ 2 , so we expect F to be greater than 1 . The F -statistic for the multiple linear regression model obtained by re- gressing sales onto radio , TV , and newspaper is shown in Table 3.6 . In this example the F -statistic is 570 . Since this is far larger than 1 , it provides compelling evidence against the null hypothesis H 0 . In other words, the large F -statistic suggests that at least one of the advertising media must be related to sales . However, what if the F -statistic had been closer to 1 ? How large does the F -statistic need to be before we can reject H 0 and \nQuantity Value Residual standard error 1.69 R 2 0.897 F -statistic 570 TABLE 3.6. More information about the least squares model for the regression of number of units sold on TV, newspaper, and radio advertising budgets in the Advertising data. Other information about this model was displayed in Table 3.4 . conclude that there is a relationship? It turns out that the answer depends on the values of n and p . When n is large, an F -statistic that is just a little larger than 1 might still provide evidence against H 0 . In contrast, a larger F -statistic is needed to reject H 0 if n is small. When H 0 is true and the errors ϵ i have a normal distribution, the F -statistic follows an F -distribution. 6 For any given value of n and p , any statistical software package can be used to compute the p -value associated with the F -statistic using this distribution. Based on this p -value, we can determine whether or not to reject H 0 . For the advertising data, the p -value associated with the F -statistic in Table 3.6 is essentially zero, so we have extremely strong evidence that at least one of the media is associated with increased sales . In ( 3.23 ) we are testing H 0 that all the coefficients are zero. Sometimes we want to test that a particular subset of q of the coefficients are zero. This corresponds to a null hypothesis H 0 : β p − q +1 = β p − q +2 = · · · = β p = 0 , where for convenience we have put the variables chosen for omission at the end of the list. In this case we fit a second model that uses all the variables except those last q . Suppose that the residual sum of squares for that model is RSS 0 . Then the appropriate F -statistic is F = (RSS 0 − RSS) /q RSS / ( n − p − 1) . (3.24) Notice that in Table 3.4 , for each individual predictor a t -statistic and a p -value were reported. These provide information about whether each individual predictor is related to the response, after adjusting for the other predictors. It turns out that each of these is exactly equivalent 7 to the F - test that omits that single variable from the model, leaving all the others in—i.e. q =1 in ( 3.24 ). So it reports the partial effect of adding that variable to the model. For instance, as we discussed earlier, these p -values indicate that TV and radio are related to sales , but that there is no evidence that newspaper is associated with sales , when TV and radio are held fixed. Given these individual p -values for each variable, why do we need to look at the overall F -statistic? After all, it seems likely that if any one of the p -values for the individual variables is very small, then at least one of the predictors is related to the response . However, this logic is flawed, especially when the number of predictors p is large. 6 Even if the errors are not normally-distributed, the F -statistic approximately follows an F -distribution provided that the sample size n is large. 7 The square of each t -statistic is the corresponding F -statistic. \nFor instance, consider an example in which p = 100 and H 0 : β 1 = β 2 = · · · = β p = 0 is true, so no variable is truly associated with the response. In this situation, about 5 % of the p -values associated with each variable (of the type shown in Table 3.4 ) will be below 0 . 05 by chance. In other words, we expect to see approximately five small p -values even in the absence of any true association between the predictors and the response. 8 In fact, it is likely that we will observe at least one p -value below 0 . 05 by chance! Hence, if we use the individual t -statistics and associated p -values in order to decide whether or not there is any association between the variables and the response, there is a very high chance that we will incorrectly conclude that there is a relationship. However, the F -statistic does not suffer from this problem because it adjusts for the number of predictors. Hence, if H 0 is true, there is only a 5 % chance that the F -statistic will result in a p - value below 0 . 05 , regardless of the number of predictors or the number of observations. The approach of using an F -statistic to test for any association between the predictors and the response works when p is relatively small, and cer- tainly small compared to n . However, sometimes we have a very large num- ber of variables. If p > n then there are more coefficients β j to estimate than observations from which to estimate them. In this case we cannot even fit the multiple linear regression model using least squares, so the F - statistic cannot be used, and neither can most of the other concepts that we have seen so far in this chapter. When p is large, some of the approaches discussed in the next section, such as forward selection , can be used. This high-dimensional setting is discussed in greater detail in Chapter 6 . high- dimensional Two: Deciding on Important Variables As discussed in the previous section, the first step in a multiple regression analysis is to compute the F -statistic and to examine the associated p - value. If we conclude on the basis of that p -value that at least one of the predictors is related to the response, then it is natural to wonder which are the guilty ones! We could look at the individual p -values as in Table 3.4 , but as discussed (and as further explored in Chapter 13 ), if p is large we are likely to make some false discoveries. It is possible that all of the predictors are associated with the response, but it is more often the case that the response is only associated with a subset of the predictors. The task of determining which predictors are associated with the response, in order to fit a single model involving only those predictors, is referred to as variable selection . The variable selection variable selection problem is studied extensively in Chapter 6 , and so here we will provide only a brief outline of some classical approaches. Ideally, we would like to perform variable selection by trying out a lot of different models, each containing a different subset of the predictors. For instance, if p = 2 , then we can consider four models: (1) a model contain- ing no variables, (2) a model containing X 1 only, (3) a model containing 8 This is related to the important concept of multiple testing , which is the focus of Chapter 13 . \nX 2 only, and (4) a model containing both X 1 and X 2 . We can then se- lect the best model out of all of the models that we have considered. How do we determine which model is best? Various statistics can be used to judge the quality of a model. These include Mallow’s C p , Akaike informa- Mallow’s C p tion criterion (AIC), Bayesian information criterion (BIC), and adjusted Akaike information criterion Bayesian information criterion R 2 . These are discussed in more detail in Chapter 6 . We can also deter- adjusted R 2 mine which model is best by plotting various model outputs, such as the residuals, in order to search for patterns. Unfortunately, there are a total of 2 p models that contain subsets of p variables. This means that even for moderate p , trying out every possible subset of the predictors is infeasible. For instance, we saw that if p = 2 , then there are 2 2 = 4 models to consider. But if p = 30 , then we must consider 2 30 = 1 , 073 , 741 , 824 models! This is not practical. Therefore, unless p is very small, we cannot consider all 2 p models, and instead we need an automated and efficient approach to choose a smaller set of models to consider. There are three classical approaches for this task: • Forward selection . We begin with the null model —a model that con- forward selection null model tains an intercept but no predictors. We then fit p simple linear re- gressions and add to the null model the variable that results in the lowest RSS. We then add to that model the variable that results in the lowest RSS for the new two-variable model. This approach is continued until some stopping rule is satisfied. • Backward selection . We start with all variables in the model, and backward selection remove the variable with the largest p -value—that is, the variable that is the least statistically significant. The new ( p − 1) -variable model is fit, and the variable with the largest p -value is removed. This procedure continues until a stopping rule is reached. For instance, we may stop when all remaining variables have a p -value below some threshold. • Mixed selection . This is a combination of forward and backward se- mixed selection lection. We start with no variables in the model, and as with forward selection, we add the variable that provides the best fit. We con- tinue to add variables one-by-one. Of course, as we noted with the Advertising example, the p -values for variables can become larger as new predictors are added to the model. Hence, if at any point the p -value for one of the variables in the model rises above a certain threshold, then we remove that variable from the model. We con- tinue to perform these forward and backward steps until all variables in the model have a sufficiently low p -value, and all variables outside the model would have a large p -value if added to the model. Backward selection cannot be used if p > n , while forward selection can always be used. Forward selection is a greedy approach, and might include variables early that later become redundant. Mixed selection can remedy this. \nThree: Model Fit Two of the most common numerical measures of model fit are the RSE and R 2 , the fraction of variance explained. These quantities are computed and interpreted in the same fashion as for simple linear regression. Recall that in simple regression, R 2 is the square of the correlation of the response and the variable. In multiple linear regression, it turns out that it equals Cor ( Y, ˆ Y ) 2 , the square of the correlation between the response and the fitted linear model; in fact one property of the fitted linear model is that it maximizes this correlation among all possible linear models. An R 2 value close to 1 indicates that the model explains a large por- tion of the variance in the response variable. As an example, we saw in Table 3.6 that for the Advertising data, the model that uses all three ad- vertising media to predict sales has an R 2 of 0 . 8972 . On the other hand, the model that uses only TV and radio to predict sales has an R 2 value of 0 . 89719 . In other words, there is a small increase in R 2 if we include newspaper advertising in the model that already contains TV and radio advertising, even though we saw earlier that the p -value for newspaper ad- vertising in Table 3.4 is not significant. It turns out that R 2 will always increase when more variables are added to the model, even if those vari- ables are only weakly associated with the response. This is due to the fact that adding another variable always results in a decrease in the residual sum of squares on the training data (though not necessarily the testing data). Thus, the R 2 statistic, which is also computed on the training data, must increase. The fact that adding newspaper advertising to the model containing only TV and radio advertising leads to just a tiny increase in R 2 provides additional evidence that newspaper can be dropped from the model. Essentially, newspaper provides no real improvement in the model fit to the training samples, and its inclusion will likely lead to poor results on independent test samples due to overfitting. By contrast, the model containing only TV as a predictor had an R 2 of 0 . 61 (Table 3.2 ). Adding radio to the model leads to a substantial improve- ment in R 2 . This implies that a model that uses TV and radio expenditures to predict sales is substantially better than one that uses only TV advertis- ing. We could further quantify this improvement by looking at the p -value for the radio coefficient in a model that contains only TV and radio as predictors. The model that contains only TV and radio as predictors has an RSE of 1.681, and the model that also contains newspaper as a predictor has an RSE of 1.686 (Table 3.6 ). In contrast, the model that contains only TV has an RSE of 3 . 26 (Table 3.2 ). This corroborates our previous conclusion that a model that uses TV and radio expenditures to predict sales is much more accurate (on the training data) than one that only uses TV spending. Furthermore, given that TV and radio expenditures are used as predictors, there is no point in also using newspaper spending as a predictor in the model. The observant reader may wonder how RSE can increase when newspaper is added to the model given that RSS must decrease. In general RSE is defined as RSE = 9 1 n − p − 1 RSS , (3.25) \nSales Radio TV FIGURE 3.5. For the Advertising data, a linear regression fit to sales using TV and radio as predictors. From the pattern of the residuals, we can see that there is a pronounced non-linear relationship in the data. The positive residuals (those visible above the surface), tend to lie along the 45-degree line, where TV and Radio budgets are split evenly. The negative residuals (most not visible), tend to lie away from this line, where budgets are more lopsided. which simplifies to ( 3.15 ) for a simple linear regression. Thus, models with more variables can have higher RSE if the decrease in RSS is small relative to the increase in p . In addition to looking at the RSE and R 2 statistics just discussed, it can be useful to plot the data. Graphical summaries can reveal problems with a model that are not visible from numerical statistics. For example, Figure 3.5 displays a three-dimensional plot of TV and radio versus sales . We see that some observations lie above and some observations lie below the least squares regression plane. In particular, the linear model seems to overestimate sales for instances in which most of the advertising money was spent exclusively on either TV or radio . It underestimates sales for instances where the budget was split between the two media. This pro- nounced non-linear pattern suggests a synergy or interaction effect between interaction the advertising media, whereby combining the media together results in a bigger boost to sales than using any single medium. In Section 3.3.2 , we will discuss extending the linear model to accommodate such synergistic effects through the use of interaction terms. Four: Predictions Once we have fit the multiple regression model, it is straightforward to apply ( 3.21 ) in order to predict the response Y on the basis of a set of values for the predictors X 1 , X 2 , . . . , X p . However, there are three sorts of uncertainty associated with this prediction. 1. The coefficient estimates ˆ β 0 , ˆ β 1 , . . . , ˆ β p are estimates for β 0 , β 1 , . . . , β p . That is, the least squares plane ˆ Y = ˆ β 0 + ˆ β 1 X 1 + · · · + ˆ β p X p \nis only an estimate for the true population regression plane f ( X ) = β 0 + β 1 X 1 + · · · + β p X p . The inaccuracy in the coefficient estimates is related to the reducible error from Chapter 2 . We can compute a confidence interval in order to determine how close ˆ Y will be to f ( X ) . 2. Of course, in practice assuming a linear model for f ( X ) is almost always an approximation of reality, so there is an additional source of potentially reducible error which we call model bias . So when we use a linear model, we are in fact estimating the best linear approximation to the true surface. However, here we will ignore this discrepancy, and operate as if the linear model were correct. 3. Even if we knew f ( X ) —that is, even if we knew the true values for β 0 , β 1 , . . . , β p —the response value cannot be predicted perfectly because of the random error ϵ in the model ( 3.20 ). In Chapter 2 , we referred to this as the irreducible error . How much will Y vary from ˆ Y ? We use prediction intervals to answer this question. Prediction intervals are always wider than confidence intervals, because they incorporate both the error in the estimate for f ( X ) (the reducible error) and the uncertainty as to how much an individual point will differ from the population regression plane (the irreducible error). We use a confidence interval to quantify the uncertainty surrounding confidence interval the average sales over a large number of cities. For example, given that $100 , 000 is spent on TV advertising and $20 , 000 is spent on radio advertising in each city, the 95 % confidence interval is [10 , 985 , 11 , 528] . We interpret this to mean that 95 % of intervals of this form will contain the true value of f ( X ) . 9 On the other hand, a prediction interval can be used to quantify the prediction interval uncertainty surrounding sales for a particular city. Given that $100 , 000 is spent on TV advertising and $20 , 000 is spent on radio advertising in that city the 95 % prediction interval is [7 , 930 , 14 , 580] . We interpret this to mean that 95 % of intervals of this form will contain the true value of Y for this city. Note that both intervals are centered at 11 , 256 , but that the prediction interval is substantially wider than the confidence interval, reflecting the increased uncertainty about sales for a given city in comparison to the average sales over many locations. 9 In other words, if we collect a large number of data sets like the Advertising data set, and we construct a confidence interval for the average sales on the basis of each data set (given $100 , 000 in TV and $20 , 000 in radio advertising), then 95 % of these confidence intervals will contain the true value of average sales . \n3.3 Other Considerations in the Regression Model 3.3.1 Qualitative Predictors In our discussion so far, we have assumed that all variables in our linear regression model are quantitative . But in practice, this is not necessarily the case; often some predictors are qualitative . For example, the Credit data set displayed in Figure 3.6 records variables for a number of credit card holders. The response is balance (average credit card debt for each individual) and there are several quantitative predictors: age , cards (number of credit cards), education (years of education), income (in thousands of dollars), limit (credit limit), and rating (credit rating). Each panel of Figure 3.6 is a scatterplot for a pair of variables whose iden- tities are given by the corresponding row and column labels. For example, the scatterplot directly to the right of the word “Balance” depicts balance versus age , while the plot directly to the right of “Age” corresponds to age versus cards . In addition to these quantitative variables, we also have four qualitative variables: own (house ownership), student (student status), status (marital status), and region (East, West or South). Predictors with Only Two Levels Suppose that we wish to investigate differences in credit card balance be- tween those who own a house and those who don’t, ignoring the other vari- ables for the moment. If a qualitative predictor (also known as a factor ) factor only has two levels , or possible values, then incorporating it into a regres- level sion model is very simple. We simply create an indicator or dummy variable dummy variable that takes on two possible numerical values. 10 For example, based on the own variable, we can create a new variable that takes the form x i = = 1 if i th person owns a house 0 if i th person does not own a house , (3.26) and use this variable as a predictor in the regression equation. This results in the model y i = β 0 + β 1 x i + ϵ i = = β 0 + β 1 + ϵ i if i th person owns a house β 0 + ϵ i if i th person does not . (3.27) Now β 0 can be interpreted as the average credit card balance among those who do not own, β 0 + β 1 as the average credit card balance among those who do own their house, and β 1 as the average difference in credit card balance between owners and non-owners. Table 3.7 displays the coefficient estimates and other information asso- ciated with the model ( 3.27 ). The average credit card debt for non-owners is estimated to be $509 . 80 , whereas owners are estimated to carry $19 . 73 in additional debt for a total of $509 . 80 + $19 . 73 = $529 . 53 . However, we 10 In the machine learning community, the creation of dummy variables to handle qualitative predictors is known as “one-hot encoding”. \nBalance 20 40 60 80 100 5 10 15 20 2000 8000 14000 0 500 1500 20 40 60 80 100 Age Cards 2 4 6 8 5 10 15 20 Education Income 50 100 150 2000 8000 14000 Limit 0 500 1500 2 4 6 8 50 100 150 200 600 1000 200 600 1000 Rating FIGURE 3.6. The Credit data set contains information about balance , age , cards , education , income , limit , and rating for a number of potential cus- tomers. notice that the p -value for the dummy variable is very high. This indicates that there is no statistical evidence of a difference in average credit card balance based on house ownership. The decision to code owners as 1 and non-owners as 0 in ( 3.27 ) is ar- bitrary, and has no effect on the regression fit, but does alter the inter- pretation of the coefficients. If we had coded non-owners as 1 and own- ers as 0 , then the estimates for β 0 and β 1 would have been 529 . 53 and − 19 . 73 , respectively, leading once again to a prediction of credit card debt of $529 . 53 − $19 . 73 = $509 . 80 for non-owners and a prediction of $529 . 53 for owners. Alternatively, instead of a 0 / 1 coding scheme, we could create a dummy variable x i = = 1 if i th person owns a house − 1 if i th person does not own a house and use this variable in the regression equation. This results in the model y i = β 0 + β 1 x i + ϵ i = = β 0 + β 1 + ϵ i if i th person owns a house β 0 − β 1 + ϵ i if i th person does not own a house. \nCoef fi cient Std. error t -statistic p -value Intercept 509.80 33.13 15.389 < 0 . 0001 own[Yes] 19.73 46.05 0.429 0.6690 TABLE 3.7. Least squares coefficient estimates associated with the regression of balance onto own in the Credit data set. The linear model is given in ( 3.27 ). That is, ownership is encoded as a dummy variable, as in ( 3.26 ). Now β 0 can be interpreted as the overall average credit card balance (ig- noring the house ownership effect), and β 1 is the amount by which house owners and non-owners have credit card balances that are above and below the average, respectively. 11 In this example, the estimate for β 0 is $519 . 665 , halfway between the non-owner and owner averages of $509 . 80 and $529 . 53 . The estimate for β 1 is $9 . 865 , which is half of $19 . 73 , the average difference between owners and non-owners. It is important to note that the final pre- dictions for the credit balances of owners and non-owners will be identical regardless of the coding scheme used. The only difference is in the way that the coefficients are interpreted. Qualitative Predictors with More than Two Levels When a qualitative predictor has more than two levels, a single dummy variable cannot represent all possible values. In this situation, we can create additional dummy variables. For example, for the region variable we create two dummy variables. The first could be x i 1 = = 1 if i th person is from the South 0 if i th person is not from the South , (3.28) and the second could be x i 2 = = 1 if i th person is from the West 0 if i th person is not from the West . (3.29) Then both of these variables can be used in the regression equation, in order to obtain the model y i = β 0 + β 1 x i 1 + β 2 x i 2 + ϵ i =      β 0 + β 1 + ϵ i if i th person is from the South β 0 + β 2 + ϵ i if i th person is from the West β 0 + ϵ i if i th person is from the East . ( 3.30) Now β 0 can be interpreted as the average credit card balance for individuals from the East, β 1 can be interpreted as the difference in the average balance between people from the South versus the East, and β 2 can be interpreted as the difference in the average balance between those from the West versus the East. There will always be one fewer dummy variable than the number of levels. The level with no dummy variable—East in this example—is known as the baseline . baseline 11 Technically β 0 is half the sum of the average debt for house owners and the average debt for non-house owners. Hence, β 0 is exactly equal to the overall average only if the two groups have an equal number of members. \nCoef fi cient Std. error t -statistic p -value Intercept 531.00 46.32 11.464 < 0 . 0001 region[South] − 12.50 56.68 − 0.221 0.8260 region[West] − 18.69 65.02 − 0.287 0.7740 TABLE 3.8. Least squares coefficient estimates associated with the regression of balance onto region in the Credit data set. The linear model is given in ( 3.30 ). That is, region is encoded via two dummy variables ( 3.28 ) and ( 3.29 ). From Table 3.8 , we see that the estimated balance for the baseline, East, is $531 . 00 . It is estimated that those in the South will have $18 . 69 less debt than those in the East, and that those in the West will have $12 . 50 less debt than those in the East. However, the p -values associated with the coefficient estimates for the two dummy variables are very large, suggesting no statistical evidence of a real difference in average credit card balance between South and East or between West and East. 12 Once again, the level selected as the baseline category is arbitrary, and the final predictions for each group will be the same regardless of this choice. However, the coefficients and their p -values do depend on the choice of dummy variable coding. Rather than rely on the individual coefficients, we can use an F -test to test H 0 : β 1 = β 2 = 0 ; this does not depend on the coding. This F -test has a p -value of 0 . 96 , indicating that we cannot reject the null hypothesis that there is no relationship between balance and region . Using this dummy variable approach presents no difficulties when in- corporating both quantitative and qualitative predictors. For example, to regress balance on both a quantitative variable such as income and a qual- itative variable such as student , we must simply create a dummy variable for student and then fit a multiple regression model using income and the dummy variable as predictors for credit card balance. There are many different ways of coding qualitative variables besides the dummy variable approach taken here. All of these approaches lead to equivalent model fits, but the coefficients are different and have different interpretations, and are designed to measure particular contrasts . This topic contrast is beyond the scope of the book. 3.3.2 Extensions of the Linear Model The standard linear regression model ( 3.19 ) provides interpretable results and works quite well on many real-world problems. However, it makes sev- eral highly restrictive assumptions that are often violated in practice. Two of the most important assumptions state that the relationship between the predictors and response are additive and linear . The additivity assumption additive linear means that the association between a predictor X j and the response Y does not depend on the values of the other predictors. The linearity assumption states that the change in the response Y associated with a one-unit change in X j is constant, regardless of the value of X j . In later chapters of this book, we examine a number of sophisticated methods that relax these two 12 There could still in theory be a difference between South and West, although the data here does not suggest any difference. \nassumptions. Here, we briefly examine some common classical approaches for extending the linear model. Removing the Additive Assumption In our previous analysis of the Advertising data, we concluded that both TV and radio seem to be associated with sales . The linear models that formed the basis for this conclusion assumed that the effect on sales of increasing one advertising medium is independent of the amount spent on the other media. For example, the linear model ( 3.20 ) states that the average increase in sales associated with a one-unit increase in TV is always β 1 , regardless of the amount spent on radio . However, this simple model may be incorrect. Suppose that spending money on radio advertising actually increases the effectiveness of TV ad- vertising, so that the slope term for TV should increase as radio increases. In this situation, given a fixed budget of $100 , 000 , spending half on radio and half on TV may increase sales more than allocating the entire amount to either TV or to radio . In marketing, this is known as a synergy effect, and in statistics it is referred to as an interaction effect. Figure 3.5 sug- gests that such an effect may be present in the advertising data. Notice that when levels of either TV or radio are low, then the true sales are lower than predicted by the linear model. But when advertising is split between the two media, then the model tends to underestimate sales . Consider the standard linear regression model with two variables, Y = β 0 + β 1 X 1 + β 2 X 2 + ϵ. According to this model, a one-unit increase in X 1 is associated with an average increase in Y of β 1 units. Notice that the presence of X 2 does not alter this statement—that is, regardless of the value of X 2 , a one- unit increase in X 1 is associated with a β 1 -unit increase in Y . One way of extending this model is to include a third predictor, called an interaction term , which is constructed by computing the product of X 1 and X 2 . This results in the model Y = β 0 + β 1 X 1 + β 2 X 2 + β 3 X 1 X 2 + ϵ. (3.31) How does inclusion of this interaction term relax the additive assumption? Notice that ( 3.31 ) can be rewritten as Y = β 0 + ( β 1 + β 3 X 2 ) X 1 + β 2 X 2 + ϵ (3.32) = β 0 + ˜ β 1 X 1 + β 2 X 2 + ϵ where ˜ β 1 = β 1 + β 3 X 2 . Since ˜ β 1 is now a function of X 2 , the association between X 1 and Y is no longer constant: a change in the value of X 2 will change the association between X 1 and Y . A similar argument shows that a change in the value of X 1 changes the association between X 2 and Y . For example, suppose that we are interested in studying the productiv- ity of a factory. We wish to predict the number of units produced on the basis of the number of production lines and the total number of workers . It seems likely that the effect of increasing the number of production lines \nCoef fi cient Std. error t -statistic p -value Intercept 6.7502 0.248 27.23 < 0 . 0001 TV 0.0191 0.002 12.70 < 0 . 0001 radio 0.0289 0.009 3.24 0.0014 TV × radio 0.0011 0.000 20.73 < 0 . 0001 TABLE 3.9. For the Advertising data, least squares coefficient estimates asso- ciated with the regression of sales onto TV and radio , with an interaction term, as in ( 3.33 ). will depend on the number of workers, since if no workers are available to operate the lines, then increasing the number of lines will not increase production. This suggests that it would be appropriate to include an inter- action term between lines and workers in a linear model to predict units . Suppose that when we fit the model, we obtain units ≈ 1 . 2 + 3 . 4 × lines + 0 . 22 × workers + 1 . 4 × ( lines × workers ) = 1 . 2 + (3 . 4 + 1 . 4 × workers ) × lines + 0 . 22 × workers . In other words, adding an additional line will increase the number of units produced by 3 . 4 + 1 . 4 × workers . Hence the more workers we have, the stronger will be the effect of lines . We now return to the Advertising example. A linear model that uses radio , TV , and an interaction between the two to predict sales takes the form sales = β 0 + β 1 × TV + β 2 × radio + β 3 × ( radio × TV ) + ϵ = β 0 + ( β 1 + β 3 × radio ) × TV + β 2 × radio + ϵ. (3.33) We can interpret β 3 as the increase in the effectiveness of TV advertising associated with a one-unit increase in radio advertising (or vice-versa). The coefficients that result from fitting the model ( 3.33 ) are given in Table 3.9 . The results in Table 3.9 strongly suggest that the model that includes the interaction term is superior to the model that contains only main effects . main effect The p -value for the interaction term, TV × radio , is extremely low, indicating that there is strong evidence for H a : β 3 ̸ = 0 . In other words, it is clear that the true relationship is not additive. The R 2 for the model ( 3.33 ) is 96.8 %, compared to only 89.7 % for the model that predicts sales using TV and radio without an interaction term. This means that (96 . 8 − 89 . 7) / (100 − 89 . 7) = 69 % of the variability in sales that remains after fitting the ad- ditive model has been explained by the interaction term. The coefficient estimates in Table 3.9 suggest that an increase in TV advertising of $1 , 000 is associated with increased sales of ( ˆ β 1 + ˆ β 3 × radio ) × 1 , 000 = 19+1 . 1 × radio units. And an increase in radio advertising of $1 , 000 will be associated with an increase in sales of ( ˆ β 2 + ˆ β 3 × TV ) × 1 , 000 = 29 + 1 . 1 × TV units. In this example, the p -values associated with TV , radio , and the interac- tion term all are statistically significant (Table 3.9 ), and so it is obvious that all three variables should be included in the model. However, it is sometimes the case that an interaction term has a very small p -value, but the associated main effects (in this case, TV and radio ) do not. The hier- archical principle states that if we include an interaction in a model, we hierarchical principle \nshould also include the main effects, even if the p -values associated with their coefficients are not significant. In other words, if the interaction be- tween X 1 and X 2 seems important, then we should include both X 1 and X 2 in the model even if their coefficient estimates have large p -values. The rationale for this principle is that if X 1 × X 2 is related to the response, then whether or not the coefficients of X 1 or X 2 are exactly zero is of lit- tle interest. Also X 1 × X 2 is typically correlated with X 1 and X 2 , and so leaving them out tends to alter the meaning of the interaction. In the previous example, we considered an interaction between TV and radio , both of which are quantitative variables. However, the concept of interactions applies just as well to qualitative variables, or to a combination of quantitative and qualitative variables. In fact, an interaction between a qualitative variable and a quantitative variable has a particularly nice interpretation. Consider the Credit data set from Section 3.3.1 , and suppose that we wish to predict balance using the income (quantitative) and student (qualitative) variables. In the absence of an interaction term, the model takes the form balance i ≈ β 0 + β 1 × income i + = β 2 if i th person is a student 0 if i th person is not a student = β 1 × income i + = β 0 + β 2 if i th person is a student β 0 if i th person is not a student . (3.34) Notice that this amounts to fitting two parallel lines to the data, one for students and one for non-students. The lines for students and non-students have different intercepts, β 0 + β 2 versus β 0 , but the same slope, β 1 . This is illustrated in the left-hand panel of Figure 3.7 . The fact that the lines are parallel means that the average effect on balance of a one-unit increase in income does not depend on whether or not the individual is a student. This represents a potentially serious limitation of the model, since in fact a change in income may have a very different effect on the credit card balance of a student versus a non-student. This limitation can be addressed by adding an interaction variable, cre- ated by multiplying income with the dummy variable for student . Our model now becomes balance i ≈ β 0 + β 1 × income i + = β 2 + β 3 × income i if student 0 if not student = = ( β 0 + β 2 ) + ( β 1 + β 3 ) × income i if student β 0 + β 1 × income i if not student . (3.35) Once again, we have two different regression lines for the students and the non-students. But now those regression lines have different intercepts, β 0 + β 2 versus β 0 , as well as different slopes, β 1 + β 3 versus β 1 . This allows for the possibility that changes in income may affect the credit card balances of students and non-students differently. The right-hand panel of Figure 3.7 \n0 50 100 150 200 600 1000 1400 Income Balance 0 50 100 150 200 600 1000 1400 Income Balance student non−student FIGURE 3.7. For the Credit data, the least squares lines are shown for pre- diction of balance from income for students and non-students. Left: The model ( 3.34 ) was fit. There is no interaction between income and student . Right: The model ( 3.35 ) was fit. There is an interaction term between income and student . shows the estimated relationships between income and balance for students and non-students in the model ( 3.35 ). We note that the slope for students is lower than the slope for non-students. This suggests that increases in income are associated with smaller increases in credit card balance among students as compared to non-students. Non-linear Relationships As discussed previously, the linear regression model ( 3.19 ) assumes a linear relationship between the response and predictors. But in some cases, the true relationship between the response and the predictors may be non- linear. Here we present a very simple way to directly extend the linear model to accommodate non-linear relationships, using polynomial regression . In polynomial regression later chapters, we will present more complex approaches for performing non-linear fits in more general settings. Consider Figure 3.8 , in which the mpg (gas mileage in miles per gallon) versus horsepower is shown for a number of cars in the Auto data set. The orange line represents the linear regression fit. There is a pronounced rela- tionship between mpg and horsepower , but it seems clear that this relation- ship is in fact non-linear: the data suggest a curved relationship. A simple approach for incorporating non-linear associations in a linear model is to include transformed versions of the predictors. For example, the points in Figure 3.8 seem to have a quadratic shape, suggesting that a model of the quadratic form mpg = β 0 + β 1 × horsepower + β 2 × horsepower 2 + ϵ (3.36) may provide a better fit. Equation 3.36 involves predicting mpg using a non-linear function of horsepower . But it is still a linear model! That is, ( 3.36 ) is simply a multiple linear regression model with X 1 = horsepower and X 2 = horsepower 2 . So we can use standard linear regression software to estimate β 0 , β 1 , and β 2 in order to produce a non-linear fit. The blue curve in Figure 3.8 shows the resulting quadratic fit to the data. The quadratic \n50 100 150 200 10 20 30 40 50 Horsepower Miles per gallon Linear Degree 2 Degree 5 FIGURE 3.8. The Auto data set. For a number of cars, mpg and horsepower are shown. The linear regression fit is shown in orange. The linear regression fit for a model that includes horsepower 2 is shown as a blue curve. The linear regression fit for a model that includes all polynomials of horsepower up to fifth-degree is shown in green. Coef fi cient Std. error t -statistic p -value Intercept 56.9001 1.8004 31.6 < 0 . 0001 horsepower − 0.4662 0.0311 − 15.0 < 0 . 0001 horsepower 2 0.0012 0.0001 10.1 < 0 . 0001 TABLE 3.10. For the Auto data set, least squares coefficient estimates associated with the regression of mpg onto horsepower and horsepower 2 . fit appears to be substantially better than the fit obtained when just the linear term is included. The R 2 of the quadratic fit is 0 . 688 , compared to 0 . 606 for the linear fit, and the p -value in Table 3.10 for the quadratic term is highly significant. If including horsepower 2 led to such a big improvement in the model, why not include horsepower 3 , horsepower 4 , or even horsepower 5 ? The green curve in Figure 3.8 displays the fit that results from including all polynomials up to fifth degree in the model ( 3.36 ). The resulting fit seems unnecessarily wiggly—that is, it is unclear that including the additional terms really has led to a better fit to the data. The approach that we have just described for extending the linear model to accommodate non-linear relationships is known as polynomial regres- sion , since we have included polynomial functions of the predictors in the regression model. We further explore this approach and other non-linear extensions of the linear model in Chapter 7 . \n3.3.3 Potential Problems When we fit a linear regression model to a particular data set, many prob- lems may occur. Most common among these are the following: 1. Non-linearity of the response-predictor relationships. 2. Correlation of error terms. 3. Non-constant variance of error terms. 4. Outliers. 5. High-leverage points. 6. Collinearity. In practice, identifying and overcoming these problems is as much an art as a science. Many pages in countless books have been written on this topic. Since the linear regression model is not our primary focus here, we will provide only a brief summary of some key points. 1. Non-linearity of the Data 5 10 15 20 25 30 −15 −10 −5 0 5 10 15 20 Fitted values Residuals Residual Plot for Linear Fit 323 330 334 15 20 25 30 35 −15 −10 −5 0 5 10 15 Fitted values Residuals Residual Plot for Quadratic Fit 334 323 155 FIGURE 3.9. Plots of residuals versus predicted (or fitted) values for the Auto data set. In each plot, the red line is a smooth fit to the residuals, intended to make it easier to identify a trend. Left: A linear regression of mpg on horsepower . A strong pattern in the residuals indicates non-linearity in the data. Right: A linear regression of mpg on horsepower and horsepower 2 . There is little pattern in the residuals. The linear regression model assumes that there is a straight-line rela- tionship between the predictors and the response. If the true relationship is far from linear, then virtually all of the conclusions that we draw from the fit are suspect. In addition, the prediction accuracy of the model can be significantly reduced. Residual plots are a useful graphical tool for identifying non-linearity. residual plot Given a simple linear regression model, we can plot the residuals, e i = \ny i − ˆ y i , versus the predictor x i . In the case of a multiple regression model, since there are multiple predictors, we instead plot the residuals versus the predicted (or fitted ) values ˆ y i . Ideally, the residual plot will show no fitted discernible pattern. The presence of a pattern may indicate a problem with some aspect of the linear model. The left panel of Figure 3.9 displays a residual plot from the linear re- gression of mpg onto horsepower on the Auto data set that was illustrated in Figure 3.8 . The red line is a smooth fit to the residuals, which is displayed in order to make it easier to identify any trends. The residuals exhibit a clear U-shape, which provides a strong indication of non-linearity in the data. In contrast, the right-hand panel of Figure 3.9 displays the residual plot that results from the model ( 3.36 ), which contains a quadratic term. There appears to be little pattern in the residuals, suggesting that the quadratic term improves the fit to the data. If the residual plot indicates that there are non-linear associations in the data, then a simple approac h i s to use non-linear transformations of the predictors, such as log X , √ X , and X 2 , in the regression model. In the later chapters of this book, we will discuss other more advanced non-linear approaches for addressing this issue. 2. Correlation of Error Terms An important assumption of the linear regression model is that the error terms, ϵ 1 , ϵ 2 , . . . , ϵ n , are uncorrelated. What does this mean? For instance, if the errors are uncorrelated, then the fact that ϵ i is positive provides little or no information about the sign of ϵ i +1 . The standard errors that are computed for the estimated regression coefficients or the fitted values are based on the assumption of uncorrelated error terms. If in fact there is correlation among the error terms, then the estimated standard errors will tend to underestimate the true standard errors. As a result, confidence and prediction intervals will be narrower than they should be. For example, a 95 % confidence interval may in reality have a much lower probability than 0 . 95 of containing the true value of the parameter. In addition, p - values associated with the model will be lower than they should be; this could cause us to erroneously conclude that a parameter is statistically significant. In short, if the error terms are correlated, we may have an unwarranted sense of confidence in our model. As an extreme example, suppose we accidentally doubled our data, lead- ing to observations and error terms identical in pairs. If we ignored this, our standard error calculations would be as if we had a sample of size 2 n , when in fact we have only n samples. Our estimated parameters would be the same for the 2 n samples as for the n samples, but the confidence intervals would be narrower by a factor of √ 2 ! Why might correlations among the error terms occur? Such correlations frequently occur in the context of time series data, which consists of ob- time series servations for which measurements are obtained at discrete points in time. In many cases, observations that are obtained at adjacent time points will have positively correlated errors. In order to determine if this is the case for a given data set, we can plot the residuals from our model as a function of time. If the errors are uncorrelated, then there should be no discernible pat- \n0 20 40 60 80 100 −3 −1 0 1 2 3 ρ =0.0 Residual 0 20 40 60 80 100 −4 −2 0 1 2 ρ =0.5 Residual 0 20 40 60 80 100 −1.5 −0.5 0.5 1.5 ρ =0.9 Residual Observation FIGURE 3.10. Plots of residuals from simulated time series data sets generated with differing levels of correlation ρ between error terms for adjacent time points. tern. On the other hand, if the error terms are positively correlated, then we may see tracking in the residuals—that is, adjacent residuals may have tracking similar values. Figure 3.10 provides an illustration. In the top panel, we see the residuals from a linear regression fit to data generated with uncorre- lated errors. There is no evidence of a time-related trend in the residuals. In contrast, the residuals in the bottom panel are from a data set in which adjacent errors had a correlation of 0 . 9 . Now there is a clear pattern in the residuals—adjacent residuals tend to take on similar values. Finally, the center panel illustrates a more moderate case in which the residuals had a correlation of 0 . 5 . There is still evidence of tracking, but the pattern is less clear. Many methods have been developed to properly take account of corre- lations in the error terms in time series data. Correlation among the error terms can also occur outside of time series data. For instance, consider a study in which individuals’ heights are predicted from their weights. The assumption of uncorrelated errors could be violated if some of the indi- viduals in the study are members of the same family, eat the same diet, or have been exposed to the same environmental factors. In general, the assumption of uncorrelated errors is extremely important for linear regres- sion as well as for other statistical methods, and good experimental design is crucial in order to mitigate the risk of such correlations. \n10 15 20 25 30 −10 −5 0 5 10 15 Fitted values Residuals Response Y 998 975 845 2.4 2.6 2.8 3.0 3.2 3.4 −0.8 −0.6 −0.4 −0.2 0.0 0.2 0.4 Fitted values Residuals Response log(Y) 437 671 605 FIGURE 3.11. Residual plots. In each plot, the red line is a smooth fit to the residuals, intended to make it easier to identify a trend. The blue lines track the outer quantiles of the residuals, and emphasize patterns. Left: The funnel shape indicates heteroscedasticity. Right: The response has been log transformed, and there is now no evidence of heteroscedasticity. 3. Non-constant Variance of Error Terms Another important assumption of the linear regression model is that the error terms have a constant variance, Var ( ϵ i ) = σ 2 . The standard errors, confidence intervals, and hypothesis tests associated with the linear model rely upon this assumption. Unfortunately, it is often the case that the variances of the error terms are non-constant. For instance, the variances of the error terms may increase with the value of the response. One can identify non-constant variances in the errors, or heteroscedasticity , from the presence of a funnel shape in hetero- scedasticity the residual plot. An example is shown in the left-hand panel of Figure 3.11 , in which the magnitude of the residuals tends to increase with the fitted values. When faced with this problem, one possible solution is to trans- form the response Y using a concave function such as log Y or √ Y . Such a transformation results in a greater amount of shrinkage of the larger re- sponses, leading to a reduction in heteroscedasticity. The right-hand panel of Figure 3.11 displays the residual plot after transforming the response using log Y . The residuals now appear to have constant variance, though there is some evidence of a slight non-linear relationship in the data. Sometimes we have a good idea of the variance of each response. For example, the i th response could be an average of n i raw observations. If each of these raw observations is uncorrelated with variance σ 2 , then their average has variance σ 2 i = σ 2 /n i . In this case a simple remedy is to fit our model by weighted least squares , with weights proportional to the inverse weighted least squares variances—i.e. w i = n i in this case. Most linear regression software allows for observation weights. 4. Outliers An outlier is a point for which y i is far from the value predicted by the outlier \n−2 −1 0 1 2 −4 −2 0 2 4 6 20 −2 0 2 4 6 −1 0 1 2 3 4 Fitted Values Residuals 20 −2 0 2 4 6 0 2 4 6 Fitted Values Studentized Residuals 20 X Y FIGURE 3.12. Left: The least squares regression line is shown in red, and the regression line after removing the outlier is shown in blue. Center: The residual plot clearly identifies the outlier. Right: The outlier has a studentized residual of 6 ; typically we expect values between − 3 and 3 . model. Outliers can arise for a variety of reasons, such as incorrect recording of an observation during data collection. The red point (observation 20) in the left-hand panel of Figure 3.12 illustrates a typical outlier. The red solid line is the least squares regression fit, while the blue dashed line is the least squares fit after removal of the outlier. In this case, removing the outlier has little effect on the least squares line: it leads to almost no change in the slope, and a miniscule reduction in the intercept. It is typical for an outlier that does not have an unusual predictor value to have little effect on the least squares fit. However, even if an outlier does not have much effect on the least squares fit, it can cause other problems. For instance, in this example, the RSE is 1 . 09 when the outlier is included in the regression, but it is only 0 . 77 when the outlier is removed. Since the RSE is used to compute all confidence intervals and p -values, such a dramatic increase caused by a single data point can have implications for the interpretation of the fit. Similarly, inclusion of the outlier causes the R 2 to decline from 0 . 892 to 0 . 805 . Residual plots can be used to identify outliers. In this example, the out- lier is clearly visible in the residual plot illustrated in the center panel of Figure 3.12 . But in practice, it can be difficult to decide how large a resid- ual needs to be before we consider the point to be an outlier. To address this problem, instead of plotting the residuals, we can plot the studentized residuals , computed by dividing each residual e i by its estimated standard studentized residual error. Observations whose studentized residuals are greater than 3 in abso- lute value are possible outliers. In the right-hand panel of Figure 3.12 , the outlier’s studentized residual exceeds 6 , while all other observations have studentized residuals between − 2 and 2 . If we believe that an outlier has occurred due to an error in data collec- tion or recording, then one solution is to simply remove the observation. However, care should be taken, since an outlier may instead indicate a deficiency with the model, such as a missing predictor. 5. High Leverage Points We just saw that outliers are observations for which the response y i is unusual given the predictor x i . In contrast, observations with high leverage high leverage have an unusual value for x i . For example, observation 41 in the left-hand \n−2 −1 0 1 2 3 4 0 5 10 20 41 −2 −1 0 1 2 −2 −1 0 1 2 0.00 0.05 0.10 0.15 0.20 0.25 −1 0 1 2 3 4 5 Leverage Studentized Residuals 20 41 X Y X 1 X 2 FIGURE 3.13. Left: Observation 41 is a high leverage point, while 20 is not. The red line is the fit to all the data, and the blue line is the fit with observation 41 removed. Center: The red observation is not unusual in terms of its X 1 value or its X 2 value, but still falls outside the bulk of the data, and hence has high leverage. Right: Observation 41 has a high leverage and a high residual. panel of Figure 3.13 has high leverage, in that the predictor value for this observation is large relative to the other observations. (Note that the data displayed in Figure 3.13 are the same as the data displayed in Figure 3.12 , but with the addition of a single high leverage observation.) The red solid line is the least squares fit to the data, while the blue dashed line is the fit produced when observation 41 is removed. Comparing the left-hand panels of Figures 3.12 and 3.13 , we observe that removing the high leverage observation has a much more substantial impact on the least squares line than removing the outlier. In fact, high leverage observations tend to have a sizable impact on the estimated regression line. It is cause for concern if the least squares line is heavily affected by just a couple of observations, because any problems with these points may invalidate the entire fit. For this reason, it is important to identify high leverage observations. In a simple linear regression, high leverage observations are fairly easy to identify, since we can simply look for observations for which the predictor value is outside of the normal range of the observations. But in a multiple linear regression with many predictors, it is possible to have an observation that is well within the range of each individual predictor’s values, but that is unusual in terms of the full set of predictors. An example is shown in the center panel of Figure 3.13 , for a data set with two predictors, X 1 and X 2 . Most of the observations’ predictor values fall within the blue dashed ellipse, but the red observation is well outside of this range. But neither its value for X 1 nor its value for X 2 is unusual. So if we examine just X 1 or just X 2 , we will fail to notice this high leverage point. This problem is more pronounced in multiple regression settings with more than two predictors, because then there is no simple way to plot all dimensions of the data simultaneously. In order to quantify an observation’s leverage, we compute the leverage statistic . A large value of this statistic indicates an observation with high leverage statistic leverage. For a simple linear regression, h i = 1 n + ( x i − ¯ x ) 2 ) n i ′ =1 ( x i ′ − ¯ x ) 2 . (3.37) \n2000 4000 6000 8000 12000 30 40 50 60 70 80 Limit Age 2000 4000 6000 8000 12000 200 400 600 800 Limit Rating FIGURE 3.14. Scatterplots of the observations from the Credit data set. Left: A plot of age versus limit . These two variables are not collinear. Right: A plot of rating versus limit . There is high collinearity. It is clear from this equation that h i increases with the distance of x i from ¯ x . There is a simple extension of h i to the case of multiple predictors, though we do not provide the formula here. The leverage statistic h i is always between 1 /n and 1 , and the average leverage for all the observations is always equal to ( p + 1) /n . So if a given observation has a leverage statistic that greatly exceeds ( p +1) /n , then we may suspect that the corresponding point has high leverage. The right-hand panel of Figure 3.13 provides a plot of the studentized residuals versus h i for the data in the left-hand panel of Figure 3.13 . Ob- servation 41 stands out as having a very high leverage statistic as well as a high studentized residual. In other words, it is an outlier as well as a high leverage observation. This is a particularly dangerous combination! This plot also reveals the reason that observation 20 had relatively little effect on the least squares fit in Figure 3.12 : it has low leverage. 6. Collinearity Collinearity refers to the situation in which two or more predictor variables collinearity are closely related to one another. The concept of collinearity is illustrated in Figure 3.14 using the Credit data set. In the left-hand panel of Fig- ure 3.14 , the two predictors limit and age appear to have no obvious rela- tionship. In contrast, in the right-hand panel of Figure 3.14 , the predictors limit and rating are very highly correlated with each other, and we say that they are collinear . The presence of collinearity can pose problems in the regression context, since it can be difficult to separate out the indi- vidual effects of collinear variables on the response. In other words, since limit and rating tend to increase or decrease together, it can be difficult to determine how each one separately is associated with the response, balance . Figure 3.15 illustrates some of the difficulties that can result from collinear- ity. The left-hand panel of Figure 3.15 is a contour plot of the RSS ( 3.22 ) associated with different possible coefficient estimates for the regression of balance on limit and age . Each ellipse represents a set of coefficients \n21.25 21.5 21.8 0.16 0.17 0.18 0.19 −5 −4 −3 −2 −1 0 21.5 21.8 −0.1 0.0 0.1 0.2 0 1 2 3 4 5 β Limit β Limit β Age β Rating FIGURE 3.15. Contour plots for the RSS values as a function of the parameters β for various regressions involving the Credit data set. In each plot, the black dots represent the coefficient values corresponding to the minimum RSS. Left: A contour plot of RSS for the regression of balance onto age and limit . The minimum value is well defined. Right: A contour plot of RSS for the regression of balance onto rating and limit . Because of the collinearity, there are many pairs ( β Limit , β Rating ) with a similar value for RSS. that correspond to the same RSS, with ellipses nearest to the center tak- ing on the lowest values of RSS. The black dots and associated dashed lines represent the coefficient estimates that result in the smallest possible RSS—in other words, these are the least squares estimates. The axes for limit and age have been scaled so that the plot includes possible coeffi- cient estimates that are up to four standard errors on either side of the least squares estimates. Thus the plot includes all plausible values for the coefficients. For example, we see that the true limit coefficient is almost certainly somewhere between 0 . 15 and 0 . 20 . In contrast, the right-hand panel of Figure 3.15 displays contour plots of the RSS associated with possible coefficient estimates for the regression of balance onto limit and rating , which we know to be highly collinear. Now the contours run along a narrow valley; there is a broad range of values for the coefficient estimates that result in equal values for RSS. Hence a small change in the data could cause the pair of coefficient values that yield the smallest RSS—that is, the least squares estimates—to move anywhere along this valley. This results in a great deal of uncertainty in the coefficient estimates. Notice that the scale for the limit coefficient now runs from roughly − 0 . 2 to 0 . 2 ; this is an eight-fold increase over the plausible range of the limit coefficient in the regression with age . Interestingly, even though the limit and rating coefficients now have much more individual uncertainty, they will almost certainly lie somewhere in this contour valley. For example, we would not expect the true value of the limit and rating coefficients to be − 0 . 1 and 1 respectively, even though such a value is plausible for each coefficient individually. Since collinearity reduces the accuracy of the estimates of the regression coefficients, it causes the standard error for ˆ β j to grow. Recall that the t -statistic for each predictor is calculated by dividing ˆ β j by its standard \nCoef fic ie n t Std. error t -statistic p -value Intercept − 173.411 43.828 − 3.957 < 0 . 0001 Model 1 age − 2.292 0.672 − 3.407 0 . 0007 limit 0.173 0.005 34.496 < 0 . 0001 Intercept − 377.537 45.254 − 8.343 < 0 . 0001 Model 2 rating 2.202 0.952 2.312 0.0213 limit 0.025 0.064 0.384 0.7012 TABLE 3.11. The results for two multiple regression models involving the Credit data set are shown. Model 1 is a regression of balance on age and limit , and Model 2 a regression of balance on rating and limit . The standard error of ˆ β limit increases 12-fold in the second regression, due to collinearity. error. Consequently, collinearity results in a decline in the t -statistic. As a result, in the presence of collinearity, we may fail to reject H 0 : β j = 0 . This means that the power of the hypothesis test—the probability of correctly power detecting a non-zero coefficient—is reduced by collinearity. Table 3.11 compares the coefficient estimates obtained from two separate multiple regression models. The first is a regression of balance on age and limit , and the second is a regression of balance on rating and limit . In the first regression, both age and limit are highly significant with very small p - values. In the second, the collinearity between limit and rating has caused the standard error for the limit coefficient estimate to increase by a factor of 12 and the p -value to increase to 0 . 701 . In other words, the importance of the limit variable has been masked due to the presence of collinearity. To avoid such a situation, it is desirable to identify and address potential collinearity problems while fitting the model. A simple way to detect collinearity is to look at the correlation matrix of the predictors. An element of this matrix that is large in absolute value indicates a pair of highly correlated variables, and therefore a collinearity problem in the data. Unfortunately, not all collinearity problems can be detected by inspection of the correlation matrix: it is possible for collinear- ity to exist between three or more variables even if no pair of variables has a particularly high correlation. We call this situation multicollinearity . multi- collinearity Instead of inspecting the correlation matrix, a better way to assess multi- collinearity is to compute the variance inflation factor (VIF). The VIF is variance inflation factor the ratio of the variance of ˆ β j when fitting the full model divided by the variance of ˆ β j if fit on its own. The smallest possible value for VIF is 1 , which indicates the complete absence of collinearity. Typically in practice there is a small amount of collinearity among the predictors. As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. The VIF for each variable can be computed using the formula VIF( ˆ β j ) = 1 1 − R 2 X j | X − j , where R 2 X j | X − j is the R 2 from a regression of X j onto all of the other predictors. If R 2 X j | X − j is close to one, then collinearity is present, and so the VIF will be large. \nIn the Credit data, a regression of balance on age , rating , and limit indicates that the predictors have VIF values of 1.01, 160.67, and 160.59. As we suspected, there is considerable collinearity in the data! When faced with the problem of collinearity, there are two simple solu- tions. The first is to drop one of the problematic variables from the regres- sion. This can usually be done without much compromise to the regression fit, since the presence of collinearity implies that the information that this variable provides about the response is redundant in the presence of the other variables. For instance, if we regress balance onto age and limit , without the rating predictor, then the resulting VIF values are close to the minimum possible value of 1 , and the R 2 drops from 0 . 754 to 0 . 75 . So dropping rating from the set of predictors has effectively solved the collinearity problem without compromising the fit. The second solution is to combine the collinear variables together into a single predictor. For in- stance, we might take the average of standardized versions of limit and rating in order to create a new variable that measures credit worthiness . 3.4 The Marketing Plan We now briefly return to the seven questions about the Advertising data that we set out to answer at the beginning of this chapter. 1. Is there a relationship between sales and advertising budget? This question can be answered by fitting a multiple regression model of sales onto TV , radio , and newspaper , as in ( 3.20 ), and testing the hypothesis H 0 : β TV = β radio = β newspaper = 0 . In Section 3.2.2 , we showed that the F -statistic can be used to determine whether or not we should reject this null hypothesis. In this case the p -value corresponding to the F -statistic in Table 3.6 is very low, indicating clear evidence of a relationship between advertising and sales. 2. How strong is the relationship? We discussed two measures of model accuracy in Section 3.1.3 . First, the RSE estimates the standard deviation of the response from the population regression line. For the Advertising data, the RSE is 1 . 69 units while the mean value for the response is 14 . 022 , indicating a percentage error of roughly 12 %. Second, the R 2 statistic records the percentage of variability in the response that is explained by the predictors. The predictors explain almost 90 % of the variance in sales . The RSE and R 2 statistics are displayed in Table 3.6 . 3. Which media are associated with sales? To answer this question, we can examine the p -values associated with each predictor’s t -statistic (Section 3.1.2 ). In the multiple linear re- gression displayed in Table 3.4 , the p -values for TV and radio are low, but the p -value for newspaper is not. This suggests that only TV and radio are related to sales . In Chapter 6 we explore this question in greater detail. \n4. How large is the association between each medium and sales? We saw in Section 3.1.2 that the standard error of ˆ β j can be used to construct confidence intervals for β j . For the Advertising data, we can use the results in Table 3.4 to compute the 95 % confidence inter- vals for the coefficients in a multiple regression model using all three media budgets as predictors. The confidence intervals are as follows: (0 . 043 , 0 . 049) for TV , (0 . 172 , 0 . 206) for radio , and ( − 0 . 013 , 0 . 011) for newspaper . The confidence intervals for TV and radio are narrow and far from zero, providing evidence that these media are related to sales . But the interval for newspaper includes zero, indicating that the variable is not statistically significant given the values of TV and radio . We saw in Section 3.3.3 that collinearity can result in very wide stan- dard errors. Could collinearity be the reason that the confidence in- terval associated with newspaper is so wide? The VIF scores are 1 . 005 , 1 . 145 , and 1 . 145 for TV , radio , and newspaper , suggesting no evidence of collinearity. In order to assess the association of each medium individually on sales, we can perform three separate simple linear regressions. Re- sults are shown in Tables 3.1 and 3.3 . There is evidence of an ex- tremely strong association between TV and sales and between radio and sales . There is evidence of a mild association between newspaper and sales , when the values of TV and radio are ignored. 5. How accurately can we predict future sales? The response can be predicted using ( 3.21 ). The accuracy associ- ated with this estimate depends on whether we wish to predict an individual response, Y = f ( X ) + ϵ , or the average response, f ( X ) (Section 3.2.2 ). If the former, we use a prediction interval, and if the latter, we use a confidence interval. Prediction intervals will al- ways be wider than confidence intervals because they account for the uncertainty associated with ϵ , the irreducible error. 6. Is the relationship linear? In Section 3.3.3 , we saw that residual plots can be used in order to identify non-linearity. If the relationships are linear, then the residual plots should display no pattern. In the case of the Advertising data, we observe a non-linear effect in Figure 3.5 , though this effect could also be observed in a residual plot. In Section 3.3.2 , we discussed the inclusion of transformations of the predictors in the linear regression model in order to accommodate non-linear relationships. 7. Is there synergy among the advertising media? The standard linear regression model assumes an additive relation- ship between the predictors and the response. An additive model is easy to interpret because the association between each predictor and the response is unrelated to the values of the other predictors. However, the additive assumption may be unrealistic for certain data sets. In Section 3.3.2 , we showed how to include an interaction term \nin the regression model in order to accommodate non-additive rela- tionships. A small p -value associated with the interaction term indi- cates the presence of such relationships. Figure 3.5 suggested that the Advertising data may not be additive. Including an interaction term in the model results in a substantial increase in R 2 , from around 90 % to almost 97 %. 3.5 Comparison of Linear Regression with K -Nearest Neighbors As discussed in Chapter 2 , linear regression is an example of a parametric approach because it assumes a linear functional form for f ( X ) . Parametric methods have several advantages. They are often easy to fit, because one need estimate only a small number of coefficients. In the case of linear re- gression, the coefficients have simple interpretations, and tests of statistical significance can be easily performed. But parametric methods do have a disadvantage: by construction, they make strong assumptions about the form of f ( X ) . If the specified functional form is far from the truth, and prediction accuracy is our goal, then the parametric method will perform poorly. For instance, if we assume a linear relationship between X and Y but the true relationship is far from linear, then the resulting model will provide a poor fit to the data, and any conclusions drawn from it will be suspect. In contrast, non-parametric methods do not explicitly assume a para- metric form for f ( X ) , and thereby provide an alternative and more flexi- ble approach for performing regression. We discuss various non-parametric methods in this book. Here we consider one of the simplest and best-known non-parametric methods, K -nearest neighbors regression (KNN regression). K -nearest neighbors regression The KNN regression method is closely related to the KNN classifier dis- cussed in Chapter 2 . Given a value for K and a prediction point x 0 , KNN regression first identifies the K training observations that are closest to x 0 , represented by N 0 . It then estimates f ( x 0 ) using the average of all the training responses in N 0 . In other words, ˆ f ( x 0 ) = 1 K 0 x i ∈N 0 y i . Figure 3.16 illustrates two KNN fits on a data set with p = 2 predictors. The fit with K = 1 is shown in the left-hand panel, while the right-hand panel corresponds to K = 9 . We see that when K = 1 , the KNN fit perfectly interpolates the training observations, and consequently takes the form of a step function. When K = 9 , the KNN fit still is a step function, but averaging over nine observations results in much smaller regions of constant prediction, and consequently a smoother fit. In general, the optimal value for K will depend on the bias-variance tradeoff , which we introduced in Chapter 2 . A small value for K provides the most flexible fit, which will have low bias but high variance. This variance is due to the fact that the prediction in a given region is entirely dependent on just one observation. \ny y x 1 x 1 x 2 x 2 y y y FIGURE 3.16. Plots of ˆ f ( X ) using KNN regression on a two-dimensional data set with 64 observations (orange dots). Left: K = 1 results in a rough step function fit. Right: K = 9 produces a much smoother fit. In contrast, larger values of K provide a smoother and less variable fit; the prediction in a region is an average of several points, and so changing one observation has a smaller effect. However, the smoothing may cause bias by masking some of the structure in f ( X ) . In Chapter 5 , we introduce several approaches for estimating test error rates. These methods can be used to identify the optimal value of K in KNN regression. In what setting will a parametric approach such as least squares linear re- gression outperform a non-parametric approach such as KNN regression? The answer is simple: the parametric approach will outperform the non- parametric approach if the parametric form that has been selected is close to the true form of f . Figure 3.17 provides an example with data generated from a one-dimensional linear regression model. The black solid lines rep- resent f ( X ) , while the blue curves correspond to the KNN fits using K = 1 and K = 9 . In this case, the K = 1 predictions are far too variable, while the smoother K = 9 fit is much closer to f ( X ) . However, since the true relationship is linear, it is hard for a non-parametric approach to compete with linear regression: a non-parametric approach incurs a cost in variance that is not offset by a reduction in bias. The blue dashed line in the left- hand panel of Figure 3.18 represents the linear regression fit to the same data. It is almost perfect. The right-hand panel of Figure 3.18 reveals that linear regression outperforms KNN for this data. The green solid line, plot- ted as a function of 1 /K , represents the test set mean squared error (MSE) for KNN. The KNN errors are well above the black dashed line, which is the test MSE for linear regression. When the value of K is large, then KNN performs only a little worse than least squares regression in terms of MSE. It performs far worse when K is small. In practice, the true relationship between X and Y is rarely exactly lin- ear. Figure 3.19 examines the relative performances of least squares regres- sion and KNN under increasing levels of non-linearity in the relationship between X and Y . In the top row, the true relationship is nearly linear. In this case we see that the test MSE for linear regression is still superior \n−1.0 −0.5 0.0 0.5 1.0 1 2 3 4 −1.0 −0.5 0.0 0.5 1.0 1 2 3 4 y y x x FIGURE 3.17. Plots of ˆ f ( X ) using KNN regression on a one-dimensional data set with 50 observations. The true relationship is given by the black solid line. Left: The blue curve corresponds to K = 1 and interpolates (i.e. passes directly through) the training data. Right: The blue curve corresponds to K = 9 , and represents a smoother fit. −1.0 −0.5 0.0 0.5 1.0 1 2 3 4 0.2 0.5 1.0 0.00 0.05 0.10 0.15 Mean Squared Error y x 1/K FIGURE 3.18. The same data set shown in Figure 3.17 is investigated further. Left: The blue dashed line is the least squares fit to the data. Since f ( X ) is in fact linear (displayed as the black line), the least squares regression line provides a very good estimate of f ( X ) . Right: The dashed horizontal line represents the least squares test set MSE, while the green solid line corresponds to the MSE for KNN as a function of 1 /K (on the log scale). Linear regression achieves a lower test MSE than does KNN regression, since f ( X ) is in fact linear. For KNN regression, the best results occur with a very large value of K , corresponding to a small value of 1 /K . \n−1.0 −0.5 0.0 0.5 1.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 0.2 0.5 1.0 0.00 0.02 0.04 0.06 0.08 Mean Squared Error −1.0 −0.5 0.0 0.5 1.0 1.0 1.5 2.0 2.5 3.0 3.5 0.2 0.5 1.0 0.00 0.05 0.10 0.15 Mean Squared Error y y x x 1/K 1/K FIGURE 3.19. Top Left: In a setting with a slightly non-linear relationship between X and Y (solid black line), the KNN fits with K = 1 (blue) and K = 9 (red) are displayed. Top Right: For the slightly non-linear data, the test set MSE for least squares regression (horizontal black) and KNN with various values of 1 /K (green) are displayed. Bottom Left and Bottom Right: As in the top panel, but with a strongly non-linear relationship between X and Y . to that of KNN for low values of K . However, for K ≥ 4 , KNN out- performs linear regression. The second row illustrates a more substantial deviation from linearity. In this situation, KNN substantially outperforms linear regression for all values of K . Note that as the extent of non-linearity increases, there is little change in the test set MSE for the non-parametric KNN method, but there is a large increase in the test set MSE of linear regression. Figures 3.18 and 3.19 display situations in which KNN performs slightly worse than linear regression when the relationship is linear, but much bet- ter than linear regression for nonlinear situations. In a real life situation in which the true relationship is unknown, one might suspect that KNN should be favored over linear regression because it will at worst be slightly inferior to linear regression if the true relationship is linear, and may give substantially better results if the true relationship is non-linear. But in re- ality, even when the true relationship is highly non-linear, KNN may still provide inferior results to linear regression. In particular, both Figures 3.18 \n0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=1 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=2 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=3 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=4 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=10 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=20 Mean Squared Error 1/K FIGURE 3.20. Test MSE for linear regression (black dashed lines) and KNN (green curves) as the number of variables p increases. The true function is non- linear in the first variable, as in the lower panel in Figure 3.19 , and does not depend on the additional variables. The performance of linear regression deteri- orates slowly in the presence of these additional noise variables, whereas KNN’s performance degrades much more quickly as p increases. and 3.19 illustrate settings with p = 1 predictor. But in higher dimensions, KNN often performs worse than linear regression. Figure 3.20 considers the same strongly non-linear situation as in the second row of Figure 3.19 , except that we have added additional noise predictors that are not associated with the response. When p = 1 or p = 2 , KNN outperforms linear regression. But for p = 3 the results are mixed, and for p ≥ 4 linear regression is superior to KNN. In fact, the increase in dimension has only caused a small deterioration in the linear regression test set MSE, but it has caused more than a ten-fold increase in the MSE for KNN. This decrease in performance as the dimension increases is a common problem for KNN, and results from the fact that in higher dimensions there is effectively a reduction in sample size. In this data set there are 50 training observations; when p = 1 , this provides enough information to accurately estimate f ( X ) . However, spreading 50 observations over p = 20 dimensions results in a phenomenon in which a given observation has no nearby neighbors —this is the so-called curse of dimensionality . That is, curse of di- mensionality the K observations that are nearest to a given test observation x 0 may be very far away from x 0 in p -dimensional space when p is large, leading to a very poor prediction of f ( x 0 ) and hence a poor KNN fit. As a general rule, parametric methods will tend to outperform non-parametric approaches when there is a small number of observations per predictor. Even when the dimension is small, we might prefer linear regression to KNN from an interpretability standpoint. If the test MSE of KNN is only slightly lower than that of linear regression, we might be willing to forego a little bit of prediction accuracy for the sake of a simple model that can be described in terms of just a few coefficients, and for which p -values are available. \n3.6 Lab: Linear Regression 3.6.1 Importing packages We import our standard libraries at this top level. In [1]: import numpy as np import pandas as pd from matplotlib.pyplot import subplots New imports Throughout this lab we will introduce new functions and libraries. However, we will import them here to emphasize these are the new code objects in this lab. Keeping imports near the top of a notebook makes the code more readable, since scanning the first few lines tells us what libraries are used. In [2]: import statsmodels.api as sm We will provide relevant details about the functions below as they are needed. Besides importing whole modules, it is also possible to import only a few items from a given module. This will help keep the namespace clean. namespace We will use a few specific objects from the statsmodels package which we statsmodels import here. In [3]: from statsmodels.stats.outliers_influence \\ import variance_inflation_factor as VIF from statsmodels.stats.anova import anova_lm As one of the import statements above is quite a long line, we inserted a line break \\ to ease readability. We will also use some functions written for the labs in this book in the ISLP package. In [4]: from ISLP import load_data from ISLP.models import (ModelSpec as MS, summarize, poly) Inspecting Objects and Namespaces The function dir() provides a list of objects in a namespace. dir() In [5]: dir() Out[5]: [ 'In' , 'MS' , '_' , '__' , '___' , '__builtin__' , '__builtins__' , ... \n'poly' , 'quit' , 'sm' , 'summarize' ] This shows you everything that Python can find at the top level. There are certain objects like __builtins__ that contain references to built-in functions like print() . Every python object has its own notion of namespace, also accessible with dir() . This will include both the attributes of the object as well as any methods associated with it. For instance, we see 'sum' in the listing for an array. In [6]: A = np.array([3,5,11]) dir(A) Out[6]: ... 'strides' , 'sum' , 'swapaxes' , ... This indicates that the object A.sum exists. In this case it is a method that can be used to compute the sum of the array A as can be seen by typing A.sum? . In [7]: A.sum() Out[7]: 19 3.6.2 Simple Linear Regression In this section we will construct model matrices (also called design matri- ces) using the ModelSpec() transform from ISLP.models . We will use the Boston housing data set, which is contained in the ISLP package. The Boston dataset records medv (median house value) for 506 neighborhoods around Boston. We will build a regression model to pre- dict medv using 13 predictors such as rmvar (average number of rooms per house), age (proportion of owner-occupied units built prior to 1940), and lstat (percent of households with low socioeconomic status). We will use statsmodels for this task, a Python package that implements several com- monly used regression methods. We have included a simple loading function load_data() in the ISLP pack- load_data() age: In [8]: Boston = load_data( \"Boston\" ) Boston.columns Out[8]: Index([ 'crim' , 'zn' , 'indus' , 'chas' , 'nox' , 'rm' , 'age' , 'dis' , 'rad' , 'tax' , 'ptratio' , 'black' , 'lstat' , 'medv' ], dtype= 'object' ) \nType Boston? to find out more about these data. We start by using the sm.OLS() function to fit a simple linear regression sm.OLS() model. Our response will be medv and lstat will be the single predictor. For this model, we can create the model matrix by hand. In [9]: X = pd.DataFrame({ 'intercept' : np.ones(Boston.shape[0]), 'lstat' : Boston[ 'lstat' ]}) X[:4] Out[9]: intercept lstat 0 1.0 4.98 1 1.0 9.14 2 1.0 4.03 3 1.0 2.94 We extract the response, and fit the model. In [10]: y = Boston[ 'medv' ] model = sm.OLS(y, X) results = model.fit() Note that sm.OLS() does not fit the model; it specifies the model, and then model.fit() does the actual fitting. Our ISLP function summarize() produces a simple table of the parame- summarize() ter estimates, their standard errors, t-statistics and p-values. The function takes a single argument, such as the object results returned here by the fit method, and returns such a summary. In [11]: summarize(results) Out[11]: coef std err t P>|t| intercept 34.5538 0.563 61.415 0.0 lstat -0.9500 0.039 -24.528 0.0 Before we describe other methods for working with fitted models, we outline a more useful and general framework for constructing a model ma- trix X . Using Transformations: Fit and Transform Our model above has a single predictor, and constructing X was straight- forward. In practice we often fit models with more than one predictor, typically selected from an array or data frame. We may wish to introduce transformations to the variables before fitting the model, specify interac- tions between variables, and expand some particular variables into sets of variables (e.g. polynomials). The sklearn package has a particular notion sklearn for this type of task: a transform . A transform is an object that is created with some parameters as arguments. The object has two main methods: fit() and transform() . .fit() .transform() We provide a general approach for specifying models and constructing the model matrix through the transform ModelSpec() in the ISLP library. ModelSpec() ModelSpec() (renamed MS() in the preamble) creates a transform object, and then a pair of methods transform() and fit() are used to construct a corresponding model matrix. \nWe first describe this process for our simple regression model using a single predictor lstat in the Boston data frame, but will use it repeatedly in more complex tasks in this and other labs in this book. In our case the transform is created by the expression design = MS(['lstat']) . The fit() method takes the original array and may do some initial com- putations on it, as specified in the transform object. For example, it may compute means and standard deviations for centering and scaling. The transform() method applies the fitted transformation to the array of data, and produces the model matrix. In [12]: design = MS([ 'lstat' ]) design = design.fit(Boston) X = design.transform(Boston) X[:4] Out[12]: intercept lstat 0 1.0 4.98 1 1.0 9.14 2 1.0 4.03 3 1.0 2.94 In this simple case, the fit() method does very little; it simply checks that the variable 'lstat' specified in design exists in Boston . Then transform() constructs the model matrix with two columns: an intercept and the vari- able lstat . These two operations can be combined with the fit_transform() method. .fit_ transform() In [13]: design = MS([ 'lstat' ]) X = design.fit_transform(Boston) X[:4] Out[13]: intercept lstat 0 1.0 4.98 1 1.0 9.14 2 1.0 4.03 3 1.0 2.94 Note that, as in the previous code chunk when the two steps were done separately, the design object is changed as a result of the fit() operation. The power of this pipeline will become clearer when we fit more complex models that involve interactions and transformations. Let’s return to our fitted regression model. The object results has several methods that can be used for inference. We already presented a function summarize() for showing the essentials of the fit. For a full and somewhat exhaustive summary of the fit, we can use the summary() method (output not shown). In [14]: results.summary() The fitted coefficients can also be retrieved as the params attribute of results . In [15]: results.params \nOut[15]: intercept 34.553841 lstat -0.950049 dtype: float64 The get_prediction() method can be used to obtain predictions, and .get_ prediction() produce confidence intervals and prediction intervals for the prediction of medv for given values of lstat . We first create a new data frame, in this case containing only the vari- able lstat , with the values for this variable at which we wish to make predictions. We then use the transform() method of design to create the corresponding model matrix. In [16]: new_df = pd.DataFrame({ 'lstat' :[5, 10, 15]}) newX = design.transform(new_df) newX Out[16]: intercept lstat 0 1.0 5 1 1.0 10 2 1.0 15 Next we compute the predictions at newX , and view them by extracting the predicted_mean attribute. In [17]: new_predictions = results.get_prediction(newX); new_predictions.predicted_mean Out[17]: array([29.80359411, 25.05334734, 20.30310057]) We can produce confidence intervals for the predicted values. In [18]: new_predictions.conf_int(alpha=0.05) Out[18]: array([[29.00741194, 30.59977628], [24.47413202, 25.63256267], [19.73158815, 20.87461299]]) Prediction intervals are computing by setting obs=True : In [19]: new_predictions.conf_int(obs=True, alpha=0.05) Out[19]: array([[17.56567478, 42.04151344], [12.82762635, 37.27906833], [ 8.0777421 , 32.52845905]]) For instance, the 95% confidence interval associated with an lstat value of 10 is (24.47, 25.63), and the 95% prediction interval is (12.82, 37.28). As expected, the confidence and prediction intervals are centered around the same point (a predicted value of 25.05 for medv when lstat equals 10), but the latter are substantially wider. Next we will plot medv and lstat using DataFrame.plot.scatter() , and .plot. scatter() wish to add the regression line to the resulting plot. \nDefining Functions While there is a function within the ISLP package that adds a line to an existing plot, we take this opportunity to define our first function to do so. def In [20]: def abline(ax, b, m): \"Add a line with slope m and intercept b to ax\" xlim = ax.get_xlim() ylim = [m * xlim[0] + b, m * xlim[1] + b] ax.plot(xlim, ylim) A few things are illustrated above. First we see the syntax for defining a function: def funcname(...) . The function has arguments ax, b, m where ax is an axis object for an exisiting plot, b is the intercept and m is the slope of the desired line. Other plotting options can be passed on to ax.plot by including additional optional arguments as follows: In [21]: def abline(ax, b, m, *args, **kwargs): \"Add a line with slope m and intercept b to ax\" xlim = ax.get_xlim() ylim = [m * xlim[0] + b, m * xlim[1] + b] ax.plot(xlim, ylim, *args, **kwargs) The addition of *args allows any number of non-named arguments to abline , while *kwargs allows any number of named arguments (such as linewidth=3 ) to abline . In our function, we pass these arguments verbatim to ax.plot above. Readers interested in learning more about functions are referred to the section on defining functions in docs.python.org/tutorial . Let’s use our new function to add this regression line to a plot of medv vs. lstat . In [22]: ax = Boston.plot.scatter( 'lstat' , 'medv' ) abline(ax, results.params[0], results.params[1], 'r--' , linewidth=3) Thus, the final call to ax.plot() is ax.plot(xlim, ylim, 'r--', linewidth=3) . We have used the argument 'r--' to produce a red dashed line, and added an argument to make it of width 3. There is some evidence for non-linearity in the relationship between lstat and medv . We will explore this issue later in this lab. As mentioned above, there is an existing function to add a line to a plot — ax.axline() — but knowing how to write such functions empowers us to create more expressive displays. Next we examine some diagnostic plots, several of which were discussed in Section 3.3.3 . We can find the fitted values and residuals of the fit as attributes of the results object. Various influence measures describing the regression model are computed with the get_influence() method. As we .get_ influence() will not use the fig component returned as the first value from subplots() , we simply capture the second returned value in ax below. In [23]: ax = subplots(figsize=(8,8))[1] \nax.scatter(results.fittedvalues , results.resid) ax.set_xlabel( 'Fitted value' ) ax.set_ylabel( 'Residual' ) ax.axhline(0, c= 'k' , ls= '--' ); We add a horizontal line at 0 for reference using the ax.axhline() method, .axhline() indicating it should be black ( c='k' ) and have a dashed linestyle ( ls='--' ). On the basis of the residual plot (not shown), there is some evidence of non-linearity. Leverage statistics can be computed for any number of predictors using the hat_matrix_diag attribute of the value returned by the get_influence() method. In [24]: infl = results.get_influence() ax = subplots(figsize=(8,8))[1] ax.scatter(np.arange(X.shape[0]), infl.hat_matrix_diag) ax.set_xlabel( 'Index' ) ax.set_ylabel( 'Leverage' ) np.argmax(infl.hat_matrix_diag) Out[24]: 374 The np.argmax() function identifies the index of the largest element of an np.argmax() array, optionally computed over an axis of the array. In this case, we maxi- mized over the entire array to determine which observation has the largest leverage statistic. 3.6.3 Multiple Linear Regression In order to fit a multiple linear regression model using least squares, we again use the ModelSpec() transform to construct the required model matrix and response. The arguments to ModelSpec() can be quite general, but in this case a list of column names suffice. We consider a fit here with the two variables lstat and age . In [25]: X = MS([ 'lstat' , 'age' ]).fit_transform(Boston) model1 = sm.OLS(y, X) results1 = model1.fit() summarize(results1) Out[25]: coef std err t P>|t| intercept 33.2228 0.731 45.458 0.000 lstat -1.0321 0.048 -21.416 0.000 age 0.0345 0.012 2.826 0.005 Notice how we have compacted the first line into a succinct expression describing the construction of X . The Boston data set contains 12 variables, and so it would be cumbersome to have to type all of these in order to perform a regression using all of the predictors. Instead, we can use the following short-hand: .columns. drop() In [26]: terms = Boston.columns.drop( 'medv' ) terms \nOut[26]: Index([ 'crim' , 'zn' , 'indus' , 'chas' , 'nox' , 'rm' , 'age' , 'dis' , 'rad' , 'tax' , 'ptratio' , 'lstat' ], dtype= 'object' ) We can now fit the model with all the variables in terms using the same model matrix builder. In [27]: X = MS(terms).fit_transform(Boston) model = sm.OLS(y, X) results = model.fit() summarize(results) Out[27]: coef std err t P>|t| intercept 41.6173 4.936 8.431 0.000 crim -0.1214 0.033 -3.678 0.000 zn 0.0470 0.014 3.384 0.001 indus 0.0135 0.062 0.217 0.829 chas 2.8400 0.870 3.264 0.001 nox -18.7580 3.851 -4.870 0.000 rm 3.6581 0.420 8.705 0.000 age 0.0036 0.013 0.271 0.787 dis -1.4908 0.202 -7.394 0.000 rad 0.2894 0.067 4.325 0.000 tax -0.0127 0.004 -3.337 0.001 ptratio -0.9375 0.132 -7.091 0.000 lstat -0.5520 0.051 -10.897 0.000 What if we would like to perform a regression using all of the variables but one? For example, in the above regression output, age has a high p -value. So we may wish to run a regression excluding this predictor. The following syntax results in a regression using all predictors except age (output not shown). In [28]: minus_age = Boston.columns.drop([ 'medv' , 'age' ]) Xma = MS(minus_age).fit_transform(Boston) model1 = sm.OLS(y, Xma) summarize(model1.fit()) 3.6.4 Multivariate Goodness of Fit We can access the individual components of results by name ( dir(results) shows us what is available). Hence results.rsquared gives us the R 2 , and np.sqrt(results.scale) gives us the RSE. Variance inflation factors (section 3.3.3 ) are sometimes useful to assess the effect of collinearity in the model matrix of a regression model. We will compute the VIFs in our multiple regression fit, and use the opportunity to introduce the idea of list comprehension . list compre- hension List Comprehension Often we encounter a sequence of objects which we would like to transform for some other task. Below, we compute the VIF for each feature in our X matrix and produce a data frame whose index agrees with the columns of X . The notion of list comprehension can often make such a task easier. \nList comprehensions are simple and powerful ways to form lists of Python objects. The language also supports dictionary and generator comprehen- sion, though these are beyond our scope here. Let’s look at an example. We compute the VIF for each of the variables in the model matrix X , using the function variance_inflation_factor() . variance_ inflation_ factor() In [29]: vals = [VIF(X, i) for i in range(1, X.shape[1])] vif = pd.DataFrame({ 'vif' :vals}, index=X.columns[1:]) vif Out[29]: vif crim 1.767 zn 2.298 indus 3.987 chas 1.071 nox 4.369 rm 1.913 age 3.088 dis 3.954 rad 7.445 tax 9.002 ptratio 1.797 lstat 2.871 The function VIF() takes two arguments: a dataframe or array, and a vari- able column index. In the code above we call VIF() on the fly for all columns in X . We have excluded column 0 above (the intercept), which is not of in- terest. In this case the VIFs are not that exciting. The object vals above could have been constructed with the following for loop: In [30]: vals = [] for i in range(1, X.values.shape[1]): vals.append(VIF(X.values, i)) List comprehension allows us to perform such repetitive operations in a more straightforward way. 3.6.5 Interaction Terms It is easy to include interaction terms in a linear model using ModelSpec() . Including a tuple (\"lstat\",\"age\") tells the model matrix builder to include an interaction term between lstat and age . In [31]: X = MS([ 'lstat' , 'age' , ( 'lstat' , 'age' )]).fit_transform(Boston) model2 = sm.OLS(y, X) summarize(model2.fit()) Out[31]: coef std err t P>|t| intercept 36.0885 1.470 24.553 0.000 lstat -1.3921 0.167 -8.313 0.000 \nage -0.0007 0.020 -0.036 0.971 lstat:age 0.0042 0.002 2.244 0.025 3.6.6 Non-linear Transformations of the Predictors The model matrix builder can include terms beyond just column names and interactions. For instance, the poly() function supplied in ISLP specifies poly() that columns representing polynomial functions of its first argument are added to the model matrix. In [32]: X = MS([poly( 'lstat' , degree=2), 'age' ]).fit_transform(Boston) model3 = sm.OLS(y, X) results3 = model3.fit() summarize(results3) Out[32]: coef std err t P>|t| intercept 17.7151 0.781 22.681 0.000 poly(lstat, degree=2)[0] -179.2279 6.733 -26.620 0.000 poly(lstat, degree=2)[1] 72.9908 5.482 13.315 0.000 age 0.0703 0.011 6.471 0.000 The effectively zero p -value associated with the quadratic term (i.e. the third row above) suggests that it leads to an improved model. By default, poly() creates a basis matrix for inclusion in the model ma- trix whose columns are orthogonal polynomials , which are designed for sta- orthogonal polynomial ble least squares computations. 13 Alternatively, had we included an argu- ment raw=True in the above call to poly() , the basis matrix would consist simply of lstat and lstat**2 . Since either of these bases represent quadratic polynomials, the fitted values would not change in this case, just the poly- nomial coefficients. Also by default, the columns created by poly() do not include an intercept column as that is automatically added by MS() . We use the anova_lm() function to further quantify the extent to which anova_lm() the quadratic fit is superior to the linear fit. In [33]: anova_lm(results1, results3) Out[33]: df_resid ssr df_diff ss_diff F Pr(>F) 0 503.0 19168.13 0.0 NaN NaN NaN 1 502.0 14165.61 1.0 5002.52 177.28 7.47e-35 Here results1 represents the linear submodel containing predictors lstat and age , while results3 corresponds to the larger model above with a quadratic term in lstat . The anova_lm() function performs a hypothesis test comparing the two models. The null hypothesis is that the quadratic term in the bigger model is not needed, and the alternative hypothesis is that the bigger model is superior. Here the F -statistic is 177.28 and the associated p -value is zero. In this case the F -statistic is the square of the t -statistic for the quadratic term in the linear model summary for results3 — a consequence of the fact that these nested models differ by one degree of 13 Actually, poly() is a wrapper for the workhorse and standalone function Poly() that does the work in building the model matrix. \nfreedom. This provides very clear evidence that the quadratic polynomial in lstat improves the linear model. This is not surprising, since earlier we saw evidence for non-linearity in the relationship between medv and lstat . The function anova_lm() can take more than two nested models as input, in which case it compares every successive pair of models. That also explains why their are NaN s in the first row above, since there is no previous model with which to compare the first. In [34]: ax = subplots(figsize=(8,8))[1] ax.scatter(results3.fittedvalues , results3.resid) ax.set_xlabel( 'Fitted value' ) ax.set_ylabel( 'Residual' ) ax.axhline(0, c= 'k' , ls= '--' ) We see that when the quadratic term is included in the model, there is little discernible pattern in the residuals. In order to create a cubic or higher-degree polynomial fit, we can simply change the degree argument to poly() . 3.6.7 Qualitative Predictors Here we use the Carseats data, which is included in the ISLP package. We will attempt to predict Sales (child car seat sales) in 400 locations based on a number of predictors. In [35]: Carseats = load_data( 'Carseats' ) Carseats.columns Out[35]: Index([ 'Sales' , 'CompPrice' , 'Income' , 'Advertising' , 'Population' , 'Price' , 'ShelveLoc' , 'Age' , 'Education' , 'Urban' , 'US' ], dtype= 'object' ) The Carseats data includes qualitative predictors such as ShelveLoc , an indicator of the quality of the shelving location — that is, the space within a store in which the car seat is displayed. The predictor ShelveLoc takes on three possible values, Bad , Medium , and Good . Given a qualitative variable such as ShelveLoc , ModelSpec() generates dummy variables automatically. These variables are often referred to as a one-hot encoding of the categorical one-hot encoding feature. Their columns sum to one, so to avoid collinearity with an inter- cept, the first column is dropped. Below we see the column ShelveLoc[Bad] has been dropped, since Bad is the first level of ShelveLoc . Below we fit a multiple regression model that includes some interaction terms. In [36]: allvars = list(Carseats.columns.drop( 'Sales' )) y = Carseats[ 'Sales' ] final = allvars + [( 'Income' , 'Advertising' ), ( 'Price' , 'Age' )] X = MS(final).fit_transform(Carseats) model = sm.OLS(y, X) summarize(model.fit()) Out[36]: coef std err t P>|t| intercept 6.5756 1.009 6.519 0.000 \nCompPrice 0.0929 0.004 22.567 0.000 Income 0.0109 0.003 4.183 0.000 Advertising 0.0702 0.023 3.107 0.002 Population 0.0002 0.000 0.433 0.665 Price -0.1008 0.007 -13.549 0.000 ShelveLoc[Good] 4.8487 0.153 31.724 0.000 ShelveLoc[Medium] 1.9533 0.126 15.531 0.000 Age -0.0579 0.016 -3.633 0.000 Education -0.0209 0.020 -1.063 0.288 Urban[Yes] 0.1402 0.112 1.247 0.213 US[Yes] -0.1576 0.149 -1.058 0.291 Income:Advertising 0.0008 0.000 2.698 0.007 Price:Age 0.0001 0.000 0.801 0.424 In the first line above, we made allvars a list, so that we could add the interaction terms two lines down. Our model-matrix builder has created a ShelveLoc[Good] dummy variable that takes on a value of 1 if the shelving location is good, and 0 otherwise. It has also created a ShelveLoc[Medium] dummy variable that equals 1 if the shelving location is medium, and 0 oth- erwise. A bad shelving location corresponds to a zero for each of the two dummy variables. The fact that the coefficient for ShelveLoc[Good] in the regression output is positive indicates that a good shelving location is asso- ciated with high sales (relative to a bad location). And ShelveLoc[Medium] has a smaller positive coefficient, indicating that a medium shelving loca- tion leads to higher sales than a bad shelving location, but lower sales than a good shelving location. 3.7 Exercises Conceptual 1. Describe the null hypotheses to which the p -values given in Table 3.4 correspond. Explain what conclusions you can draw based on these p -values. Your explanation should be phrased in terms of sales , TV , radio , and newspaper , rather than in terms of the coefficients of the linear model. 2. Carefully explain the differences between the KNN classifier and KNN regression methods. 3. Suppose we have a data set with five predictors, X 1 = GPA, X 2 = IQ, X 3 = Level ( 1 for College and 0 for High School), X 4 = Interac- tion between GPA and IQ, and X 5 = Interaction between GPA and Level. The response is starting salary after graduation (in thousands of dollars). Suppose we use least squares to fit the model, and get ˆ β 0 = 50 , ˆ β 1 = 20 , ˆ β 2 = 0 . 07 , ˆ β 3 = 35 , ˆ β 4 = 0 . 01 , ˆ β 5 = − 10 . (a) Which answer is correct, and why? i. For a fixed value of IQ and GPA, high school graduates earn more, on average, than college graduates. ii. For a fixed value of IQ and GPA, college graduates earn more, on average, than high school graduates. \niii. For a fixed value of IQ and GPA, high school graduates earn more, on average, than college graduates provided that the GPA is high enough. iv. For a fixed value of IQ and GPA, college graduates earn more, on average, than high school graduates provided that the GPA is high enough. (b) Predict the salary of a college graduate with IQ of 110 and a GPA of 4 . 0 . (c) True or false: Since the coefficient for the GPA/IQ interaction term is very small, there is very little evidence of an interaction effect. Justify your answer. 4. I collect a set of data ( n = 100 observations) containing a single predictor and a quantitative response. I then fit a linear regression model to the data, as well as a separate cubic regression, i.e. Y = β 0 + β 1 X + β 2 X 2 + β 3 X 3 + ϵ . (a) Suppose that the true relationship between X and Y is linear, i.e. Y = β 0 + β 1 X + ϵ . Consider the training residual sum of squares (RSS) for the linear regression, and also the training RSS for the cubic regression. Would we expect one to be lower than the other, would we expect them to be the same, or is there not enough information to tell? Justify your answer. (b) Answer (a) using test rather than training RSS. (c) Suppose that the true relationship between X and Y is not linear, but we don’t know how far it is from linear. Consider the training RSS for the linear regression, and also the training RSS for the cubic regression. Would we expect one to be lower than the other, would we expect them to be the same, or is there not enough information to tell? Justify your answer. (d) Answer (c) using test rather than training RSS. 5. Consider the fitted values that result from performing linear regres- sion without an intercept. In this setting, the i th fitted value takes the form ˆ y i = x i ˆ β, where ˆ β = > n 0 i =1 x i y i ? / > n 0 i ′ =1 x 2 i ′ ? . (3.38) Show that we can write ˆ y i = n 0 i ′ =1 a i ′ y i ′ . What is a i ′ ? Note: We interpret this result by saying that the fitted values from linear regression are linear combinations of the response values. \n6. Using ( 3.4 ), argue that in the case of simple linear regression, the least squares line always passes through the point (¯ x, ¯ y ) . 7. It is claimed in the text that in the case of simple linear regression of Y onto X , the R 2 statistic ( 3.17 ) is equal to the square of the correlation between X and Y ( 3.18 ). Prove that this is the case. For simplicity, you may assume that ¯ x = ¯ y = 0 . Applied 8. This question involves the use of simple linear regression on the Auto data set. (a) Use the sm.OLS() function to perform a simple linear regression with mpg as the response and horsepower as the predictor. Use the summarize() function to print the results. Comment on the output. For example: i. Is there a relationship between the predictor and the re- sponse? ii. How strong is the relationship between the predictor and the response? iii. Is the relationship between the predictor and the response positive or negative? iv. What is the predicted mpg associated with a horsepower of 98? What are the associated 95 % confidence and prediction intervals? (b) Plot the response and the predictor in a new set of axes ax . Use the ax.axline() method or the abline() function defined in the lab to display the least squares regression line. (c) Produce some of diagnostic plots of the least squares regression fit as described in the lab. Comment on any problems you see with the fit. 9. This question involves the use of multiple linear regression on the Auto data set. (a) Produce a scatterplot matrix which includes all of the variables in the data set. (b) Compute the matrix of correlations between the variables using the DataFrame.corr() method. .corr() (c) Use the sm.OLS() function to perform a multiple linear regression with mpg as the response and all other variables except name as the predictors. Use the summarize() function to print the results. Comment on the output. For instance: i. Is there a relationship between the predictors and the re- sponse? Use the anova_lm() function from statsmodels to answer this question. \nii. Which predictors appear to have a statistically significant relationship to the response? iii. What does the coefficient for the year variable suggest? (d) Produce some of diagnostic plots of the linear regression fit as described in the lab. Comment on any problems you see with the fit. Do the residual plots suggest any unusually large outliers? Does the leverage plot identify any observations with unusually high leverage? (e) Fit some models with interactions as described in the lab. Do any interactions appear to be statistically significant? (f) Try a fe w d ifferent transformations of the variables, such as log( X ) , √ X , X 2 . Comment on your findings. 10. This question should be answered using the Carseats data set. (a) Fit a multiple regression model to predict Sales using Price , Urban , and US . (b) Provide an interpretation of each coefficient in the model. Be careful—some of the variables in the model are qualitative! (c) Write out the model in equation form, being careful to handle the qualitative variables properly. (d) For which of the predictors can you reject the null hypothesis H 0 : β j = 0 ? (e) On the basis of your response to the previous question, fit a smaller model that only uses the predictors for which there is evidence of association with the outcome. (f) How well do the models in (a) and (e) fit the data? (g) Using the model from (e), obtain 95 % confidence intervals for the coefficient(s). (h) Is there evidence of outliers or high leverage observations in the model from (e)? 11. In this problem we will investigate the t -statistic for the null hypoth- esis H 0 : β = 0 in simple linear regression without an intercept. To begin, we generate a predictor x and a response y as follows. rng = np.random.default_rng(1) x = rng.normal(size=100) y = 2 * x + rng.normal(size=100) (a) Perform a simple linear regression of y onto x , without an in- tercept. Report the coefficient estimate ˆ β , the standard error of this coefficient estimate, and the t -statistic and p -value associ- ated with the null hypothesis H 0 : β = 0 . Comment on these results. (You can perform regression without an intercept using the keywords argument intercept=False to ModelSpec() .) \n(b) Now perform a simple linear regression of x onto y without an intercept, and report the coefficient estimate, its standard error, and the corresponding t -statistic and p -values associated with the null hypothesis H 0 : β = 0 . Comment on these results. (c) What is the relationship between the results obtained in (a) and (b)? (d) For the regression of Y onto X without an intercept, the t - statistic for H 0 : β = 0 takes the form ˆ β/ SE( ˆ β ) , where ˆ β is given by ( 3.38 ), and where SE( ˆ β ) = @ ) n i =1 ( y i − x i ˆ β ) 2 ( n − 1) ) n i ′ =1 x 2 i ′ . (These formulas are slightly different from those given in Sec- tions 3.1.1 and 3.1.2 , since here we are performing regression without an intercept.) Show algebraically, and confirm numeri- cally in R , that the t -statistic can be written as ( √ n − 1) ) n i =1 x i y i 5 ( ) n i =1 x 2 i )( ) n i ′ =1 y 2 i ′ ) − ( ) n i ′ =1 x i ′ y i ′ ) 2 . (e) Using the results from (d), argue that the t -statistic for the re- gression of y onto x is the same as the t -statistic for the regression of x onto y . (f) In R , show that when regression is performed with an intercept, the t -statistic for H 0 : β 1 = 0 is the same for the regression of y onto x as it is for the regression of x onto y . 12. This problem involves simple linear regression without an intercept. (a) Recall that the coefficient estimate ˆ β for the linear regression of Y onto X without an intercept is given by ( 3.38 ). Under what circumstance is the coefficient estimate for the regression of X onto Y the same as the coefficient estimate for the regression of Y onto X ? (b) Generate an example in Python with n = 100 observations in which the coefficient estimate for the regression of X onto Y is different from the coefficient estimate for the regression of Y onto X . (c) Generate an example in Python with n = 100 observations in which the coefficient estimate for the regression of X onto Y is the same as the coefficient estimate for the regression of Y onto X . 13. In this exercise you will create some simulated data and will fit simple linear regression models to it. Make sure to use the default random number generator with seed set to 1 prior to starting part (a) to ensure consistent results. \n(a) Using the normal() method of your random number generator, create a vector, x , containing 100 observations drawn from a N (0 , 1) distribution. This represents a feature, X . (b) Using the normal() method, create a vector, eps , containing 100 observations drawn from a N (0 , 0 . 25) distribution—a normal distribution with mean zero and variance 0 . 25 . (c) Using x and eps , generate a vector y according to the model Y = − 1 + 0 . 5 X + ϵ. (3.39) What is the length of the vector y ? What are the values of β 0 and β 1 in this linear model? (d) Create a scatterplot displaying the relationship between x and y . Comment on what you observe. (e) Fit a least squares linear model to predict y using x . Comment on the model obtained. How do ˆ β 0 and ˆ β 1 compare to β 0 and β 1 ? (f) Display the least squares line on the scatterplot obtained in (d). Draw the population regression line on the plot, in a different color. Use the legend() method of the axes to create an appro- priate legend. (g) Now fit a polynomial regression model that predicts y using x and x 2 . Is there evidence that the quadratic term improves the model fit? Explain your answer. (h) Repeat (a)–(f) after modifying the data generation process in such a way that there is less noise in the data. The model ( 3.39 ) should remain the same. You can do this by decreasing the vari- ance of the normal distribution used to generate the error term ϵ in (b). Describe your results. (i) Repeat (a)–(f) after modifying the data generation process in such a way that there is more noise in the data. The model ( 3.39 ) should remain the same. You can do this by increasing the variance of the normal distribution used to generate the error term ϵ in (b). Describe your results. (j) What are the confidence intervals for β 0 and β 1 based on the original data set, the noisier data set, and the less noisy data set? Comment on your results. 14. This problem focuses on the collinearity problem. (a) Perform the following commands in Python : rng = np.random.default_rng(10) x1 = rng.uniform(0, 1, size=100) x2 = 0.5 * x1 + rng.normal(size=100) / 10 y = 2 + 2 * x1 + 0.3 * x2 + rng.normal(size=100) The last line corresponds to creating a linear model in which y is a function of x1 and x2 . Write out the form of the linear model. What are the regression coefficients? \n(b) What is the correlation between x1 and x2 ? Create a scatterplot displaying the relationship between the variables. (c) Using this data, fit a least squares regression to predict y using x1 and x2 . Describe the results obtained. What are ˆ β 0 , ˆ β 1 , and ˆ β 2 ? How do these relate to the true β 0 , β 1 , and β 2 ? Can you reject the null hypothesis H 0 : β 1 = 0 ? How about the null hypothesis H 0 : β 2 = 0 ? (d) Now fit a least squares regression to predict y using only x1 . Comment on your results. Can you reject the null hypothesis H 0 : β 1 = 0 ? (e) Now fit a least squares regression to predict y using only x2 . Comment on your results. Can you reject the null hypothesis H 0 : β 1 = 0 ? (f) Do the results obtained in (c)–(e) contradict each other? Explain your answer. (g) Suppose we obtain one additional observation, which was unfor- tunately mismeasured. We use the function np.concatenate() to np.conca- tenate() add this additional observation to each of x1 , x2 and y . x1 = np.concatenate([x1, [0.1]]) x2 = np.concatenate([x2, [0.8]]) y = np.concatenate([y, [6]]) Re-fit the linear models from (c) to (e) using this new data. What effect does this new observation have on the each of the models? In each model, is this observation an outlier? A high-leverage point? Both? Explain your answers. 15. This problem involves the Boston data set, which we saw in the lab for this chapter. We will now try to predict per capita crime rate using the other variables in this data set. In other words, per capita crime rate is the response, and the other variables are the predictors. (a) For each predictor, fit a simple linear regression model to predict the response. Describe your results. In which of the models is there a statistically significant association between the predictor and the response? Create some plots to back up your assertions. (b) Fit a multiple regression model to predict the response using all of the predictors. Describe your results. For which predictors can we reject the null hypothesis H 0 : β j = 0 ? (c) How do your results from (a) compare to your results from (b)? Create a plot displaying the univariate regression coefficients from (a) on the x -axis, and the multiple regression coefficients from (b) on the y -axis. That is, each predictor is displayed as a single point in the plot. Its coefficient in a simple linear regres- sion model is shown on the x -axis, and its coefficient estimate in the multiple linear regression model is shown on the y -axis. \n(d) Is there evidence of non-linear association between any of the predictors and the response? To answer this question, for each predictor X , fit a model of the form Y = β 0 + β 1 X + β 2 X 2 + β 3 X 3 + ϵ. \n4 Classification The linear regression model discussed in Chapter 3 assumes that the re- sponse variable Y is quantitative. But in many situations, the response variable is instead qualitative . For example, eye color is qualitative. Of- qualitative ten qualitative variables are referred to as categorical ; we will use these terms interchangeably. In this chapter, we study approaches for predicting qualitative responses, a process that is known as classification . Predicting classification a qualitative response for an observation can be referred to as classifying that observation, since it involves assigning the observation to a category, or class. On the other hand, often the methods used for classification first predict the probability that the observation belongs to each of the cate- gories of a qualitative variable, as the basis for making the classification. In this sense they also behave like regression methods. There are many possible classification techniques, or classifiers , that one classifier might use to predict a qualitative response. We touched on some of these in Sections 2.1.5 and 2.2.3 . In this chapter we discuss some widely-used classifiers: logistic regression , linear discriminant analysis , quadratic dis- logistic regression linear discriminant analysis criminant analysis , naive Bayes , and K -nearest neighbors . The discussion quadratic discriminant analysis naive Bayes K -nearest neighbors of logistic regression is used as a jumping-off point for a discussion of gen- eralized linear models , and in particular, Poisson regression . We discuss generalized linear models Poisson regression more computer-intensive classification methods in later chapters: these in- clude generalized additive models (Chapter 7 ); trees, random forests, and boosting (Chapter 8 ); and support vector machines (Chapter 9 ). 4.1 An Overview of Classification Classification problems occur often, perhaps even more so than regression problems. Some examples include: 135 \n1. A person arrives at the emergency room with a set of symptoms that could possibly be attributed to one of three medical conditions. Which of the three conditions does the individual have? 2. An online banking service must be able to determine whether or not a transaction being performed on the site is fraudulent, on the basis of the user’s IP address, past transaction history, and so forth. 3. On the basis of DNA sequence data for a number of patients with and without a given disease, a biologist would like to figure out which DNA mutations are deleterious (disease-causing) and which are not. Just as in the regression setting, in the classification setting we have a set of training observations ( x 1 , y 1 ) , . . . , ( x n , y n ) that we can use to build a classifier. We want our classifier to perform well not only on the training data, but also on test observations that were not used to train the classifier. In this chapter, we will illustrate the concept of classification using the simulated Default data set. We are interested in predicting whether an individual will default on his or her credit card payment, on the basis of annual income and monthly credit card balance. The data set is displayed in Figure 4.1 . In the left-hand panel of Figure 4.1 , we have plotted annual income and monthly credit card balance for a subset of 10 , 000 individuals. The individuals who defaulted in a given month are shown in orange, and those who did not in blue. (The overall default rate is about 3 %, so we have plotted only a fraction of the individuals who did not default.) It appears that individuals who defaulted tended to have higher credit card balances than those who did not. In the center and right-hand panels of Figure 4.1 , two pairs of boxplots are shown. The first shows the distribution of balance split by the binary default variable; the second is a similar plot for income . In this chapter, we learn how to build a model to predict default ( Y ) for any given value of balance ( X 1 ) and income ( X 2 ). Since Y is not quantitative, the simple linear regression model of Chapter 3 is not a good choice: we will elaborate on this further in Section 4.2 . It is worth noting that Figure 4.1 displays a very pronounced relation- ship between the predictor balance and the response default . In most real applications, the relationship between the predictor and the response will not be nearly so strong. However, for the sake of illustrating the classifica- tion procedures discussed in this chapter, we use an example in which the relationship between the predictor and the response is somewhat exagger- ated. 4.2 Why Not Linear Regression? We have stated that linear regression is not appropriate in the case of a qualitative response. Why not? Suppose that we are trying to predict the medical condition of a patient in the emergency room on the basis of her symptoms. In this simplified example, there are three possible diagnoses: stroke , drug overdose , and"
}