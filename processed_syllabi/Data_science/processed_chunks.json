[
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "1 Introduction An Overview of Statistical Learning Statistical learning refers to a vast set of tools for understanding data . These tools can be classified as supervised or unsupervised . Broadly speaking, supervised statistical learning involves building a statistical model for prdicting, or estimating, an output based on one or more inputs . Problems of this nature occur in fields as diverse as business, medicine, astrophysics, and public policy. With unsupervised statistical learning, there are inputs but no supervising output; nevertheless we can learn relationships and struture from such data. To provide an illustration of some applications of statistical learning, we briefly discuss three real-world data sets that are considered in this book. Wage Data In this application (which we refer to as the Wage data set throughout this book), we examine a number of factors that relate to wages for a group of men from the Atlantic region of the United States. In particular, we wish to understand the association between an employee’s age and education , as well as the calendar year , on his wage . Consider, for example, the left-hand panel of Figure 1.1 , which displays wage versus age for each of the individals in the data set. There is evidence that wage increases with age but then decreases again after approximately age 60 . The blue line, which provides an estimate of the average wage for a given age , makes this trend clearer. Given an employee’s age , we can use this curve to predict his wage . However, it is also clear from Figure 1.1 that there is a significant amount of varability associated with this average value, and so age alone is unlikely to provide an accurate prediction of a particular man’s wage . 1 20 40 60 80 50 100 200 300 Age Wage 2003 2006 2009 50 100 200 300 Year Wage 1 2 3 4 5 50 100 200 300 Education Level Wage FIGURE 1.1. Wage data, which contains income survey information for men from the central Atlantic region of the United States. Left: wage as a function of age",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Wage data, which contains income survey information for men from the central Atlantic region of the United States. Left: wage as a function of age . On average, wage increases with age until about 60 years of age, at which point it begins to decline. Center: wage as a function of year . There is a slow but steady increase of approximately $10 , 000 in the average wage between 2003 and 2009 . Right: Boxplots displaying wage as a function of education , with 1 indicating the lowest level (no high school diploma) and 5 the highest level (an advanced graduate degree). On average, wage increases with the level of education. We also have information regarding each employee’s education level and the year in which the wage was earned. The center and right-hand panels of Figure 1.1 , which display wage as a function of both year and education , indicate that both of these factors are associated with wage . Wages increase by approximately $10 , 000 , in a roughly linear (or straight-line) fashion, between 2003 and 2009 , though this rise is very slight relative to the varability in the data. Wages are also typically greater for individuals with higher education levels: men with the lowest education level (1) tend to have substantially lower wages than those with the highest education level (5). Clearly, the most accurate prediction of a given man’s wage will be obtained by combining his age , his education , and the year . In Chapter 3 , we discuss linear regression, which can be used to predict wage from this data set. Ideally, we should predict wage in a way that accounts for the non-linear relationship between wage and age . In Chapter 7 , we discuss a class of approaches for addressing this problem. Stock Market Data The Wage data involves predicting a continuous or quantitative output value. This is often referred to as a regression problem. However, in certain cases we may instead wish to predict a non-numerical value—that is, a categorical or qualitative output",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This is often referred to as a regression problem. However, in certain cases we may instead wish to predict a non-numerical value—that is, a categorical or qualitative output. For example, in Chapter 4 we examine a stock market data set that contains the daily movements in the Standard & Poor’s 500 (S&P) stock index over a 5-year period between 2001 and 2005 . We refer to this as the Smarket data. The goal is to predict whether the index will increase or decrease on a given day, using the past 5 days’ percentage changes in the index. Here the statistical learning problem does not involve predicting a numerical value. Instead it involves predicting whether a given Down Up −4 −2 0 2 4 6 Yesterday Today’s Direction Percentage change in S&P Down Up −4 −2 0 2 4 6 Two Days Previous Today’s Direction Percentage change in S&P Down Up −4 −2 0 2 4 6 Three Days Previous Today’s Direction Percentage change in S & P FIGURE 1.2. Left: Boxplots of the previous day’s percentage change in the S&P index for the days for which the market increased or decreased, obtained from the Smarket data. Center and Right: Same as left panel, but the percentage changes for 2 and 3 days previous are shown. day’s stock market performance will fall into the Up bucket or the Down bucket. This is known as a classification problem. A model that could accurately predict the direction in which the market will move would be very useful! The left-hand panel of Figure 1.2 displays two boxplots of the previous day’s percentage changes in the stock index: one for the 648 days for which the market increased on the subsequent day, and one for the 602 days for which the market decreased. The two plots look almost identical, suggesing that there is no simple strategy for using yesterday’s movement in the S&P to predict today’s returns. The remaining panels, which display boplots for the percentage changes 2 and 3 days previous to today, similarly indicate little association between past and present returns",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The remaining panels, which display boplots for the percentage changes 2 and 3 days previous to today, similarly indicate little association between past and present returns. Of course, this lack of pattern is to be expected: in the presence of strong correlations btween successive days’ returns, one could adopt a simple trading strategy to generate profits from the market. Nevertheless, in Chapter 4 , we explore these data using several different statistical learning methods. Interestingly, there are hints of some weak trends in the data that suggest that, at least for this 5-year period, it is possible to correctly predict the direction of movement in the market approximately 60% of the time (Figure 1.3 ). Gene Expression Data The previous two applications illustrate data sets with both input and output variables. However, another important class of problems involves situations in which we only observe input variables, with no corresponding output. For example, in a marketing setting, we might have demographic information for a number of current or potential customers. We may wish to understand which types of customers are similar to each other by grouping individuals according to their observed characteristics. This is known as a Down Up 0.46 0.48 0.50 0.52 Today’s Direction Predicted Probability FIGURE 1.3. We fit a quadratic discriminant analysis model to the subset of the Smarket data corresponding to the 2001–2004 time period, and predicted the probability of a stock market decrease using the 2005 data. On average, the predicted probability of decrease is higher for the days in which the market does decrease. Based on these results, we are able to correctly predict the direction of movement in the market 60% of the time. clustering problem. Unlike in the previous examples, here we are not trying to predict an output variable. We devote Chapter 12 to a discussion of statistical learning methods for problems in which no natural output variable is available",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We devote Chapter 12 to a discussion of statistical learning methods for problems in which no natural output variable is available. We consider the NCI60 data set, which consists of 6 , 830 gene expression measurements for each of 64 cancer cell lines. Instead of predicting a particular output variable, we are interested in determining whether there are groups, or clusters, among the cell lines based on their gene expression measurements. This is a difficult question to address, in part because there are thousands of gene expression measurements per cell line, making it hard to visualize the data. The left-hand panel of Figure 1.4 addresses this problem by represening each of the 64 cell lines using just two numbers, Z 1 and Z 2 . These are the first two principal components of the data, which summarize the 6 , 830 expression measurements for each cell line down to two numbers or dimensions . While it is likely that this dimension reduction has resulted in some loss of information, it is now possible to visually examine the data for evidence of clustering. Deciding on the number of clusters is often a difficult problem. But the left-hand panel of Figure 1.4 suggests at least four groups of cell lines, which we have represented using separate colors. In this particular data set, it turns out that the cell lines correspond to 14 different types of cancer. (However, this information was not used to create the left-hand panel of Figure 1.4 .) The right-hand panel of Fiure 1.4 is identical to the left-hand panel, except that the 14 cancer types are shown using distinct colored symbols. There is clear evidence that cell lines with the same cancer type tend to be located near each other in this two-dimensional representation. In addition, even though the cancer infomation was not used to produce the left-hand panel, the clustering obtained does bear some resemblance to some of the actual cancer types observed in the right-hand panel",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This provides some independent verification of the accuracy of our clustering analysis. −40 −20 0 20 40 60 −60 −40 −20 0 20 −40 −20 0 20 40 60 −60 −40 −20 0 20 Z 1 Z 1 Z 2 Z 2 FIGURE 1.4. Left: Representation of the NCI60 gene expression data set in a two-dimensional space, Z 1 and Z 2 . Each point corresponds to one of the 64 cell lines. There appear to be four groups of cell lines, which we have represented using different colors. Right: Same as left panel except that we have represented each of the 14 different types of cancer using a different colored symbol. Cell lines corresponding to the same cancer type tend to be nearby in the two-dimensional space. A Brief History of Statistical Learning Though the term statistical learning is fairly new, many of the concepts that underlie the field were developed long ago. At the beginning of the ninteenth century, the method of least squares was developed, implementing the earliest form of what is now known as linear regression . The approach was first successfully applied to problems in astronomy. Linear regression is used for predicting quantitative values, such as an individual’s salary. In order to predict qualitative values, such as whether a patient survives or dies, or whether the stock market increases or decreases, linear discriinant analysis was proposed in 1936. In the 1940s, various authors put forth an alternative approach, logistic regression . In the early 1970s, the term generalized linear model was developed to describe an entire class of statistical learning methods that include both linear and logistic regression as special cases. By the end of the 1970s, many more techniques for learning from data were available. However, they were almost exclusively linear methods bcause fitting non-linear relationships was computationally difficult at the time. By the 1980s, computing technology had finally improved sufficiently that non-linear methods were no longer computationally prohibitive",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". By the 1980s, computing technology had finally improved sufficiently that non-linear methods were no longer computationally prohibitive. In the mid 1980s, classification and regression trees were developed, followed shortly by generalized additive models . Neural networks gained popularity in the 1980s, and support vector machines arose in the 1990s. Since that time, statistical learning has emerged as a new subfield in statistics, focused on supervised and unsupervised modeling and prediction. In recent years, progress in statistical learning has been marked by the increasing availability of powerful and relatively user-friendly software, such as the popular and freely available Python system. This has the potential to continue the transformation of the field from a set of techniques used and developed by statisticians and computer scientists to an essential toolkit for a much broader community. This Book The Elements of Statistical Learning (ESL) by Hastie, Tibshirani, and Friedman was first published in 2001. Since that time, it has become an important reference on the fundamentals of statistical machine learning. Its success derives from its comprehensive and detailed treatment of many important topics in statistical learning, as well as the fact that (relative to many upper-level statistics textbooks) it is accessible to a wide audience. However, the greatest factor behind the success of ESL has been its topical nature. At the time of its publication, interest in the field of statistical learning was starting to explode. ESL provided one of the first accessible and comprehensive introductions to the topic. Since ESL was first published, the field of statistical learning has cotinued to flourish. The field’s expansion has taken two forms. The most obvious growth has involved the development of new and improved statitical learning approaches aimed at answering a range of scientific questions across a number of fields. However, the field of statistical learning has also expanded its audience",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, the field of statistical learning has also expanded its audience. In the 1990s, increases in computational power generated a surge of interest in the field from non-statisticians who were eager to use cutting-edge statistical tools to analyze their data. Unfortnately, the highly technical nature of these approaches meant that the user community remained primarily restricted to experts in statistics, computer science, and related fields with the training (and time) to understand and implement them. In recent years, new and improved software packages have significantly eased the implementation burden for many statistical learning methods. At the same time, there has been growing recognition across a number of fields, from business to health care to genetics to the social sciences and beyond, that statistical learning is a powerful tool with important practical applications. As a result, the field has moved from one of primarily academic interest to a mainstream discipline, with an enormous potential audience. This trend will surely continue with the increasing availability of enormous quantities of data and the software to analyze it. The purpose of An Introduction to Statistical Learning (ISL) is to faciltate the transition of statistical learning from an academic to a mainstream field. ISL is not intended to replace ESL, which is a far more comprehesive text both in terms of the number of approaches considered and the depth to which they are explored. We consider ESL to be an important companion for professionals (with graduate degrees in statistics, machine learning, or related fields) who need to understand the technical details behind statistical learning approaches. However, the community of users of statistical learning techniques has expanded to include individuals with a wider range of interests and backgrounds. Therefore, there is a place for a less technical and more accessible version of ESL",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Therefore, there is a place for a less technical and more accessible version of ESL. In teaching these topics over the years, we have discovered that they are of interest to master’s and PhD students in fields as disparate as business administration, biology, and computer science, as well as to quantitativeloriented upper-division undergraduates. It is important for this diverse group to be able to understand the models, intuitions, and strengths and weaknesses of the various approaches. But for this audience, many of the technical details behind statistical learning methods, such as optimiztion algorithms and theoretical properties, are not of primary interest. We believe that these students do not need a deep understanding of these aspects in order to become informed users of the various methodologies, and in order to contribute to their chosen fields through the use of statistical learning tools. ISL is based on the following four premises. 1. Many statistical learning methods are relevant and useful in a wide range of academic and non-academic disciplines, beyond just the sttistical sciences. We believe that many contemporary statistical learing procedures should, and will, become as widely available and used as is currently the case for classical methods such as linear regresion. As a result, rather than attempting to consider every possible approach (an impossible task), we have concentrated on presenting the methods that we believe are most widely applicable. 2. Statistical learning should not be viewed as a series of black boxes. No single approach will perform well in all possible applications. Witout understanding all of the cogs inside the box, or the interaction between those cogs, it is impossible to select the best box. Hence, we have attempted to carefully describe the model, intuition, assumtions, and trade-offs behind each of the methods that we consider. 3",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Hence, we have attempted to carefully describe the model, intuition, assumtions, and trade-offs behind each of the methods that we consider. 3. While it is important to know what job is performed by each cog, it is not necessary to have the skills to construct the machine inside the box! Thus, we have minimized discussion of technical details related to fitting procedures and theoretical properties. We assume that the reader is comfortable with basic mathematical concepts, but we do not assume a graduate degree in the mathematical sciences. For istance, we have almost completely avoided the use of matrix algebra, and it is possible to understand the entire book without a detailed knowledge of matrices and vectors. 4. We presume that the reader is interested in applying statistical learing methods to real-world problems. In order to facilitate this, as well as to motivate the techniques discussed, we have devoted a section within each chapter to computer labs. In each lab, we walk the reader through a realistic application of the methods considered in that chater. When we have taught this material in our courses, we have alocated roughly one-third of classroom time to working through the labs, and we have found them to be extremely useful. Many of the less computationally-oriented students who were initially intimidated by the labs got the hang of things over the course of the quarter or semester. This book originally appeared (2013, second edition 2021) with computer labs written in the R language. Since then, there has been increasing demand for Python implementations of the impotant techniques in statistical learning. Consequently, this version has labs in Python . There are a rapidly growing number of Python pacages available, and by examination of the imports at the beginning of each lab, readers will see that we have carefully selected and used the most appropriate. We have also supplied some additional code and functionality in our package ISLP",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We have also supplied some additional code and functionality in our package ISLP . However, the labs in ISL are selcontained, and can be skipped if the reader wishes to use a different software package or does not wish to apply the methods discussed to real-world problems. Who Should Read This Book? This book is intended for anyone who is interested in using modern statitical methods for modeling and prediction from data. This group includes scientists, engineers, data analysts, data scientists, and quants, but also less technical individuals with degrees in non-quantitative fields such as the scial sciences or business. We expect that the reader will have had at least one elementary course in statistics. Background in linear regression is also useful, though not required, since we review the key concepts behind linear regression in Chapter 3 . The mathematical level of this book is modest, and a detailed knowledge of matrix operations is not required. This book provides an introduction to Python . Previous exposure to a programming language, such as MATLAB or R , is useful but not required. The first edition of this textbook has been used to teach master’s and PhD students in business, economics, computer science, biology, earth scences, psychology, and many other areas of the physical and social sciences. It has also been used to teach advanced undergraduates who have already taken a course on linear regression. In the context of a more mathemaically rigorous course in which ESL serves as the primary textbook, ISL could be used as a supplementary text for teaching computational aspects of the various approaches. Notation and Simple Matrix Algebra Choosing notation for a textbook is always a difficult task. For the most part we adopt the same notational conventions as ESL. We will use n to represent the number of distinct data points, or observtions, in our sample. We will let p denote the number of variables that are available for use in making predictions",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We will use n to represent the number of distinct data points, or observtions, in our sample. We will let p denote the number of variables that are available for use in making predictions. For example, the Wage data set cosists of 11 variables for 3 , 000 people, so we have n = 3 , 000 observations and p = 11 variables (such as year , age , race , and more). Note that throughout this book, we indicate variable names using colored font: Variable Name . In some examples, p might be quite large, such as on the order of thosands or even millions; this situation arises quite often, for example, in the analysis of modern biological data or web-based advertising data. In general, we will let x ij represent the value of the j th variable for the i th observation, where i = 1 , 2 , , n and j = 1 , 2 , , p . Throughout this book, i will be used to index the samples or observations (from 1 to n ) and j will be used to index the variables (from 1 to p ). We let X denote an n × p matrix whose ( i, j ) th element is x ij . That is, X =      x 11 x 12 x 1 p x 21 x 22 x 2 p x n 1 x n 2 x np      . For readers who are unfamiliar with matrices, it is useful to visualize X as a spreadsheet of numbers with n rows and p columns. At times we will be interested in the rows of X , which we write as x 1 , x 2 , , x n . Here x i is a vector of length p , containing the p variable measurements for the i th observation. That is, x i =      x i 1 x i 2 x ip      . (1.1) (Vectors are by default represented as columns.) For example, for the Wage data, x i is a vector of length 11, consisting of year , age , race , and other values for the i th individual. At other times we will instead be interested in the columns of X , which we write as x 1 , x 2 , , x p . Each is a vector of length n . That is, x j =      x 1 j x 2 j x nj      . For example, for the Wage data, x 1 contains the n = 3 , 000 values for year",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Each is a vector of length n . That is, x j =      x 1 j x 2 j x nj      . For example, for the Wage data, x 1 contains the n = 3 , 000 values for year . Using this notation, the matrix X can be written as X = ' x 1 x 2 · · · x p ( , or X =      x T 1 x T 2 x T n      . The T notation denotes the transpose of a matrix or vector. So, for example, X T =      x 11 x 21 x n 1 x 12 x 22 x n 2 x 1 p x 2 p x np      , while x T i = ' x i 1 x i 2 · · · x ip ( . We use y i to denote the i th observation of the variable on which we wish to make predictions, such as wage . Hence, we write the set of all n observations in vector form as y =      y 1 y 2 y n      . Then our observed data consists of { ( x 1 , y 1 ) , ( x 2 , y 2 ) , , ( x n , y n ) } , where each x i is a vector of length p . (If p = 1 , then x i is simply a scalar.) In this text, a vector of length n will always be denoted in lower case bold ; e.g. a =      a 1 a 2 a n      . However, vectors that are not of length n (such as feature vectors of length p , as in ( 1.1 )) will be denoted in lower case normal font , e.g. a . Scalars will also be denoted in lower case normal font , e.g. a . In the rare cases in which these two uses for lower case normal font lead to ambiguity, we will clarify which use is intended. Matrices will be denoted using bold capitals , such as A . Random variables will be denoted using capital normal font , e.g. A , regardless of their dimensions. Occasionally we will want to indicate the dimension of a particular object. To indicate that an object is a scalar, we will use the notation a ∈ R . To indicate that it is a vector of length k , we will use a ∈ R k (or a ∈ R n if it is of length n ). We will indicate that an object is an r × s matrix using A ∈ R r × s . We have avoided using matrix algebra whenever possible. However, in a few instances it becomes too cumbersome to avoid it entirely. In these rare instances it is important to understand the concept of multiplying two matrices",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, in a few instances it becomes too cumbersome to avoid it entirely. In these rare instances it is important to understand the concept of multiplying two matrices. Suppose that A ∈ R r × d and B ∈ R d × s . Then the product of A and B is denoted AB . The ( i, j ) th element of AB is computed by multiplying each element of the i th row of A by the corresponding element of the j th column of B . That is, ( AB ) ij = ) d k =1 a ik b kj . As an example, consider A = * 1 2 3 4 + and B = * 5 6 7 8 + . Then AB = * 1 2 3 4 + * 5 6 7 8 + = * 1 × 5 + 2 × 7 1 × 6 + 2 × 8 3 × 5 + 4 × 7 3 × 6 + 4 × 8 + = * 19 22 43 50 + . Note that this operation produces an r × s matrix. It is only possible to compute AB if the number of columns of A is the same as the number of rows of B . Organization of This Book Chapter 2 introduces the basic terminology and concepts behind statistcal learning. This chapter also presents the K -nearest neighbor classifier, a very simple method that works surprisingly well on many problems. Chaters 3 and 4 cover classical linear methods for regression and classification. In particular, Chapter 3 reviews linear regression , the fundamental staring point for all regression methods. In Chapter 4 we discuss two of the most important classical classification methods, logistic regression and liear discriminant analysis . A central problem in all statistical learning situations involves choosing the best method for a given application. Hence, in Chapter 5 we intrduce cross-validation and the bootstrap , which can be used to estimate the accuracy of a number of different methods in order to choose the best one. Much of the recent research in statistical learning has concentrated on non-linear methods. However, linear methods often have advantages over their non-linear competitors in terms of interpretability and sometimes also accuracy. Hence, in Chapter 6 we consider a host of linear methods, both classical and more modern, which offer potential improvements over stadard linear regression",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Hence, in Chapter 6 we consider a host of linear methods, both classical and more modern, which offer potential improvements over stadard linear regression. These include stepwise selection , ridge regression , principal components regression , and the lasso . The remaining chapters move into the world of non-linear statistical learning. We first introduce in Chapter 7 a number of non-linear metods that work well for problems with a single input variable. We then show how these methods can be used to fit non-linear additive models for which there is more than one input. In Chapter 8 , we investigate tree -based methods, including bagging , boosting , and random forests . Support vector machines , a set of approaches for performing both linear and non-linear classification, are discussed in Chapter 9 . We cover deep learning , an aproach for non-linear regression and classification that has received a lot of attention in recent years, in Chapter 10 . Chapter 11 explores survival analysis , a regression approach that is specialized to the setting in which the output variable is censored , i.e. not fully observed. In Chapter 12 , we consider the unsupervised setting in which we have input variables but no output variable. In particular, we present princpal components analysis , K -means clustering , and hierarchical clustering . Finally, in Chapter 13 we cover the very important topic of multiple hpothesis testing. At the end of each chapter, we present one or more Python lab sections in which we systematically work through applications of the various metods discussed in that chapter. These labs demonstrate the strengths and weaknesses of the various approaches, and also provide a useful reference for the syntax required to implement the various methods. The reader may choose to work through the labs at their own pace, or the labs may be the focus of group sessions as part of a classroom environment",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The reader may choose to work through the labs at their own pace, or the labs may be the focus of group sessions as part of a classroom environment. Within each Python lab, we present the results that we obtained when we performed the lab at the time of writing this book. However, new versions of Python are continuously released, and over time, the packages called in the labs will be updated. Therefore, in the future, it is possible that the results shown in Name Description Auto Gas mileage, horsepower, and other information for cars. Bikeshare Hourly usage of a bike sharing program in Washington, DC. Boston Housing values and other information about Boston census tracts. BrainCancer Survival times for patients diagnosed with brain cancer. Caravan Information about individuals offered caravan insurance. Carseats Information about car seat sales in 400 stores. College Demographic characteristics, tuition, and more for USA colleges. Credit Information about credit card debt for 400 customers. Default Customer default records for a credit card company. Fund Returns of 2,000 hedge fund managers over 50 months. Hitters Records and salaries for baseball players. Khan Gene expression measurements for four cancer types. NCI60 Gene expression measurements for 64 cancer cell lines. NYSE Returns, volatility, and volume for the New York Stock Exchange. OJ Sales information for Citrus Hill and Minute Maid orange juice. Portfolio Past values of financial assets, for use in portfolio allocation. Publication Time to publication for 244 clinical trials. Smarket Daily percentage returns for S&P 500 over a 5-year period. USArrests Crime statistics per 100,000 residents in 50 states of USA. Wage Income survey data for men in central Atlantic region of USA. Weekly 1,089 weekly st ock market returns for 21 years. TABLE 1.1. A list of data sets needed to perform the labs and exercises in this textbook",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Weekly 1,089 weekly st ock market returns for 21 years. TABLE 1.1. A list of data sets needed to perform the labs and exercises in this textbook. All data sets are available in the ISLP package, with the exception of USArrests , which is part of the base R distribution, but accessible from Python . the lab sections may no longer correspond precisely to the results obtained by the reader who performs the labs. As necessary, we will post updates to the labs on the book website. We use the symbol to denote sections or exercises that contain more challenging concepts. These can be easily skipped by readers who do not wish to delve as deeply into the material, or who lack the mathematical background. Data Sets Used in Labs and Exercises In this textbook, we illustrate statistical learning methods using applictions from marketing, finance, biology, and other areas. The ISLP package contains a number of data sets that are required in order to perform the labs and exercises associated with this book. One other data set is part of the base R distribution (the USArrests data), and we show how to access it from Python in Section 12.5.1 . Table 1.1 contains a summary of the data sets required to perform the labs and exercises. A couple of these data sets are also available as text files on the book website, for use in Chapter 2 . Book Website The website for this book is located at www.statlearning.com It contains a number of resources, including the Python package associated with this book, and some additional data sets. Acknowledgements A few of the plots in this book were taken from ESL: Figures 6.7 , 8.3 , and 12.14 . All other plots were produced for the R version of ISL, except for Figure 13.10 which differs because of the Python software supporting the plot. 2 Statistical Learning 2.1 What Is Statistical Learning? In order to motivate our study of statistical learning, we begin with a simple example",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 2 Statistical Learning 2.1 What Is Statistical Learning? In order to motivate our study of statistical learning, we begin with a simple example. Suppose that we are statistical consultants hired by a client to investigate the association between advertising and sales of a particular product. The Advertising data set consists of the sales of that product in 200 different markets, along with advertising budgets for the product in each of those markets for three different media: TV , radio , and newspaper . The data are displayed in Figure 2.1 . It is not possible for our client to directly increase sales of the product. On the other hand, they can control the advertising expenditure in each of the three media. Therefore, if we determine that there is an association between advertising and sales, then we can instruct our client to adjust advertising budgets, thereby indirectly increasing sales. In other words, our goal is to develop an accurate model that can be used to predict sales on the basis of the three media budgets. In this setting, the advertising budgets are input variables while sales input variable is an output variable . The input variables are typically denoted using the output variable symbol X , with a subscript to distinguish them. So X 1 might be the TV budget, X 2 the radio budget, and X 3 the newspaper budget. The inputs go by different names, such as predictors , independent variables , features , predictor independent variable feature or sometimes just variables . The output variable—in this case, sales —is variable often called the response or dependent variable , and is typically denoted response dependent variable using the symbol Y . Throughout this book, we will use all of these terms interchangeably. More generally, suppose that we observe a quantitative response Y and p different predictors, X 1 , X 2 , , X p . We assume that there is some relationship between Y and X = ( X 1 , X 2 , , X p ) , which can be written in the very general form Y = f ( X ) + ε. (2.1) 15",
    "chunk_id": "an_introduction_to_statistical_learning_page-1-14.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "0 500 1000 1500 2000 2500 0 20000 40000 60000 Balance Income No Yes 0 500 1000 1500 2000 2500 Default Balance No Yes 0 20000 40000 60000 Default Income FIGURE 4.1. The Default data set. Left: The annual incomes and monthly credit card balances of a number of individuals. The individuals who defaulted on their credit card payments are shown in orange, and those who did not are shown in blue. Center: Boxplots of balance as a function of default status. Right: Boxplots of income as a function of default status. epileptic seizure . We could consider encoding these values as a quantittive response variable, Y , as follows: Y =      1 if stroke ; 2 if drug overdose ; 3 if epileptic seizure . Using this coding, least squares could be used to fit a linear regression model to predict Y on the basis of a set of predictors X 1 , , X p . Unfortunately, this coding implies an ordering on the outcomes, putting drug overdose in between stroke and epileptic seizure , and insisting that the difference between stroke and drug overdose is the same as the difference between drug overdose and epileptic seizure . In practice there is no particular reason that this needs to be the case. For instance, one could choose an equally reasonable coding, Y =      1 if epileptic seizure ; 2 if stroke ; 3 if drug overdose , which would imply a totally different relationship among the three condtions. Each of these codings would produce fundamentally different linear models that would ultimately lead to different sets of predictions on test observations. If the response variable’s values did take on a natural ordering, such as mild , moderate , and severe , and we felt the gap between mild and moderate was similar to the gap between moderate and severe, then a 1, 2, 3 coding would be reasonable. Unfortunately, in general there is no natural way to convert a qualitative response variable with more than two levels into a quantitative response that is ready for linear regression",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Unfortunately, in general there is no natural way to convert a qualitative response variable with more than two levels into a quantitative response that is ready for linear regression. For a binary (two level) qualitative response, the situation is better. For binary instance, perhaps there are only two possibilities for the patient’s medical condition: stroke and drug overdose . We could then potentially use the dummy variable approach from Section 3.3.1 to code the response as follows: Y = = 0 if stroke ; 1 if drug overdose . We could then fit a linear regression to this binary response, and predict drug overdose if ˆ Y > 0 . 5 and stroke otherwise. In the binary case it is not hard to show that even if we flip the above coding, linear regression will produce the same final predictions. For a binary response with a 0/1 coding as above, regression by least squares is not completely unreasonable: it can be shown that the X ˆ β otained using linear regression is in fact an estimate of Pr( drug overdose | X ) in this special case. However, if we use linear regression, some of our etimates might be outside the [0 , 1] interval (see Figure 4.2 ), making them hard to interpret as probabilities! Nevertheless, the predictions provide an ordering and can be interpreted as crude probability estimates. Curiously, it turns out that the classifications that we get if we use linear regression to predict a binary response will be the same as for the linear discriminant analysis (LDA) procedure we discuss in Section 4.4 . To summarize, there are at least two reasons not to perform classifiction using a regression method: (a) a regression method cannot accommdate a qualitative response with more than two classes; (b) a regression method will not provide meaningful estimates of Pr( Y | X ) , even with just two classes. Thus, it is preferable to use a classification method that is truly suited for qualitative response values",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Thus, it is preferable to use a classification method that is truly suited for qualitative response values. In the next section, we present logistic regression, which is well-suited for the case of a binary qualittive response; in later sections we will cover classification methods that are appropriate when the qualitative response has two or more classes. 4.3 Logistic Regression Consider again the Default data set, where the response default falls into one of two categories, Yes or No . Rather than modeling this response Y directly, logistic regression models the probability that Y belongs to a paticular category. For the Default data, logistic regression models the probability of default. For example, the probability of default given balance can be written as Pr( default = Yes | balance ) . The values of Pr( default = Yes | balance ) , which we abbreviate p ( balance ) , will range between 0 and 1. Then for any given value of balance , a prediction can be made for default",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For example, one might predict default = Yes 0 500 1000 1500 2000 2500 0.0 0.2 0.4 0.6 0.8 1.0 Balance Probability of Default | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | || | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | ||| | | | ||| | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || ||| | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| || | | | | | | | | || | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | || | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | || | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | || | | | | || | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | 0 500 1000 1500 2000 2500 0.0 0.2 0.4 0.6 0.8 1.0 Balance Probability of Default | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | || | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | ||| | | | ||| | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || ||| | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | || | | | | | | | | | | | | | | | | | | | | ||",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | || | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | || | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_19"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | || | | | | || | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_20"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_21"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | || | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_22"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_23"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_24"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | || | | || || | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | FIGURE 4.2",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_25"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Classification using the Default data. Left: Estimated probability of default using linear regression. Some estimated probabilities are negative! The orange ticks indicate the 0/1 values coded for default ( No or Yes ). Right: Predicted probabilities of default using logistic regression. All probabilities lie between 0 and 1 . for any individual for whom p ( balance ) > 0 . 5 . Alternatively, if a company wishes to be conservative in predicting individuals who are at risk for dfault, then they may choose to use a lower threshold, such as p ( balance ) > 0 . 1 . 4.3.1 The Logistic Model How should we model the relationship between p ( X ) = Pr( Y = 1 | X ) and X ? (For convenience we are using the generic 0/1 coding for the response.) In Section 4.2 we considered using a linear regression model to represent these probabilities: p ( X ) = β 0 + β 1 X. (4.1) If we use this approach to predict default = Yes using balance , then we obtain the model shown in the left-hand panel of Figure 4.2 . Here we see the problem with this approach: for balances close to zero we predict a negative probability of default; if we were to predict for very large balances, we would get values bigger than 1. These predictions are not sensible, since of course the true probability of default, regardless of credit card balance, must fall between 0 and 1 . This problem is not unique to the credit default data. Any time a straight line is fit to a binary response that is coded as 0 or 1 , in principle we can always predict p ( X ) < 0 for some values of X and p ( X ) > 1 for others (unless the range of X is limited). To avoid this problem, we must model p ( X ) using a function that gives outputs between 0 and 1 for all values of X . Many functions meet this description. In logistic regression, we use the logistic function , logistic function p ( X ) = e β 0 + β 1 X 1 + e β 0 + β 1 X . (4.2) To fit the model ( 4.2 ), we use a method called maximum likelihood , which maximum likelihood we discuss in the next section",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_26"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (4.2) To fit the model ( 4.2 ), we use a method called maximum likelihood , which maximum likelihood we discuss in the next section. The right-hand panel of Figure 4.2 illustrates the fit of the logistic regression model to the Default data. Notice that for low balances we now predict the probability of default as close to, but never below, zero. Likewise, for high balances we predict a default probability close to, but never above, one. The logistic function will always produce an S-shaped curve of this form, and so regardless of the value of X , we will obtain a sensible prediction. We also see that the logistic model is better able to capture the range of probabilities than is the linear regression model in the left-hand plot. The average fitted probability in both cases is 0.0333 (averaged over the training data), which is the same as the overall proportion of defaulters in the data set. After a bit of manipulation of ( 4.2 ), we find that p ( X ) 1 − p ( X ) = e β 0 + β 1 X . (4.3) The quantity p ( X ) / [1 − p ( X )] is called the odds , and can take on any value odds between 0 and ∞ . Values of the odds close to 0 and ∞ indicate very low and very high probabilities of default, respectively. For example, on average 1 in 5 people with an odds of 1 / 4 will default, since p ( X ) = 0 . 2 implies an odds of 0 . 2 1 − 0 . 2 = 1 / 4 . Likewise, on average nine out of every ten people with an odds of 9 will default, since p ( X ) = 0 . 9 implies an odds of 0 . 9 1 − 0 . 9 = 9 . Odds are traditionally used instead of probabilities in horse-racing, since they relate more naturally to the correct betting strategy. By taking the logarithm of both sides of ( 4.3 ), we arrive at log * p ( X ) 1 − p ( X ) + = β 0 + β 1 X. (4.4) The left-hand side is called the log odds or logit . We see that the logistic log odds logit regression model ( 4.2 ) has a logit that is linear in X . Recall from Chapter 3 that in a linear regression model, β 1 gives the average change in Y associated with a one-unit increase in X",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_27"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Recall from Chapter 3 that in a linear regression model, β 1 gives the average change in Y associated with a one-unit increase in X . By contrast, in a logistic regression model, increasing X by one unit changes the log odds by β 1 ( 4.4 ). Equivalently, it multiplies the odds by e β 1 ( 4.3 ). However, because the relationship between p ( X ) and X in ( 4.2 ) is not a straight line, β 1 does not correspond to the change in p ( X ) associated with a one-unit increase in X . The amount that p ( X ) changes due to a one-unit change in X depends on the current value of X . But regardless of the value of X , if β 1 is positive then increasing X will be associated with increasing p ( X ) , and if β 1 is negative then increasing X will be associated with decreasing p ( X ) . The fact that there is not a straight-line relationship between p ( X ) and X , and the fact that the rate of change in p ( X ) per unit change in X depends on the current value of X , can also be seen by inspection of the right-hand panel of Figure 4.2 . 4.3.2 Estimating the Regression Coefficients The coefficients β 0 and β 1 in ( 4.2 ) are unknown, and must be estimated based on the available training data. In Chapter 3 , we used the least squares approach to estimate the unknown linear regression coefficients. Although we could use (non-linear) least squares to fit the model ( 4.4 ), the more general method of maximum likelihood is preferred, since it has better sttistical properties. The basic intuition behind using maximum likelihood to fit a logistic regression model is as follows: we seek estimates for β 0 and β 1 such that the predicted probability ˆ p ( x i ) of default for each individual, using ( 4.2 ), corresponds as closely as possible to the individual’s observed default status. In other words, we try to find ˆ β 0 and ˆ β 1 such that plugging these estimates into the model for p ( X ) , given in ( 4.2 ), yields a number close to one for all individuals who defaulted, and a number close to zero for all individuals who did not",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_28"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This intuition can be formalized using a mathematical equation called a likelihood function : likelihood function l ( β 0 , β 1 ) = E i : y i =1 p ( x i ) E i ′ : y i ′ =0 (1 − p ( x i ′ )) . (4.5) The estimates ˆ β 0 and ˆ β 1 are chosen to maximize this likelihood function. Maximum likelihood is a very general approach that is used to fit many of the non-linear models that we examine throughout this book. In the linear regression setting, the least squares approach is in fact a special case of maximum likelihood. The mathematical details of maximum likelihood are beyond the scope of this book. However, in general, logistic regression and other models can be easily fit using statistical software such as R , and so we do not need to concern ourselves with the details of the maximum likelihood fitting procedure. Table 4.1 shows the coefficient estimates and related information that result from fitting a logistic regression model on the Default data in order to predict the probability of default = Yes using balance . We see that ˆ β 1 = 0 . 0055 ; this indicates that an increase in balance is associated with an increase in the probability of default . To be precise, a one-unit increase in balance is associated with an increase in the log odds of default by 0 . 0055 units. Many aspects of the logistic regression output shown in Table 4.1 are similar to the linear regression output of Chapter 3 . For example, we can measure the accuracy of the coefficient estimates by computing their stadard errors. The z -statistic in Table 4.1 plays the same role as the t -statistic in the linear regression output, for example in Table 3.1 on page 77 . For instance, the z -statistic associated with β 1 is equal to ˆ β 1 / SE( ˆ β 1 ) , and so a large (absolute) value of the z -statistic indicates evidence against the null hypothesis H 0 : β 1 = 0 . This null hypothesis implies that p ( X ) = e β 0 1+ e β 0 : in other words, that the probability of default does not depend on balance",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_29"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This null hypothesis implies that p ( X ) = e β 0 1+ e β 0 : in other words, that the probability of default does not depend on balance . Since the p -value associated with balance in Table 4.1 is tiny, we can reject H 0 . In other words, we conclude that there is indeed an association between balance and probability of default . The estimated intercept in Table 4.1 is typically not of interest; its main purpose is to adjust the average fitted probabilities to the proportion of ones in the data (in this case, the overall default rate). 4.3.3 Making Predictions Once the coefficients have been estimated, we can compute the probability of default for any given credit card balance. For example, using the coeffcient estimates given in Table 4.1 , we predict that the default probability Coef fi cient Std. error z -statistic p -value Intercept − 10.6513 0.3612 − 29.5 < 0.0001 balance 0.0055 0.0002 24.9 < 0.0001 TABLE 4.1. For the Default data, estimated coefficients of the logistic regresion model that predicts the probability of default using balance . A one-unit increase in balance is associated with an increase in the log odds of default by 0 . 0055 units. Coef fi cient Std. error z -statistic p -value Intercept − 3.5041 0.0707 − 49.55 < 0.0001 student[Yes] 0.4049 0.1150 3.52 0.0004 TABLE 4.2. For the Default data, estimated coefficients of the logistic regression model that predicts the probability of default using student status. Student status is encoded as a dummy variable, with a value of 1 for a student and a value of 0 for a non-student, and represented by the variable student[Yes] in the table. for an individual with a balance of $1 , 000 is ˆ p ( X ) = e ˆ β 0 + ˆ β 1 X 1 + e ˆ β 0 + ˆ β 1 X = e − 10 . 6513+0 . 0055 × 1 , 000 1 + e − 10 . 6513+0 . 0055 × 1 , 000 = 0 . 00576 , which is below 1 %. In contrast, the predicted probability of default for an individual with a balance of $2 , 000 is much higher, and equals 0 . 586 or 58 . 6 %",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_30"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 0055 × 1 , 000 = 0 . 00576 , which is below 1 %. In contrast, the predicted probability of default for an individual with a balance of $2 , 000 is much higher, and equals 0 . 586 or 58 . 6 %. One can use qualitative predictors with the logistic regression model uing the dummy variable approach from Section 3.3.1 . As an example, the Default data set contains the qualitative variable student . To fit a model that uses student status as a predictor variable, we simply create a dummy variable that takes on a value of 1 for students and 0 for non-students. The logistic regression model that results from predicting probability of default from student status can be seen in Table 4.2 . The coefficient associated with the dummy variable is positive, and the associated p -value is statistcally significant. This indicates that students tend to have higher default probabilities than non-students: 6 Pr( default = Yes | student = Yes ) = e − 3 . 5041+0 . 4049 × 1 1 + e − 3 . 5041+0 . 4049 × 1 = 0 . 0431 , 6 Pr( default = Yes | student = No ) = e − 3 . 5041+0 . 4049 × 0 1 + e − 3 . 5041+0 . 4049 × 0 = 0 . 0292 . 4.3.4 Multiple Logistic Regression We now consider the problem of predicting a binary response using multiple predictors. By analogy with the extension from simple to multiple linear regression in Chapter 3 , we can generalize ( 4.4 ) as follows: log * p ( X ) 1 − p ( X ) + = β 0 + β 1 X 1 + · · · + β p X p , (4.6) where X = ( X 1 , , X p ) are p predictors. Equation 4.6 can be rewritten as p ( X ) = e β 0 + β 1 X 1 + ··· + β p X p 1 + e β 0 + β 1 X 1 + ··· + β p X p . (4.7) Coef fi cient Std. error z -statistic p -value Intercept − 10.8690 0.4923 − 22.08 < 0.0001 balance 0.0057 0.0002 24.74 < 0.0001 income 0.0030 0.0082 0.37 0.7115 student[Yes] − 0.6468 0.2362 − 2.74 0.0062 TABLE 4.3. For the Default data, estimated coefficients of the logistic regression model that predicts the probability of default using balance , income , and student status",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_31"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For the Default data, estimated coefficients of the logistic regression model that predicts the probability of default using balance , income , and student status. Student status is encoded as a dummy variable student[Yes] , with a value of 1 for a student and a value of 0 for a non-student. In fitting this model, income was measured in thousands of dollars. Just as in Section 4.3.2 , we use the maximum likelihood method to estimate β 0 , β 1 , , β p . Table 4.3 shows the coefficient estimates for a logistic regression model that uses balance , income (in thousands of dollars), and student status to predict probability of default . There is a surprising result here. The p - values associated with balance and the dummy variable for student status are very small, indicating that each of these variables is associated with the probability of default . However, the coefficient for the dummy variable is negative, indicating that students are less likely to default than nostudents. In contrast, the coefficient for the dummy variable is positive in Table 4.2 . How is it possible for student status to be associated with an increase in probability of default in Table 4.2 and a decrease in probability of default in Table 4.3 ? The left-hand panel of Figure 4.3 provides a grapical illustration of this apparent paradox. The orange and blue solid lines show the average default rates for students and non-students, respectively, as a function of credit card balance. The negative coefficient for student in the multiple logistic regression indicates that for a fixed value of balance and income , a student is less likely to default than a non-student. Indeed, we observe from the left-hand panel of Figure 4.3 that the student default rate is at or below that of the non-student default rate for every value of balance",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_32"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Indeed, we observe from the left-hand panel of Figure 4.3 that the student default rate is at or below that of the non-student default rate for every value of balance . But the horizontal broken lines near the base of the plot, which show the default rates for students and non-students averaged over all vaues of balance and income , suggest the opposite effect: the overall student default rate is higher than the non-student default rate. Consequently, there is a positive coefficient for student in the single variable logistic regression output shown in Table 4.2 . The right-hand panel of Figure 4.3 provides an explanation for this dicrepancy. The variables student and balance are correlated. Students tend to hold higher levels of debt, which is in turn associated with higher proability of default. In other words, students are more likely to have large credit card balances, which, as we know from the left-hand panel of Fiure 4.3 , tend to be associated with high default rates. Thus, even though an individual student with a given credit card balance will tend to have a lower probability of default than a non-student with the same credit card balance, the fact that students on the whole tend to have higher credit card balances means that overall, students tend to default at a higher rate than non-students. This is an important distinction for a credit card company that is trying to determine to whom they should offer credit. A student is riskier than a non-student if no information about the student’s credit card 500 1000 1500 2000 0.0 0.2 0.4 0.6 0.8 Credit Card Balance Default Rate No Yes 0 500 1000 1500 2000 2500 Student Status Credit Card Balance FIGURE 4.3. Confounding in the Default data. Left: Default rates are shown for students (orange) and non-students (blue). The solid lines display default rate as a function of balance , while the horizontal broken lines display the overall default rates. Right: Boxplots of balance for students (orange) and non-students (blue) are shown. balance is available",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_33"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Right: Boxplots of balance for students (orange) and non-students (blue) are shown. balance is available. However, that student is less risky than a non-student with the same credit card balance ! This simple example illustrates the dangers and subtleties associated with performing regressions involving only a single predictor when other predictors may also be relevant. As in the linear regression setting, the results obtained using one predictor may be quite different from those otained using multiple predictors, especially when there is correlation among the predictors. In general, the phenomenon seen in Figure 4.3 is known as confounding . confounding By substituting estimates for the regression coefficients from Table 4.3 into ( 4.7 ), we can make predictions. For example, a student with a credit card balance of $1 , 500 and an income of $40 , 000 has an estimated probbility of default of ˆ p ( X ) = e − 10 . 869+0 . 00574 × 1 , 500+0 . 003 × 40 − 0 . 6468 × 1 1 + e − 10 . 869+0 . 00574 × 1 , 500+0 . 003 × 40 − 0 . 6468 × 1 = 0 . 058 . (4.8) A non-student with the same balance and income has an estimated proability of default of ˆ p ( X ) = e − 10 . 869+0 . 00574 × 1 , 500+0 . 003 × 40 − 0 . 6468 × 0 1 + e − 10 . 869+0 . 00574 × 1 , 500+0 . 003 × 40 − 0 . 6468 × 0 = 0 . 105 . (4.9) (Here we multiply the income coefficient estimate from Table 4.3 by 40, rather than by 40,000, because in that table the model was fit with income measured in units of $1 , 000 .) 4.3.5 Multinomial Logistic Regression We sometimes wish to classify a response variable that has more than two classes. For example, in Section 4.2 we had three categories of medical codition in the emergency room: stroke , drug overdose , epileptic seizure . However, the logistic regression approach that we have seen in this section only allows for K = 2 classes for the response variable. It turns out that it is possible to extend the two-class logistic regression approach to the setting of K > 2 classes",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_34"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It turns out that it is possible to extend the two-class logistic regression approach to the setting of K > 2 classes. This extension is sometimes known as multinomial logistic regression . To do this, we first select a single multinomial logistic regression class to serve as the baseline ; without loss of generality, we select the K th class for this role. Then we replace the model ( 4.7 ) with the model Pr( Y = k | X = x ) = e β k 0 + β k 1 x 1 + ··· + β kp x p 1 + ) K − 1 l =1 e β l 0 + β l 1 x 1 + ··· + β lp x p (4.10) for k = 1 , , K − 1 , and Pr( Y = K | X = x ) = 1 1 + ) K − 1 l =1 e β l 0 + β l 1 x 1 + ··· + β lp x p . (4.11) It is not hard to show that for k = 1 , , K − 1 , log * Pr( Y = k | X = x ) Pr( Y = K | X = x ) + = β k 0 + β k 1 x 1 + · · · + β kp x p . (4.12) Notice that ( 4.12 ) is quite similar to ( 4.6 ). Equation 4.12 indicates that once again, the log odds between any pair of classes is linear in the features. It turns out that in ( 4.10 )–( 4.12 ), the decision to treat the K th class as the baseline is unimportant. For example, when classifying emergency room visits into stroke , drug overdose , and epileptic seizure , suppose that we fit two multinomial logistic regression models: one treating stroke as the baseline, another treating drug overdose as the baseline. The coefficient estimates will differ between the two fitted models due to the differing choice of baseline, but the fitted values (predictions), the log odds between any pair of classes, and the other key model outputs will remain the same. Nonetheless, interpretation of the coefficients in a multinomial logistic regression model must be done with care, since it is tied to the choice of baseline. For example, if we set epileptic seizure to be the baseline, then we can interpret β stroke 0 as the log odds of stroke versus epileptic seizure , given that x 1 = · · · = x p = 0 . Furthermore, a one-unit increase in X j is associated with a β stroke j increase in the log odds of stroke over epileptic seizure",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_35"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Furthermore, a one-unit increase in X j is associated with a β stroke j increase in the log odds of stroke over epileptic seizure . Stated another way, if X j increases by one unit, then Pr( Y = stroke | X = x ) Pr( Y = epileptic seizure | X = x ) increases by e β stroke j . We now briefly present an alternative coding for multinomial logistic regression, known as the softmax coding. The softmax coding is equivalent softmax to the coding just described in the sense that the fitted values, log odds between any pair of classes, and other key model outputs will remain the same, regardless of coding. But the softmax coding is used extensively in some areas of the machine learning literature (and will appear again in Chapter 10 ), so it is worth being aware of it. In the softmax coding, rather than selecting a baseline class, we treat all K classes symmetrically, and assume that for k = 1 , , K , Pr( Y = k | X = x ) = e β k 0 + β k 1 x 1 + ··· + β kp x p ) K l =1 e β l 0 + β l 1 x 1 + ··· + β lp x p . (4.13) Thus, rather than estimating coefficients for K − 1 classes, we actually estimate coefficients for all K classes. It is not hard to see that as a result of ( 4.13 ), the log odds ratio between the k th and k ′ th classes equals log % Pr( Y = k | X = x ) Pr( Y = k ′ | X = x ) & = ( β k 0 − β k ′ 0 ) + ( β k 1 − β k ′ 1 ) x 1 + · · · + ( β kp − β k ′ p ) x p . (4.14) 4.4 Generative Models for Classification Logistic regression involves directly modeling Pr( Y = k | X = x ) using the logistic function, given by ( 4.7 ) for the case of two response classes. In statistical jargon, we model the conditional distribution of the response Y , given the predictor(s) X . We now consider an alternative and less direct approach to estimating these probabilities. In this new approach, we model the distribution of the predictors X separately in each of the response classes (i.e. for each value of Y ). We then use Bayes’ theorem to flip these around into estimates for Pr( Y = k | X = x )",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_36"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". for each value of Y ). We then use Bayes’ theorem to flip these around into estimates for Pr( Y = k | X = x ) . When the distribution of X within each class is assumed to be normal, it turns out that the model is very similar in form to logistic regression. Why do we need another method, when we have logistic regression? There are several reasons: • When there is substantial separation between the two classes, the parameter estimates for the logistic regression model are surprisingly unstable. The methods that we consider in this section do not suffer from this problem. • If the distribution of the predictors X is approximately normal in each of the classes and the sample size is small, then the approaches in this section may be more accurate than logistic regression. • The methods in this section can be naturally extended to the case of more than two response classes. (In the case of more than two response classes, we can also use multinomial logistic regression from Section 4.3.5 .) Suppose that we wish to classify an observation into one of K classes, where K ≥ 2 . In other words, the qualitative response variable Y can take on K possible distinct and unordered values. Let π k represent the overall or prior probability that a randomly chosen observation comes from the prior k th class. Let f k ( X ) ≡ Pr( X | Y = k ) 1 denote the density function of X density function for an observation that comes from the k th class. In other words, f k ( x ) is relatively large if there is a high probability that an observation in the k th class has X ≈ x , and f k ( x ) is small if it is very unlikely that an observation in the k th class has X ≈ x . Then Bayes’ theorem states that Bayes’ theorem 1 Technically, this definition is only correct if X is a qualitative random variable. If X is quantitative, then f k ( x ) dx corresponds to the probability of X falling in a small region dx around x . Pr( Y = k | X = x ) = π k f k ( x ) ) K l =1 π l f l ( x )",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_37"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". If X is quantitative, then f k ( x ) dx corresponds to the probability of X falling in a small region dx around x . Pr( Y = k | X = x ) = π k f k ( x ) ) K l =1 π l f l ( x ) . (4.15) In accordance with our earlier notation, we will use the abbreviation p k ( x ) = Pr( Y = k | X = x ) ; this is the posterior probability that an observation posterior X = x belongs to the k th class. That is, it is the probability that the observation belongs to the k th class, given the predictor value for that observation. Equation 4.15 suggests that instead of directly computing the posterior probability p k ( x ) as in Section 4.3.1 , we can simply plug in estimates of π k and f k ( x ) into ( 4.15 ). In general, estimating π k is easy if we have a random sample from the population: we simply compute the fraction of the training observations that belong to the k th class. However, estimating the density function f k ( x ) is much more challenging. As we will see, to estimate f k ( x ) , we will typically have to make some simplifying assumptions. We know from Chapter 2 that the Bayes classifier, which classifies an observation x to the class for which p k ( x ) is largest, has the lowest possible error rate out of all classifiers. (Of course, this is only true if all of the terms in ( 4.15 ) are correctly specified.) Therefore, if we can find a way to estimate f k ( x ) , then we can plug it into ( 4.15 ) in order to approximate the Bayes classifier. In the following sections, we discuss three classifiers that use different estimates of f k ( x ) in ( 4.15 ) to approximate the Bayes classifier: linear dicriminant analysis, quadratic discriminant analysis, and naive Bayes . 4.4.1 Linear Discriminant Analysis for p = 1 For now, assume that p = 1 —that is, we have only one predictor. We would like to obtain an estimate for f k ( x ) that we can plug into ( 4.15 ) in order to estimate p k ( x ) . We will then classify an observation to the class for which p k ( x ) is greatest",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_38"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We would like to obtain an estimate for f k ( x ) that we can plug into ( 4.15 ) in order to estimate p k ( x ) . We will then classify an observation to the class for which p k ( x ) is greatest. To estimate f k ( x ) , we will first make some assumptions about its form. In particular, we assume that f k ( x ) is normal or Gaussian . In the onnormal Gaussian dimensional setting, the normal density takes the form f k ( x ) = 1 √ 2 πσ k exp * − 1 2 σ 2 k ( x − μ k ) 2 + , (4.16) where μ k and σ 2 k are the mean and variance parameters for the k th class. For now, let us further assume that σ 2 1 = · · · = σ 2 K : that is, there is a shared variance term across all K classes, which for simplicity we can denote by σ 2 . Plugging ( 4.16 ) into ( 4.15 ), we find that p k ( x ) = π k 1 √ 2 πσ exp ' − 1 2 σ 2 ( x − μ k ) 2 ( ) K l =1 π l 1 √ 2 πσ exp ' − 1 2 σ 2 ( x − μ l ) 2 ( . (4.17) (Note that in ( 4.17 ), π k denotes the prior probability that an observation belongs to the k th class, not to be confused with π ≈ 3 . 14159 , the matematical constant.) The Bayes classifier 2 involves assigning an observation 2 Recall that the Bayes classifier assigns an observation to the class for which p k ( x ) is largest. This is different from Bayes’ theorem in ( 4.15 ), which allows us to manipulate conditional distributions. −4 −2 0 2 4 −3 −2 −1 0 1 2 3 4 0 1 2 3 4 5 FIGURE 4.4. Left: Two one-dimensional normal density functions are shown. The dashed vertical line represents the Bayes decision boundary. Right: 20 obsevations were drawn from each of the two classes, and are shown as histograms. The Bayes decision boundary is again shown as a dashed vertical line. The solid vertical line represents the LDA decision boundary estimated from the training data. X = x to the class for which ( 4.17 ) is largest. Taking the log of ( 4.17 ) and rearranging the terms, it is not hard to show 3 that this is equivalent to assigning the observation to the class for which δ k ( x ) = x · μ k σ 2 − μ 2 k 2 σ 2 + log( π k ) (4.18) is largest",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_39"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For instance, if K = 2 and π 1 = π 2 , then the Bayes classifier assigns an observation to class 1 if 2 x ( μ 1 − μ 2 ) > μ 2 1 − μ 2 2 , and to class 2 otherwise. The Bayes decision boundary is the point for which δ 1 ( x ) = δ 2 ( x ) ; one can show that this amounts to x = μ 2 1 − μ 2 2 2( μ 1 − μ 2 ) = μ 1 + μ 2 2 . (4.19) An example is shown in the left-hand panel of Figure 4.4 . The two normal density functions that are displayed, f 1 ( x ) and f 2 ( x ) , represent two distinct classes. The mean and variance parameters for the two density functions are μ 1 = − 1 . 25 , μ 2 = 1 . 25 , and σ 2 1 = σ 2 2 = 1 . The two densities overlap, and so given that X = x , there is some uncertainty about the class to which the observation belongs. If we assume that an observation is equally likely to come from either class—that is, π 1 = π 2 = 0 . 5 —then by inspection of ( 4.19 ), we see that the Bayes classifier assigns the observation to class 1 if x < 0 and class 2 otherwise. Note that in this case, we can compute the Bayes classifier because we know that X is drawn from a Gaussian distribution within each class, and we know all of the parameters involved. In a real-life situation, we are not able to calculate the Bayes classifier. In practice, even if we are quite certain of our assumption that X is drawn from a Gaussian distribution within each class, to apply the Bayes classifier we still have to estimate the parameters μ 1 , , μ K , π 1 , , π K , and σ 2 . The linear discriminant analysis (LDA) method approximates the linear discriminant analysis Bayes classifier by plugging estimates for π k , μ k , and σ 2 into ( 4.18 ). In 3 See Exercise 2 at the end of this chapter. particular, the following estimates are used: ˆ μ k = 1 n k 0 i : y i = k x i ˆ σ 2 = 1 n − K K 0 k =1 0 i : y i = k ( x i − ˆ μ k ) 2 (4.20) where n is the total number of training observations, and n k is the number of training observations in the k th class",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_40"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The estimate for μ k is simply the average of all the training observations from the k th class, while ˆ σ 2 can be seen as a weighted average of the sample variances for each of the K classes. Sometimes we have knowledge of the class membership probabilties π 1 , , π K , which can be used directly. In the absence of any additional information, LDA estimates π k using the proportion of the training obsevations that belong to the k th class. In other words, ˆ π k = n k /n. (4.21) The LDA classifier plugs the estimates given in ( 4.20 ) and ( 4.21 ) into ( 4.18 ), and assigns an observation X = x to the class for which ˆ δ k ( x ) = x · ˆ μ k ˆ σ 2 − ˆ μ 2 k 2ˆ σ 2 + log(ˆ π k ) (4.22) is largest. The word linear in the classifier’s name stems from the fact that the discriminant functions ˆ δ k ( x ) in ( 4.22 ) are linear functions of x (as discriminant function opposed to a more complex function of x ). The right-hand panel of Figure 4.4 displays a histogram of a random sample of 20 observations from each class. To implement LDA, we began by estimating π k , μ k , and σ 2 using ( 4.20 ) and ( 4.21 ). We then computed the decision boundary, shown as a black solid line, that results from assigning an observation to the class for which ( 4.22 ) is largest. All points to the left of this line will be assigned to the green class, while points to the right of this line are assigned to the purple class. In this case, since n 1 = n 2 = 20 , we have ˆ π 1 = ˆ π 2 . As a result, the decision boundary corresponds to the midpoint between the sample means for the two classes, (ˆ μ 1 + ˆ μ 2 ) / 2 . The figure indicates that the LDA decision boundary is slightly to the left of the optimal Bayes decision boundary, which instead equals ( μ 1 + μ 2 ) / 2 = 0 . How well does the LDA classifier perform on this data? Since this is simulated data, we can generate a large number of test observations in order to compute the Bayes error rate and the LDA test error rate. These are 10 . 6 % and 11 . 1 %, respectively",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_41"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". These are 10 . 6 % and 11 . 1 %, respectively. In other words, the LDA classifier’s error rate is only 0 . 5 % above the smallest possible error rate! This indicates that LDA is performing pretty well on this data set. To reiterate, the LDA classifier results from assuming that the obsevations within each class come from a normal distribution with a classpecific mean and a common variance σ 2 , and plugging estimates for these parameters into the Bayes classifier. In Section 4.4.3 , we will consider a less stringent set of assumptions, by allowing the observations in the k th class to have a class-specific variance, σ 2 k . x 1 x 1 x 2 x 2 FIGURE 4.5. Two multivariate Gaussian density functions are shown, with p = 2 . Left: The two predictors are uncorrelated. Right: The two variables have a correlation of 0 . 7 . 4.4.2 Linear Discriminant Analysis for p > 1 We now extend the LDA classifier to the case of multiple predictors. To do this, we will assume that X = ( X 1 , X 2 , , X p ) is drawn from a multvariate Gaussian (or multivariate normal) distribution, with a class-specific multivariate Gaussian mean vector and a common covariance matrix. We begin with a brief review of this distribution. The multivariate Gaussian distribution assumes that each individual prdictor follows a one-dimensional normal distribution, as in ( 4.16 ), with some correlation between each pair of predictors. Two examples of multivariate Gaussian distributions with p = 2 are shown in Figure 4.5 . The height of the surface at any particular point represents the probability that both X 1 and X 2 fall in a small region around that point. In either panel, if the suface is cut along the X 1 axis or along the X 2 axis, the resulting cross-section will have the shape of a one-dimensional normal distribution. The left-hand panel of Figure 4.5 illustrates an example in which Var ( X 1 ) = Var ( X 2 ) and Cor ( X 1 , X 2 ) = 0 ; this surface has a characteristic bell shape",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_42"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The left-hand panel of Figure 4.5 illustrates an example in which Var ( X 1 ) = Var ( X 2 ) and Cor ( X 1 , X 2 ) = 0 ; this surface has a characteristic bell shape . However, the bell shape will be distorted if the predictors are correlated or have unequal variances, as is illustrated in the right-hand panel of Figure 4.5 . In this situation, the base of the bell will have an elliptical, rather than circular, shape. To indicate that a p -dimensional random variable X has a multvariate Gaussian distribution, we write X ∼ N ( μ, Σ ) . Here E( X ) = μ is the mean of X (a vector with p components), and Cov ( X ) = Σ is the p × p covariance matrix of X . Formally, the multivariate Gaussian density is defined as f ( x ) = 1 (2 π ) p/ 2 | Σ | 1 / 2 exp * − 1 2 ( x − μ ) T Σ − 1 ( x − μ ) + . (4.23) In the case of p > 1 predictors, the LDA classifier assumes that the observations in the k th class are drawn from a multivariate Gaussian ditribution N ( μ k , Σ ) , where μ k is a class-specific mean vector, and Σ is a covariance matrix that is common to all K classes. Plugging the density function for the k th class, f k ( X = x ) , into ( 4.15 ) and performing a little bit of algebra reveals that the Bayes classifier assigns an observation X = x −4 −2 0 2 4 −4 −2 0 2 4 −4 −2 0 2 4 −4 −2 0 2 4 X 1 X 1 X 2 X 2 FIGURE 4.6. An example with three classes. The observations from each class are drawn from a multivariate Gaussian distribution with p = 2 , with a class-spcific mean vector and a common covariance matrix. Left: Ellipses that contain 95 % of the probability for each of the three classes are shown. The dashed lines are the Bayes decision boundaries. Right: 20 observations were generated from each class, and the corresponding LDA decision boundaries are indicated using solid black lines. The Bayes decision boundaries are once again shown as dashed lines. to the class for which δ k ( x ) = x T Σ − 1 μ k − 1 2 μ T k Σ − 1 μ k + log π k (4.24) is largest. This is the vector/matrix version of ( 4.18 )",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_43"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". to the class for which δ k ( x ) = x T Σ − 1 μ k − 1 2 μ T k Σ − 1 μ k + log π k (4.24) is largest. This is the vector/matrix version of ( 4.18 ). An example is shown in the left-hand panel of Figure 4.6 . Three equallsized Gaussian classes are shown with class-specific mean vectors and a common covariance matrix. The three ellipses represent regions that cotain 95 % of the probability for each of the three classes. The dashed lines are the Bayes decision boundaries. In other words, they represent the set of values x for which δ k ( x ) = δ l ( x ) ; i.e. x T Σ − 1 μ k − 1 2 μ T k Σ − 1 μ k = x T Σ − 1 μ l − 1 2 μ T l Σ − 1 μ l (4.25) for k ̸ = l . (The log π k term from ( 4.24 ) has disappeared because each of the three classes has the same number of training observations; i.e. π k is the same for each class.) Note that there are three lines representing the Bayes decision boundaries because there are three pairs of classes among the three classes. That is, one Bayes decision boundary separates class 1 from class 2, one separates class 1 from class 3, and one separates class 2 from class 3. These three Bayes decision boundaries divide the predictor space into three regions. The Bayes classifier will classify an observation according to the region in which it is located. Once again, we need to estimate the unknown parameters μ 1 , , μ K , π 1 , , π K , and Σ ; the formulas are similar to those used in the ondimensional case, given in ( 4.20 ). To assign a new observation X = x , LDA plugs these estimates into ( 4.24 ) to obtain quantities ˆ δ k ( x ) , and clasifies to the class for which ˆ δ k ( x ) is largest. Note that in ( 4.24 ) δ k ( x ) is a linear function of x ; that is, the LDA decision rule depends on x only True default status No Yes Total Predicted No 9644 252 9896 default status Yes 23 81 104 Total 9667 333 10000 TABLE 4.4. A confusion matrix compares the LDA predictions to the true default statuses for the 10 , 000 training observations in the Default data set",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_44"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A confusion matrix compares the LDA predictions to the true default statuses for the 10 , 000 training observations in the Default data set. Elements on the diagonal of the matrix represent individuals whose default statuses were correctly predicted, while off-diagonal elements represent individuals that were misclassified. LDA made incorrect predictions for 23 individuals who did not default and for 252 individuals who did default. through a linear combination of its elements. As previously discussed, this is the reason for the word linear in LDA. In the right-hand panel of Figure 4.6 , 20 observations drawn from each of the three classes are displayed, and the resulting LDA decision boundaries are shown as solid black lines. Overall, the LDA decision boundaries are pretty close to the Bayes decision boundaries, shown again as dashed lines. The test error rates for the Bayes and LDA classifiers are 0 . 0746 and 0 . 0770 , respectively. This indicates that LDA is performing well on this data. We can perform LDA on the Default data in order to predict whether or not an individual will default on the basis of credit card balance and student status. 4 The LDA model fit to the 10 , 000 training samples results in a training error rate of 2 . 75 %. This sounds like a low error rate, but two caveats must be noted. • First of all, training error rates will usually be lower than test error rates, which are the real quantity of interest. In other words, we might expect this classifier to perform worse if we use it to predict whether or not a new set of individuals will default. The reason is that we specifically adjust the parameters of our model to do well on the training data. The higher the ratio of parameters p to number of samples n , the more we expect this overfitting to play a role. For overfitting these data we don’t expect this to be a problem, since p = 2 and n = 10 , 000 . • Second, since only 3",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_45"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For overfitting these data we don’t expect this to be a problem, since p = 2 and n = 10 , 000 . • Second, since only 3 . 33 % of the individuals in the training sample defaulted, a simple but useless classifier that always predicts that an individual will not default, regardless of his or her credit card balance and student status, will result in an error rate of 3 . 33 %. In other words, the trivial null classifier will achieve an error rate that null is only a bit higher than the LDA training set error rate. In practice, a binary classifier such as this one can make two types of errors: it can incorrectly assign an individual who defaults to the no default category, or it can incorrectly assign an individual who does not default to 4 The careful reader will notice that student status is qualitative — thus, the normality assumption made by LDA is clearly violated in this example! However, LDA is often remarkably robust to model violations, as this example shows. Naive Bayes, discussed in Section 4.4.4 , provides an alternative to LDA that does not assume normally distributed predictors. the default category. It is often of interest to determine which of these two types of errors are being made. A confusion matrix , shown for the Default confusion matrix data in Table 4.4 , is a convenient way to display this information. The table reveals that LDA predicted that a total of 104 people would default. Of these people, 81 actually defaulted and 23 did not. Hence only 23 out of 9 , 667 of the individuals who did not default were incorrectly labeled. This looks like a pretty low error rate! However, of the 333 individuals who defaulted, 252 (or 75 . 7 %) were missed by LDA. So while the overall error rate is low, the error rate among individuals who defaulted is very high. From the perspective of a credit card company that is trying to identify high-risk individuals, an error rate of 252 / 333 = 75 . 7 % among individuals who default may well be unacceptable",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_46"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". From the perspective of a credit card company that is trying to identify high-risk individuals, an error rate of 252 / 333 = 75 . 7 % among individuals who default may well be unacceptable. Class-specific performance is also important in medicine and biology, where the terms sensitivity and specificity characterize the performance of sensitivity specificity a classifier or screening test. In this case the sensitivity is the percenage of true defaulters that are identified; it equals 24.3 %. The specificity is the percentage of non-defaulters that are correctly identified; it equals (1 − 23 / 9667) = 99 . 8 %. Why does LDA do such a poor job of classifying the customers who dfault? In other words, why does it have such low sensitivity? As we have seen, LDA is trying to approximate the Bayes classifier, which has the loest total error rate out of all classifiers. That is, the Bayes classifier will yield the smallest possible total number of misclassified observations, rgardless of the class from which the errors stem. Some misclassifications will result from incorrectly assigning a customer who does not default to the default class, and others will result from incorrectly assigning a customer who defaults to the non-default class. In contrast, a credit card company might particularly wish to avoid incorrectly classifying an individual who will default, whereas incorrectly classifying an individual who will not dfault, though still to be avoided, is less problematic. We will now see that it is possible to modify LDA in order to develop a classifier that better meets the credit card company’s needs. The Bayes classifier works by assigning an observation to the class for which the posterior probability p k ( X ) is greatest. In the two-class case, this amounts to assigning an observation to the default class if Pr( default = Yes | X = x ) > 0 . 5",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_47"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In the two-class case, this amounts to assigning an observation to the default class if Pr( default = Yes | X = x ) > 0 . 5 . (4.26) Thus, the Bayes classifier, and by extension LDA, uses a threshold of 50 % for the posterior probability of default in order to assign an observation to the default class. However, if we are concerned about incorrectly prdicting the default status for individuals who default, then we can consider lowering this threshold. For instance, we might label any customer with a posterior probability of default above 20 % to the default class. In other words, instead of assigning an observation to the default class if ( 4.26 ) holds, we could instead assign an observation to this class if Pr( default = Yes | X = x ) > 0 . 2 . (4.27) The error rates that result from taking this approach are shown in Table 4.5 . Now LDA predicts that 430 individuals will default. Of the 333 individuals who default, LDA correctly predicts all but 138 , or 41 . 4 %. This is a vast True default status No Yes Total Predicted No 9432 138 9570 default status Yes 235 195 430 Total 9667 333 10000 TABLE 4.5. A confusion matrix compares the LDA predictions to the true default statuses for the 10 , 000 training observations in the Default data set, using a modified threshold value that predicts default for any individuals whose posterior default probability exceeds 20 %. 0.0 0.1 0.2 0.3 0.4 0.5 0.0 0.2 0.4 0.6 Threshold Error Rate FIGURE 4.7. For the Default data set, error rates are shown as a function of the threshold value for the posterior probability that is used to perform the assigment. The black solid line displays the overall error rate. The blue dashed line represents the fraction of defaulting customers that are incorrectly classified, and the orange dotted line indicates the fraction of errors among the non-defaulting customers. improvement over the error rate of 75 . 7 % that resulted from using the threshold of 50 %",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_48"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". improvement over the error rate of 75 . 7 % that resulted from using the threshold of 50 %. However, this improvement comes at a cost: now 235 individuals who do not default are incorrectly classified. As a result, the overall error rate has increased slightly to 3 . 73 %. But a credit card company may consider this slight increase in the total error rate to be a small price to pay for more accurate identification of individuals who do indeed default. Figure 4.7 illustrates the trade-off that results from modifying the thresold value for the posterior probability of default. Various error rates are shown as a function of the threshold value. Using a threshold of 0 . 5 , as in ( 4.26 ), minimizes the overall error rate, shown as a black solid line. This is to be expected, since the Bayes classifier uses a threshold of 0 . 5 and is known to have the lowest overall error rate. But when a threshold of 0 . 5 is used, the error rate among the individuals who default is quite high (blue dashed line). As the threshold is reduced, the error rate among individuals who default decreases steadily, but the error rate among the individuals who do not default increases. How can we decide which threshold value is best? Such a decision must be based on domain knowledge , such as detailed information about the costs associated with default. The ROC curve is a popular graphic for simultaneously displaying the ROC curve two types of errors for all possible thresholds. The name “ROC” is historic, and comes from communications theory. It is an acronym for receiver oerating characteristics . Figure 4.8 displays the ROC curve for the LDA classifier on the training data. The overall performance of a classifier, su ROC Curve False positive rate True positive rate 0.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0 FIGURE 4.8. A ROC curve for the LDA classifier on the Default data. It traces out two types of error as we vary the threshold value for the posterior probability of default. The actual thresholds are not shown",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_49"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A ROC curve for the LDA classifier on the Default data. It traces out two types of error as we vary the threshold value for the posterior probability of default. The actual thresholds are not shown. The true positive rate is the sensitivity: the fraction of defaulters that are correctly identified, using a given threshold value. The false positive rate is 1-specificity: the fraction of non-defaulters that we classify incorrectly as defaulters, using that same threshold value. The ideal ROC curve hugs the top left corner, indicating a high true positive rate and a low false positive rate. The dotted line represents the “no information” classifier; this is what we would expect if student status and credit card balance are not associated with probability of default. marized over all possible thresholds, is given by the area under the (ROC) curve (AUC). An ideal ROC curve will hug the top left corner, so the larger area under the (ROC) curve the AUC the better the classifier. For this data the AUC is 0 . 95 , which is close to the maximum of 1 . 0 , so would be considered very good. We expect a classifier that performs no better than chance to have an AUC of 0.5 (when evaluated on an independent test set not used in model training). ROC curves are useful for comparing different classifiers, since they take into account all possible thresholds. It turns out that the ROC curve for the logistic regression model of Section 4.3.4 fit to these data is virtually indistinguishable from this one for the LDA model, so we do not display it here. As we have seen above, varying the classifier threshold changes its true positive and false positive rate. These are also called the sensitivity and one sensitivity minus the specificity of our classifier. Since there is an almost bewildering specificity array of terms used in this context, we now give a summary. Table 4.6 shows the possible results when applying a classifier (or diagnostic test) to a population",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_50"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Table 4.6 shows the possible results when applying a classifier (or diagnostic test) to a population. To make the connection with the epidemiology literature, we think of “+” as the “disease” that we are trying to detect, and “ − ” as the “non-disease” state. To make the connection to the classical hypothesis testing literature, we think of “ − ” as the null hypothesis and “+” as the True class − or Null + or Non-null Total Predicted − or Null True Neg. (TN) False Neg. (FN) N ∗ class + or Non-null False Pos. (FP) True Pos. (TP) P ∗ Total N P TABLE 4.6. Possible results when applying a classifier or diagnostic test to a population. Name Def i nition Synonyms False Pos. rate FP / N Type I error, 1 − Specificity True Pos. rate TP / P 1 − Type II error, power, sensitivity, recall Pos. Pred. value TP / P ∗ Precision, 1 − false discovery proportion Neg. Pred. value TN / N ∗ TABLE 4.7. Important measures for classification and diagnostic testing, derived from quantities in Table 4.6 . alternative (non-null) hypothesis. In the context of the Default data, “+” indicates an individual who defaults, and “ − ” indicates one who does not. Table 4.7 lists many of the popular performance measures that are used in this context. The denominators for the false positive and true positive rates are the actual population counts in each class. In contrast, the denominators for the positive predictive value and the negative predictive value are the total predicted counts for each class. 4.4.3 Quadratic Discriminant Analysis As we have discussed, LDA assumes that the observations within each class are drawn from a multivariate Gaussian distribution with a class-specific mean vector and a covariance matrix that is common to all K classes. Quadratic discriminant analysis (QDA) provides an alternative approach",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_51"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Quadratic discriminant analysis (QDA) provides an alternative approach. quadratic discriminant analysis Like LDA, the QDA classifier results from assuming that the observations from each class are drawn from a Gaussian distribution, and plugging etimates for the parameters into Bayes’ theorem in order to perform prdiction. However, unlike LDA, QDA assumes that each class has its own covariance matrix. That is, it assumes that an observation from the k th class is of the form X ∼ N ( μ k , Σ k ) , where Σ k is a covariance matrix for the k th class. Under this assumption, the Bayes classifier assigns an obsevation X = x to the class for which δ k ( x ) = − 1 2 ( x − μ k ) T Σ − 1 k ( x − μ k ) − 1 2 log | Σ k | + log π k = − 1 2 x T Σ − 1 k x + x T Σ − 1 k μ k − 1 2 μ T k Σ − 1 k μ k − 1 2 log | Σ k | + log π k (4.28) is largest. So the QDA classifier involves plugging estimates for Σ k , μ k , and π k into ( 4.28 ), and then assigning an observation X = x to the class for which this quantity is largest. Unlike in ( 4.24 ), the quantity x appears as a quadratic function in ( 4.28 ). This is where QDA gets its name. Why does it matter whether or not we assume that the K classes share a common covariance matrix? In other words, why would one prefer LDA to −4 −2 0 2 4 −4 −3 −2 −1 0 1 2 −4 −2 0 2 4 −4 −3 −2 −1 0 1 2 X 1 X 1 X 2 X 2 FIGURE 4.9. Left: The Bayes (purple dashed), LDA (black dotted), and QDA (green solid) decision boundaries for a two-class problem with Σ 1 = Σ 2 . The shading indicates the QDA decision rule. Since the Bayes decision boundary is linear, it is more accurately approximated by LDA than by QDA. Right: Details are as given in the left-hand panel, except that Σ 1 ̸ = Σ 2 . Since the Bayes decision boundary is non-linear, it is more accurately approximated by QDA than by LDA. QDA, or vice-versa? The answer lies in the bias-variance trade-off. When there are p predictors, then estimating a covariance matrix requires estmating p ( p +1) / 2 parameters",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_52"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". QDA, or vice-versa? The answer lies in the bias-variance trade-off. When there are p predictors, then estimating a covariance matrix requires estmating p ( p +1) / 2 parameters. QDA estimates a separate covariance matrix for each class, for a total of Kp ( p +1) / 2 parameters. With 50 predictors this is some multiple of 1,275, which is a lot of parameters. By instead assuing that the K classes share a common covariance matrix, the LDA model becomes linear in x , which means there are Kp linear coefficients to estmate. Consequently, LDA is a much less flexible classifier than QDA, and so has substantially lower variance. This can potentially lead to improved prediction performance. But there is a trade-off: if LDA’s assumption that the K classes share a common covariance matrix is badly off, then LDA can suffer from high bias. Roughly speaking, LDA tends to be a better bet than QDA if there are relatively few training observations and so reducing variance is crucial. In contrast, QDA is recommended if the training set is very large, so that the variance of the classifier is not a major concern, or if the assumption of a common covariance matrix for the K classes is clearly untenable. Figure 4.9 illustrates the performances of LDA and QDA in two scenarios. In the left-hand panel, the two Gaussian classes have a common correltion of 0 . 7 between X 1 and X 2 . As a result, the Bayes decision boundary is linear and is accurately approximated by the LDA decision boundary. The QDA decision boundary is inferior, because it suffers from higher varance without a corresponding decrease in bias. In contrast, the right-hand panel displays a situation in which the orange class has a correlation of 0 . 7 between the variables and the blue class has a correlation of − 0 . 7 . Now the Bayes decision boundary is quadratic, and so QDA more accurately approximates this boundary than does LDA. 4.4.4 Naive Bayes In previous sections, we used Bayes’ theorem ( 4.15 ) to develop the LDA and QDA classifiers",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_53"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 4.4.4 Naive Bayes In previous sections, we used Bayes’ theorem ( 4.15 ) to develop the LDA and QDA classifiers. Here, we use Bayes’ theorem to motivate the popular naive Bayes classifier. naive Bayes Recall that Bayes’ theorem ( 4.15 ) provides an expression for the poterior probability p k ( x ) = Pr( Y = k | X = x ) in terms of π 1 , , π K and f 1 ( x ) , , f K ( x ) . To use ( 4.15 ) in practice, we need estimates for π 1 , , π K and f 1 ( x ) , , f K ( x ) . As we saw in previous sections, estimating the prior probabilities π 1 , , π K is typically straightforward: for instance, we can estimate ˆ π k as the proportion of training observations belonging to the k th class, for k = 1 , , K . However, estimating f 1 ( x ) , , f K ( x ) is more subtle. Recall that f k ( x ) is the p -dimensional density function for an observation in the k th class, for k = 1 , , K . In general, estimating a p -dimensional density function is challenging. In LDA, we make a very strong assumption that greatly siplifies the task: we assume that f k is the density function for a multivariate normal random variable with class-specific mean μ k , and shared covariance matrix Σ . By contrast, in QDA, we assume that f k is the density function for a multivariate normal random variable with class-specific mean μ k , and class-specific covariance matrix Σ k . By making these very strong assumtions, we are able to replace the very challenging problem of estimating K p -dimensional density functions with the much simpler problem of estimaing K p -dimensional mean vectors and one (in the case of LDA) or K (in the case of QDA) ( p × p ) -dimensional covariance matrices. The naive Bayes classifier takes a different tack for estimating f 1 ( x ) , , f K ( x ) . Instead of assuming that these functions belong to a particular family of distributions (e.g. multivariate normal), we instead make a single assumption: Within the k th class, the p predictors are independent",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_54"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". multivariate normal), we instead make a single assumption: Within the k th class, the p predictors are independent. Stated mathematically, this assumption means that for k = 1 , , K , f k ( x ) = f k 1 ( x 1 ) × f k 2 ( x 2 ) × · · · × f kp ( x p ) , (4.29) where f kj is the density function of the j th predictor among observations in the k th class. Why is this assumption so powerful? Essentially, estimating a p -dimesional density function is challenging because we must consider not only the marginal distribution of each predictor — that is, the distribution of marginal distribution each predictor on its own — but also the joint distribution of the predictors joint distribution — that is, the association between the different predictors. In the case of a multivariate normal distribution, the association between the different predictors is summarized by the off-diagonal elements of the covariance matrix. However, in general, this association can be very hard to charaterize, and exceedingly challenging to estimate. But by assuming that the p covariates are independent within each class, we completely eliminate the need to worry about the association between the p predictors, because we have simply assumed that there is no association between the predictors! Do we really believe the naive Bayes assumption that the p covariates are independent within each class? In most settings, we do not. But even though this modeling assumption is made for convenience, it often leads to pretty decent results, especially in settings where n is not large enough reltive to p for us to effectively estimate the joint distribution of the predictors within each class. In fact, since estimating a joint distribution requires such a huge amount of data, naive Bayes is a good choice in a wide range of setings. Essentially, the naive Bayes assumption introduces some bias, but reduces variance, leading to a classifier that works quite well in practice as a result of the bias-variance trade-off",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_55"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Essentially, the naive Bayes assumption introduces some bias, but reduces variance, leading to a classifier that works quite well in practice as a result of the bias-variance trade-off. Once we have made the naive Bayes assumption, we can plug ( 4.29 ) into ( 4.15 ) to obtain an expression for the posterior probability, Pr( Y = k | X = x ) = π k × f k 1 ( x 1 ) × f k 2 ( x 2 ) × · · · × f kp ( x p ) ) K l =1 π l × f l 1 ( x 1 ) × f l 2 ( x 2 ) × · · · × f lp ( x p ) (4.30) for k = 1 , , K . To estimate the one-dimensional density function f kj using training data x 1 j , , x nj , we have a few options. • If X j is quantitative, then we can assume that X j | Y = k ∼ N ( μ jk , σ 2 jk ) . In other words, we assume that within each class, the j th predictor is drawn from a (univariate) normal distribution. While this may sound a bit like QDA, there is one key difference, in that here we are assuing that the predictors are independent; this amounts to QDA with an additional assumption that the class-specific covariance matrix is diagonal. • If X j is quantitative, then another option is to use a non-parametric estimate for f kj . A very simple way to do this is by making a hitogram for the observations of the j th predictor within each class. Then we can estimate f kj ( x j ) as the fraction of the training obsevations in the k th class that belong to the same histogram bin as x j . Alternatively, we can use a kernel density estimator , which is kernel density estimator essentially a smoothed version of a histogram. • If X j is qualitative, then we can simply count the proportion of traiing observations for the j th predictor corresponding to each class. For instance, suppose that X j ∈{ 1 , 2 , 3 } , and we have 100 observations in the k th class. Suppose that the j th predictor takes on values of 1 , 2 , and 3 in 32, 55, and 13 of those observations, respectively. Then we can estimate f kj as ˆ f kj ( x j ) =      0 . 32 if x j = 1 0 . 55 if x j = 2 0 . 13 if x j = 3",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_56"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Then we can estimate f kj as ˆ f kj ( x j ) =      0 . 32 if x j = 1 0 . 55 if x j = 2 0 . 13 if x j = 3 . We now consider the naive Bayes classifier in a toy example with p = 3 predictors and K = 2 classes. The first two predictors are quantitative, and the third predictor is qualitative with three levels. Suppose further that ˆ π 1 = ˆ π 2 = 0 . 5 . The estimated density functions ˆ f kj for k = 1 , 2 and j = 1 , 2 , 3 are displayed in Figure 4.10 . Now suppose that we wish to classify a new observation, x ∗ = (0 . 4 , 1 . 5 , 1) T . It turns out that in this Density estimates for class k=1 ˆ f 11 ˆ f 12 ˆ f 13 −4 −2 0 2 4 −2 0 2 4 1 2 3 Density estimates for class k=2 ˆ f 21 ˆ f 22 ˆ f 23 −4 −2 0 2 4 −2 0 2 4 1 2 3 FIGURE 4.10. In the toy example in Section 4.4.4 , we generate data with p = 3 predictors and K = 2 classes. The first two predictors are quantitative, and the third predictor is qualitative with three levels. In each class, the estimated density for each of the three predictors is displayed. If the prior probabilities for the two classes are equal, then the observation x ∗ = (0 . 4 , 1 . 5 , 1) T has a 94 . 4% posterior probability of belonging to the first class. True default status No Yes Total Predicted No 9621 244 9865 default status Yes 46 89 135 Total 9667 333 10000 TABLE 4.8. Comparison of the naive Bayes predictions to the true default status for the 10 , 000 training observations in the Default data set, when we predict default for any observation for which P ( Y = default | X = x ) > 0 . 5 . example, ˆ f 11 (0 . 4) = 0 . 368 , ˆ f 12 (1 . 5) = 0 . 484 , ˆ f 13 (1) = 0 . 226 , and ˆ f 21 (0 . 4) = 0 . 030 , ˆ f 22 (1 . 5) = 0 . 130 , ˆ f 23 (1) = 0 . 616 . Plugging these estimates into ( 4.30 ) results in posterior probability estimates of Pr( Y = 1 | X = x ∗ ) = 0 . 944 and Pr( Y = 2 | X = x ∗ ) = 0 . 056",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_57"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 5) = 0 . 130 , ˆ f 23 (1) = 0 . 616 . Plugging these estimates into ( 4.30 ) results in posterior probability estimates of Pr( Y = 1 | X = x ∗ ) = 0 . 944 and Pr( Y = 2 | X = x ∗ ) = 0 . 056 . Table 4.8 provides the confusion matrix resulting from applying the naive Bayes classifier to the Default data set, where we predict a default if the posterior probability of a default — that is, P ( Y = default | X = x ) — eceeds 0 . 5 . Comparing this to the results for LDA in Table 4.4 , our findings are mixed. While LDA has a slightly lower overall error rate, naive Bayes True default status No Yes Total Predicted No 9339 130 9469 default status Yes 328 203 531 Total 9667 333 10000 TABLE 4.9. Comparison of the naive Bayes predictions to the true default status for the 10 , 000 training observations in the Default data set, when we predict default for any observation for which P ( Y = default | X = x ) > 0 . 2 . correctly predicts a higher fraction of the true defaulters. In this implemetation of naive Bayes, we have assumed that each quantitative predictor is drawn from a Gaussian distribution (and, of course, that within each class, each predictor is independent). Just as with LDA, we can easily adjust the probability threshold for predicting a default. For example, Table 4.9 provides the confusion matrix resulting from predicting a default if P ( Y = default | X = x ) > 0 . 2 . Again, the results are mixed relative to LDA with the same threshold (Table 4.5 ). Naive Bayes has a higher error rate, but correctly predicts almost two-thirds of the true defaults. In this example, it should not be too surprising that naive Bayes does not convincingly outperform LDA: this data set has n = 10 , 000 and p = 2 , and so the reduction in variance resulting from the naive Bayes assumption is not necessarily worthwhile. We expect to see a greater pay-off to using naive Bayes relative to LDA or QDA in instances where p is larger or n is smaller, so that reducing the variance is very important",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_58"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We expect to see a greater pay-off to using naive Bayes relative to LDA or QDA in instances where p is larger or n is smaller, so that reducing the variance is very important. 4.5 A Comparison of Classification Methods 4.5.1 An Analytical Comparison We now perform an analytical (or mathematical) comparison of LDA, QDA, naive Bayes, and logistic regression. We consider these approaches in a setting with K classes, so that we assign an observation to the class that maximizes Pr( Y = k | X = x ) . Equivalently, we can set K as the baseline class and assign an observation to the class that maximizes log * Pr( Y = k | X = x ) Pr( Y = K | X = x ) + (4.31) for k = 1 , , K . Examining the specific form of ( 4.31 ) for each method provides a clear understanding of their similarities and differences. First, for LDA, we can make use of Bayes’ theorem ( 4.15 ) as well as the assumption that the predictors within each class are drawn from a multivariate normal density ( 4.23 ) with class-specific mean and shared c variance matrix in order to show that log * Pr( Y = k | X = x ) Pr( Y = K | X = x ) + = log * π k f k ( x ) π K f K ( x ) + = log > π k exp ' − 1 2 ( x − μ k ) T Σ − 1 ( x − μ k ) ( π K exp ' − 1 2 ( x − μ K ) T Σ − 1 ( x − μ K ) ( ? = log * π k π K + − 1 2 ( x − μ k ) T Σ − 1 ( x − μ k ) + 1 2 ( x − μ K ) T Σ − 1 ( x − μ K ) = log * π k π K + − 1 2 ( μ k + μ K ) T Σ − 1 ( μ k − μ K ) + x T Σ − 1 ( μ k − μ K ) = a k + p 0 j =1 b kj x j , (4.32) where a k = log 1 π k π K 2 − 1 2 ( μ k + μ K ) T Σ − 1 ( μ k − μ K ) and b kj is the j th component of Σ − 1 ( μ k − μ K ) . Hence LDA, like logistic regression, assumes that the log odds of the posterior probabilities is linear in x . Using similar calculations, in the QDA setting ( 4.31 ) becomes log * Pr( Y = k | X = x ) Pr( Y = K | X = x ) + = a k + p 0 j =1 b kj x j + p 0 j =1 p 0 l =1 c kjl x j x l , (4.33) where a k , b kj , and c kjl are functions of π k , π K , μ k , μ K , Σ k and Σ K",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_59"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Again, as the name suggests, QDA assumes that the log odds of the posterior probabilities is quadratic in x . Finally, we examine ( 4.31 ) in the naive Bayes setting. Recall that in this setting, f k ( x ) is modeled as a product of p one-dimensional functions f kj ( x j ) for j = 1 , , p . Hence, log * Pr( Y = k | X = x ) Pr( Y = K | X = x ) + = log * π k f k ( x ) π K f K ( x ) + = log > π k F p j =1 f kj ( x j ) π K F p j =1 f Kj ( x j ) ? = log * π k π K + + p 0 j =1 log * f kj ( x j ) f Kj ( x j ) + = a k + p 0 j =1 g kj ( x j ) , (4.34) where a k = log 1 π k π K 2 and g kj ( x j ) = log 1 f kj ( x j ) f Kj ( x j ) 2 . Hence, the right-hand side of ( 4.34 ) takes the form of a generalized additive model , a topic that is discussed further in Chapter 7 . Inspection of ( 4.32 ), ( 4.33 ), and ( 4.34 ) yields the following observations about LDA, QDA, and naive Bayes: • LDA is a special case of QDA with c kjl = 0 for all j = 1 , , p , l = 1 , , p , and k = 1 , , K . (Of course, this is not surprising, since LDA is simply a restricted version of QDA with Σ 1 = · · · = Σ K = Σ .) • Any classifier with a linear decision boundary is a special case of naive Bayes with g kj ( x j ) = b kj x j . In particular, this means that LDA is a special case of naive Bayes! This is not at all obvious from the descriptions of LDA and naive Bayes earlier in this chapter, since each method makes very different assumptions: LDA assumes that the features are normally distributed with a common within-class covariance matrix, and naive Bayes instead assumes independence of the features. • If we model f kj ( x j ) in the naive Bayes classifier using a one-dimensinal Gaussian distribution N ( μ kj , σ 2 j ) , then we end up with g kj ( x j ) = b kj x j where b kj = ( μ kj − μ Kj ) /σ 2 j . In this case, naive Bayes is actually a special case of LDA with Σ restricted to be a diagonal matrix with j th diagonal element equal to σ 2 j . • Neither QDA nor naive Bayes is a special case of the other",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_60"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". • Neither QDA nor naive Bayes is a special case of the other. Naive Bayes can produce a more flexible fit, since any choice can be made for g kj ( x j ) . However, it is restricted to a purely additive fit, in the sense that in ( 4.34 ), a function of x j is added to a function of x l , for j ̸ = l ; however, these terms are never multiplied. By contrast, QDA includes multiplicative terms of the form c kjl x j x l . Therefore, QDA has the potential to be more accurate in settings where interactions among the predictors are important in discriminating between classes. None of these methods uniformly dominates the others: in any setting, the choice of method will depend on the true distribution of the predictors in each of the K classes, as well as other considerations, such as the values of n and p . The latter ties into the bias-variance trade-off. How does logistic regression tie into this story? Recall from ( 4.12 ) that multinomial logistic regression takes the form log * Pr( Y = k | X = x ) Pr( Y = K | X = x ) + = β k 0 + p 0 j =1 β kj x j . This is identical to the linear form of LDA ( 4.32 ): in both cases, log 1 Pr( Y = k | X = x ) Pr( Y = K | X = x ) 2 is a linear function of the predictors. In LDA, the cefficients in this linear function are functions of estimates for π k , π K , μ k , μ K , and Σ obtained by assuming that X 1 , , X p follow a normal distrbution within each class. By contrast, in logistic regression, the coefficients are chosen to maximize the likelihood function ( 4.5 ). Thus, we expect LDA to outperform logistic regression when the normality assumption (approxmately) holds, and we expect logistic regression to perform better when it does not. We close with a brief discussion of K -nearest neighbors (KNN), intrduced in Chapter 2 . Recall that KNN takes a completely different approach from the classifiers seen in this chapter. In order to make a prediction for an observation X = x , the training observations that are closest to x are identified",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_61"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In order to make a prediction for an observation X = x , the training observations that are closest to x are identified. Then X is assigned to the class to which the plurality of these observations belong. Hence KNN is a completely non-parametric approach: no assumptions are made about the shape of the decision boundary. We make the following observations about KNN: • Because KNN is completely non-parametric, we can expect this aproach to dominate LDA and logistic regression when the decision boundary is highly non-linear, provided that n is very large and p is small. • In order to provide accurate classification, KNN requires a lot of oservations relative to the number of predictors—that is, n much larger than p . This has to do with the fact that KNN is non-parametric, and thus tends to reduce the bias while incurring a lot of variance. • In settings where the decision boundary is non-linear but n is only modest, or p is not very small, then QDA may be preferred to KNN. This is because QDA can provide a non-linear decision boundary while taking advantage of a parametric form, which means that it requires a smaller sample size for accurate classification, relative to KNN. • Unlike logistic regression, KNN does not tell us which predictors are important: we don’t get a table of coefficients as in Table 4.3 . 4.5.2 An Empirical Comparison We now compare the empirical (practical) performance of logistic regresion, LDA, QDA, naive Bayes, and KNN. We generated data from six diferent scenarios, each of which involves a binary (two-class) classification problem. In three of the scenarios, the Bayes decision boundary is linear, and in the remaining scenarios it is non-linear. For each scenario, we prduced 100 random training data sets. On each of these training sets, we fit each method to the data and computed the resulting test error rate on a large test set. Results for the linear scenarios are shown in Figure 4.11 , and the results for the non-linear scenarios are in Figure 4.12",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_62"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Results for the linear scenarios are shown in Figure 4.11 , and the results for the non-linear scenarios are in Figure 4.12 . The KNN method requires selection of K , the number of neighbors (not to be cofused with the number of classes in earlier sections of this chapter). We performed KNN with two values of K : K = 1 , and a value of K that was chosen automatically using an approach called cross-validation , which we discuss further in Chapter 5 . We applied naive Bayes assuming univariate Gaussian densities for the features within each class (and, of course — since this is the key characteristic of naive Bayes — assuming independence of the features). In each of the six scenarios, there were p = 2 quantitative predictors. The scenarios were as follows: KNN−1 KNN−CV LDA Logistic NBayes QDA SCENARIO 1 0.25 0.30 0.35 0.40 0.45 KNN−1 KNN−CV LDA Logistic NBayes QDA SCENARIO 2 0.15 0.20 0.25 0.30 KNN−1 KNN−CV LDA Logistic NBayes QDA SCENARIO 3 0.20 0.25 0.30 0.35 0.40 0.45 0.50 FIGURE 4.11. Boxplots of the test error rates for each of the linear scenarios described in the main text. Scenario 1: There were 20 training observations in each of two classes. The observations within each class were uncorrelated random normal variables with a different mean in each class. The left-hand panel of Figure 4.11 shows that LDA performed well in this setting, as one would expect since this is the model assumed by LDA. Logistic regression also performed quite well, since it assumes a linear decision boundary. KNN performed poorly because it paid a price in terms of variance that was not offset by a reduction in bias. QDA also performed worse than LDA, since it fit a more flexible classifier than necessary. The performance of naive Bayes was slightly better than QDA, because the naive Bayes assumption of independent predictors is correct. Scenario 2: Details are as in Scenario 1, except that within each class, the two predictors had a correlation of − 0 . 5",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_63"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Scenario 2: Details are as in Scenario 1, except that within each class, the two predictors had a correlation of − 0 . 5 . The center panel of Figure 4.11 indicates that the performance of most methods is similar to the prevous scenario. The notable exception is naive Bayes, which performs very poorly here, since the naive Bayes assumption of independent predictors is violated. Scenario 3: As in the previous scenario, there is substantial negative corelation between the predictors within each class. However, this time we generated X 1 and X 2 from the t -distribution , with 50 observations per class. t - distribution The t -distribution has a similar shape to the normal distribution, but it has a tendency to yield more extreme points—that is, more points that are far from the mean. In this setting, the decision boundary was still linear, and so fit into the logistic regression framework. The set-up violated the assumptions of LDA, since the observations were not drawn from a normal distribution. The right-hand panel of Figure 4.11 shows that logistic regresion outperformed LDA, though both methods were superior to the other approaches. In particular, the QDA results deteriorated considerably as a consequence of non-normality. Naive Bayes performed very poorly because the independence assumption is violated. Scenario 4: The data were generated from a normal distribution, with a correlation of 0 . 5 between the predictors in the first class, and correlation of − 0 . 5 between the predictors in the second class. This setup corresponded to the QDA assumption, and resulted in quadratic decision boundaries. The left-hand panel of Figure 4.12 shows that QDA outperformed all of the KNN−1 KNN−CV LDA Logistic NBayes QDA SCENARIO 4 0.30 0.35 0.40 KNN−1 KNN−CV LDA Logistic NBayes QDA SCENARIO 5 0.18 0.20 0.22 0.24 0.26 0.28 0.30 0.32 KNN−1 KNN−CV LDA Logistic NBayes QDA SCENARIO 6 0.15 0.20 0.25 0.30 0.35 0.40 0.45 FIGURE 4.12. Boxplots of the test error rates for each of the non-linear scenarios described in the main text",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_64"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Boxplots of the test error rates for each of the non-linear scenarios described in the main text. other approaches. The naive Bayes assumption of independent predictors is violated, so naive Bayes performs poorly. Scenario 5: The data were generated from a normal distribution with ucorrelated predictors. Then the responses were sampled from the logistic function applied to a complicated non-linear function of the predictors. The center panel of Figure 4.12 shows that both QDA and naive Bayes gave slightly better results than the linear methods, while the much more flexble KNN-CV method gave the best results. But KNN with K = 1 gave the worst results out of all methods. This highlights the fact that even when the data exhibits a complex non-linear relationship, a non-parametric method such as KNN can still give poor results if the level of smoothness is not chosen correctly. Scenario 6: The observations were generated from a normal distribution with a different diagonal covariance matrix for each class. However, the sample size was very small: just n = 6 in each class. Naive Bayes performed very well, because its assumptions are met. LDA and logistic regression performed poorly because the true decision boundary is non-linear, due to the unequal covariance matrices. QDA performed a bit worse than naive Bayes, because given the very small sample size, the former incurred too much variance in estimating the correlation between the predictors within each class. KNN’s performance also suffered due to the very small sample size. These six examples illustrate that no one method will dominate the oters in every situation. When the true decision boundaries are linear, then the LDA and logistic regression approaches will tend to perform well. When the boundaries are moderately non-linear, QDA or naive Bayes may give better results. Finally, for much more complicated decision boundaries, a non-parametric approach such as KNN can be superior",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_65"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Finally, for much more complicated decision boundaries, a non-parametric approach such as KNN can be superior. But the level of smoothness for a non-parametric approach must be chosen carefully. In the next chapter we examine a number of approaches for choosing the correct level of smoothness and, in general, for selecting the best overall method. Finally, recall from Chapter 3 that in the regression setting we can accomodate a non-linear relationship between the predictors and the response by performing regression using transformations of the predictors. A similar approach could be taken in the classification setting. For instance, we could Coef fi cient Std. error t -statistic p -value Intercept 73.60 5.13 14.34 0.00 workingday 1.27 1.78 0.71 0.48 temp 157.21 10.26 15.32 0.00 weathersit[cloudy/misty] -12.89 1.96 -6.56 0.00 weathersit[light rain/snow] -66.49 2.97 -22.43 0.00 weathersit[heavy rain/snow] -109.75 76.67 -1.43 0.15 TABLE 4.10. Results for a least squares linear model fit to predict bikers in the Bikeshare data. The predictors mnth and hr are omitted from this table due to space constraints, and can be seen in Figure 4.13 . For the qualitative variable weathersit , the baseline level corresponds to clear skies. create a more flexible version of logistic regression by including X 2 , X 3 , and even X 4 as predictors. This may or may not improve logistic regresion’s performance, depending on whether the increase in variance due to the added flexibility is offset by a sufficiently large reduction in bias. We could do the same for LDA. If we added all possible quadratic terms and cross-products to LDA, the form of the model would be the same as the QDA model, although the parameter estimates would be different. This device allows us to move somewhere between an LDA and a QDA model. 4.6 Generalized Linear Models In Chapter 3 , we assumed that the response Y is quantitative, and eplored the use of least squares linear regression to predict Y",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_66"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 4.6 Generalized Linear Models In Chapter 3 , we assumed that the response Y is quantitative, and eplored the use of least squares linear regression to predict Y . Thus far in this chapter, we have instead assumed that Y is qualitative. However, we may sometimes be faced with situations in which Y is neither qualitative nor quantitative, and so neither linear regression from Chapter 3 nor the classification approaches covered in this chapter is applicable. As a concrete example, we consider the Bikeshare data set. The response is bikers , the number of hourly users of a bike sharing program in Wasington, DC. This response value is neither qualitative nor quantitative: instead, it takes on non-negative integer values, or counts . We will consider counts predicting bikers using the covariates mnth (month of the year), hr (hour of the day, from 0 to 23), workingday (an indicator variable that equals 1 if it is neither a weekend nor a holiday), temp (the normalized temperature, in Celsius), and weathersit (a qualitative variable that takes on one of four possible values: clear; misty or cloudy; light rain or light snow; or heavy rain or heavy snow.) In the analyses that follow, we will treat mnth , hr , and weathersit as qualitative variables. 4.6.1 Linear Regression on the Bikeshare Data To begin, we consider predicting bikers using linear regression. The results are shown in Table 4.10 . We see, for example, that a progression of weather from clear to cloudy results in, on average, 12 . 89 fewer bikers per hour; however, if the weather progresses further to rain or snow, then this further results in 53 . 60 fewer bikers per hour. Figure 4.13 displays the coefficients associated with mnth FIGURE 4.13. A least squares linear regression model was fit to predict bikers in the Bikeshare data set. Left: The coefficients associated with the month of the year. Bike usage is highest in the spring and fall, and lowest in the winter. Right: The coefficients associated with the hour of the day",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_67"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Left: The coefficients associated with the month of the year. Bike usage is highest in the spring and fall, and lowest in the winter. Right: The coefficients associated with the hour of the day. Bike usage is highest during peak commute times, and lowest overnight. and the coefficients associated with hr . We see that bike usage is highest in the spring and fall, and lowest during the winter months. Furthermore, bike usage is greatest around rush hour (9 AM and 6 PM), and lowest overnight. Thus, at first glance, fitting a linear regression model to the Bikeshare data set seems to provide reasonable and intuitive results. But upon more careful inspection, some issues become apparent. For example, 9.6% of the fitted values in the Bikeshare data set are negative: that is, the linear regression model predicts a negative number of users during 9.6% of the hours in the data set. This calls into question our ability to perform meaningful predictions on the data, and it also raises concerns about the accuracy of the coefficient estimates, confidence intervals, and other outputs of the regression model. Furthermore, it is reasonable to suspect that when the expected value of bikers is small, the variance of bikers should be small as well. For instance, at 2 AM during a heavy December snow storm, we expect that extremely few people will use a bike, and moreover that there should be little variance associated with the number of users during those conditions. This is borne out in the data: between 1 AM and 4 AM, in December, January, and February, when it is raining, there are 5 . 05 users, on average, with a standard deviation of 3 . 73 . By contrast, between 7 AM and 10 AM, in April, May, and June, when skies are clear, there are 243 . 59 users, on average, with a standard deviation of 131 . 7 . The mean-variance relationship is displayed in the left-hand panel of Figure 4.14",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_68"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 59 users, on average, with a standard deviation of 131 . 7 . The mean-variance relationship is displayed in the left-hand panel of Figure 4.14 . This is a major violation of the assumptions of a linear model, which state that Y = ) p j =1 X j β j + ε , where ε is a mean-zero error term with variance σ 2 that is constant , and not a function of the covariates. Therefore, the heteroscedasticity of the data calls into question the suitability of a linear regression model. Finally, the response bikers is integer-valued. But under a linear model, Y = β 0 + ) p j =1 X j β j + ε , where ε is a continuous-valued error term. This means that in a linear model, the response Y is necessarily continuouvalued (quantitative). Thus, the integer nature of the response bikers sugests that a linear regression model is not entirely satisfactory for this data set. ● ● ● ● ● ● ● ● ● ● ● ● −40 −20 0 20 Month Coefficient J F M A M J J A S O N D ● ●●●● ● ● ● ● ● ● ● ●● ●● ● ● ● ● ● ● ● ● 5 10 15 20 −100 0 50 100 200 Hour Coefficient 5 10 15 20 0 100 200 300 400 500 600 Hour Number of Bikers 5 10 15 20 0 1 2 3 4 5 6 Hour Log(Number of Bikers) FIGURE 4.14. Left: On the Bikeshare dataset, the number of bikers is diplayed on the y -axis, and the hour of the day is displayed on the x -axis. Jitter was applied for ease of visualization. For the most part, as the mean number of bikers increases, so does the variance in the number of bikers. A smoothing spline fit is shown in green. Right: The log of the number of bikers is now displayed on the y -axis. Some of the problems that arise when fitting a linear regression model to the Bikeshare data can be overcome by transforming the response; for instance, we can fit the model log( Y ) = p 0 j =1 X j β j + ε. Transforming the response avoids the possibility of negative predictions, and it overcomes much of the heteroscedasticity in the untransformed data, as is shown in the right-hand panel of Figure 4.14",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_69"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, it is not quite a satisfactory solution, since predictions and inference are made in terms of the log of the response, rather than the response. This leads to challenges in interpretation, e.g. “a one-unit increase in X j is associated with an increase in the mean of the log of Y by an amount β j ” . Furthermore, a log transformation of the response cannot be applied in settings where the response can take on a value of 0 . Thus, while fitting a linear model to a transformation of the response may be an adequate approach for some count-valued data sets, it often leaves something to be desired. We will see in the next section that a Poisson regression model provides a much more natural and elegant approach for this task. 4.6.2 Poisson Regression on the Bikeshare Data To overcome the inadequacies of linear regression for analyzing the Bikeshare data set, we will make use of an alternative approach, called Poisson regression . Before we can talk about Poisson regression, we must first iPoisson regression troduce the Poisson distribution . Poisson distribution Suppose that a random variable Y takes on nonnegative integer values, i.e. Y ∈{ 0 , 1 , 2 , } . If Y follows the Poisson distribution, then Pr( Y = k ) = e − λ λ k k ! for k = 0 , 1 , 2 , (4.35) Here, λ > 0 is the expected value of Y , i.e. E( Y ) . It turns out that λ also equals the variance of Y , i.e. λ = E( Y ) = Var( Y ) . This means that if Y follows the Poisson distribution, then the larger the mean of Y , the larger its variance. (In ( 4.35 ), the notation k ! , pronounced “k factorial”, is defined as k ! = k × ( k − 1) × ( k − 2) × × 3 × 2 × 1 .) The Poisson distribution is typically used to model counts ; this is a naural choice for a number of reasons, including the fact that counts, like the Poisson distribution, take on nonnegative integer values",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_70"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". To see how we might use the Poisson distribution in practice, let Y denote the nuber of users of the bike sharing program during a particular hour of the day, under a particular set of weather conditions, and during a particlar month of the year. We might model Y as a Poisson distribution with mean E( Y ) = λ = 5 . This means that the probability of no users duing this particular hour is Pr( Y = 0) = e − 5 5 0 0! = e − 5 = 0 . 0067 (where 0! = 1 by convention). The probability that there is exactly one user is Pr( Y = 1) = e − 5 5 1 1! = 5 e − 5 = 0 . 034 , the probability of two users is Pr( Y = 2) = e − 5 5 2 2! = 0 . 084 , and so on. Of course, in reality, we expect the mean number of users of the bike sharing program, λ = E( Y ) , to vary as a function of the hour of the day, the month of the year, the weather conditions, and so forth. So rather than modeling the number of bikers, Y , as a Poisson distribution with a fixed mean value like λ = 5 , we would like to allow the mean to vary as a function of the covariates. In particular, we consider the following model for the mean λ = E( Y ) , which we now write as λ ( X 1 , , X p ) to emphasize that it is a function of the covariates X 1 , , X p : log( λ ( X 1 , , X p )) = β 0 + β 1 X 1 + · · · + β p X p (4.36) or equivalently λ ( X 1 , , X p ) = e β 0 + β 1 X 1 + ··· + β p X p . (4.37) Here, β 0 , β 1 , , β p are parameters to be estimated. Together, ( 4.35 ) and ( 4.36 ) define the Poisson regression model. Notice that in ( 4.36 ), we take the log of λ ( X 1 , , X p ) to be linear in X 1 , , X p , rather than having λ ( X 1 , , X p ) itself be linear in X 1 , , X p ; this ensures that λ ( X 1 , , X p ) takes on nonnegative values for all values of the covariates. To estimate the coefficients β 0 , β 1 , , β p , we use the same maximum likelihood approach that we adopted for logistic regression in Section 4.3.2",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_71"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". To estimate the coefficients β 0 , β 1 , , β p , we use the same maximum likelihood approach that we adopted for logistic regression in Section 4.3.2 . Specifically, given n independent observations from the Poisson regression model, the likelihood takes the form l ( β 0 , β 1 , , β p ) = n E i =1 e − λ ( x i ) λ ( x i ) y i y i ! , (4.38) where λ ( x i ) = e β 0 + β 1 x i 1 + ··· + β p x ip , due to ( 4.37 ). We estimate the coeficients that maximize the likelihood l ( β 0 , β 1 , , β p ) , i.e. that make the observed data as likely as possible. We now fit a Poisson regression model to the Bikeshare data set. The results are shown in Table 4.11 and Figure 4.15 . Qualitatively, the results are similar to those from linear regression in Section 4.6.1 . We again see that bike usage is highest in the spring and fall and during rush hour, C o e ffi cient Std. error z -statistic p -value Intercept 4.12 0.01 683.96 0.00 workingday 0.01 0.00 7.5 0.00 temp 0.79 0.01 68.43 0.00 weathersit[cloudy/misty] -0.08 0.00 -34.53 0.00 weathersit[light rain/snow] -0.58 0.00 -141.91 0.00 weathersit[heavy rain/snow] - 0.93 0.17 -5.55 0.00 TABLE 4.11. Results for a Poisson regression model fit to predict bikers in the Bikeshare data. The predictors mnth and hr are omitted from this table due to space constraints, and can be seen in Figure 4.15 . For the qualitative variable weathersit , the baseline corresponds to clear skies. FIGURE 4.15. A Poisson regression model was fit to predict bikers in the Bikeshare data set. Left: The coefficients associated with the month of the year. Bike usage is highest in the spring and fall, and lowest in the winter. Right: The coefficients associated with the hour of the day. Bike usage is highest during peak commute times, and lowest overnight. and lowest during the winter and in the early morning hours. Moreover, bike usage increases as the temperature increases, and decreases as the weather worsens",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_72"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". and lowest during the winter and in the early morning hours. Moreover, bike usage increases as the temperature increases, and decreases as the weather worsens. Interestingly, the coefficient associated with workingday is statistically significant under the Poisson regression model, but not under the linear regression model. Some important distinctions between the Poisson regression model and the linear regression model are as follows: • Interpretation: To interpret the coefficients in the Poisson regression model, we must pay close attention to ( 4.37 ), which states that an increase in X j by one unit is associated with a change in E( Y ) = λ by a factor of exp( β j ) . For example, a change in weather from clear to cloudy skies is associated with a change in mean bike usage by a factor of exp( − 0 . 08) = 0 . 923 , i.e. on average, only 92.3% as many people will use bikes when it is cloudy relative to when it is clear. If the weather worsens further and it begins to rain, then the mean bike usage will further change by a factor of exp( − 0 . 5) = 0 . 607 , i.e. on average only 60.7% as many people will use bikes when it is rainy relative to when it is cloudy. ● ● ● ● ● ● ● ● ● ● ● ● −0.6 −0.4 −0.2 0.0 0.2 Month Coefficient J F M A M J J A S O N D ● ● ● ● ● ● ● ● ● ● ● ● ●●●● ● ●● ● ● ● ● ● 5 10 15 20 −2 −1 0 1 Hour Coefficient • Mean-variance relationship: As mentioned earlier, under the Poisson model, λ = E( Y ) = Var( Y ) . Thus, by modeling bike usage with a Poisson regression, we implicitly assume that mean bike usage in a given hour equals the variance of bike usage during that hour. By contrast, under a linear regression model, the variance of bike usage always takes on a constant value. Recall from Figure 4.14 that in the Bikeshare data, when biking conditions are favorable, both the mean and the variance in bike usage are much higher than when conditions are unfavorable",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_73"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Recall from Figure 4.14 that in the Bikeshare data, when biking conditions are favorable, both the mean and the variance in bike usage are much higher than when conditions are unfavorable. Thus, the Poisson regression model is able to handle the mean-variance relationship seen in the Bikeshare data in a way that the linear regression model is not. 5 overdispersion • nonnegative fitted values: There are no negative predictions using the Poisson regression model. This is because the Poisson model itself only allows for nonnegative values; see ( 4.35 ). By contrast, when we fit a linear regression model to the Bikeshare data set, almost 10% of the predictions were negative. 4.6.3 Generalized Linear Models in Greater Generality We have now discussed three types of regression models: linear, logistic and Poisson. These approaches share some common characteristics: 1. Each approach uses predictors X 1 , , X p to predict a response Y . We assume that, conditional on X 1 , , X p , Y belongs to a certain family of distributions. For linear regression, we typically assume that Y follows a Gaussian or normal distribution. For logistic regression, we assume that Y follows a Bernoulli distribution. Finally, for Poisson regression, we assume that Y follows a Poisson distribution. 2. Each approach models the mean of Y as a function of the predictors. In linear regression, the mean of Y takes the form E( Y | X 1 , , X p ) = β 0 + β 1 X 1 + · · · + β p X p , (4.39) i.e. it is a linear function of the predictors. For logistic regression, the mean instead takes the form E( Y | X 1 , , X p ) = Pr( Y = 1 | X 1 , , X p ) = e β 0 + β 1 X 1 + ··· + β p X p 1 + e β 0 + β 1 X 1 + ··· + β p X p , (4.40) while for Poisson regression it takes the form E( Y | X 1 , , X p ) = λ ( X 1 , , X p ) = e β 0 + β 1 X 1 + ··· + β p X p",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_74"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (4.41) Equations ( 4.39 )–( 4.41 ) can be expressed using a link function , η , which link function 5 In fact, the variance in the Bikeshare data appears to be much higher than the mean, a situation referred to as overdispersion . This causes the Z-values to be inflated in Table 4.11 . A more careful analysis should account for this overdispersion to obtain more accurate Z-values, and there are a variety of methods for doing this. But they are beyond the scope of this book. applies a transformation to E( Y | X 1 , , X p ) so that the transformed mean is a linear function of the predictors. That is, η (E( Y | X 1 , , X p )) = β 0 + β 1 X 1 + · · · + β p X p . (4.42) The link functions for linear, logistic and Poisson regression are η ( μ ) = μ , η ( μ ) = log( μ/ (1 − μ )) , and η ( μ ) = log( μ ) , respectively. The Gaussian, Bernoulli and Poisson distributions are all members of a wider class of distributions, known as the exponential family . Other welexponential family known members of this family are the exponential distribution, the Gamma exponential Gamma distribution, and the negative binomial distribution. In general, we can penegative binomial form a regression by modeling the response Y as coming from a particular member of the exponential family, and then transforming the mean of the response so that the transformed mean is a linear function of the predictors via ( 4.42 ). Any regression approach that follows this very general recipe is known as a generalized linear model (GLM). Thus, linear regression, logistic generalized linear model regression, and Poisson regression are three examples of GLMs. Other eamples not covered here include Gamma regression and negative binomial regression . 4.7 Lab: Logistic Regression, LDA, QDA, and KNN 4.7.1 The Stock Market Data In this lab we will examine the Smarket data, which is part of the ISLP library. This data set consists of percentage returns for the S&P 500 stock index over 1,250 days, from the beginning of 2001 until the end of 2005",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_75"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This data set consists of percentage returns for the S&P 500 stock index over 1,250 days, from the beginning of 2001 until the end of 2005. For each date, we have recorded the percentage returns for each of the five previous trading days, Lag1 through Lag5 . We have also recorded Volume (the number of shares traded on the previous day, in billions), Today (the percentage return on the date in question) and Direction (whether the market was Up or Down on this date). We start by importing our libraries at this top level; these are all imports we have seen in previous labs. In [1]: import numpy as np import pandas as pd from matplotlib.pyplot import subplots import statsmodels.api as sm from ISLP import load_data from ISLP.models import (ModelSpec as MS, summarize) We also collect together the new imports needed for this lab. In [2]: from ISLP import confusion_table from ISLP.models import contrast from sklearn.discriminant_analysis import \\ (LinearDiscriminantAnalysis as LDA, QuadraticDiscriminantAnalysis as QDA) from sklearn.naive_bayes import GaussianNB from sklearn.neighbors import KNeighborsClassifier from sklearn.preprocessing import StandardScaler from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression Now we are ready to load the Smarket data. In [3]: Smarket = load_data( 'Smarket' ) Smarket This gives a truncated listing of the data, which we do not show here. We can see what the variable names are. In [4]: Smarket.columns Out[4]: Index([ 'Year' , 'Lag1' , 'Lag2' , 'Lag3' , 'Lag4' , 'Lag5' , 'Volume' , 'Today' , 'Direction' ], dtype= 'object' ) We compute the correlation matrix using the corr() method for data .corr() frames, which produces a matrix that contains all of the pairwise corrlations among the variables. (We suppress the output here.) The pandas library does not report a correlation for the Direction variable because it is qualitative",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_76"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (We suppress the output here.) The pandas library does not report a correlation for the Direction variable because it is qualitative. In [5]: Smarket.corr() As one would expect, the correlations between the lagged return variables and today’s return are close to zero. The only substantial correlation is between Year and Volume . By plotting the data we see that Volume is icreasing over time. In other words, the average number of shares traded daily increased from 2001 to 2005. In [6]: Smarket.plot(y= 'Volume' ); 4.7.2 Logistic Regression Next, we will fit a logistic regression model in order to predict Direction using Lag1 through Lag5 and Volume . The sm.GLM() function fits genesm.GLM() alized linear models , a class of models that includes logistic regression. generalized linear model Alternatively, the function sm.Logit() fits a logistic regression model drectly. The syntax of sm.GLM() is similar to that of sm.OLS() , except that we must pass in the argument family=sm.families.Binomial() in order to tell statsmodels to run a logistic regression rather than some other type of generalized linear model. In [7]: allvars = Smarket.columns.drop([ 'Today' , 'Direction' , 'Year' ]) design = MS(allvars) X = design.fit_transform(Smarket) y = Smarket.Direction == 'Up' glm = sm.GLM(y, X, family=sm.families.Binomial()) results = glm.fit() summarize(results) Out[7]: coef std err z P>|z| intercept -0.1260 0.241 -0.523 0.601 Lag1 -0.0731 0.050 -1.457 0.145 Lag2 -0.0423 0.050 -0.845 0.398 Lag3 0.0111 0.050 0.222 0.824 Lag4 0.0094 0.050 0.187 0.851 Lag5 0.0103 0.050 0.208 0.835 Volume 0.1354 0.158 0.855 0.392 The smallest p -value here is associated with Lag1 . The negative coefficient for this predictor suggests that if the market had a positive return yesterday, then it is less likely to go up today. However, at a value of 0.15, the p -value is still relatively large, and so there is no clear evidence of a real association between Lag1 and Direction",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_77"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, at a value of 0.15, the p -value is still relatively large, and so there is no clear evidence of a real association between Lag1 and Direction . We use the params attribute of results in order to access just the coeffcients for this fitted model. In [8]: results.params Out[8]: intercept -0.126000 Lag1 -0.073074 Lag2 -0.042301 Lag3 0.011085 Lag4 0.009359 Lag5 0.010313 Volume 0.135441 dtype: float64 Likewise we can use the pvalues attribute to access the p -values for the coefficients (not shown). In [9]: results.pvalues The predict() method of results can be used to predict the probability that the market will go up, given values of the predictors. This method returns predictions on the probability scale. If no data set is supplied to the predict() function, then the probabilities are computed for the traiing data that was used to fit the logistic regression model. As with linear regression, one can pass an optional exog argument consistent with a design matrix if desired. Here we have printed only the first ten probabilities. In [10]: probs = results.predict() probs[:10] Out[10]: array([0.5070841, 0.4814679, 0.4811388, 0.5152223, 0.5107812, 0.5069565, 0.4926509, 0.5092292, 0.5176135, 0.4888378]) In order to make a prediction as to whether the market will go up or down on a particular day, we must convert these predicted probabilities into class labels, Up or Down . The following two commands create a vector of class predictions based on whether the predicted probability of a market increase is greater than or less than 0.5. In [11]: labels = np.array([ 'Down' ]*1250) labels[probs >0.5] = \"Up\" The confusion_table() function from the ISLP package summarizes these confusion_ table() predictions, showing how many observations were correctly or incorrectly classified. Our function, which is adapted from a similar function in the module sklearn.metrics , transposes the resulting matrix and includes row and column labels",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_78"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Our function, which is adapted from a similar function in the module sklearn.metrics , transposes the resulting matrix and includes row and column labels. The confusion_table() function takes as first argument the predicted labels, and second argument the true labels. In [12]: confusion_table(labels, Smarket.Direction) Out[12]: Truth Down Up Predicted Down 145 141 Up 457 507 The diagonal elements of the confusion matrix indicate correct predictions, while the off-diagonals represent incorrect predictions. Hence our model correctly predicted that the market would go up on 507 days and that it would go down on 145 days, for a total of 507 + 145 = 652 correct predictions. The np.mean() function can be used to compute the fraction of days for which the prediction was correct. In this case, logistic regression correctly predicted the movement of the market 52.2% of the time. In [13]: (507+145)/1250, np.mean(labels == Smarket.Direction) Out[13]: (0.5216, 0.5216) At first glance, it appears that the logistic regression model is working a little better than random guessing. However, this result is misleading because we trained and tested the model on the same set of 1,250 obsevations. In other words, 100 − 52 . 2 = 47 . 8% is the training error rate. As we have seen previously, the training error rate is often overly optimistic — it tends to underestimate the test error rate. In order to better assess the accuracy of the logistic regression model in this setting, we can fit the model using part of the data, and then examine how well it predicts the held out data. This will yield a more realistic error rate, in the sense that in practice we will be interested in our model’s performance not on the data that we used to fit the model, but rather on days in the future for which the market’s movements are unknown. To implement this strategy, we first create a Boolean vector corresponing to the observations from 2001 through 2004. We then use this vector to create a held out data set of observations from 2005",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_79"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". To implement this strategy, we first create a Boolean vector corresponing to the observations from 2001 through 2004. We then use this vector to create a held out data set of observations from 2005. In [14]: train = (Smarket.Year < 2005) Smarket_train = Smarket.loc[train] Smarket_test = Smarket.loc[ ∼ train] Smarket_test.shape Out[14]: (252, 9) The object train is a vector of 1,250 elements, corresponding to the observations in our data set. The elements of the vector that correspond to observations that occurred before 2005 are set to True , whereas those that correspond to observations in 2005 are set to False . Hence train is a boolean array, since its elements are True and False . Boolean arrays can be used to obtain a subset of the rows or columns of a data frame using the loc method. For instance, the command Smarket.loc[train] would pick out a submatrix of the stock market data set, corresponding only to the dates before 2005, since those are the ones for which the elements of train are True . The ∼ symbol can be used to negate all of the elements of a Boolean vector. That is, ∼ train is a vector similar to train , except that the elements that are True in train get swapped to False in ∼ train , and vice versa. Therefore, Smarket.loc[ ∼ train] yields a subset of the rows of the data frame of the stock market data containing only the observations for which train is False . The output above indicates that there are 252 such observations. We now fit a logistic regression model using only the subset of the oservations that correspond to dates before 2005. We then obtain predicted probabilities of the stock market going up for each of the days in our test set — that is, for the days in 2005",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_80"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We then obtain predicted probabilities of the stock market going up for each of the days in our test set — that is, for the days in 2005. In [15]: X_train, X_test = X.loc[train], X.loc[ ∼ train] y_train, y_test = y.loc[train], y.loc[ ∼ train] glm_train = sm.GLM(y_train, X_train, family=sm.families.Binomial()) results = glm_train.fit() probs = results.predict(exog=X_test) Notice that we have trained and tested our model on two completely separate data sets: training was performed using only the dates before 2005, and testing was performed using only the dates in 2005. Finally, we compare the predictions for 2005 to the actual movements of the market over that time period. We will first store the test and training labels (recall y_test is binary). In [16]: D = Smarket.Direction L_train, L_test = D.loc[train], D.loc[ ∼ train] Now we threshold the fitted probability at 50% to form our predicted labels. In [17]: labels = np.array([ 'Down' ]*252) labels[probs >0.5] = 'Up' confusion_table(labels, L_test) Out[17]: Truth Down Up Predicted Down 77 97 Up 34 44 The test accuracy is about 48% while the error rate is about 52% In [18]: np.mean(labels == L_test), np.mean(labels != L_test) Out[18]: (0.4802, 0.5198) The != notation means not equal to , and so the last command computes != the test set error rate. The results are rather disappointing: the test error rate is 52%, which is worse than random guessing! Of course this result is not all that surprising, given that one would not generally expect to be able to use previous days’ returns to predict future market performance. (After all, if it were possible to do so, then the authors of this book would be out striking it rich rather than writing a statistics textbook.) We recall that the logistic regression model had very underwhelming p - values associated with all of the predictors, and that the smallest p -value, though not very small, corresponded to Lag1",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_81"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Perhaps by removing the variables that appear not to be helpful in predicting Direction , we can obtain a more effective model. After all, using predictors that have no relationship with the response tends to cause a deterioration in the test error rate (since such predictors cause an increase in variance without a corresponding decrease in bias), and so removing such predictors may in turn yield an improvement. Below we refit the logistic regression using just Lag1 and Lag2 , which seemed to have the highest predictive power in the original logistic regression model. In [19]: model = MS([ 'Lag1' , 'Lag2' ]).fit(Smarket) X = model.transform(Smarket) X_train, X_test = X.loc[train], X.loc[ ∼ train] glm_train = sm.GLM(y_train, X_train, family=sm.families.Binomial()) results = glm_train.fit() probs = results.predict(exog=X_test) labels = np.array([ 'Down' ]*252) labels[probs >0.5] = 'Up' confusion_table(labels, L_test) Out[19]: Truth Down Up Predicted Down 35 35 Up 76 106 Let’s evaluate the overall accuracy as well as the accuracy within the days when logistic regression predicts an increase. In [20]: (35+106)/252,106/(106+76) Out[20]: (0.5595, 0.5824) Now the results appear to be a little better: 56% of the daily movements have been correctly predicted. It is worth noting that in this case, a much simpler strategy of predicting that the market will increase every day will also be correct 56% of the time! Hence, in terms of overall error rate, the logistic regression method is no better than the naive approach. However, the confusion matrix shows that on days when logistic regression predicts an increase in the market, it has a 58% accuracy rate. This suggests a possible trading strategy of buying on days when the model predicts an icreasing market, and avoiding trades on days when a decrease is predicted. Of course one would need to investigate more carefully whether this small improvement was real or just due to random chance",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_82"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Of course one would need to investigate more carefully whether this small improvement was real or just due to random chance. Suppose that we want to predict the returns associated with particular values of Lag1 and Lag2 . In particular, we want to predict Direction on a day when Lag1 and Lag2 equal 1 . 2 and 1 . 1 , respectively, and on a day when they equal 1 . 5 and − 0 . 8 . We do this using the predict() function. In [21]: newdata = pd.DataFrame({ 'Lag1' :[1.2, 1.5], 'Lag2' :[1.1, -0.8]}); newX = model.transform(newdata) results.predict(newX) Out[21]: 0 0.4791 1 0.4961 dtype: float64 4.7.3 Linear Discriminant Analysis We begin by performing LDA on the Smarket data, using the function LinearDiscriminantAnalysis() , which we have abbreviated LDA() . We fit Linear Discriminant Analysis() the model using only the observations before 2005. In [22]: lda = LDA(store_covariance=True) Since the LDA estimator automatically adds an intercept, we should rmove the column corresponding to the intercept in both X_train and X_test . We can also directly use the labels rather than the Boolean vectors y_train . In [23]: X_train, X_test = [M.drop(columns=[ 'intercept' ]) for M in [X_train, X_test]] lda.fit(X_train, L_train) Out[23]: LinearDiscriminantAnalysis(store_covariance=True) Here we have used the list comprehensions introduced in Section 3.6.4 . Looking at our first line above, we see that the right-hand side is a list of length two. This is because the code for M in [X_train, X_test] iterates over a list of length two. While here we loop over a list, the list comprehesion method works when looping over any iterable object. We then apply the drop() method to each element in the iteration, collecting the result .drop() in a list. The left-hand side tells Python to unpack this list of length two, assigning its elements to the variables X_train and X_test . Of course, this overwrites the previous values of X_train and X_test . Having fit the model, we can extract the means in the two classes with the means_ attribute",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_83"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Of course, this overwrites the previous values of X_train and X_test . Having fit the model, we can extract the means in the two classes with the means_ attribute. These are the average of each predictor within each class, and are used by LDA as estimates of μ k . These suggest that there is a tendency for the previous 2 days’ returns to be negative on days when the market increases, and a tendency for the previous days’ returns to be positive on days when the market declines. In [24]: lda.means_ Out[24]: array([[ 0.04, 0.03], [-0.04, -0.03]]) The estimated prior probabilities are stored in the priors_ attribute. The package sklearn typically uses this trailing _ to denote a quantity estimated when using the fit() method. We can be sure of which entry corresponds to which label by looking at the classes_ attribute. In [25]: lda.classes_ Out[25]: array([ 'Down' , 'Up' ], dtype= '<U4' ) The LDA output indicates that ˆ π Down = 0 . 492 and ˆ π Up = 0 . 508 . In [26]: lda.priors_ Out[26]: array([0.492, 0.508]) The linear discriminant vectors can be found in the scalings_ attribute: In [27]: lda.scalings_ Out[27]: array([[-0.642], [-0.513]]) These values provide the linear combination of Lag1 and Lag2 that are used to form the LDA decision rule. In other words, these are the multipliers of the elements of X = x in ( 4.24 ). If − 0 . 64 × Lag1 − 0 . 51 × Lag2 is large, then the LDA classifier will predict a market increase, and if it is small, then the LDA classifier will predict a market decline. In [28]: lda_pred = lda.predict(X_test) As we observed in our comparison of classification methods (Section 4.5 ), the LDA and logistic regression predictions are almost identical. In [29]: confusion_table(lda_pred, L_test) Out[29]: Truth Down Up Predicted Down 35 35 Up 76 106 We can also estimate the probability of each class for each point in a training set. Applying a 50% threshold to the posterior probabilities of bing in class one allows us to recreate the predictions contained in lda_pred",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_84"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Applying a 50% threshold to the posterior probabilities of bing in class one allows us to recreate the predictions contained in lda_pred . In [30]: lda_prob = lda.predict_proba(X_test) np.all( np.where(lda_prob[:,1] >= 0.5, 'Up' , 'Down' ) == lda_pred ) Out[30]: True Above, we used the np.where() function that creates an array with value np.where() 'Up' for indices where the second column of lda_prob (the estimated postrior probability of 'Up' ) is greater than 0.5. For problems with more than two classes the labels are chosen as the class whose posterior probability is highest: In [31]: np.all( [lda.classes_[i] for i in np.argmax(lda_prob, 1)] == lda_pred ) Out[31]: True If we wanted to use a posterior probability threshold other than 50% in order to make predictions, then we could easily do so. For instance, suppose that we wish to predict a market decrease only if we are very certain that the market will indeed decrease on that day — say, if the posterior probability is at least 90%. We know that the first column of lda_prob corresponds to the label Down after having checked the classes_ attribute, hence we use the column index 0 rather than 1 as we did above. In [32]: np.sum(lda_prob[:,0] > 0.9) Out[32]: 0 No days in 2005 meet that threshold! In fact, the greatest posterior proability of decrease in all of 2005 was 52.02%. The LDA classifier above is the first classifier from the sklearn library. We will use several other objects from this library. The objects follow a common structure that simplifies tasks such as cross-validation, which we will see in Chapter 5 . Specifically, the methods first create a generic classifier without referring to any data. This classifier is then fit to data with the fit() method and predictions are always produced with the predict() method. This pattern of first instantiating the classifier, followed by fitting it, and then producing predictions is an explicit design choice of sklearn",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_85"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This pattern of first instantiating the classifier, followed by fitting it, and then producing predictions is an explicit design choice of sklearn . This uniformity makes it possible to cleanly copy the classifier so that it can be fit on different data; e.g. different training sets arising in cross-validation. This standard pattern also allows for a predictable formation of workflows. 4.7.4 Quadratic Discriminant Analysis We will now fit a QDA model to the Smarket data. QDA is implemented via QuadraticDiscriminantAnalysis() in the sklearn package, which we aQuadratic Discriminant Analysis() breviate to QDA() . The syntax is very similar to LDA() . In [33]: qda = QDA(store_covariance=True) qda.fit(X_train, L_train) Out[33]: QuadraticDiscriminantAnalysis(store_covariance=True) The QDA() function will again compute means_ and priors_ . In [34]: qda.means_, qda.priors_ Out[34]: (array([[ 0.04279022, 0.03389409], [-0.03954635, -0.03132544]]), array([0.49198397, 0.50801603])) The QDA() classifier will estimate one covariance per class. Here is the estimated covariance in the first class: In [35]: qda.covariance_[0] Out[35]: array([[ 1.50662277, -0.03924806], [-0.03924806, 1.53559498]]) The output contains the group means. But it does not contain the coeficients of the linear discriminants, because the QDA classifier involves a quadratic, rather than a linear, function of the predictors. The predict() function works in exactly the same fashion as for LDA. In [36]: qda_pred = qda.predict(X_test) confusion_table(qda_pred, L_test) Out[36]: Truth Down Up Predicted Down 30 20 Up 81 121 Interestingly, the QDA predictions are accurate almost 60% of the time, even though the 2005 data was not used to fit the model. In [37]: np.mean(qda_pred == L_test) Out[37]: 0.599 This level of accuracy is quite impressive for stock market data, which is known to be quite hard to model accurately",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_86"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [37]: np.mean(qda_pred == L_test) Out[37]: 0.599 This level of accuracy is quite impressive for stock market data, which is known to be quite hard to model accurately. This suggests that the quadratic form assumed by QDA may capture the true relationship more accurately than the linear forms assumed by LDA and logistic regression. However, we recommend evaluating this method’s performance on a larger test set before betting that this approach will consistently beat the market! 4.7.5 Naive Bayes Next, we fit a naive Bayes model to the Smarket data. The syntax is similar to that of LDA() and QDA() . By default, this implementation GaussianNB() of GaussianNB() the naive Bayes classifier models each quantitative feature using a Gaussian distribution. However, a kernel density method can also be used to estimate the distributions. In [38]: NB = GaussianNB() NB.fit(X_train, L_train) Out[38]: GaussianNB() The classes are stored as classes_ . In [39]: NB.classes_ Out[39]: array([ 'Down' , 'Up' ], dtype= '<U4' ) The class prior probabilities are stored in the class_prior_ attribute. In [40]: NB.class_prior_ Out[40]: array([0.49, 0.51]) The parameters of the features can be found in the theta_ and var_ attributes. The number of rows is equal to the number of classes, while the number of columns is equal to the number of features. We see below that the mean for feature Lag1 in the Down class is 0.043. In [41]: NB.theta_ Out[41]: array([[ 0.043, 0.034], [-0.040, -0.031]]) Its variance is 1.503. In [42]: NB.var_ Out[42]: array([[1.503, 1.532], [1.514, 1.487]]) How do we know the names of these attributes? We use NB? (or ?NB ). We can easily verify the mean computation: In [43]: X_train[L_train == 'Down' ].mean() Out[43]: Lag1 0.042790 Lag2 0.033894 dtype: float64 Similarly for the variance: In [44]: X_train[L_train == 'Down' ].var(ddof=0) Out[44]: Lag1 1.503554 Lag2 1.532467 dtype: float64 The GaussianNB() function calculates variances using the 1 /n formula",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_87"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 6 Since NB() is a classifier in the sklearn library, making predictions uses the same syntax as for LDA() and QDA() above. In [45]: nb_labels = NB.predict(X_test) confusion_table(nb_labels, L_test) Out[45]: Truth Down Up Predicted Down 29 20 Up 82 121 Naive Bayes performs well on these data, with accurate predictions over 59% of the time. This is slightly worse than QDA, but much better than LDA. As for LDA , the predict_proba() method estimates the probability that each observation belongs to a particular class. In [46]: NB.predict_proba(X_test)[:5 ] Out[46]: array([[0.4873, 0.5127], [0.4762, 0.5238], [0.4653, 0.5347], [0.4748, 0.5252], [0.4902, 0.5098]]) 4.7.6 K-Nearest Neighbors We will now perform KNN using the KNeighborsClassifier() function. This KNeighbors Classifier() 6 There are two formulas for computing the sample variance of n observations x 1 , , x n : 1 n ! n i =1 ( x i − ̄ x ) 2 and 1 n − 1 ! n i =1 ( x i − ̄ x ) 2 where ̄ x is the sample mean. In most cases the distinction is not important. function works similarly to the other model-fitting functions that we have encountered thus far. As is the case for LDA and QDA, we fit the classifier using the fit method. New predictions are formed using the predict method of the object returned by fit() . In [47]: knn1 = KNeighborsClassifier(n_neighbors=1) knn1.fit(X_train, L_train) knn1_pred = knn1.predict(X_test) confusion_table(knn1_pred, L_test) Out[47]: Truth Down Up Predicted Down 43 58 Up 68 83 The results using K = 1 are not very good, since only 50% of the observtions are correctly predicted. Of course, it may be that K = 1 results in an overly-flexible fit to the data. In [48]: (83+43)/252, np.mean(knn1_pred == L_test) Out[48]: (0.5, 0.5) We repeat the analysis below using K = 3 . In [49]: knn3 = KNeighborsClassifier(n_neighbors=3) knn3_pred = knn3.fit(X_train, L_train).predict(X_test) np.mean(knn3_pred == L_test) Out[49]: 0.532 The results have improved slightly. But increasing K further provides no further improvements",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_88"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". But increasing K further provides no further improvements. It appears that for these data, and this train/test split, QDA gives the best results of the methods that we have examined so far. KNN does not perform well on the Smarket data, but it often does provide impressive results. As an example we will apply the KNN approach to the Caravan data set, which is part of the ISLP library. This data set includes 85 predictors that measure demographic characteristics for 5,822 individuals. The response variable is Purchase , which indicates whether or not a given individual purchases a caravan insurance policy. In this data set, only 6% of people purchased caravan insurance. In [50]: Caravan = load_data( 'Caravan' ) Purchase = Caravan.Purchase Purchase.value_counts() Out[50]: No 5474 Yes 348 Name: Purchase, dtype: int64 The method value_counts() takes a pd.Series or pd.DataFrame and rturns a pd.Series with the corresponding counts for each unique element. In this case Purchase has only Yes and No values and returns how many values of each there are. In [51]: 348 / 5822 Out[51]: 0.0598 Our features will include all columns except Purchase . In [52]: feature_df = Caravan.drop(columns=[ 'Purchase' ]) Because the KNN classifier predicts the class of a given test observtion by identifying the observations that are nearest to it, the scale of the variables matters. Any variables that are on a large scale will have a much larger effect on the distance between the observations, and hence on the KNN classifier, than variables that are on a small scale. For instance, imagine a data set that contains two variables, salary and age (measured in dollars and years, respectively). As far as KNN is concerned, a difference of 1,000 USD in salary is enormous compared to a difference of 50 years in age. Consequently, salary will drive the KNN classification results, and age will have almost no effect. This is contrary to our intuition that a salary difference of 1,000 USD is quite small compared to an age difference of 50 years",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_89"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This is contrary to our intuition that a salary difference of 1,000 USD is quite small compared to an age difference of 50 years. Furthermore, the importance of scale to the KNN classifier leads to another issue: if we measured salary in Japanese yen, or if we measured age in minutes, then we’d get quite different classification results from what we get if these two variables are measured in dollars and years. A good way to handle this problem is to standardize the data so that all standardize variables are given a mean of zero and a standard deviation of one. Then all variables will be on a comparable scale. This is accomplished using the StandardScaler() transformation. Standard Scaler() In [53]: scaler = StandardScaler(with_mean=True, with_std=True, copy=True) The argument with_mean indicates whether or not we should subtract the mean, while with_std indicates whether or not we should scale the columns to have standard deviation of 1 or not. Finally, the argument copy=True idicates that we will always copy data, rather than trying to do calculations in place where possible. This transformation can be fit and then applied to arbitrary data. In the first line below, the parameters for the scaling are computed and stored in scaler , while the second line actually constructs the standardized set of features. In [54]: scaler.fit(feature_df) X_std = scaler.transform(feature_df) Now every column of feature_std below has a standard deviation of one and a mean of zero. In [55]: feature_std = pd.DataFrame( X_std, columns=feature_df.columns); feature_std.std() Out[55]: MOSTYPE 1.000086 MAANTHUI 1.000086 MGEMOMV 1.000086 MGEMLEEF 1.000086 MOSHOOFD 1.000086 AZEILPL 1.000086 APLEZIER 1.000086 AFIETS 1.000086 AINBOED 1.000086 ABYSTAND 1.000086 Length: 85, dtype: float64 Notice that the standard deviations are not quite 1 here; this is again due to some procedures using the 1 /n convention for variances (in this case scaler() ), while others use 1 / ( n − 1) (the std() method). See the footnote .std() on page 183",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_90"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". See the footnote .std() on page 183 . In this case it does not matter, as long as the variables are all on the same scale. Using the function train_test_split() we now split the observations into train_test_ split() a test set, containing 1000 observations, and a training set containing the remaining observations. The argument random_state=0 ensures that we get the same split each time we rerun the code. In [56]: (X_train, X_test, y_train, y_test) = train_test_split(feature_std , Purchase, test_size=1000, random_state=0) ?train_test_split reveals that the non-keyword arguments can be lists , arrays , pandas dataframes etc that all have the same length ( shape[0] ) and hence are indexable . In this case they are the dataframe feature_std and indexable the response variable Purchase . We fit a KNN model on the training data using K = 1 , and evaluate its performance on the test data. In [57]: knn1 = KNeighborsClassifier(n_neighbors=1) knn1_pred = knn1.fit(X_train, y_train).predict(X_test) np.mean(y_test != knn1_pred), np.mean(y_test != \"No\" ) Out[57]: (0.111, 0.067) The KNN error rate on the 1,000 test observations is about 11% . At first glance, this may appear to be fairly good. However, since just over 6% of customers purchased insurance, we could get the error rate down to almost 6% by always predicting No regardless of the values of the predictors! This is known as the null rate . null rate Suppose that there is some non-trivial cost to trying to sell insurance to a given individual. For instance, perhaps a salesperson must visit each potential customer. If the company tries to sell insurance to a random selection of customers, then the success rate will be only 6%, which may be far too low given the costs involved. Instead, the company would like to try to sell insurance only to customers who are likely to buy it. So the overall error rate is not of interest. Instead, the fraction of individuals that are correctly predicted to buy insurance is of interest",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_91"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". So the overall error rate is not of interest. Instead, the fraction of individuals that are correctly predicted to buy insurance is of interest. In [58]: confusion_table(knn1_pred, y_test) Out[58]: Truth No Yes Predicted No 880 58 Yes 53 9 It turns out that KNN with K = 1 does far better than random guessing among the customers that are predicted to buy insurance. Among 62 such customers, 9, or 14.5%, actually do purchase insurance. This is double the rate that one would obtain from random guessing. In [59]: 9/(53+9) Out[59]: 0.145 Tuning Parameters The number of neighbors in KNN is referred to as a tuning parameter , also tuning parameter referred to as a hyperparameter . We do not know a priori what value to hypeparameter use. It is therefore of interest to see how the classifier performs on test data as we vary these parameters. This can be achieved with a for loop, described in Section 2.3.8 . Here we use a for loop to look at the accuracy of our classifier in the group predicted to purchase insurance as we vary the number of neighbors from 1 to 5: In [60]: for K in range(1,6): knn = KNeighborsClassifier(n_neighbors=K) knn_pred = knn.fit(X_train, y_train).predict(X_test) C = confusion_table(knn_pred, y_test) templ = ( 'K={0:d}: # predicted to rent: {1:>2},' + ' # who did rent {2:d}, accuracy {3:.1%}' ) pred = C.loc[ 'Yes' ].sum() did_rent = C.loc[ 'Yes' , 'Yes' ] print(templ.format( K, pred, did_rent, did_rent / pred)) K=1: # predicted to rent: 62,# who did rent 9, accuracy 14.5% K=2: # predicted to rent: 6,# who did rent 1, accuracy 16.7% K=3: # predicted to rent: 20,# who did rent 3, accuracy 15.0% K=4: # predicted to rent: 3,# who did rent 0, accuracy 0.0% K=5: # predicted to rent: 7,# who did rent 1, accuracy 14.3% We see some variability — the numbers for K=4 are very different from the rest. Comparison to Logistic Regression As a comparison, we can also fit a logistic regression model to the data",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_92"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Comparison to Logistic Regression As a comparison, we can also fit a logistic regression model to the data. This can also be done with sklearn , though by default it fits something like the ridge regression version of logistic regression, which we introduce in Chapter 6 . This can be modified by appropriately setting the argument C below. Its default value is 1 but by setting it to a very large number, the algorithm converges to the same solution as the usual (unregularized) logistic regression estimator discussed above. Unlike the statsmodels package, sklearn focuses less on inference and more on classification. Hence, the summary methods seen in statsmodels and our simplified version seen with summarize are not generally available for the classifiers in sklearn . In [61]: logit = LogisticRegression(C=1e10, solver= 'liblinear' ) logit.fit(X_train, y_train) logit_pred = logit.predict_proba(X_test) logit_labels = np.where(logit_pred[:,1] > 5, 'Yes' , 'No' ) confusion_table(logit_labels , y_test) Out[61]: Truth No Yes Predicted No 933 67 Yes 0 0 We used the argument solver='liblinear' above to avoid a warning with the default solver which would indicate that the algorithm does not coverge. If we use 0 . 5 as the predicted probability cut-off for the classifier, then we have a problem: none of the test observations are predicted to purchase insurance. However, we are not required to use a cut-off of 0 . 5 . If we instead predict a purchase any time the predicted probability of purchase exceeds 0 . 25 , we get much better results: we predict that 29 people will purchase insurance, and we are correct for about 31% of these people",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_93"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 25 , we get much better results: we predict that 29 people will purchase insurance, and we are correct for about 31% of these people. This is almost five times better than random guessing! In [62]: logit_labels = np.where(logit_pred[:,1]>0.25, 'Yes' , 'No' ) confusion_table(logit_labels , y_test) Out[62]: Truth No Yes Predicted No 913 58 Yes 20 9 In [63]: 9/(20+9) Out[63]: 0.310 4.7.7 Linear and Poisson Regression on the Bikeshare Data Here we fit linear and Poisson regression models to the Bikeshare data, as described in Section 4.6 . The response bikers measures the number of bike rentals per hour in Washington, DC in the period 2010–2012. In [64]: Bike = load_data( 'Bikeshare' ) Let’s have a peek at the dimensions and names of the variables in this dataframe. In [65]: Bike.shape, Bike.columns Out[65]: ((8645, 15), Index([ 'season' , 'mnth' , 'day' , 'hr' , 'holiday' , 'weekday' , 'workingday' , 'weathersit' , 'temp' , 'atemp' , 'hum' , 'windspeed' , 'casual' , 'registered' , 'bikers' ], dtype= 'object' )) Linear Regression We begin by fitting a linear regression model to the data. In [66]: X = MS([ 'mnth' , 'hr' , 'workingday' , 'temp' , 'weathersit' ]).fit_transform(Bike) Y = Bike[ 'bikers' ] M_lm = sm.OLS(Y, X).fit() summarize(M_lm) Out[66]: coef std err t P>|t| intercept -68.6317 5.307 -12.932 0.000 mnth[Feb] 6.8452 4.287 1.597 0.110 mnth[March] 16.5514 4.301 3.848 0.000 mnth[April] 41.4249 4.972 8.331 0.000 mnth[May] 72.5571 5.641 12.862 0.000 mnth[June] 67.8187 6.544 10.364 0.000 mnth[July] 45.3245 7.081 6.401 0.000 mnth[Aug] 53.2430 6.640 8.019 0.000 mnth[Sept] 66.6783 5.925 11.254 0.000 mnth[Oct] 75.8343 4.950 15.319 0.000 mnth[Nov] 60.3100 4.610 13.083 0.000 mnth[Dec] 46.4577 4.271 10.878 0.000 hr[1] -14.5793 5.699 -2.558 0.011 hr[2] -21.5791 5.733 -3.764 0.000 hr[3] -31.1408 5.778 -5.389 0.000 There are 24 levels in hr and 40 rows in all, so we have truncated the summary",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_94"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In M_lm , the first levels hr[0] and mnth[Jan] are treated as the baseline values, and so no coefficient estimates are provided for them: iplicitly, their coefficient estimates are zero, and all other levels are measured relative to these baselines. For example, the Feb coefficient of 6 . 845 signfies that, holding all other variables constant, there are on average about 7 more riders in February than in January. Similarly there are about 16.5 more riders in March than in January. The results seen in Section 4.6.1 used a slightly different coding of the variables hr and mnth , as follows: In [67]: hr_encode = contrast( 'hr' , 'sum' ) mnth_encode = contrast( 'mnth' , 'sum' ) Refitting again: In [68]: X2 = MS([mnth_encode , hr_encode, 'workingday' , 'temp' , 'weathersit' ]).fit_transform(Bike) M2_lm = sm.OLS(Y, X2).fit() S2 = summarize(M2_lm) S2 Out[68]: coef std err t P>|t| intercept 73.5974 5.132 14.340 0.000 mnth[Jan] -46.0871 4.085 -11.281 0.000 mnth[Feb] -39.2419 3.539 -11.088 0.000 mnth[March] -29.5357 3.155 -9.361 0.000 mnth[April] -4.6622 2.741 -1.701 0.089 mnth[May] 26.4700 2.851 9.285 0.000 mnth[June] 21.7317 3.465 6.272 0.000 mnth[July] -0.7626 3.908 -0.195 0.845 mnth[Aug] 7.1560 3.535 2.024 0.043 mnth[Sept] 20.5912 3.046 6.761 0.000 mnth[Oct] 29.7472 2.700 11.019 0.000 mnth[Nov] 14.2229 2.860 4.972 0.000 hr[0] -96.1420 3.955 -24.307 0.000 hr[1] -110.7213 3.966 -27.916 0.000 hr[2] -117.7212 4.016 -29.310 0.000 What is the difference between the two codings? In M2_lm , a coefficient estmate is reported for all but level 23 of hr and level Dec of mnth . Importantly, in M2_lm , the (unreported) coefficient estimate for the last level of mnth is not zero: instead, it equals the negative of the sum of the coefficient estmates for all of the other levels. Similarly, in M2_lm , the coefficient estimate for the last level of hr is the negative of the sum of the coefficient estimates for all of the other levels",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_95"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Similarly, in M2_lm , the coefficient estimate for the last level of hr is the negative of the sum of the coefficient estimates for all of the other levels. This means that the coefficients of hr and mnth in M2_lm will always sum to zero, and can be interpreted as the difference from the mean level. For example, the coefficient for January of − 46 . 087 indicates that, holding all other variables constant, there are typically 46 fewer riders in January relative to the yearly average. It is important to realize that the choice of coding really does not matter, provided that we interpret the model output correctly in light of the coding used. For example, we see that the predictions from the linear model are the same regardless of coding: In [69]: np.sum((M_lm.fittedvalues - M2_lm.fittedvalues)**2) Out[69]: 1.53e-20 The sum of squared differences is zero. We can also see this using the np.allclose() function: np.allclose() In [70]: np.allclose(M_lm.fittedvalues , M2_lm.fittedvalues) Out[70]: True To reproduce the left-hand side of Figure 4.13 we must first obtain the coefficient estimates associated with mnth . The coefficients for January through November can be obtained directly from the M2_lm object. The coefficient for December must be explicitly computed as the negative sum of all the other months. We first extract all the coefficients for month from the coefficients of M2_lm . In [71]: coef_month = S2[S2.index.str.contains( 'mnth' )][ 'coef' ] coef_month Out[71]: mnth[Jan] -46.0871 mnth[Feb] -39.2419 mnth[March] -29.5357 mnth[April] -4.6622 mnth[May] 26.4700 mnth[June] 21.7317 mnth[July] -0.7626 mnth[Aug] 7.1560 mnth[Sept] 20.5912 mnth[Oct] 29.7472 mnth[Nov] 14.2229 Name: coef, dtype: float64 Next, we append Dec as the negative of the sum of all other months",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_96"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [72]: months = Bike[ 'mnth' ].dtype.categories coef_month = pd.concat([ coef_month, pd.Series([-coef_month.sum()], index=[ 'mnth[Dec]' ]) ]) coef_month Out[72]: mnth[Jan] -46.0871 mnth[Feb] -39.2419 mnth[March] -29.5357 mnth[April] -4.6622 mnth[May] 26.4700 mnth[June] 21.7317 mnth[July] -0.7626 mnth[Aug] 7.1560 mnth[Sept] 20.5912 mnth[Oct] 29.7472 mnth[Nov] 14.2229 mnth[Dec] 0.3705 Name: coef, dtype: float64 Finally, to make the plot neater, we’ll just use the first letter of each month, which is the 6 th entry of each of the labels in the index. In [73]: fig_month, ax_month = subplots(figsize=(8,8)) x_month = np.arange(coef_month.shape[0]) ax_month.plot(x_month, coef_month , marker= 'o' , ms=10) ax_month.set_xticks(x_month) ax_month.set_xticklabels([l[5] for l in coef_month.index], fontsize =20) ax_month.set_xlabel( 'Month' , fontsize=20) ax_month.set_ylabel( 'Coeff icient ' , fontsize=20); Reproducing the right-hand plot in Figure 4.13 follows a similar process. In [74]: coef_hr = S2[S2.index.str.contains( 'hr' )][ 'coef' ] coef_hr = coef_hr.reindex([ 'hr[{0}]' .format(h) for h in range(23)]) coef_hr = pd.concat([coef_hr, pd.Series([-coef_hr.sum()], index=[ 'hr[23]' ]) ]) We now make the hour plot. In [75]: fig_hr, ax_hr = subplots(figsize=(8,8)) x_hr = np.arange(coef_hr.shape[0]) ax_hr.plot(x_hr, coef_hr, marker= 'o' , ms=10) ax_hr.set_xticks(x_hr[::2]) ax_hr.set_xticklabels(range(24)[::2], fontsize=20) ax_hr.set_xlabel( 'Hour' , fontsize=20) ax_hr.set_ylabel( 'Coefficient' , fontsize=20); Poisson Regression Now we fit instead a Poisson regression model to the Bikeshare data. Very little changes, except that we now use the function sm.GLM() with the Poison family specified: In [76]: M_pois = sm.GLM(Y, X2, family=sm.families.Poisson()).fit() We can plot the coefficients associated with mnth and hr , in order to reproduce Figure 4.15 . We first complete these coefficients as before",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_97"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We first complete these coefficients as before. In [77]: S_pois = summarize(M_pois) coef_month = S_pois[S_pois.index.str.contains( 'mnth' )][ 'coef' ] coef_month = pd.concat([coef_month, pd.Series([-coef_month.sum()], index=[ 'mnth[Dec]' ])]) coef_hr = S_pois[S_pois.index.str.contains( 'hr' )][ 'coef' ] coef_hr = pd.concat([coef_hr, pd.Series([-coef_hr.sum()], index=[ 'hr[23]' ])]) The plotting is as before. In [78]: fig_pois, (ax_month, ax_hr) = subplots(1, 2, figsize=(16,8)) ax_month.plot(x_month, coef_month , marker= 'o' , ms=10) ax_month.set_xticks(x_month) ax_month.set_xticklabels([l[5] for l in coef_month.index], fontsize =20) ax_month.set_xlabel( 'Month' , fontsize=20) ax_month.set_ylabel( 'Coefficient' , fontsize=20) ax_hr.plot(x_hr, coef_hr, marker= 'o' , ms=10) ax_hr.set_xticklabels(range(24)[::2], fontsize=20) ax_hr.set_xlabel( 'Hour' , fontsize=20) ax_hr.set_ylabel( 'Coefficient' , fontsize=20); We compare the fitted values of the two models. The fitted values are stored in the fittedvalues attribute returned by the fit() method for both the linear regression and the Poisson fits. The linear predictors are stored as the attribute lin_pred . In [79]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(M2_lm.fittedvalues , M_pois.fittedvalues , s=20) ax.set_xlabel( 'Linear Regression Fit' , fontsize=20) ax.set_ylabel( 'Poisson Regression Fit' , fontsize=20) ax.axline([0,0], c= 'black' , linewidth=3, linestyle= '--' , slope=1); The predictions from the Poisson regression model are correlated with those from the linear model; however, the former are non-negative. As a result the Poisson regression predictions tend to be larger than those from the linear model for either very low or very high levels of ridership. In this section, we fit Poisson regression models using the sm.GLM() funtion with the argument family=sm.families.Poisson() . Earlier in this lab we used the sm.GLM() function with family=sm.families.Binomial() to peform logistic regression",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_98"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Earlier in this lab we used the sm.GLM() function with family=sm.families.Binomial() to peform logistic regression. Other choices for the family argument can be used to fit other types of GLMs. For instance, family=sm.families.Gamma() fits a Gamma regression model. 4.8 Exercises Conceptual 1. Using a little bit of algebra, prove that ( 4.2 ) is equivalent to ( 4.3 ). In other words, the logistic function representation and logit represetation for the logistic regression model are equivalent. 2. It was stated in the text that classifying an observation to the class for which ( 4.17 ) is largest is equivalent to classifying an observation to the class for which ( 4.18 ) is largest. Prove that this is the case. In other words, under the assumption that the observations in the k th class are drawn from a N ( μ k , σ 2 ) distribution, the Bayes classifier assigns an observation to the class for which the discriminant function is maximized. 3. This problem relates to the QDA model, in which the observations within each class are drawn from a normal distribution with a classpecific mean vector and a class specific covariance matrix. We cosider the simple case where p = 1 ; i.e. there is only one feature. Suppose that we have K classes, and that if an observation belongs to the k th class then X comes from a one-dimensional normal ditribution, X ∼ N ( μ k , σ 2 k ) . Recall that the density function for the one-dimensional normal distribution is given in ( 4.16 ). Prove that in this case, the Bayes classifier is not linear. Argue that it is in fact quadratic. Hint: For this problem, you should follow the arguments laid out in Section 4.4.1 , but without making the assumption that σ 2 1 = · · · = σ 2 K . 4. When the number of features p is large, there tends to be a deteroration in the performance of KNN and other local approaches that perform prediction using only observations that are near the test oservation for which a prediction must be made",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_99"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This phenomenon is known as the curse of dimensionality , and it ties into the fact that curse of dmensionality non-parametric approaches often perform poorly when p is large. We will now investigate this curse. (a) Suppose that we have a set of observations, each with measurments on p = 1 feature, X . We assume that X is uniformly (evenly) distributed on [0 , 1] . Associated with each observation is a response value. Suppose that we wish to predict a test obsevation’s response using only observations that are within 10 % of the range of X closest to that test observation. For instance, in order to predict the response for a test observation with X = 0 . 6 , we will use observations in the range [0 . 55 , 0 . 65] . On average, what fraction of the available observations will we use to make the prediction? (b) Now suppose that we have a set of observations, each with measurements on p = 2 features, X 1 and X 2 . We assume that ( X 1 , X 2 ) are uniformly distributed on [0 , 1] × [0 , 1] . We wish to predict a test observation’s response using only observations that are within 10 % of the range of X 1 and within 10 % of the range of X 2 closest to that test observation. For instance, in order to predict the response for a test observation with X 1 = 0 . 6 and X 2 = 0 . 35 , we will use observations in the range [0 . 55 , 0 . 65] for X 1 and in the range [0 . 3 , 0 . 4] for X 2 . On average, what fraction of the available observations will we use to make the prediction? (c) Now suppose that we have a set of observations on p = 100 fetures. Again the observations are uniformly distributed on each feature, and again each feature ranges in value from 0 to 1. We wish to predict a test observation’s response using observations within the 10 % of each feature’s range that is closest to that test observation",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_100"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We wish to predict a test observation’s response using observations within the 10 % of each feature’s range that is closest to that test observation. What fraction of the available observations will we use to make the prediction? (d) Using your answers to parts (a)–(c), argue that a drawback of KNN when p is large is that there are very few training obsevations “near” any given test observation. (e) Now suppose that we wish to make a prediction for a test obsevation by creating a p -dimensional hypercube centered around the test observation that contains, on average, 10 % of the traiing observations. For p = 1 , 2 , and 100 , what is the length of each side of the hypercube? Comment on your answer. Note: A hypercube is a generalization of a cube to an arbitrary number of dimensions. When p = 1 , a hypercube is simply a line segment, when p = 2 it is a square, and when p = 100 it is a 100-dimensional cube. 5. We now examine the differences between LDA and QDA. (a) If the Bayes decision boundary is linear, do we expect LDA or QDA to perform better on the training set? On the test set? (b) If the Bayes decision boundary is non-linear, do we expect LDA or QDA to perform better on the training set? On the test set? (c) In general, as the sample size n increases, do we expect the test prediction accuracy of QDA relative to LDA to improve, decline, or be unchanged? Why? (d) True or False: Even if the Bayes decision boundary for a given problem is linear, we will probably achieve a superior test eror rate using QDA rather than LDA because QDA is flexible enough to model a linear decision boundary. Justify your aswer. 6. Suppose we collect data for a group of students in a statistics class with variables X 1 = hours studied, X 2 = undergrad GPA, and Y = receive an A. We fit a logistic regression and produce estimated coefficient, ˆ β 0 = − 6 , ˆ β 1 = 0 . 05 , ˆ β 2 = 1 . (a) Estimate the probability that a student who studies for 40 h and has an undergrad GPA of 3 . 5 gets an A in the class",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_101"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 05 , ˆ β 2 = 1 . (a) Estimate the probability that a student who studies for 40 h and has an undergrad GPA of 3 . 5 gets an A in the class. (b) How many hours would the student in part (a) need to study to have a 50 % chance of getting an A in the class? 7. Suppose that we wish to predict whether a given stock will issue a dividend this year (“Yes” or “No”) based on X , last year’s percent profit. We examine a large number of companies and discover that the mean value of X for companies that issued a dividend was ̄ X = 10 , while the mean for those that didn’t was ̄ X = 0 . In addition, the variance of X for these two sets of companies was ˆ σ 2 = 36 . Finally, 80 % of companies issued dividends. Assuming that X follows a nomal distribution, predict the probability that a company will issue a dividend this year given that its percentage profit was X = 4 last year. Hint: Recall that the density function for a normal random variable is f ( x ) = 1 √ 2 πσ 2 e − ( x − μ ) 2 / 2 σ 2 . You will need to use Bayes’ theorem. 8. Suppose that we take a data set, divide it into equally-sized training and test sets, and then try out two different classification procedures. First we use logistic regression and get an error rate of 20 % on the training data and 30 % on the test data. Next we use 1-nearest neigbors (i.e. K = 1 ) and get an average error rate (averaged over both test and training data sets) of 18 %. Based on these results, which method should we prefer to use for classification of new observations? Why? 9. This problem has to do with odds . (a) On average, what fraction of people with an odds of 0.37 of defaulting on their credit card payment will in fact default? (b) Suppose that an individual has a 16 % chance of defaulting on her credit card payment. What are the odds that she will dfault? 10",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_102"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". What are the odds that she will dfault? 10. Equation 4.32 derived an expression for log 1 Pr( Y = k | X = x ) Pr( Y = K | X = x ) 2 in the setting where p > 1 , so that the mean for the k th class, μ k , is a p - dimensional vector, and the shared covariance Σ is a p × p matrix. However, in the setting with p = 1 , ( 4.32 ) takes a simpler form, since the means μ 1 , , μ K and the variance σ 2 are scalars. In this simpler setting, repeat the calculation in ( 4.32 ), and provide expressions for a k and b kj in terms of π k , π K , μ k , μ K , and σ 2 . 11. Work out the detailed forms of a k , b kj , and b kjl in ( 4.33 ). Your answer should involve π k , π K , μ k , μ K , Σ k , and Σ K . 12. Suppose that you wish to classify an observation X ∈ R into apples and oranges . You fit a logistic regression model and find that 6 Pr( Y = orange | X = x ) = exp( ˆ β 0 + ˆ β 1 x ) 1 + exp( ˆ β 0 + ˆ β 1 x ) . Your friend fits a logistic regression model to the same data using the softmax formulation in ( 4.13 ), and finds that 6 Pr( Y = orange | X = x ) = exp(ˆ α orange 0 + ˆ α orange 1 x ) exp(ˆ α orange 0 + ˆ α orange 1 x ) + exp(ˆ α apple 0 + ˆ α apple 1 x ) . (a) What is the log odds of orange versus apple in your model? (b) What is the log odds of orange versus apple in your friend’s model? (c) Suppose that in your model, ˆ β 0 = 2 and ˆ β 1 = − 1 . What are the coefficient estimates in your friend’s model? Be as specific as possible. (d) Now suppose that you and your friend fit the same two models on a different data set. This time, your friend gets the coefficient estimates ˆ α orange 0 = 1 . 2 , ˆ α orange 1 = − 2 , ˆ α orange 0 = 3 , ˆ α orange 1 = 0 . 6 . What are the coefficient estimates in your model? (e) Finally, suppose you apply both models from (d) to a data set with 2,000 test observations. What fraction of the time do you expect the predicted class labels from your model to agree with those from your friend’s model? Explain your answer. Applied 13",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_103"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". What fraction of the time do you expect the predicted class labels from your model to agree with those from your friend’s model? Explain your answer. Applied 13. This question should be answered using the Weekly data set, which is part of the ISLP package. This data is similar in nature to the Smarket data from this chapter’s lab, except that it contains 1 , 089 weekly returns for 21 years, from the beginning of 1990 to the end of 2010. (a) Produce some numerical and graphical summaries of the Weekly data. Do there appear to be any patterns? (b) Use the full data set to perform a logistic regression with Direction as the response and the five lag variables plus Volume as predictors. Use the summary function to print the results. Do any of the predictors appear to be statistically significant? If so, which ones? (c) Compute the confusion matrix and overall fraction of correct predictions. Explain what the confusion matrix is telling you about the types of mistakes made by logistic regression. (d) Now fit the logistic regression model using a training data period from 1990 to 2008, with Lag2 as the only predictor. Compute the confusion matrix and the overall fraction of correct predictions for the held out data (that is, the data from 2009 and 2010). (e) Repeat (d) using LDA. (f) Repeat (d) using QDA. (g) Repeat (d) using KNN with K = 1 . (h) Repeat (d) using naive Bayes. (i) Which of these methods appears to provide the best results on this data? (j) Experiment with different combinations of predictors, incluing possible transformations and interactions, for each of the methods. Report the variables, method, and associated confsion matrix that appears to provide the best results on the held out data. Note that you should also experiment with values for K in the KNN classifier. 14. In this problem, you will develop a model to predict whether a given car gets high or low gas mileage based on the Auto data set",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_104"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 14. In this problem, you will develop a model to predict whether a given car gets high or low gas mileage based on the Auto data set. (a) Create a binary variable, mpg01 , that contains a 1 if mpg contains a value above its median, and a 0 if mpg contains a value below its median. You can compute the median using the median() method of the data frame. Note you may find it helpful to add a column mpg01 to the data frame by assignment. Assuming you have stored the data frame as Auto , this can be done as follows: Auto[ 'mpg01' ] = mpg01 (b) Explore the data graphically in order to investigate the assocation between mpg01 and the other features. Which of the other features seem most likely to be useful in predicting mpg01 ? Scaterplots and boxplots may be useful tools to answer this quetion. Describe your findings. (c) Split the data into a training set and a test set. (d) Perform LDA on the training data in order to predict mpg01 using the variables that seemed most associated with mpg01 in (b). What is the test error of the model obtained? (e) Perform QDA on the training data in order to predict mpg01 using the variables that seemed most associated with mpg01 in (b). What is the test error of the model obtained? (f) Perform logistic regression on the training data in order to prdict mpg01 using the variables that seemed most associated with mpg01 in (b). What is the test error of the model obtained? (g) Perform naive Bayes on the training data in order to predict mpg01 using the variables that seemed most associated with mpg01 in (b). What is the test error of the model obtained? (h) Perform KNN on the training data, with several values of K , in order to predict mpg01 . Use only the variables that seemed most associated with mpg01 in (b). What test errors do you obtain? Which value of K seems to perform the best on this data set? 15. This problem involves writing functions. (a) Write a function, Power() , that prints out the result of raising 2 to the 3 rd power",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_105"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This problem involves writing functions. (a) Write a function, Power() , that prints out the result of raising 2 to the 3 rd power. In other words, your function should compute 2 3 and print out the results. Hint: Recall that x**a raises x to the power a . Use the print() function to display the result. (b) Create a new function, Power2() , that allows you to pass any two numbers, x and a , and prints out the value of x**a . You can do this by beginning your function with the line def Power2(x, a): You should be able to call your function by entering, for instance, Power2(3, 8) on the command line. This should output the value of 3 8 , namely, 6 , 561 . (c) Using the Power2() function that you just wrote, compute 10 3 , 8 17 , and 131 3 . (d) Now create a new function, Power3() , that actually returns the result x**a as a Python object, rather than simply printing it to the screen. That is, if you store the value x**a in an object called result within your function, then you can simply return return this result, using the following line: return result Note that the line above should be the last line in your function, and it should be indented 4 spaces. (e) Now using the Power3() function, create a plot of f ( x ) = x 2 . The x -axis should display a range of integers from 1 to 10 , and the y -axis should display x 2 . Label the axes appropriately, and use an appropriate title for the figure. Consider displaying either the x -axis, the y -axis, or both on the log-scale. You can do this by using the ax.set_xscale() and ax.set_yscale() methods of .set_xscale() .set_yscale() the axes you are plotting to. (f) Create a function, PlotPower() , that allows you to create a plot of x against x**a for a fixed a and a sequence of values of x . For instance, if you call PlotPower(np.arange(1, 11), 3) then a plot should be created with an x -axis taking on values 1 , 2 , , 10 , and a y -axis taking on values 1 3 , 2 3 , , 10 3 . 16",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_106"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For instance, if you call PlotPower(np.arange(1, 11), 3) then a plot should be created with an x -axis taking on values 1 , 2 , , 10 , and a y -axis taking on values 1 3 , 2 3 , , 10 3 . 16. Using the Boston data set, fit classification models in order to predict whether a given suburb has a crime rate above or below the median. Explore logistic regression, LDA, naive Bayes, and KNN models using various subsets of the predictors. Describe your findings. Hint: You will have to create the response variable yourself, using the variables that are contained in the Boston data set. 5 Resampling Methods Resampling methods are an indispensable tool in modern statistics. They involve repeatedly drawing samples from a training set and refitting a model of interest on each sample in order to obtain additional information about the fitted model. For example, in order to estimate the variability of a linear regression fit, we can repeatedly draw different samples from the training data, fit a linear regression to each new sample, and then examine the extent to which the resulting fits differ. Such an approach may allow us to obtain information that would not be available from fitting the model only once using the original training sample. Resampling approaches can be computationally expensive, because they involve fitting the same statistical method multiple times using different subsets of the training data. However, due to recent advances in computing power, the computational requirements of resampling methods generally are not prohibitive. In this chapter, we discuss two of the most commonly used resampling methods, cross-validation and the bootstrap . Both methods are important tools in the practical application of many statistical learning procedures. For example, cross-validation can be used to estimate the test error associated with a given statistical learning method in order to evaluate its performance, or to select the appropriate level of flexibility",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_107"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The process of evaluating a model’s performance is known as model assessment , whereas model assessment the process of selecting the proper level of flexibility for a model is known as model selection . The bootstrap is used in several contexts, most commonly model selection to provide a measure of accuracy of a parameter estimate or of a given statistical learning method. 201 5.1 Cross-Validation In Chapter 2 we discuss the distinction between the test error rate and the training error rate . The test error is the average error that results from using a statistical learning method to predict the response on a new observation— that is, a measurement that was not used in training the method. Given a data set, the use of a particular statistical learning method is warranted if it results in a low test error. The test error can be easily calculated if a designated test set is available. Unfortunately, this is usually not the case. In contrast, the training error can be easily calculated by applying the statistical learning method to the observations used in its training. But as we saw in Chapter 2 , the training error rate often is quite different from the test error rate, and in particular the former can dramatically underestimate the latter. In the absence of a very large designated test set that can be used to directly estimate the test error rate, a number of techniques can be used to estimate this quantity using the available training data. Some methods make a mathematical adjustment to the training error rate in order to estimate the test error rate. Such approaches are discussed in Chapter 6 . In this section, we instead consider a class of methods that estimate the test error rate by holding out a subset of the training observations from the fitting process, and then applying the statistical learning method to those held out observations. In Sections 5.1.1 – 5.1.4 , for simplicity we assume that we are interested in performing regression with a quantitative response",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_108"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In Sections 5.1.1 – 5.1.4 , for simplicity we assume that we are interested in performing regression with a quantitative response. In Section 5.1.5 we consider the case of classification with a qualitative response. As we will see, the key concepts remain the same regardless of whether the response is quantitative or qualitative. 5.1.1 The Validation Set Approach Suppose that we would like to estimate the test error associated with fiting a particular statistical learning method on a set of observations. The validation set approach , displayed in Figure 5.1 , is a very simple strategy validation set approach for this task. It involves randomly dividing the available set of observtions into two parts, a training set and a validation set or hold-out set . The validation set hold-out set model is fit on the training set, and the fitted model is used to predict the responses for the observations in the validation set. The resulting validation set error rate—typically assessed using MSE in the case of a quantitative response—provides an estimate of the test error rate. We illustrate the validation set approach on the Auto data set. Recall from Chapter 3 that there appears to be a non-linear relationship between mpg and horsepower , and that a model that predicts mpg using horsepower and horsepower 2 gives better results than a model that uses only a linear term. It is natural to wonder whether a cubic or higher-order fit might provide even better results. We answer this question in Chapter 3 by looking at the p-values associated with a cubic term and higher-order polynomial terms in a linear regression. But we could also answer this question using the validation method. We randomly split the 392 observations into two",
    "chunk_id": "an_introduction_to_statistical_learning_page-135-199.json_chunk_109"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "0 50 100 200 300 5 10 15 20 25 TV Sales 0 10 20 30 40 50 5 10 15 20 25 Radio Sales 0 20 40 60 80 100 5 10 15 20 25 Newspaper Sales FIGURE 2.1. The Advertising data set. The plot displays sales , in thousands of units, as a function of TV , radio , and newspaper budgets, in thousands of dollars, for 200 different markets. In each plot we show the simple least squares fit of sales to that variable, as described in Chapter 3 . In other words, each blue line represents a simple model that can be used to predict sales using TV , radio , and newspaper , respectively. Here f is some fixed but unknown function of X 1 , , X p , and ε is a random error term , which is independent of X and has mean zero. In this formulerror term tion, f represents the systematic information that X provides about Y . systematic 10 12 14 16 18 20 22 20 30 40 50 60 70 80 Years of Education Income 10 12 14 16 18 20 22 20 30 40 50 60 70 80 Years of Education Income FIGURE 2.2. The Income data set. Left: The red dots are the observed values of income (in thousands of dollars) and years of education for 30 individuals. Right: The blue curve represents the true underlying relationship between income and years of education , which is generally unknown (but is known in this case because the data were simulated). The black lines represent the error associated with each observation. Note that some errors are positive (if an observation lies above the blue curve) and some are negative (if an observation lies below the curve). Overall, these errors have approximately mean zero. As another example, consider the left-hand panel of Figure 2.2 , a plot of income versus years of education for 30 individuals in the Income data set. The plot suggests that one might be able to predict income using years of education . However, the function f that connects the input variable to the output variable is in general unknown. In this situation one must estimate f based on the observed points",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, the function f that connects the input variable to the output variable is in general unknown. In this situation one must estimate f based on the observed points. Since Income is a simulated data set, f is known and is shown by the blue curve in the right-hand panel of Figure 2.2 . The vertical lines represent the error terms ε . We note that some of the 30 observations lie above the blue curve and some lie below it; overall, the errors have approximately mean zero. In general, the function f may involve more than one input variable. In Figure 2.3 we plot income as a function of years of education and seniority . Here f is a two-dimensional surface that must be estimated based on the observed data. In essence, statistical learning refers to a set of approaches for estimating f . In this chapter we outline some of the key theoretical concepts that arise in estimating f , as well as tools for evaluating the estimates obtained. 2.1.1 Why Estimate f ? There are two main reasons that we may wish to estimate f : prediction and inference . We discuss each in turn. Prediction In many situations, a set of inputs X are readily available, but the output Y cannot be easily obtained. In this setting, since the error term averages to zero, we can predict Y using ˆ Y = ˆ f ( X ) , (2.2) where ˆ f represents our estimate for f , and ˆ Y represents the resulting prdiction for Y . In this setting, ˆ f is often treated as a black box , in the sense that one is not typically concerned with the exact form of ˆ f , provided that it yields accurate predictions for Y . As an example, suppose that X 1 , , X p are characteristics of a patient’s blood sample that can be easily measured in a lab, and Y is a variable encoding the patient’s risk for a severe adverse reaction to a particular drug. It is natural to seek to predict Y using X , since we can then avoid giving the drug in question to patients who are at high risk of an adverse reaction—that is, patients for whom the estimate of Y is high",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The accuracy of ˆ Y as a prediction for Y depends on two quantities, which we will call the reducible error and the irreducible error . In general, reducible error irreducible error ˆ f will not be a perfect estimate for f , and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracy of ˆ f by using the most appropriate statistical learning technique to estimate f . However, even if it were possible to form a perfect estimate for f , so that our estimated response took the form ˆ Y = f ( X ) , our prediction would still have some error in it! This is because Y is also a function of ε , which, by definition, cannot be predicted using X . Therefore, variability associated with ε also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate f , we cannot reduce the error introduced by ε . Why is the irreducible error larger than zero? The quantity ε may cotain unmeasured variables that are useful in predicting Y : since we don’t Years of Education Seniority Income FIGURE 2.3. The plot displays income as a function of years of education and seniority in the Income data set. The blue surface represents the true underlying relationship between income and years of education and seniority , which is known since the data are simulated. The red dots indicate the observed values of these quantities for 30 individuals. measure them, f cannot use them for its prediction. The quantity ε may also contain unmeasurable variation. For example, the risk of an adverse reaction might vary for a given patient on a given day, depending on manufacturing variation in the drug itself or the patient’s general feeling of well-being on that day. Consider a given estimate ˆ f and a set of predictors X , which yields the prediction ˆ Y = ˆ f ( X ) . Assume for a moment that both ˆ f and X are fixed, so that the only variability comes from ε",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Consider a given estimate ˆ f and a set of predictors X , which yields the prediction ˆ Y = ˆ f ( X ) . Assume for a moment that both ˆ f and X are fixed, so that the only variability comes from ε . Then, it is easy to show that E( Y − ˆ Y ) 2 = E[ f ( X ) + ε − ˆ f ( X )] 2 = [ f ( X ) − ˆ f ( X )] 2 , - . / Reducible + Var( ε ) , -. / Irreducible , (2.3) where E( Y − ˆ Y ) 2 represents the average, or expected value , of the squared expected value difference between the predicted and actual value of Y , and Var( ε ) reprsents the variance associated with the error term ε . variance The focus of this book is on techniques for estimating f with the aim of minimizing the reducible error. It is important to keep in mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for Y . This bound is almost always unknown in practice. Inference We are often interested in understanding the association between Y and X 1 , , X p . In this situation we wish to estimate f , but our goal is not necessarily to make predictions for Y . Now ˆ f cannot be treated as a black box, because we need to know its exact form. In this setting, one may be interested in answering the following questions: • Which predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with Y . Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application. • What is the relationship between the response and each predictor? Some predictors may have a positive relationship with Y , in the sense that larger values of the predictor are associated with larger values of Y . Other predictors may have the opposite relationship. Depending on the complexity of f , the relationship between the response and a given predictor may also depend on the values of the other predictors",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Depending on the complexity of f , the relationship between the response and a given predictor may also depend on the values of the other predictors. • Can the relationship between Y and each predictor be adequately sumarized using a linear equation, or is the relationship more complcated? Historically, most methods for estimating f have taken a linear form. In some situations, such an assumption is reasonable or even dsirable. But often the true relationship is more complicated, in which case a linear model may not provide an accurate representation of the relationship between the input and output variables. In this book, we will see a number of examples that fall into the prediction setting, the inference setting, or a combination of the two. For instance, consider a company that is interested in conducting a direct-marketing campaign. The goal is to identify individuals who are likely to respond positively to a mailing, based on observations of demgraphic variables measured on each individual. In this case, the demgraphic variables serve as predictors, and response to the marketing capaign (either positive or negative) serves as the outcome. The company is not interested in obtaining a deep understanding of the relationships btween each individual predictor and the response; instead, the company simply wants to accurately predict the response using the predictors. This is an example of modeling for prediction. In contrast, consider the Advertising data illustrated in Figure 2.1 . One may be interested in answering questions such as: – Which media are associated with sales? – Which media generate the biggest boost in sales? or – How large of an increase in sales is associated with a given increase in TV advertising? This situation falls into the inference paradigm. Another example involves modeling the brand of a product that a customer might purchase based on variables such as price, store location, discount levels, competition price, and so forth",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Another example involves modeling the brand of a product that a customer might purchase based on variables such as price, store location, discount levels, competition price, and so forth. In this situation one might really be most interested in the association between each variable and the probability of purchase. For istance, to what extent is the product’s price associated with sales? This is an example of modeling for inference. Finally, some modeling could be conducted both for prediction and iference. For example, in a real estate setting, one may seek to relate values of homes to inputs such as crime rate, zoning, distance from a river, air quality, schools, income level of community, size of houses, and so forth. In this case one might be interested in the association between each indiviual input variable and housing price—for instance, how much extra will a house be worth if it has a view of the river? This is an inference problem. Alternatively, one may simply be interested in predicting the value of a home given its characteristics: is this house undeor over-valued? This is a prediction problem. Depending on whether our ultimate goal is prediction, inference, or a combination of the two, different methods for estimating f may be apropriate. For example, linear models allow for relatively simple and ilinear model terpretable inference, but may not yield as accurate predictions as some other approaches. In contrast, some of the highly non-linear approaches that we discuss in the later chapters of this book can potentially provide quite accurate predictions for Y , but this comes at the expense of a less interpretable model for which inference is more challenging. 2.1.2 How Do We Estimate f ? Throughout this book, we explore many linear and non-linear approaches for estimating f . However, these methods generally share certain charateristics. We provide an overview of these shared characteristics in this section. We will always assume that we have observed a set of n different data points",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We provide an overview of these shared characteristics in this section. We will always assume that we have observed a set of n different data points. For example in Figure 2.2 we observed n = 30 data points. These observations are called the training data because we will use these training data observations to train, or teach, our method how to estimate f . Let x ij represent the value of the j th predictor, or input, for observation i , where i = 1 , 2 , , n and j = 1 , 2 , , p . Correspondingly, let y i represent the response variable for the i th observation. Then our training data consist of { ( x 1 , y 1 ) , ( x 2 , y 2 ) , , ( x n , y n ) } where x i = ( x i 1 , x i 2 , , x ip ) T . Our goal is to apply a statistical learning method to the training data in order to estimate the unknown function f . In other words, we want to find a function ˆ f such that Y ≈ ˆ f ( X ) for any observation ( X, Y ) . Broadly speaking, most statistical learning methods for this task can be characteized as either parametric or non-parametric . We now briefly discuss these parametric noparametric two types of approaches. Parametric Methods Parametric methods involve a two-step model-based approach. 1. First, we make an assumption about the functional form, or shape, of f . For example, one very simple assumption is that f is linear in X : f ( X ) = β 0 + β 1 X 1 + β 2 X 2 + · · · + β p X p . (2.4) This is a linear model , which will be discussed extensively in Chater 3 . Once we have assumed that f is linear, the problem of estimaing f is greatly simplified. Instead of having to estimate an entirely arbitrary p -dimensional function f ( X ) , one only needs to estimate the p + 1 coefficients β 0 , β 1 , , β p . Years of Education Seniority Income FIGURE 2.4. A linear model fit by least squares to the Income data from Figure 2.3 . The observations are shown in red, and the yellow plane indicates the least squares fit to the data. 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A linear model fit by least squares to the Income data from Figure 2.3 . The observations are shown in red, and the yellow plane indicates the least squares fit to the data. 2. After a model has been selected, we need a procedure that uses the training data to fit or train the model. In the case of the linear model fit train ( 2.4 ), we need to estimate the parameters β 0 , β 1 , , β p . That is, we want to find values of these parameters such that Y ≈ β 0 + β 1 X 1 + β 2 X 2 + · · · + β p X p . The most common approach to fitting the model ( 2.4 ) is referred to as (ordinary) least squares , which we discuss in Chapter 3 . However, least squares least squares is one of many possible ways to fit the linear model. In Chapter 6 , we discuss other approaches for estimating the parameters in ( 2.4 ). The model-based approach just described is referred to as parametric ; it reduces the problem of estimating f down to one of estimating a set of parameters. Assuming a parametric form for f simplifies the problem of estimating f because it is generally much easier to estimate a set of prameters, such as β 0 , β 1 , , β p in the linear model ( 2.4 ), than it is to fit an entirely arbitrary function f . The potential disadvantage of a parameric approach is that the model we choose will usually not match the true unknown form of f . If the chosen model is too far from the true f , then our estimate will be poor. We can try to address this problem by chooing flexible models that can fit many different possible functional forms flexible for f . But in general, fitting a more flexible model requires estimating a greater number of parameters. These more complex models can lead to a phenomenon known as overfitting the data, which essentially means they overfitting follow the errors, or noise , too closely. These issues are discussed througnoise out this book. Figure 2.4 shows an example of the parametric approach applied to the Income data from Figure 2.3",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". These issues are discussed througnoise out this book. Figure 2.4 shows an example of the parametric approach applied to the Income data from Figure 2.3 . We have fit a linear model of the form income ≈ β 0 + β 1 × education + β 2 × seniority . Years of Education Seniority Income FIGURE 2.5. A smooth thin-plate spline fit to the Income data from Figure 2.3 is shown in yellow; the observations are displayed in red. Splines are discussed in Chapter 7 . Since we have assumed a linear relationship between the response and the two predictors, the entire fitting problem reduces to estimating β 0 , β 1 , and β 2 , which we do using least squares linear regression. Comparing Figure 2.3 to Figure 2.4 , we can see that the linear fit given in Figure 2.4 is not quite right: the true f has some curvature that is not captured in the linear fit. However, the linear fit still appears to do a reasonable job of capturing the positive relationship between years of education and income , as well as the slightly less positive relationship between seniority and income . It may be that with such a small number of observations, this is the best we can do. Non-Parametric Methods Non-parametric methods do not make explicit assumptions about the funtional form of f . Instead they seek an estimate of f that gets as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric approaches: by avoiding the assumption of a particular functional form for f , they have the potential to accurately fit a wider range of possible shapes for f . Any parametric approach brings with it the possibility that the functional form used to estimate f is very different from the true f , in which case the resulting model will not fit the data well. In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form of f is made",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form of f is made. But non-parametric approaches do suffer from a major disadvantage: since they do not reduce the problem of estimating f to a small number of parameters, a very large number of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for f . An example of a non-parametric approach to fitting the Income data is shown in Figure 2.5 . A thin-plate spline is used to estimate f . This athin-plate spline proach does not impose any pre-specified model on f . It instead attempts Years of Education Seniority Income FIGURE 2.6. A rough thin-plate spline fit to the Income data from Figure 2.3 . This fit makes zero errors on the training data. to produce an estimate for f that is as close as possible to the observed data, subject to the fit—that is, the yellow surface in Figure 2.5 —being smooth . In this case, the non-parametric fit has produced a remarkably acurate estimate of the true f shown in Figure 2.3 . In order to fit a thin-plate spline, the data analyst must select a level of smoothness. Figure 2.6 shows the same thin-plate spline fit using a lower level of smoothness, allowing for a rougher fit. The resulting estimate fits the observed data perfectly! However, the spline fit shown in Figure 2.6 is far more variable than the true function f , from Figure 2.3 . This is an example of overfitting the data, which we discussed previously. It is an undesirable situation because the fit obtained will not yield accurate estimates of the response on new observations that were not part of the original training data set. We dicuss methods for choosing the correct amount of smoothness in Chapter 5 . Splines are discussed in Chapter 7 . As we have seen, there are advantages and disadvantages to parametric and non-parametric methods for statistical learning. We explore both types of methods throughout this book",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As we have seen, there are advantages and disadvantages to parametric and non-parametric methods for statistical learning. We explore both types of methods throughout this book. 2.1.3 The Trade-Off Between Prediction Accuracy and Model Interpretability Of the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate f . For example, linear regression is a relatively inflexible approach, because it can only generate linear functions such as the lines shown in Figure 2.1 or the plane shown in Figure 2.4 . Other methods, such as the thin plate splines shown in Figures 2.5 and 2.6 , are considerably more flexible because they can generate a much wider range of possible shapes to estimate f . Flexibility Interpretability Low High Low High Subset Selection Lasso Least Squares Generalized Additive Models Trees Bagging, Boosting Support Vector Machines Deep Learning FIGURE 2.7. A representation of the tradeoff between flexibility and intepretability, using different statistical learning methods. In general, as the flexibility of a method increases, its interpretability decreases. One might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very flexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inference, then restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between Y and X 1 , X 2 , , X p . In contrast, very flexible approaches, such as the splines discussed in Chapter 7 and displayed in Figures 2.5 and 2.6 , and the boosting methods discussed in Chapter 8 , can lead to such complicated estimates of f that it is difficult to understand how any individual predictor is associated with the response",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Figure 2.7 provides an illustration of the trade-off between flexibility and interpretability for some of the methods that we cover in this book. Least squares linear regression, discussed in Chapter 3 , is relatively inflexible but is quite interpretable. The lasso , discussed in Chapter 6 , relies upon the lasso linear model ( 2.4 ) but uses an alternative fitting procedure for estimating the coefficients β 0 , β 1 , , β p . The new procedure is more restrictive in etimating the coefficients, and sets a number of them to exactly zero. Hence in this sense the lasso is a less flexible approach than linear regression. It is also more interpretable than linear regression, because in the final model the response variable will only be related to a small subset of the predictors—namely, those with nonzero coefficient estimates. Generalized additive models (GAMs), discussed in Chapter 7 , instead extend the ligeneralized additive model ear model ( 2.4 ) to allow for certain non-linear relationships. Consequently, GAMs are more flexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve. Finally, fully non-linear methods such as bagging , boosting , support vector machines bagging boosting with non-linear kernels, and neural networks (deep learning), discussed in support vector machine Chapters 8 , 9 , and 10 , are highly flexible approaches that are harder to interpret. We have established that when inference is the goal, there are clear avantages to using simple and relatively inflexible statistical learning metods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is simply not of interest. For instance, if we seek to develop an algorithm to predict the price of a stock, our sole requirement for the algorithm is that it predict accurately— interpretability is not a concern",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For instance, if we seek to develop an algorithm to predict the price of a stock, our sole requirement for the algorithm is that it predict accurately— interpretability is not a concern. In this setting, we might expect that it will be best to use the most flexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a less flexible method. This phenomenon, which may seem counterintitive at first glance, has to do with the potential for overfitting in highly flexible methods. We saw an example of overfitting in Figure 2.6 . We will discuss this very important concept further in Section 2.2 and throughout this book. 2.1.4 Supervised Versus Unsupervised Learning Most statistical learning problems fall into one of two categories: supervised supervised or unsupervised . The examples that we have discussed so far in this chaunsupervised ter all fall into the supervised learning domain. For each observation of the predictor measurement(s) x i , i = 1 , , n there is an associated response measurement y i . We wish to fit a model that relates the response to the predictors, with the aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the response and the predictors (inference). Many classical statistical learing methods such as linear regression and logistic regression (Chapter 4 ), as logistic regression well as more modern approaches such as GAM, boosting, and support vetor machines, operate in the supervised learning domain. The vast majority of this book is devoted to this setting. By contrast, unsupervised learning describes the somewhat more chalenging situation in which for every observation i = 1 , , n , we observe a vector of measurements x i but no associated response y i . It is not posible to fit a linear regression model, since there is no response variable to predict",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It is not posible to fit a linear regression model, since there is no response variable to predict. In this setting, we are in some sense working blind; the siuation is referred to as unsupervised because we lack a response varable that can supervise our analysis. What sort of statistical analysis is possible? We can seek to understand the relationships between the variables or between the observations. One statistical learning tool that we may use in this setting is cluster analysis , or clustering. The goal of cluster analysis cluster analysis is to ascertain, on the basis of x 1 , , x n , whether the observations fall into relatively distinct groups. For example, in a market segmentation study we might observe multiple characteristics (variables) for potential customers, such as zip code, family income, and shopping habits. We might believe that the customers fall into different groups, such as big spenders versus low spenders. If the information about each customer’s spending patterns were available, then a supervised analysis would be possible. However, this information is not available—that is, we do not know whether each potetial customer is a big spender or not. In this setting, we can try to cluster the customers on the basis of the variables measured, in order to identify 0 2 4 6 8 10 12 2 4 6 8 10 12 0 2 4 6 2 4 6 8 X 1 X 1 X 2 X 2 FIGURE 2.8. A clustering data set involving three groups. Each group is shown using a different colored symbol. Left: The three groups are well-separated. In this setting, a clustering approach should successfully identify the three groups. Right: There is some overlap among the groups. Now the clustering task is more challenging. distinct groups of potential customers. Identifying such groups can be of interest because it might be that the groups differ with respect to some property of interest, such as spending habits. Figure 2.8 provides a simple illustration of the clustering problem. We have plotted 150 observations with measurements on two variables, X 1 and X 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Figure 2.8 provides a simple illustration of the clustering problem. We have plotted 150 observations with measurements on two variables, X 1 and X 2 . Each observation corresponds to one of three distinct groups. For illustrative purposes, we have plotted the members of each group using different colors and symbols. However, in practice the group memberships are unknown, and the goal is to determine the group to which each obsevation belongs. In the left-hand panel of Figure 2.8 , this is a relatively easy task because the groups are well-separated. By contrast, the right-hand panel illustrates a more challenging setting in which there is some overlap between the groups. A clustering method could not be expected to assign all of the overlapping points to their correct group (blue, green, or orange). In the examples shown in Figure 2.8 , there are only two variables, and so one can simply visually inspect the scatterplots of the observations in order to identify clusters. However, in practice, we often encounter data sets that contain many more than two variables. In this case, we cannot easily plot the observations. For instance, if there are p variables in our data set, then p ( p − 1) / 2 distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, automated clustering methods are important. We discuss clustering and other unsupervised learning approaches in Chapter 12 . Many problems fall naturally into the supervised or unsupervised learing paradigms. However, sometimes the question of whether an analysis should be considered supervised or unsupervised is less clear-cut. For istance, suppose that we have a set of n observations. For m of the observtions, where m < n , we have both predictor measurements and a response measurement. For the remaining n − m observations, we have predictor measurements but no response measurement",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For the remaining n − m observations, we have predictor measurements but no response measurement. Such a scenario can arise if the predictors can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as a semi-supervised learning problem. In this setting, we wish to use a stsemsupervised learning tistical learning method that can incorporate the m observations for which response measurements are available as well as the n − m observations for which they are not. Although this is an interesting topic, it is beyond the scope of this book. 2.1.5 Regression Versus Classification Problems Variables can be characterized as either quantitative or qualitative (also quantitative qualitative known as categorical ). Quantitative variables take on numerical values. Ecategorical amples include a person’s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on values in one of K different classes , or categories. Examples of qualitative variables class include a person’s marital status (married or not), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lyphoblastic Leukemia, or No Leukemia). We tend to refer to problems with a quantitative response as regression problems, while those involving a regression qualitative response are often referred to as classification problems. Hoclassification ever, the distinction is not always that crisp. Least squares linear regression (Chapter 3 ) is used with a quantitative response, whereas logistic regression (Chapter 4 ) is typically used with a qualitative (two-class, or binary ) rbinary sponse. Thus, despite its name, logistic regression is a classification method. But since it estimates class probabilities, it can be thought of as a regresion method as well",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Thus, despite its name, logistic regression is a classification method. But since it estimates class probabilities, it can be thought of as a regresion method as well. Some statistical methods, such as K -nearest neighbors (Chapters 2 and 4 ) and boosting (Chapter 8 ), can be used in the case of either quantitative or qualitative responses. We tend to select statistical learning methods on the basis of whether the response is quantitative or qualitative; i.e. we might use linear regresion when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or quantitative is generally consiered less important. Most of the statistical learning methods discussed in this book can be applied regardless of the predictor variable type, provided that any qualitative predictors are properly coded before the analysis is performed. This is discussed in Chapter 3 . 2.2 Assessing Model Accuracy One of the key aims of this book is to introduce the reader to a wide range of statistical learning methods that extend far beyond the standard linear regression approach. Why is it necessary to introduce so many different statistical learning approaches, rather than just a single best method? There is no free lunch in statistics: no one method dominates all others over all possible data sets. On a particular data set, one specific method may work best, but some other method may work better on a similar but different data set. Hence it is an important task to decide for any given set of data which method produces the best results. Selecting the best approach can be one of the most challenging parts of performing statistical learning in practice. In this section, we discuss some of the most important concepts that arise in selecting a statistical learning procedure for a specific data set. As the book progresses, we will explain how the concepts presented here can be applied in practice",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As the book progresses, we will explain how the concepts presented here can be applied in practice. 2.2.1 Measuring the Quality of Fit In order to evaluate the performance of a statistical learning method on a given data set, we need some way to measure how well its predictions actually match the observed data. That is, we need to quantify the extent to which the predicted response value for a given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure is the mean squared error (MSE), given by mean squared error MSE = 1 n n 0 i =1 ( y i − ˆ f ( x i )) 2 , (2.5) where ˆ f ( x i ) is the prediction that ˆ f gives for the i th observation. The MSE will be small if the predicted responses are very close to the true responses, and will be large if for some of the observations, the predicted and true responses differ substantially. The MSE in ( 2.5 ) is computed using the training data that was used to fit the model, and so should more accurately be referred to as the training MSE . But in general, we do not really care how well the method works training MSE on the training data. Rather, we are interested in the accuracy of the prdictions that we obtain when we apply our method to previously unseen test data . Why is this what we care about? Suppose that we are interested test data in developing an algorithm to predict a stock’s price based on previous stock returns. We can train the method using stock returns from the past 6 months. But we don’t really care how well our method predicts last week’s stock price. We instead care about how well it will predict tomorrow’s price or next month’s price. On a similar note, suppose that we have clinical measurements (e.g. weight, blood pressure, height, age, family history of disease) for a number of patients, as well as information about whether each patient has diabetes. We can use these patients to train a statistical learing method to predict risk of diabetes based on clinical measurements",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We can use these patients to train a statistical learing method to predict risk of diabetes based on clinical measurements. In practice, we want this method to accurately predict diabetes risk for future patients based on their clinical measurements. We are not very interested in whether or not the method accurately predicts diabetes risk for patients used to train the model, since we already know which of those patients have diabetes. To state it more mathematically, suppose that we fit our statistical learing method on our training observations { ( x 1 , y 1 ) , ( x 2 , y 2 ) , , ( x n , y n ) } , and we obtain the estimate ˆ f . We can then compute ˆ f ( x 1 ) , ˆ f ( x 2 ) , , ˆ f ( x n ) . 0 20 40 60 80 100 2 4 6 8 10 12 X Y 2 5 10 20 0.0 0.5 1.0 1.5 2.0 2.5 Flexibility Mean Squared Error FIGURE 2.9. Left: Data simulated from f , shown in black. Three estimates of f are shown: the linear regression line (orange curve), and two smoothing spline fits (blue and green curves). Right: Training MSE (grey curve), test MSE (red curve), and minimum possible test MSE over all methods (dashed line). Squares represent the training and test MSEs for the three fits shown in the left-hand panel. If these are approximately equal to y 1 , y 2 , , y n , then the training MSE given by ( 2.5 ) is small. However, we are really not interested in whether ˆ f ( x i ) ≈ y i ; instead, we want to know whether ˆ f ( x 0 ) is approximately equal to y 0 , where ( x 0 , y 0 ) is a previously unseen test observation not used to train the statistical learning method . We want to choose the method that gives the lowest test MSE , as opposed to the lowest training MSE. In other words, test MSE if we had a large number of test observations, we could compute Ave ( y 0 − ˆ f ( x 0 )) 2 , (2.6) the average squared prediction error for these test observations ( x 0 , y 0 ) . We’d like to select the model for which this quantity is as small as possible",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_19"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We’d like to select the model for which this quantity is as small as possible. How can we go about trying to select a method that minimizes the test MSE? In some settings, we may have a test data set available—that is, we may have access to a set of observations that were not used to train the statistical learning method. We can then simply evaluate ( 2.6 ) on the test observations, and select the learning method for which the test MSE is smallest. But what if no test observations are available? In that case, one might imagine simply selecting a statistical learning method that minimizes the training MSE ( 2.5 ). This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger. Figure 2.9 illustrates this phenomenon on a simple example. In the lefhand panel of Figure 2.9 , we have generated observations from ( 2.1 ) with the true f given by the black curve. The orange, blue and green curves illutrate three possible estimates for f obtained using methods with increasing levels of flexibility. The orange line is the linear regression fit, which is reltively inflexible. The blue and green curves were produced using smoothing splines , discussed in Chapter 7 , with different levels of smoothness. It is smoothing spline clear that as the level of flexibility increases, the curves fit the observed data more closely. The green curve is the most flexible and matches the data very well; however, we observe that it fits the true f (shown in black) poorly because it is too wiggly",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_20"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The green curve is the most flexible and matches the data very well; however, we observe that it fits the true f (shown in black) poorly because it is too wiggly. By adjusting the level of flexibility of the smoothing spline fit, we can produce many different fits to this data. We now move on to the right-hand panel of Figure 2.9 . The grey curve displays the average training MSE as a function of flexibility, or more formally the degrees of freedom , for a number of smoothing splines. The degrees of freedom degrees of freedom is a quantity that summarizes the flexibility of a curve; it is discussed more fully in Chapter 7 . The orange, blue and green squares indicate the MSEs associated with the corresponding curves in the lefhand panel. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve—note that in Figure 2.9 , linear regression is at the most restrictive end, with two degrees of freedom. The training MSE declines monotonically as flexibility increases. In this example the true f is non-linear, and so the orange linear fit is not flexible enough to estimate f well. The green curve has the lowest training MSE of all three methods, since it corresponds to the most flexible of the three curves fit in the left-hand panel. In this example, we know the true function f , and so we can also copute the test MSE over a very large test set, as a function of flexibility. (Of course, in general f is unknown, so this will not be possible.) The test MSE is displayed using the red curve in the right-hand panel of Figure 2.9 . As with the training MSE, the test MSE initially declines as the level of fleibility increases. However, at some point the test MSE levels off and then starts to increase again. Consequently, the orange and green curves both have high test MSE. The blue curve minimizes the test MSE, which should not be surprising given that visually it appears to estimate f the best in the left-hand panel of Figure 2.9",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_21"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The blue curve minimizes the test MSE, which should not be surprising given that visually it appears to estimate f the best in the left-hand panel of Figure 2.9 . The horizontal dashed line indicates Var ( ε ) , the irreducible error in ( 2.3 ), which corresponds to the lowest achievable test MSE among all possible methods. Hence, the smoothing spline reprsented by the blue curve is close to optimal. In the right-hand panel of Figure 2.9 , as the flexibility of the statistical learning method increases, we observe a monotone decrease in the training MSE and a U-shape in the test MSE. This is a fundamental property of statistical learning that holds regardless of the particular data set at hand and regardless of the statistical method being used. As model flexibility increases, the training MSE will decrease, but the test MSE may not. When a given method yields a small training MSE but a large test MSE, we are said to be overfitting the data. This happens because our statistical learning procedure is working too hard to find patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function f . When we overfit the training data, the test MSE will be very large because the supposed 0 20 40 60 80 100 2 4 6 8 10 12 X Y 2 5 10 20 0.0 0.5 1.0 1.5 2.0 2.5 Flexibility Mean Squared Error FIGURE 2.10. Details are as in Figure 2.9 , using a different true f that is much closer to linear. In this setting, linear regression provides a very good fit to the data. patterns that the method found in the training data simply don’t exist in the test data. Note that regardless of whether or not overfitting has occurred, we almost always expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek to minimize the training MSE. Overfitting refers specifically to the case in which a less flexible model would have yielded a smaller test MSE",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_22"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Overfitting refers specifically to the case in which a less flexible model would have yielded a smaller test MSE. Figure 2.10 provides another example in which the true f is approxmately linear. Again we observe that the training MSE decreases montonically as the model flexibility increases, and that there is a U-shape in the test MSE. However, because the truth is close to linear, the test MSE only decreases slightly before increasing again, so that the orange least squares fit is substantially better than the highly flexible green curve. Fnally, Figure 2.11 displays an example in which f is highly non-linear. The training and test MSE curves still exhibit the same general patterns, but now there is a rapid decrease in both curves before the test MSE starts to increase slowly. In practice, one can usually compute the training MSE with relative ease, but estimating the test MSE is considerably more difficult because usually no test data are available. As the previous three examples illustrate, the flexibility level corresponding to the model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a variety of approaches that can be used in practice to estimate this minimum point. One important method is cross-validation (Chapter 5 ), which is a crosvalidation method for estimating the test MSE using the training data. 2.2.2 The Bias-Variance Trade-Off The U-shape observed in the test MSE curves (Figures 2.9 – 2.11 ) turns out to be the result of two competing properties of statistical learning methods. 0 20 40 60 80 100 −10 0 10 20 X Y 2 5 10 20 0 5 10 15 20 Flexibility Mean Squared Error FIGURE 2.11. Details are as in Figure 2.9 , using a different f that is far from linear. In this setting, linear regression provides a very poor fit to the data",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_23"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Details are as in Figure 2.9 , using a different f that is far from linear. In this setting, linear regression provides a very poor fit to the data. Though the mathematical proof is beyond the scope of this book, it is possible to show that the expected test MSE, for a given value x 0 , can always be decomposed into the sum of three fundamental quantities: the variance of ˆ f ( x 0 ) , the squared bias of ˆ f ( x 0 ) and the variance of the error variance bias terms ε . That is, E 1 y 0 − ˆ f ( x 0 ) 2 2 = Var ( ˆ f ( x 0 )) + [ Bias ( ˆ f ( x 0 ))] 2 + Var ( ε ) . (2.7) Here the notation E 1 y 0 − ˆ f ( x 0 ) 2 2 defines the expected test MSE at x 0 , expected test MSE and refers to the average test MSE that we would obtain if we repeatedly estimated f using a large number of training sets, and tested each at x 0 . The overall expected test MSE can be computed by averaging E 1 y 0 − ˆ f ( x 0 ) 2 2 over all possible values of x 0 in the test set. Equation 2.7 tells us that in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance and low bias . Note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. Hence, we see that the expected test MSE can never lie below Var ( ε ) , the irreducible error from ( 2.3 ). What do we mean by the variance and bias of a statistical learning method? Variance refers to the amount by which ˆ f would change if we estimated it using a different training data set. Since the training data are used to fit the statistical learning method, different training data sets will result in a different ˆ f . But ideally the estimate for f should not vary too much between training sets. However, if a method has high variance then small changes in the training data can result in large changes in ˆ f . In general, more flexible statistical methods have higher variance. Consider the green and orange curves in Figure 2.9",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_24"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In general, more flexible statistical methods have higher variance. Consider the green and orange curves in Figure 2.9 . The flexible green curve is following the observations very closely. It has high variance because changing any one of these data points may cause the estimate ˆ f to change considerably. 2 5 10 20 0.0 0.5 1.0 1.5 2.0 2.5 Flexibility 2 5 10 20 0.0 0.5 1.0 1.5 2.0 2.5 Flexibility 2 5 10 20 0 5 10 15 20 Flexibility MSE Bias Var FIGURE 2.12. Squared bias (blue curve), variance (orange curve), Var ( ε ) (dashed line), and test MSE (red curve) for the three data sets in Figures 2.9 – 2.11 . The vertical dotted line indicates the flexibility level corresponding to the smallest test MSE. In contrast, the orange least squares line is relatively inflexible and has low variance, because moving any single observation will likely cause only a small shift in the position of the line. On the other hand, bias refers to the error that is introduced by approxmating a real-life problem, which may be extremely complicated, by a much simpler model. For example, linear regression assumes that there is a linear relationship between Y and X 1 , X 2 , , X p . It is unlikely that any real-life problem truly has such a simple linear relationship, and so performing liear regression will undoubtedly result in some bias in the estimate of f . In Figure 2.11 , the true f is substantially non-linear, so no matter how many training observations we are given, it will not be possible to produce an accurate estimate using linear regression. In other words, linear regression results in high bias in this example. However, in Figure 2.10 the true f is very close to linear, and so given enough data, it should be possible for linear regression to produce an accurate estimate. Generally, more flexible methods result in less bias. As a general rule, as we use more flexible methods, the variance will increase and the bias will decrease",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_25"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Generally, more flexible methods result in less bias. As a general rule, as we use more flexible methods, the variance will increase and the bias will decrease. The relative rate of change of these two quantities determines whether the test MSE increases or decreases. As we increase the flexibility of a class of methods, the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. When this happens the test MSE increases. Note that we observed this pattern of decreasing test MSE followed by increasing test MSE in the right-hand panels of Figures 2.9 – 2.11 . The three plots in Figure 2.12 illustrate Equation 2.7 for the examples in Figures 2.9 – 2.11 . In each case the blue solid curve represents the squared bias, for different levels of flexibility, while the orange curve corresponds to the variance. The horizontal dashed line represents Var ( ε ) , the irreducible error. Finally, the red curve, corresponding to the test set MSE, is the sum of these three quantities. In all three cases, the variance increases and the bias decreases as the method’s flexibility increases. However, the flexibility level corresponding to the optimal test MSE differs considerably among the three data sets, because the squared bias and variance change at different rates in each of the data sets. In the left-hand panel of Figure 2.12 , the bias initially decreases rapidly, resulting in an initial sharp decrease in the expected test MSE. On the other hand, in the center panel of Figure 2.12 the true f is close to linear, so there is only a small decrease in bias as fleibility increases, and the test MSE only declines slightly before increasing rapidly as the variance increases. Finally, in the right-hand panel of Fiure 2.12 , as flexibility increases, there is a dramatic decline in bias because the true f is very non-linear",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_26"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Finally, in the right-hand panel of Fiure 2.12 , as flexibility increases, there is a dramatic decline in bias because the true f is very non-linear. There is also very little increase in variance as flexibility increases. Consequently, the test MSE declines substantially before experiencing a small increase as model flexibility increases. The relationship between bias, variance, and test set MSE given in Eqution 2.7 and displayed in Figure 2.12 is referred to as the bias-variance trade-off . Good test set performance of a statistical learning method rbias-variance trade-off quires low variance as well as low squared bias. This is referred to as a trade-off because it is easy to obtain a method with extremely low bias but high variance (for instance, by drawing a curve that passes through every single training observation) or a method with very low variance but high bias (by fitting a horizontal line to the data). The challenge lies in finding a method for which both the variance and the squared bias are low. This trade-off is one of the most important recurring themes in this book. In a real-life situation in which f is unobserved, it is generally not posible to explicitly compute the test MSE, bias, or variance for a statistical learning method. Nevertheless, one should always keep the bias-variance trade-off in mind. In this book we explore methods that are extremely flexible and hence can essentially eliminate bias. However, this does not guarantee that they will outperform a much simpler method such as linear regression. To take an extreme example, suppose that the true f is linear. In this situation linear regression will have no bias, making it very hard for a more flexible method to compete. In contrast, if the true f is highly non-linear and we have an ample number of training observations, then we may do better using a highly flexible approach, as in Figure 2.11 . In Chapter 5 we discuss cross-validation, which is a way to estimate the test MSE using the training data",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_27"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In Chapter 5 we discuss cross-validation, which is a way to estimate the test MSE using the training data. 2.2.3 The Classification Setting Thus far, our discussion of model accuracy has been focused on the regresion setting. But many of the concepts that we have encountered, such as the bias-variance trade-off, transfer over to the classification setting with only some modifications due to the fact that y i is no longer quatitative. Suppose that we seek to estimate f on the basis of training obsevations { ( x 1 , y 1 ) , , ( x n , y n ) } , where now y 1 , , y n are qualitative. The most common approach for quantifying the accuracy of our estimate ˆ f is the training error rate , the proportion of mistakes that are made if we apply error rate our estimate ˆ f to the training observations: 1 n n 0 i =1 I ( y i ̸ = ˆ y i ) . (2.8) Here ˆ y i is the predicted class label for the i th observation using ˆ f . And I ( y i ̸ = ˆ y i ) is an indicator variable that equals 1 if y i ̸ = ˆ y i and zero if y i = ˆ y i . indicator variable If I ( y i ̸ = ˆ y i ) = 0 then the i th observation was classified correctly by our classification method; otherwise it was misclassified. Hence Equation 2.8 computes the fraction of incorrect classifications. Equation 2.8 is referred to as the training error rate because it is cotraining error puted based on the data that was used to train our classifier. As in the regression setting, we are most interested in the error rates that result from applying our classifier to test observations that were not used in training. The test error rate associated with a set of test observations of the form test error ( x 0 , y 0 ) is given by Ave ( I ( y 0 ̸ = ˆ y 0 )) , (2.9) where ˆ y 0 is the predicted class label that results from applying the classifier to the test observation with predictor x 0 . A good classifier is one for which the test error ( 2.9 ) is smallest",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_28"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A good classifier is one for which the test error ( 2.9 ) is smallest. The Bayes Classifier It is possible to show (though the proof is outside of the scope of this book) that the test error rate given in ( 2.9 ) is minimized, on average, by a very simple classifier that assigns each observation to the most likely class, given its predictor values . In other words, we should simply assign a test observation with predictor vector x 0 to the class j for which Pr( Y = j | X = x 0 ) (2.10) is largest. Note that ( 2.10 ) is a conditional probability : it is the probability conditional probability that Y = j , given the observed predictor vector x 0 . This very simple clasifier is called the Bayes classifier . In a two-class problem where there are Bayes classifier only two possible response values, say class 1 or class 2 , the Bayes classifier corresponds to predicting class one if Pr( Y = 1 | X = x 0 ) > 0 . 5 , and class two otherwise. Figure 2.13 provides an example using a simulated data set in a twdimensional space consisting of predictors X 1 and X 2 . The orange and blue circles correspond to training observations that belong to two different classes. For each value of X 1 and X 2 , there is a different probability of the response being orange or blue. Since this is simulated data, we know how the data were generated and we can calculate the conditional probabilities for each value of X 1 and X 2 . The orange shaded region reflects the set of points for which Pr( Y = orange | X ) is greater than 50 % , while the blue shaded region indicates the set of points for which the probability is below 50 % . The purple dashed line represents the points where the probability is exactly 50 % . This is called the Bayes decision boundary",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_29"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The purple dashed line represents the points where the probability is exactly 50 % . This is called the Bayes decision boundary . The Bayes Bayes decision boundary classifier’s prediction is determined by the Bayes decision boundary; an observation that falls on the orange side of the boundary will be assigned o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o X 1 X 2 FIGURE 2.13. A simulated data set consisting of 100 observations in each of two groups, indicated in blue and in orange. The purple dashed line represents the Bayes decision boundary. The orange background grid indicates the region in which a test observation will be assigned to the orange class, and the blue background grid indicates the region in which a test observation will be assigned to the blue class. to the orange class, and similarly an observation on the blue side of the boundary will be assigned to the blue class. The Bayes classifier produces the lowest possible test error rate, called the Bayes error rate . Since the Bayes classifier will always choose the class Bayes error rate for which ( 2.10 ) is largest, the error rate will be 1 − max j Pr( Y = j | X = x 0 ) at X = x 0 . In general, the overall Bayes error rate is given by 1 − E * max j Pr( Y = j | X ) + , (2.11) where the expectation averages the probability over all possible values of X . For our simulated data, the Bayes error rate is 0 . 133 . It is greater than zero, because the classes overlap in the true population, which implies that max j Pr( Y = j | X = x 0 ) < 1 for some values of x 0 . The Bayes error rate is analogous to the irreducible error, discussed earlier",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_30"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The Bayes error rate is analogous to the irreducible error, discussed earlier. K -Nearest Neighbors In theory we would always like to predict qualitative responses using the Bayes classifier. But for real data, we do not know the conditional distrbution of Y given X , and so computing the Bayes classifier is impossble. Therefore, the Bayes classifier serves as an unattainable gold standard against which to compare other methods. Many approaches attempt to estimate the conditional distribution of Y given X , and then classify a given observation to the class with highest estimated probability. One such method is the K -nearest neighbors (KNN) classifier. Given a positive iK -nearest neighbors teger K and a test observation x 0 , the KNN classifier first identifies the K points in the training data that are closest to x 0 , represented by N 0 . It then estimates the conditional probability for class j as the fraction of points in N 0 whose response values equal j : Pr( Y = j | X = x 0 ) = 1 K 0 i ∈N 0 I ( y i = j ) . (2.12) Finally, KNN classifies the test observation x 0 to the class with the largest probability from ( 2.12 ). Figure 2.14 provides an illustrative example of the KNN approach. In the left-hand panel, we have plotted a small training data set consisting of six blue and six orange observations. Our goal is to make a prediction for the point labeled by the black cross. Suppose that we choose K = 3 . Then KNN will first identify the three observations that are closest to the cross. This neighborhood is shown as a circle. It consists of two blue points and one orange point, resulting in estimated probabilities of 2 / 3 for the blue class and 1 / 3 for the orange class. Hence KNN will predict that the black cross belongs to the blue class. In the right-hand panel of Figure 2.14 we have applied the KNN approach with K = 3 at all of the possible values for X 1 and X 2 , and have drawn in the corresponding KNN decision boundary",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_31"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In the right-hand panel of Figure 2.14 we have applied the KNN approach with K = 3 at all of the possible values for X 1 and X 2 , and have drawn in the corresponding KNN decision boundary. Despite the fact that it is a very simple approach, KNN can often prduce classifiers that are surprisingly close to the optimal Bayes classifier. Figure 2.15 displays the KNN decision boundary, using K = 10 , when aplied to the larger simulated data set from Figure 2.13 . Notice that even though the true distribution is not known by the KNN classifier, the KNN decision boundary is very close to that of the Bayes classifier. The test error rate using KNN is 0 . 1363 , which is close to the Bayes error rate of 0 . 1304 . The choice of K has a drastic effect on the KNN classifier obtained. Figure 2.16 displays two KNN fits to the simulated data from Figure 2.13 , using K = 1 and K = 100 . When K = 1 , the decision boundary is overly flexible and finds patterns in the data that don’t correspond to the Bayes decision boundary. This corresponds to a classifier that has low bias but very high variance. As K grows, the method becomes less flexible and produces a decision boundary that is close to linear. This corresponds to a low-variance but high-bias classifier. On this simulated data set, neither K = 1 nor K = 100 give good predictions: they have test error rates of 0 . 1695 and 0 . 1925 , respectively. Just as in the regression setting, there is not a strong relationship btween the training error rate and the test error rate. With K = 1 , the KNN training error rate is 0 , but the test error rate may be quite high. In general, as we use more flexible classification methods, the training error rate will decline but the test error rate may not. In Figure 2.17 , we have plotted the KNN test and training errors as a function of 1 /K . As 1 /K icreases, the method becomes more flexible. As in the regression setting, the training error rate consistently declines as the flexibility increases",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_32"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As 1 /K icreases, the method becomes more flexible. As in the regression setting, the training error rate consistently declines as the flexibility increases. However, the test error exhibits a characteristic U-shape, declining at first (with a minimum at approximately K = 10 ) before increasing again when the method becomes excessively flexible and overfits. o o o o o o o o o o o o o o o o o o o o o o o o FIGURE 2.14. The KNN approach, using K = 3 , is illustrated in a simple situation with six blue observations and six orange observations. Left: a test observation at which a predicted class label is desired is shown as a black cross. The three closest points to the test observation are identified, and it is predicted that the test observation belongs to the most commonly-occurring class, in this case blue. Right: The KNN decision boundary for this example is shown in black. The blue grid indicates the region in which a test observation will be assigned to the blue class, and the orange grid indicates the region in which it will be assigned to the orange class. o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o X 1 X 2 KNN: K=10 FIGURE 2.15. The black curve indicates the KNN decision boundary on the data from Figure 2.13 , using K = 10 . The Bayes decision boundary is shown as a purple dashed line. The KNN and Bayes decision boundaries are very similar. In both the regression and classification settings, choosing the correct level of flexibility is critical to the success of any statistical learning method. The bias-variance tradeoff, and the resulting U-shape in the test error, can make this a difficult task",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_33"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The bias-variance tradeoff, and the resulting U-shape in the test error, can make this a difficult task. In Chapter 5 , we return to this topic and discuss o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o KNN: K=1 KNN: K=100 FIGURE 2.16. A comparison of the KNN decision boundaries (solid black curves) obtained using K = 1 and K = 100 on the data from Figure 2.13 . With K = 1 , the decision boundary is overly flexible, while with K = 100 it is not sufficiently flexible. The Bayes decision boundary is shown as a purple dashed line. 0.01 0.02 0.05 0.10 0.20 0.50 1.00 0.00 0.05 0.10 0.15 0.20 1/K Error Rate Training Errors Test Errors FIGURE 2.17. The KNN training error rate (blue, 200 observations) and test error rate (orange, 5,000 observations) on the data from Figure 2.13 , as the level of flexibility (assessed using 1 /K on the log scale) increases, or equivalently as the number of neighbors K decreases. The black dashed line indicates the Bayes error rate. The jumpiness of the curves is due to the small size of the training data set. various methods for estimating test error rates and thereby choosing the optimal level of flexibility for a given statistical learning method",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_34"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". various methods for estimating test error rates and thereby choosing the optimal level of flexibility for a given statistical learning method. 2.3 Lab: Introduction to Python 2.3.1 Getting Started To run the labs in this book, you will need two things: 1. An installation of Python3 , which is the specific version of Python used in the labs. 2. Access to Jupyter , a very popular Python interface that runs code through a file called a notebook . notebook You can download and install Python3 by following the instructions avaiable at anaconda.com . There are a number of ways to get access to Jupyter . Here are just a few: 1. Using Google’s Colaboratory service: colab.research.google.com/ . 2. Using JupyterHub , available at jupyter.org/hub . 3. Using your own jupyter installation. Installation instructions are available at jupyter.org/install . Please see the Python resources page on the book website statlearning.com for up-to-date information about getting Python and Jupyter working on your computer. You will need to install the ISLP package, which provides access to the datasets and custom-built functions that we provide. Inside a macOS or Linux terminal type pip install ISLP ; this also installs most other pacages needed in the labs. The Python resources page has a link to the ISLP documentation website. To run this lab, download the file Ch2-statlearn-lab.ipynb from the Python resources page. Now run the following code at the command line: jupyter lab Ch2-statlearn-lab.ipynb . If you’re using Windows, you can use the start menu to access anaconda , and follow the links. For example, to install ISLP and run this lab, you can run the same code above in an anaconda shell. 2.3.2 Basic Commands In this lab, we will introduce some simple Python commands. For more resources about Python in general, readers may want to consult the tutorial at docs.python.org/3/tutorial/ . Like most programming languages, Python uses functions to perform ofunction erations",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_35"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Like most programming languages, Python uses functions to perform ofunction erations. To run a function called fun , we type fun(input1,input2) , where the inputs (or arguments ) input1 and input2 tell Python how to run the function. A function can have any number of inputs. For example, the argument print() function outputs a text representation of all of its arguments to print() the console. In [1]: print( 'fit a model with' , 11, 'variables' ) fit a model with 11 variables The following command will provide information about the print() funtion. In [2]: print? Adding two integers in Python is pretty intuitive. In [3]: 3 + 5 Out[3]: 8 In Python , textual data is handled using strings . For instance, \"hello\" and string 'hello' are strings. We can concatenate them using the addition + symbol. In [4]: \"hello\" + \" \" + \"world\" Out[4]: 'hello world' A string is actually a type of sequence : this is a generic term for an ordered sequence list. The three most important types of sequences are lists, tuples, and strings. We introduce lists now. The following command instructs Python to join together the numbers 3, 4, and 5, and to save them as a list named x . When we type x , it gives us list back the list. In [5]: x = [3, 4, 5] x Out[5]: [3, 4, 5] Note that we used the brackets [] to construct this list. We will often want to add two sets of numbers together. It is reasonable to try the following code, though it will not produce the desired results. In [6]: y = [4, 9, 7] x + y Out[6]: [3, 4, 5, 4, 9, 7] The result may appear slightly counterintuitive: why did Python not add the entries of the lists element-by-element? In Python , lists hold arbitrary objects, and are added using concatenation . In fact, concatenation is the concatenaion behavior that we saw earlier when we entered \"hello\" + \" \" + \"world\" . This example reflects the fact that Python is a general-purpose programing language. Much of Python ’s data-specific functionality comes from other packages, notably numpy and pandas",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_36"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This example reflects the fact that Python is a general-purpose programing language. Much of Python ’s data-specific functionality comes from other packages, notably numpy and pandas . In the next section, we will intrduce the numpy package. See docs.scipy.org/doc/numpy/user/quickstart.html for more information about numpy . 2.3.3 Introduction to Numerical Python As mentioned earlier, this book makes use of functionality that is contained in the numpy library , or package . A package is a collection of modules that numpy package are not necessarily included in the base Python distribution. The name numpy is an abbreviation for numerical Python . To access numpy , we must first import it. import In [7]: import numpy as np In the previous line, we named the numpy module np ; an abbreviation for module easier referencing. In numpy , an array is a generic term for a multidimensional set of numbers. array We use the np.array() function to define x and y , which are one-dimensional np.array() arrays, i.e. vectors. In [8]: x = np.array([3, 4, 5]) y = np.array([4, 9, 7]) Note that if you forgot to run the import numpy as np command earlier, then you will encounter an error in calling the np.array() function in the previous line. The syntax np.array() indicates that the function bing called is part of the numpy package, which we have abbreviated as np . Since x and y have been defined using np.array() , we get a sensible result when we add them together. Compare this to our results in the previous section, when we tried to add two lists without using numpy . In [9]: x + y Out[9]: array([ 7, 13, 12]) In numpy , matrices are typically represented as two-dimensional arrays, and vectors as one-dimensional arrays. 1 We can create a two-dimensional array as follows. In [10]: x = np.array([[1, 2], [3, 4]]) x Out[10]: array([[1, 2], [3, 4]]) The object x has several attributes , or associated objects. To access an attribute attribute of x , we type x.attribute , where we replace attribute with the name of the attribute",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_37"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". To access an attribute attribute of x , we type x.attribute , where we replace attribute with the name of the attribute. For instance, we can access the ndim attribute of x ndim as follows. In [11]: x.ndim Out[11]: 2 The output indicates that x is a two-dimensional array. Similarly, x.dtype is the data type attribute of the object x . This indicates that x is comprised data type of 64-bit integers: 1 While it is also possible to create matrices using np.matrix() , we will use np.array() throughout the labs in this book. In [12]: x.dtype Out[12]: dtype( 'int64' ) Why is x comprised of integers? This is because we created x by passing in exclusively integers to the np.array() function. If we had passed in any decimals, then we would have obtained an array of floating point numbers floating point (i.e. real-valued numbers). In [13]: np.array([[1, 2], [3.0, 4]]).dtype Out[13]: dtype( 'float64' ) Typing fun? will cause Python to display documentation associated with the function fun , if it exists. We can try this for np.array() . In [14]: np.array? This documentation indicates that we could create a floating point array by passing a dtype argument into np.array() . dtype In [15]: np.array([[1, 2], [3, 4]], float).dtype Out[15]: dtype( 'float64' ) The array x is two-dimensional. We can find out the number of rows and columns by looking at its shape attribute. shape In [16]: x.shape Out[16]: (2, 2) A method is a function that is associated with an object. For instance, method given an array x , the expression x.sum() sums all of its elements, using the sum() method for arrays. The call x.sum() automatically provides x as the .sum() first argument to its sum() method. In [17]: x = np.array([1, 2, 3, 4]) x.sum() Out[17]: 10 We could also sum the elements of x by passing in x as an argument to the np.sum() function. np.sum() In [18]: x = np.array([1, 2, 3, 4]) np.sum(x) Out[18]: 10 As another example, the reshape() method returns a new array with the .reshape() same elements as x , but a different shape",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_38"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". np.sum() In [18]: x = np.array([1, 2, 3, 4]) np.sum(x) Out[18]: 10 As another example, the reshape() method returns a new array with the .reshape() same elements as x , but a different shape. We do this by passing in a tuple tuple in our call to reshape() , in this case (2, 3) . This tuple specifies that we would like to create a two-dimensional array with 2 rows and 3 columns. 2 In what follows, the \\n character creates a new line . In [19]: x = np.array([1, 2, 3, 4, 5, 6]) print( 'beginning x:\\n' , x) x_reshape = x.reshape((2, 3)) print( 'reshaped x:\\n' , x_reshape) beginning x: [1 2 3 4 5 6] reshaped x: [[1 2 3] [4 5 6]] The previous output reveals that numpy arrays are specified as a sequence of rows . This is called row-major ordering , as opposed to column-major ordering . Python (and hence numpy ) uses 0-based indexing. This means that to access the top left element of x_reshape , we type in x_reshape[0,0] . In [20]: x_reshape[0, 0] Out[20]: 1 Similarly, x_reshape[1,2] yields the element in the second row and the third column of x_reshape . In [21]: x_reshape[1, 2] Out[21]: 6 Similarly, x[2] yields the third entry of x . Now, let’s modify the top left element of x_reshape . To our surprise, we discover that the first element of x has been modified as well! In [22]: print( 'x before we modify x_reshape:\\n' , x) print( 'x_reshape before we modify x_reshape:\\n' , x_reshape) x_reshape[0, 0] = 5 print( 'x_reshape after we modify its top left element:\\n' , x_reshape) print( 'x after we modify t op l e f t e lement of x_reshape:\\n' , x) Out[22]: x before we modify x_reshape: [1 2 3 4 5 6] x_reshape before we modify x_reshape: [[1 2 3] [4 5 6]] x_reshape after we modify its top left element: [[5 2 3] 2 Like lists, tuples represent a sequence of objects. Why do we need more than one way to create a sequence? There are a few differences between tuples and lists, but perhaps the most important is that elements of a tuple cannot be modified, whereas elements of a list can be",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_39"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". [4 5 6]] x after we modify top left element of x_reshape: [5 2 3 4 5 6] Modifying x_reshape also modified x because the two objects occupy the same space in memory. We just saw that we can modify an element of an array. Can we also moify a tuple? It turns out that we cannot — and trying to do so introduces an exception , or error. exception In [23]: my_tuple = (3, 4, 5) my_tuple[0] = 2 TypeError: 'tuple' object does not support item assignment We now briefly mention some attributes of arrays that will come in handy. An array’s shape attribute contains its dimension; this is always a tuple. The ndim attribute yields the number of dimensions, and T provides its transpose. In [24]: x_reshape.shape, x_reshape.ndim, x_reshape.T Out[24]: ((2, 3), 2, array([[5, 4], [2, 5], [3, 6]])) Notice that the three individual outputs (2,3) , 2 , and array([[5, 4],[2, 5], [3,6]]) are themselves output as a tuple. We will often want to apply functions to arrays. For instance, we can compute the square root of the entries using the np.sqrt() function: np.sqrt() In [25]: np.sqrt(x) Out[25]: array([2.24, 1.41, 1.73, 2., 2.24, 2.45]) We can also square the elements: In [26]: x**2 Out[26]: array([25, 4, 9, 16, 25, 36]) We can compute the square roots using the same notation, raising to the power of 1 / 2 instead of 2. In [27]: x**0.5 Out[27]: array([2.24, 1.41, 1.73, 2., 2.24, 2.45]) Throughout this book, we will often want to generate random data. The np.random.normal() function generates a vector of random normal variables. np.random. normal() We can learn more about this function by looking at the help page, via a call to np.random.normal? . The first line of the help page reads normal(loc=0.0, scale=1.0, size=None) . This signature line tells us that the function’s asignature guments are loc , scale , and size . These are keyword arguments, which keyword means that when they are passed into the function, they can be referred to by name (in any order)",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_40"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". These are keyword arguments, which keyword means that when they are passed into the function, they can be referred to by name (in any order). 3 By default, this function will generate random normal variable(s) with mean ( loc ) 0 and standard deviation ( scale ) 1 ; futhermore, a single random variable will be generated unless the argument to size is changed. We now generate 50 independent random variables from a N (0 , 1) ditribution. In [28]: x = np.random.normal(size=50) x Out[28]: array([-1.19, 0.41, 0.9 , -0.44, -0.9 , -0.38, 0.13, 1.87, -0.35, 1.16, 0.79, -0.97, -1.21, 0.06, -1.62, -0.6 , -0.77, -2.12, 0.38, -1.22, -0.06, -1.97, -1.74, -0.56, 1.7 , -0.95, 0.56, 0.35, 0.87, 0.88, -1.66, -0.32, -0.3 , -1.36, 0.92, -0.31, 1.28, -1.94, 1.07, 0.07, 0.79, -0.46, 2.19, -0.27, -0.64, 0.85, 0.13, 0.46, -0.09, 0.7 ]) We create an array y by adding an independent N (50 , 1) random variable to each element of x . In [29]: y = x + np.random.normal(loc=50, scale=1, size=50) The np.corrcoef() function computes the correlation matrix between x and np.corrcoef() y . The off-diagonal elements give the correlation between x and y . In [30]: np.corrcoef(x, y) Out[30]: array([[1. , 0.69], [0.69, 1. ]]) If you’re following along in your own Jupyter notebook, then you probably noticed that you got a different set of results when you ran the past few commands. In particular, each time we call np.random.normal() , we will get a different answer, as shown in the following example. In [31]: print(np.random.normal(scale=5, size=2)) print(np.random.normal(scale=5, size=2)) Out[31]: [4.28 2.59] [4.62 -2.54] In order to ensure that our code provides exactly the same results each time it is run, we can set a random seed using the np.random.default_rng() random seed np.random. default_rng() function. This function takes an arbitrary, user-specified integer argument. If we set a random seed before generating random data, then re-running our code will yield the same results",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_41"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". default_rng() function. This function takes an arbitrary, user-specified integer argument. If we set a random seed before generating random data, then re-running our code will yield the same results. The object rng has essentially all the 3 Python also uses positional arguments. Positional arguments do not need to use a keyword. To see an example, type in np.sum? . We see that a is a positional argument, i.e. this function assumes that the first unnamed argument that it receives is the array to be summed. By contrast, axis and dtype are keyword arguments: the position in which these arguments are entered into np.sum() does not matter. random number generating methods found in np.random . Hence, to generate normal data we use rng.normal() . In [32]: rng = np.random.default_rng(1303) print(rng.normal(scale=5, size=2)) rng2 = np.random.default_rng(1303) print(rng2.normal(scale=5, size=2)) Out[32]: [4.09 -1.07 ] [4.09 -1.07 ] Throughout the labs in this book, we use np.random.default_rng() wheever we perform calculations involving random quantities within numpy . In principle, this should enable the reader to exactly reproduce the stated results. However, as new versions of numpy become available, it is possible that some small discrepancies may occur between the output in the labs and the output from numpy . The np.mean() , np.var() , and np.std() functions can be used to compute np.mean() np.var() np.std() the mean, variance, and standard deviation of arrays. These functions are also available as methods on the arrays. In [33]: rng = np.random.default_rng(3) y = rng.standard_normal(10) np.mean(y), y.mean() Out[33]: (-0.11, -0.11) In [34]: np.var(y), y.var(), np.mean((y - y.mean())**2) Out[34]: (2.72, 2.72, 2.72) Notice that by default np.var() divides by the sample size n rather than n − 1 ; see the ddof argument in np.var? . In [35]: np.sqrt(np.var(y)), np.std(y) Out[35]: (1.65, 1.65) The np.mean() , np.var() , and np.std() functions can also be applied to the rows and columns of a matrix",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_42"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [35]: np.sqrt(np.var(y)), np.std(y) Out[35]: (1.65, 1.65) The np.mean() , np.var() , and np.std() functions can also be applied to the rows and columns of a matrix. To see this, we construct a 10 × 3 matrix of N (0 , 1) random variables, and consider computing its row sums. In [36]: X = rng.standard_normal((10, 3)) X Out[36]: array([[ 0.23, -0.35, -0.28], [-0.67, -1.06, -0.39], [ 0.48, -0.24, 0.96], [-0.2 , 0.02, 1.55], [ 0.55, -0.51, -0.18], [ 0.54, 1.94, -0.27], [-0.24, 1. , -0.89], [-0.29, 0.88, 0.58], [ 0.09, 0.67, -2.83], [ 1.02, -0.96, -1.67]]) Since arrays are row-major ordered, the first axis, i.e. axis=0 , refers to its rows. We pass this argument into the mean() method for the object X . .mean() In [37]: X.mean(axis=0) Out[37]: array([0.15, 0.14, -0.34]) The following yields the same result. In [38]: X.mean(0) Out[38]: array([0.15, 0.14, -0.34]) 2.3.4 Graphics In Python , common practice is to use the library matplotlib for graphics. matplotlib However, since Python was not written with data analysis in mind, the ntion of plotting is not intrinsic to the language. We will use the subplots() function from matplotlib.pyplot to create a figure and the axes onto which we plot our data. For many more examples of how to make plots in Python , readers are encouraged to visit matplotlib.org/stable/gallery/ . In matplotlib , a plot consists of a figure and one or more axes . You can figure axes think of the figure as the blank canvas upon which one or more plots will be displayed: it is the entire plotting window. The axes contain important information about each plot, such as its x - and y -axis labels, title, and more. (Note that in matplotlib , the word axes is not the plural of axis : a plot’s axes contains much more information than just the x -axis and the y -axis.) We begin by importing the subplots() function from matplotlib . We subplots() use this function throughout when creating figures. The function returns a tuple of length two: a figure object as well as the relevant axes object",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_43"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We subplots() use this function throughout when creating figures. The function returns a tuple of length two: a figure object as well as the relevant axes object. We will typically pass figsize as a keyword argument. Having created our axes, we attempt our first plot using its plot() method. To learn more .plot() about it, type ax.plot? . In [39]: from matplotlib.pyplot import subplots fig, ax = subplots(figsize=(8, 8)) x = rng.standard_normal(100) y = rng.standard_normal(100) ax.plot(x, y); We pause here to note that we have unpacked the tuple of length two rturned by subplots() into the two distinct variables fig and ax . Unpacking is typically preferred to the following equivalent but slightly more verbose code: In [40]: output = subplots(figsize=(8, 8)) fig = output[0] ax = output[1] We see that our earlier cell produced a line plot, which is the default. To create a scatterplot, we provide an additional argument to ax.plot() , indicating that circles should be displayed. In [41]: fig, ax = subplots(figsize=(8, 8)) ax.plot(x, y, 'o' ); Different values of this additional argument can be used to produce different colored lines as well as different linestyles. As an alternative, we could use the ax.scatter() function to create a .scatter() scatterplot. In [42]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(x, y, marker= 'o' ); Notice that in the code blocks above, we have ended the last line with a semicolon. This prevents ax.plot(x, y) from printing text to the notebook. However, it does not prevent a plot from being produced. If we omit the trailing semi-colon, then we obtain the following output: In [43]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(x, y, marker= 'o' ) Out[43]: <matplotlib.collections.PathCollection at 0x7fb3d9c8f310 > Figure(432x288) In what follows, we will use trailing semicolons whenever the text that would be output is not germane to the discussion at hand. To label our plot, we make use of the set_xlabel() , set_ylabel() , and .set_xlabel() .set_ylabel() set_title() methods of ax",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_44"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". To label our plot, we make use of the set_xlabel() , set_ylabel() , and .set_xlabel() .set_ylabel() set_title() methods of ax . .set_title() In [44]: fig, ax = subplots(figsize=(8, 8)) ax.scatter(x, y, marker= 'o' ) ax.set_xlabel( \"this is the x-axis\" ) ax.set_ylabel( \"this is the y-axis\" ) ax.set_title( \"Plot of X vs Y\" ); Having access to the figure object fig itself means that we can go in and change some aspects and then redisplay it. Here, we change the size from (8, 8) to (12, 3) . fig.set_size_inches(12,3) fig Occasionally we will want to create several plots within a figure. This can be achieved by passing additional arguments to subplots() . Below, we create a 2 × 3 grid of plots in a figure of size determined by the figsize argument. In such situations, there is often a relationship between the axes in the plots. For example, all plots may have a common x -axis. The subplots() function can automatically handle this situation when passed the keyword argument sharex=True . The axes object below is an array pointing to different plots in the figure. In [45]: fig, axes = subplots(nrows=2, ncols=3, figsize=(15, 5)) We now produce a scatter plot with 'o' in the second column of the first row and a scatter plot with '+' in the third column of the second row. In [46]: axes[0,1].plot(x, y, 'o' ) axes[1,2].scatter(x, y, marker= '+' ) fig Type subplots? to learn more about subplots() . To save the output of fig , we call its savefig() method. The argument .savefig() dpi is the dots per inch, used to determine how large the figure will be in pixels. In [47]: fig.savefig( \"Figure.png\" , dpi=400) fig.savefig( \"Figure.pdf\" , dpi=200); We can continue to modify fig using step-by-step updates; for example, we can modify the range of the x -axis, re-save the figure, and even re-display it. In [48]: axes[0,1].set_xlim([-1,1]) fig.savefig( \"Figure_updated.jpg\" ) fig We now create some more sophisticated plots",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_45"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [48]: axes[0,1].set_xlim([-1,1]) fig.savefig( \"Figure_updated.jpg\" ) fig We now create some more sophisticated plots. The ax.contour() method .contour() produces a contour plot in order to represent three-dimensional data, similar contour plot to a topographical map. It takes three arguments: • A vector of x values (the first dimension), • A vector of y values (the second dimension), and • A matrix whose elements correspond to the z value (the third dimesion) for each pair of (x,y) coordinates. To create x and y , we’ll use the command np.linspace(a, b, n) , which np.linspace() returns a vector of n numbers starting at a and ending at b . In [49]: fig, ax = subplots(figsize=(8, 8)) x = np.linspace(-np.pi, np.pi, 50) y = x f = np.multiply.outer(np.cos(y), 1 / (1 + x**2)) ax.contour(x, y, f); We can increase the resolution by adding more levels to the image. In [50]: fig, ax = subplots(figsize=(8, 8)) ax.contour(x, y, f, levels=45); To fine-tune the output of the ax.contour() function, take a look at the help file by typing ?plt.contour . The ax.imshow() method is similar to ax.contour() , except that it pr.imshow() duces a color-coded plot whose colors depend on the z value. This is known as a heatmap , and is sometimes used to plot temperature in weather forheatmap casts. In [51]: fig, ax = subplots(figsize=(8, 8)) ax.imshow(f); 2.3.5 Sequences and Slice Notation As seen above, the function np.linspace() can be used to create a sequence of numbers. In [52]: seq1 = np.linspace(0, 10, 11) seq1 Out[52]: array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) The function np.arange() returns a sequence of numbers spaced out by np.arange() step . If step is not specified, then a default value of 1 is used. Let’s create a sequence that starts at 0 and ends at 10 . In [53]: seq2 = np.arange(0, 10) seq2 Out[53]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) Why isn’t 10 output above? This has to do with slice notation in Python . slice Slice notation is used to index sequences such as lists, tuples and arrays",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_46"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". slice Slice notation is used to index sequences such as lists, tuples and arrays. Suppose we want to retrieve the fourth through sixth (inclusive) entries of a string. We obtain a slice of the string using the indexing notation [3:6] . In [54]: \"hello world\" [3:6] Out[54]: 'lo ' In the code block above, the notation 3:6 is shorthand for slice(3,6) when used inside [] . In [55]: \"hello world\" [slice(3,6)] Out[55]: 'lo ' You might have expected slice(3,6) to output the fourth through seventh characters in the text string (recalling that Python begins its indexing at zero), but instead it output the fourth through sixth. This also explains why the earlier np.arange(0, 10) command output only the integers from 0 to 9 . See the documentation slice? for useful options in creating slices. 2.3.6 Indexing Data To begin, we create a two-dimensional numpy array. In [56]: A = np.array(np.arange(16)).reshape((4, 4)) A Out[56]: array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) Typing A[1,2] retrieves the element corresponding to the second row and third column. (As usual, Python indexes from 0 . ) In [57]: A[1,2] Out[57]: 6 The first number after the open-bracket symbol [ refers to the row, and the second number refers to the column. Indexing Rows, Columns, and Submatrices To select multiple rows at a time, we can pass in a list specifying our selection. For instance, [1,3] will retrieve the second and fourth rows: In [58]: A[[1,3]] Out[58]: array([[ 4, 5, 6, 7], [12, 13, 14, 15]]) To select the first and third columns, we pass in [0,2] as the second agument in the square brackets. In this case we need to supply the first argument : which selects all rows. In [59]: A[:,[0,2]] Out[59]: array([[ 0, 2], [ 4, 6], [ 8, 10], [12, 14]]) Now, suppose that we want to select the submatrix made up of the second and fourth rows as well as the first and third columns. This is where indeing gets slightly tricky",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_47"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This is where indeing gets slightly tricky. It is natural to try to use lists to retrieve the rows and columns: In [60]: A[[1,3],[0,2]] Out[60]: array([ 4, 14]) Oops — what happened? We got a one-dimensional array of length two identical to In [61]: np.array([A[1,0],A[3,2]]) Out[61]: array([ 4, 14]) Similarly, the following code fails to extract the submatrix comprised of the second and fourth rows and the first, third, and fourth columns: In [62]: A[[1,3],[0,2,3]] IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (2,) (3,) We can see what has gone wrong here. When supplied with two indexing lists, the numpy interpretation is that these provide pairs of i, j indices for a series of entries. That is why the pair of lists must have the same length. However, that was not our intent, since we are looking for a submatrix. One easy way to do this is as follows. We first create a submatrix by subsetting the rows of A , and then on the fly we make a further submatrix by subsetting its columns. In [63]: A[[1,3]][:,[0,2]] Out[63]: array([[ 4, 6], [12, 14]]) There are more efficient ways of achieving the same result. The convenience function np.ix_() allows us to extract a submatrix using convenience function np.ix_() lists, by creating an intermediate mesh object. mesh In [64]: idx = np.ix_([1,3],[0,2,3]) A[idx] Out[64]: array([[ 4, 6, 7], [12, 14, 15]]) Alternatively, we can subset matrices efficiently using slices. The slice 1:4:2 captures the second and fourth items of a sequence, while the slice 0:3:2 captures the first and third items (the third element in a slice squence is the step size). In [65]: A[1:4:2,0:3:2] Out[65]: array([[ 4, 6], [12, 14]]) Why are we able to retrieve a submatrix directly using slices but not using lists? Its because they are different Python types, and are treated differently by numpy . Slices can be used to extract objects from arbitrary sequences, such as strings, lists, and tuples, while the use of lists for indexing is more limited",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_48"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Slices can be used to extract objects from arbitrary sequences, such as strings, lists, and tuples, while the use of lists for indexing is more limited. Boolean Indexing In numpy , a Boolean is a type that equals either True or False (also reBoolean resented as 1 and 0 , respectively). The next line creates a vector of 0 ’s, represented as Booleans, of length equal to the first dimension of A . In [66]: keep_rows = np.zeros(A.shape[0], bool) keep_rows Out[66]: array([False, False, False, False]) We now set two of the elements to True . In [67]: keep_rows[[1,3]] = True keep_rows Out[67]: array([False, True, False, True]) Note that the elements of keep_rows , when viewed as integers, are the same as the values of np.array([0,1,0,1]) . Below, we use == to verify their equaity. When applied to two arrays, the == operation is applied elementwise. In [68]: np.all(keep_rows == np.array([0,1,0,1])) Out[68]: True (Here, the function np.all() has checked whether all entries of an array np.all() are True . A similar function, np.any() , can be used to check whether any np.any() entries of an array are True .) However, even though np.array([0,1,0,1]) and keep_rows are equal acording to == , they index different sets of rows! The former retrieves the first, second, first, and second rows of A . In [69]: A[np.array([0,1,0,1])] Out[69]: array([[0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 2, 3], [4, 5, 6, 7]]) By contrast, keep_rows retrieves only the second and fourth rows of A — i.e. the rows for which the Boolean equals TRUE . In [70]: A[keep_rows] Out[70]: array([[ 4, 5, 6, 7], [12, 13, 14, 15]]) This example shows that Booleans and integers are treated differently by numpy . We again make use of the np.ix_() function to create a mesh containing the second and fourth rows, and the first, third, and fourth columns. This time, we apply the function to Booleans, rather than lists",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_49"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This time, we apply the function to Booleans, rather than lists. In [71]: keep_cols = np.zeros(A.shape[1], bool) keep_cols[[0, 2, 3]] = True idx_bool = np.ix_(keep_rows, keep_cols) A[idx_bool] Out[71]: array([[ 4, 6, 7], [12, 14, 15]]) We can also mix a list with an array of Booleans in the arguments to np.ix_() : In [72]: idx_mixed = np.ix_([1,3], keep_cols) A[idx_mixed] Out[72]: array([[ 4, 6, 7], [12, 14, 15]]) For more details on indexing in numpy , readers are referred to the numpy tutorial mentioned earlier. 2.3.7 Loading Data Data sets often contain different types of data, and may have names asociated with the rows or columns. For these reasons, they typically are best accommodated using a data frame . We can think of a data frame as data frame a sequence of arrays of identical length; these are the columns. Entries in the different arrays can be combined to form a row. The pandas library can be used to create and work with data frame objects. Reading in a Data Set The first step of most analyses involves importing a data set into Python . Before attempting to load a data set, we must make sure that Python knows where to find the file containing it. If the file is in the same location as this notebook file, then we are all set. Otherwise, the command os.chdir() can os.chdir() be used to change directory . (You will need to call import os before calling os.chdir() .) We will begin by reading in Auto.csv , available on the book website. This is a comma-separated file, and can be read in using pd.read_csv() : pd.read_csv() In [73]: import pandas as pd Auto = pd.read_csv( 'Auto.csv' ) Auto The book website also has a whitespace-delimited version of this data, called Auto.data . This can be read in as follows: In [74]: Auto = pd.read_csv( 'Auto.data' , delim_whitespace=True ) Both Auto.csv and Auto.data are simply text files. Before loading data into Python , it is a good idea to view it using a text editor or other software, such as Microsoft Excel",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_50"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Before loading data into Python , it is a good idea to view it using a text editor or other software, such as Microsoft Excel. We now take a look at the column of Auto corresponding to the variable horsepower : In [75]: Auto[ 'horsepower' ] Out[75]: 0 130.0 1 165.0 2 150.0 3 150.0 4 140.0 392 86.00 393 52.00 394 84.00 395 79.00 396 82.00 Name: horsepower , Length: 397, dtype: object We see that the dtype of this column is object . It turns out that all values of the horsepower column were interpreted as strings when reading in the data. We can find out why by looking at the unique values. In [76]: np.unique(Auto[ 'horsepower' ]) To save space, we have omitted the output of the previous code block. We see the culprit is the value ? , which is being used to encode missing values. To fix the problem, we must provide pd.read_csv() with an argument called na_values . Now, each instance of ? in the file is replaced with the value np.nan , which means not a number : In [77]: Auto = pd.read_csv( 'Auto.data' , na_values=[ '?' ], delim_whitespace=True) Auto[ 'horsepower' ].sum() Out[77]: 40952.0 The Auto.shape attribute tells us that the data has 397 observations, or rows, and nine variables, or columns. In [78]: Auto.shape Out[78]: (397, 9) There are various ways to deal with missing data. In this case, since only five of the rows contain missing observations, we choose to use the Auto.dropna() method to simply remove these rows. .dropna() In [79]: Auto_new = Auto.dropna() Auto_new.shape Out[79]: (392, 9) Basics of Selecting Rows and Columns We can use Auto.columns to check the variable names. In [80]: Auto = Auto_new # overwrite the previous value Auto.columns Out[80]: Index([ 'mpg' , 'cylinders' , 'displacement' , 'horsepower' , 'weight' , 'acceleration' , 'year' , 'origin' , 'name' ], dtype= 'object' ) Accessing the rows and columns of a data frame is similar, but not idetical, to accessing the rows and columns of an array. Recall that the first argument to the [] method is always applied to the rows of the array",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_51"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Recall that the first argument to the [] method is always applied to the rows of the array. Siilarly, passing in a slice to the [] method creates a data frame whose rows are determined by the slice: In [81]: Auto[:3] Out[81]: mpg cylinders displacement horsepower weight 0 18.0 8 307.0 130.0 3504.0 1 15.0 8 350.0 165.0 3693.0 2 18.0 8 318.0 150.0 3436.0 Similarly, an array of Booleans can be used to subset the rows: In [82]: idx_80 = Auto[ 'year' ] > 80 Auto[idx_80] However, if we pass in a list of strings to the [] method, then we obtain a data frame containing the corresponding set of columns . In [83]: Auto[[ 'mpg' , 'horsepower' ]] Out[83]: mpg horsepower 0 18.0 130.0 1 15.0 165.0 2 18.0 150.0 3 16.0 150.0 4 17.0 140.0 392 27.0 86.0 393 44.0 52.0 394 32.0 84.0 395 28.0 79.0 396 31.0 82.0 392 rows x 2 columns Since we did not specify an index column when we loaded our data frame, the rows are labeled using integers 0 to 396. In [84]: Auto.index Out[84]: Int64Index([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396], dtype= 'int64' , length=392) We can use the set_index() method to re-name the rows using the contents .set_index() of Auto['name'] . In [85]: Auto_re = Auto.set_index( 'name' ) Auto_re Out[85]: mpg cylinders displacement name chevrolet chevelle malibu 18.0 8 307.0 buick skylark 32 15.0 8 350.0 plymouth satellite 18.0 8 318.0 amc rebel sst 16.0 8 304.0 In [86]: Auto_re.columns Out[86]: Index([ 'mpg' , 'cylinders' , 'displacement' , 'horsepower' , 'weight' , 'acceleration' , 'year' , 'origin' ], dtype= 'object' ) We see that the column 'name' is no longer there",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_52"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Now that the index has been set to name , we can access rows of the data frame by name using the loc[] method of Auto : .loc[] In [87]: rows = [ 'amc rebel sst' , 'ford torino' ] Auto_re.loc[rows] Out[87]: mpg cylinders displacement horsepower name amc rebel sst 16.0 8 304.0 150.0 ford torino 17.0 8 302.0 140.0 As an alternative to using the index name, we could retrieve the 4th and 5th rows of Auto using the iloc[] method: .iloc[] In [88]: Auto_re.iloc[[3,4]] We can also use it to retrieve the 1st, 3rd and and 4th columns of Auto_re : In [89]: Auto_re.iloc[:,[0,2,3]] We can extract the 4th and 5th rows, as well as the 1st, 3rd and 4th columns, using a single call to iloc[] : In [90]: Auto_re.iloc[[3,4],[0,2,3]] Out[90]: mpg displacement horsepower name amc rebel sst 16.0 304.0 150.0 ford torino 17.0 302.0 140.0 Index entries need not be unique: there are several cars in the data frame named ford galaxie 500 . In [91]: Auto_re.loc[ 'ford galaxie 500' , [ 'mpg' , 'origin' ]] Out[91]: mpg origin name ford galaxie 500 15.0 1 ford galaxie 500 14.0 1 ford galaxie 500 14.0 1 More on Selecting Rows and Columns Suppose now that we want to create a data frame consisting of the weight and origin of the subset of cars with year greater than 80 — i.e. those built after 1980. To do this, we first create a Boolean array that indexes the rows. The loc[] method allows for Boolean entries as well as strings: In [92]: idx_80 = Auto_re[ 'year' ] > 80 Auto_re.loc[idx_80, [ 'weight' , 'origin' ]] To do this more concisely, we can use an anonymous function called a lambda : lambda In [93]: Auto_re.loc[lambda df: df[ 'year' ] > 80, [ 'weight' , 'or i g i n' ] ] The lambda call creates a function that takes a single argument, here df , and returns df['year']>80 . Since it is created inside the loc[] method for the dataframe Auto_re , that dataframe will be the argument supplied",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_53"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Since it is created inside the loc[] method for the dataframe Auto_re , that dataframe will be the argument supplied. As another example of using a lambda , suppose that we want all cars built after 1980 that achieve greater than 30 miles per gallon: In [94]: Auto_re.loc[lambda df: (df[ 'year' ] > 80) & (df[ 'mpg' ] > 30), [ 'weight' , 'origin' ] ] The symbol & computes an element-wise and operation. As another eample, suppose that we want to retrieve all Ford and Datsun cars with displacement less than 300. We check whether each name entry contains either the string ford or datsun using the str.contains() method of the .str. contains() index attribute of of the dataframe: In [95]: Auto_re.loc[lambda df: (df[ 'displacement' ] < 300) & (df.index.str.contains( 'ford' ) | df.index.str.contains( 'datsun' )), [ 'weight' , 'origin' ] ] Here, the symbol | computes an element-wise or operation. In summary, a powerful set of operations is available to index the rows and columns of data frames. For integer based queries, use the iloc[] method. For string and Boolean selections, use the loc[] method. For functional queries that filter rows, use the loc[] method with a function (typically a lambda ) in the rows argument. 2.3.8 For Loops A for loop is a standard tool in many languages that repeatedly evaluates for some chunk of code while varying different values inside the code. For example, suppose we loop over elements of a list and compute their sum. In [96]: total = 0 for value in [3,2,19]: total += value print( 'Total is: {0}' .format(total)) Total is: 24 The indented code beneath the line with the for statement is run for each value in the sequence specified in the for statement. The loop ends either when the cell ends or when code is indented at the same level as the original for statement. We see that the final line above which prints the total is executed only once after the for loop has terminated. Loops can be nested by additional indentation",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_54"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We see that the final line above which prints the total is executed only once after the for loop has terminated. Loops can be nested by additional indentation. In [97]: total = 0 for value in [2,3,19]: for weight in [3, 2, 1]: total += value * weight print( 'Total is: {0}' .format(total)) Total is: 144 Above, we summed over each combination of value and weight . We also took advantage of the increment notation in Python : the expression a += b increment is equivalent to a = a + b . Besides being a convenient notation, this can save time in computationally heavy tasks in which the intermediate value of a+b need not be explicitly created. Perhaps a more common task would be to sum over (value, weight) pairs. For instance, to compute the average value of a random variable that takes on possible values 2, 3 or 19 with probability 0.2, 0.3, 0.5 respetively we would compute the weighted sum. Tasks such as this can often be accomplished using the zip() function that loops over a sequence of tuples. zip() In [98]: total = 0 for value, weight in zip([2,3,19], [0.2,0.3,0.5]): total += weight * value print( 'Weighted average is: {0}' .format(total)) Weighted average is: 10.8 String Formatting In the code chunk above we also printed a string displaying the total. However, the object total is an integer and not a string. Inserting the value of something into a string is a common task, made simple using some of the powerful string formatting tools in Python . Many data cleaning tasks involve manipulating and programmatically producing strings. For example we may want to loop over the columns of a data frame and print the percent missing in each column. Let’s create a data frame D with columns in which 20% of the entries are missing i.e. set to np.nan . np.nan We’ll create the values in D from a normal distribution with mean 0 and variance 1 using rng.standard_normal() and then overwrite some random entries using rng.choice()",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_55"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". set to np.nan . np.nan We’ll create the values in D from a normal distribution with mean 0 and variance 1 using rng.standard_normal() and then overwrite some random entries using rng.choice() . In [99]: rng = np.random.default_rng(1) A = rng.standard_normal((127, 5)) M = rng.choice([0, np.nan], p=[0.8,0.2], size=A.shape) A += M D = pd.DataFrame(A, columns=[ 'food' , 'bar' , 'pickle' , 'snack' , 'popcorn' ]) D[:3] Out[99]: food bar pickle snack popcorn 0 0.345584 0.821618 0.330437 -1.303157 NaN 1 NaN -0.536953 0.581118 0.364572 0.294132 2 NaN 0.546713 NaN -0.162910 -0.482119 In [100]: for col in D.columns: template = 'Column \"{0}\" has {1:.2%} missing values' print(template.format(col, np.isnan(D[col]).mean())) Column \"food\" has 16.54% missing values Column \"bar\" has 25.98% missing values Column \"pickle\" has 29.13% missing values Column \"snack\" has 21.26% missing values Column \"popcorn\" has 22.83% missing values We see that the template.format() method expects two arguments {0} and {1:.2%} , and the latter includes some formatting information. In particular, it specifies that the second argument should be expressed as a percent with two decimal digits. The reference docs.python.org/3/library/string.html includes many helful and more complex examples. 2.3.9 Additional Graphical and Numerical Summaries We can use the ax.plot() or ax.scatter() functions to display the quatitative variables. However, simply typing the variable names will produce an error message, because Python does not know to look in the Auto data set for those variables. In [101]: fig, ax = subplots(figsize=(8, 8)) ax.plot(horsepower, mpg, 'o' ); NameError: name 'horsepower' is not defined We can address this by accessing the columns directly: In [102]: fig, ax = subplots(figsize=(8, 8)) ax.plot(Auto[ 'horsepower' ], Auto[ 'mpg' ], 'o' ); Alternatively, we can use the plot() method with the call Auto.plot() . U.plot() ing this method, the variables can be accessed by name. The plot methods of a data frame return a familiar object: an axes",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_56"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". U.plot() ing this method, the variables can be accessed by name. The plot methods of a data frame return a familiar object: an axes. We can use it to update the plot as we did previously: In [103]: ax = Auto.plot.scatter( 'horsepower' , 'mpg' ); ax.set_title( 'Horsepower vs. MPG' ) If we want to save the figure that contains a given axes, we can find the relevant figure by accessing the figure attribute: In [104]: fig = ax.figure fig.savefig( 'horsepower_mpg.png' ); We can further instruct the data frame to plot to a particular axes object. In this case the corresponding plot() method will return the modified axes we passed in as an argument. Note that when we request a one-dimensional grid of plots, the object axes is similarly one-dimensional. We place our scatter plot in the middle plot of a row of three plots within a figure. In [105]: fig, axes = subplots(ncols=3, figsize=(15, 5)) Auto.plot.scatter( 'horsepower' , 'mpg' , ax=axes[1]); Note also that the columns of a data frame can be accessed as attributes: try typing in Auto.horsepower . We now consider the cylinders variable. Typing in Auto.cylinders.dtype reveals that it is being treated as a quantitative variable. However, since there is only a small number of possible values for this variable, we may wish to treat it as qualitative. Below, we replace the cylinders column with a categorical version of Auto.cylinders . The function pd.Series() owes its pd.Series() name to the fact that pandas is often used in time series applications. In [106]: Auto.cylinders = pd.Series(Auto.cylinders, dtype= 'category' ) Auto.cylinders.dtype Now that cylinders is qualitative, we can display it using the boxplot() .boxplot() method. In [107]: fig, ax = subplots(figsize=(8, 8)) Auto.boxplot( 'mpg' , by= 'cylinders' , ax=ax); The hist() method can be used to plot a histogram",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_57"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [107]: fig, ax = subplots(figsize=(8, 8)) Auto.boxplot( 'mpg' , by= 'cylinders' , ax=ax); The hist() method can be used to plot a histogram . .hist() In [108]: fig, ax = subplots(figsize=(8, 8)) Auto.hist( 'mpg' , ax=ax); The color of the bars and the number of bins can be changed: In [109]: fig, ax = subplots(figsize=(8, 8)) Auto.hist( 'mpg' , color= 'red' , bins=12, ax=ax); See Auto.hist? for more plotting options. We can use the pd.plotting.scatter_matrix() function to create a scapd.plotting. scatter_ matrix() terplot matrix to visualize all of the pairwise relationships between the columns in a data frame. In [110]: pd.plotting.scatter_matrix(Auto); We can also produce scatterplots for a subset of the variables. In [111]: pd.plotting.scatter_matrix(Auto[[ 'mpg' , 'displacement' , 'weight' ]]); The describe() method produces a numerical summary of each column in .describe() a data frame. In [112]: Auto[[ 'mpg' , 'weight' ]].describe() We can also produce a summary of just a single column. In [113]: Auto[ 'cylinders' ].describe() Auto[ 'mpg' ].describe() To exit Jupyter , select File / Close and Halt . 2.4 Exercises Conceptual 1. For each of parts (a) through (d), indicate whether we would generally expect the performance of a flexible statistical learning method to be better or worse than an inflexible method. Justify your answer. (a) The sample size n is extremely large, and the number of preditors p is small. (b) The number of predictors p is extremely large, and the number of observations n is small. (c) The relationship between the predictors and response is highly non-linear. (d) The variance of the error terms, i.e. σ 2 = Var ( ε ) , is extremely high. 2. Explain whether each scenario is a classification or regression prolem, and indicate whether we are most interested in inference or prdiction. Finally, provide n and p . (a) We collect a set of data on the top 500 firms in the US. For each firm we record profit, number of employees, industry and the CEO salary",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_58"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Finally, provide n and p . (a) We collect a set of data on the top 500 firms in the US. For each firm we record profit, number of employees, industry and the CEO salary. We are interested in understanding which factors affect CEO salary. (b) We are considering launching a new product and wish to know whether it will be a success or a failure . We collect data on 20 similar products that were previously launched. For each prouct we have recorded whether it was a success or failure, price charged for the product, marketing budget, competition price, and ten other variables. (c) We are interested in predicting the % change in the USD/Euro exchange rate in relation to the weekly changes in the world stock markets. Hence we collect weekly data for all of 2012. For each week we record the % change in the USD/Euro, the % change in the US market, the % change in the British market, and the % change in the German market. 3. We now revisit the bias-variance decomposition. (a) Provide a sketch of typical (squared) bias, variance, training eror, test error, and Bayes (or irreducible) error curves, on a sigle plot, as we go from less flexible statistical learning methods towards more flexible approaches. The x -axis should represent the amount of flexibility in the method, and the y -axis should represent the values for each curve. There should be five curves. Make sure to label each one. (b) Explain why each of the five curves has the shape displayed in part (a). 4. You will now think of some real-life applications for statistical learing. (a) Describe three real-life applications in which classification might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer. (b) Describe three real-life applications in which regression might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_59"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer. (c) Describe three real-life applications in which cluster analysis might be useful. 5. What are the advantages and disadvantages of a very flexible (versus a less flexible) approach for regression or classification? Under what circumstances might a more flexible approach be preferred to a less flexible approach? When might a less flexible approach be preferred? 6. Describe the differences between a parametric and a non-parametric statistical learning approach. What are the advantages of a parmetric approach to regression or classification (as opposed to a noparametric approach)? What are its disadvantages? 7. The table below provides a training data set containing six observtions, three predictors, and one qualitative response variable. Obs. X 1 X 2 X 3 Y 1 0 3 0 Red 2 2 0 0 Red 3 0 1 3 Red 4 0 1 2 Green 5 − 1 0 1 Green 6 1 1 1 Red Suppose we wish to use this data set to make a prediction for Y when X 1 = X 2 = X 3 = 0 using K -nearest neighbors. (a) Compute the Euclidean distance between each observation and the test point, X 1 = X 2 = X 3 = 0 . (b) What is our prediction with K = 1 ? Why? (c) What is our prediction with K = 3 ? Why? (d) If the Bayes decision boundary in this problem is highly nolinear, then would we expect the best value for K to be large or small? Why? Applied 8. This exercise relates to the College data set, which can be found in the file College.csv on the book website. It contains a number of variables for 777 different universities and colleges in the US",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_60"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This exercise relates to the College data set, which can be found in the file College.csv on the book website. It contains a number of variables for 777 different universities and colleges in the US. The variables are • Private : Public/private indicator • Apps : Number of applications received • Accept : Number of applicants accepted • Enroll : Number of new students enrolled • Top10perc : New students from top 10 % of high school class • Top25perc : New students from top 25 % of high school class • F.Undergrad : Number of full-time undergraduates • P.Undergrad : Number of part-time undergraduates • Outstate : Out-of-state tuition • Room.Board : Room and board costs • Books : Estimated book costs • Personal : Estimated personal spending • PhD : Percent of faculty with Ph.D.s • Terminal : Percent of faculty with terminal degree • S.F.Ratio : Student/faculty ratio • perc.alumni : Percent of alumni who donate • Expend : Instructional expenditure per student • Grad.Rate : Graduation rate Before reading the data into Python , it can be viewed in Excel or a text editor. (a) Use the pd.read_csv() function to read the data into Python . Call the loaded data college . Make sure that you have the directory set to the correct location for the data. (b) Look at the data used in the notebook by creating and running a new cell with just the code college in it. You should notice that the first column is just the name of each university in a column named something like Unnamed: 0 . We don’t really want pandas to treat this as data. However, it may be handy to have these names for later. Try the following commands and similarly look at the resulting data frames: college2 = pd.read_csv( 'College.csv' , index_col=0) college3 = college.rename({ 'Unnamed: 0' : 'College' }, axis=1) college3 = college3.set_index( 'College' ) This has used the first column in the file as an index for the data frame. This means that pandas has given each row a name corresponding to the appropriate university",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_61"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This means that pandas has given each row a name corresponding to the appropriate university. Now you should see that the first data column is Private . Note that the names of the colleges appear on the left of the table. We also introduced a new python object above: a dictionary , which is specified by dictionary (key, value) pairs. Keep your modified version of the data with the following: college = college3 (c) Use the describe() method of to produce a numerical summary of the variables in the data set. (d) Use the pd.plotting.scatter_matrix() function to produce a scatterplot matrix of the first columns [Top10perc, Apps, Enroll] . Recall that you can reference a list C of columns of a data frame A using A[C] . (e) Use the boxplot() method of college to produce side-by-side boxplots of Outstate versus Private . (f) Create a new qualitative variable, called Elite , by binning the Top10perc variable into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%. college[ 'Elite' ] = pd.cut(college[ 'Top10perc' ], [0,0.5,1], labels=[ 'No' , 'Yes' ]) Use the value_counts() method of college['Elite'] to see how many elite universities there are. Finally, use the boxplot() method again to produce side-by-side boxplots of Outstate versus Elite . (g) Use the plot.hist() method of college to produce some hitograms with differing numbers of bins for a few of the quanttative variables. The command plt.subplots(2, 2) may be usful: it will divide the plot window into four regions so that four plots can be made simultaneously. By changing the arguments you can divide the screen up in other combinations. (h) Continue exploring the data, and provide a brief summary of what you discover. 9. This exercise involves the Auto data set studied in the lab. Make sure that the missing values have been removed from the data",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_62"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 9. This exercise involves the Auto data set studied in the lab. Make sure that the missing values have been removed from the data. (a) Which of the predictors are quantitative, and which are qualtative? (b) What is the range of each quantitative predictor? You can aswer this using the min() and max() methods in numpy . .min() .max() (c) What is the mean and standard deviation of each quantitative predictor? (d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains? (e) Using the full data set, investigate the predictors graphically, using scatterplots or other tools of your choice. Create some plots highlighting the relationships among the predictors. Comment on your findings. (f) Suppose that we wish to predict gas mileage ( mpg ) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg ? Justify your answer. 10. This exercise involves the Boston housing data set. (a) To begin, load in the Boston data set, which is part of the ISLP library. (b) How many rows are in this data set? How many columns? What do the rows and columns represent? (c) Make some pairwise scatterplots of the predictors (columns) in this data set. Describe your findings. (d) Are any of the predictors associated with per capita crime rate? If so, explain the relationship. (e) Do any of the suburbs of Boston appear to have particularly high crime rates? Tax rates? Pupil-teacher ratios? Comment on the range of each predictor. (f) How many of the suburbs in this data set bound the Charles river? (g) What is the median pupil-teacher ratio among the towns in this data set? (h) Which suburb of Boston has lowest median value of owneoccupied homes? What are the values of the other predictors for that suburb, and how do those values compare to the overall ranges for those predictors? Comment on your findings",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_63"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (i) In this data set, how many of the suburbs average more than seven rooms per dwelling? More than eight rooms per dwelling? Comment on the suburbs that average more than eight rooms per dwelling. 3 Linear Regression This chapter is about linear regression , a very simple approach for supevised learning. In particular, linear regression is a useful tool for predicting a quantitative response. It has been around for a long time and is the topic of innumerable textbooks. Though it may seem somewhat dull compared to some of the more modern statistical learning approaches described in later chapters of this book, linear regression is still a useful and widely used sttistical learning method. Moreover, it serves as a good jumping-off point for newer approaches: as we will see in later chapters, many fancy statistical learning approaches can be seen as generalizations or extensions of linear regression. Consequently, the importance of having a good understanding of linear regression before studying more complex learning methods cannot be overstated. In this chapter, we review some of the key ideas underlying the linear regression model, as well as the least squares approach that is most commonly used to fit this model. Recall the Advertising data from Chapter 2 . Figure 2.1 displays sales (in thousands of units) for a particular product as a function of advertiing budgets (in thousands of dollars) for TV , radio , and newspaper media. Suppose that in our role as statistical consultants we are asked to suggest, on the basis of this data, a marketing plan for next year that will result in high product sales. What information would be useful in order to provide such a recommendation? Here are a few important questions that we might seek to address: 1. Is there a relationship between advertising budget and sales? Our first goal should be to determine whether the data provide evdence of an association between advertising expenditure and sales",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_64"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Is there a relationship between advertising budget and sales? Our first goal should be to determine whether the data provide evdence of an association between advertising expenditure and sales. If the evidence is weak, then one might argue that no money should be spent on advertising! 69 2. How strong is the relationship between advertising budget and sales? Assuming that there is a relationship between advertising and sales, we would like to know the strength of this relationship. Does knowedge of the advertising budget provide a lot of information about product sales? 3. Which media are associated with sales? Are all three media—TV, radio, and newspaper—associated with sales, or are just one or two of the media associated? To answer this question, we must find a way to separate out the individual contribtion of each medium to sales when we have spent money on all three media. 4. How large is the association between each medium and sales? For every dollar spent on advertising in a particular medium, by what amount will sales increase? How accurately can we predict this amount of increase? 5. How accurately can we predict future sales? For any given level of television, radio, or newspaper advertising, what is our prediction for sales, and what is the accuracy of this prediction? 6. Is the relationship linear? If there is approximately a straight-line relationship between advertiing expenditure in the various media and sales, then linear regression is an appropriate tool. If not, then it may still be possible to tranform the predictor or the response so that linear regression can be used. 7. Is there synergy among the advertising media? Perhaps spending $50 , 000 on television advertising and $50 , 000 on rdio advertising is associated with higher sales than allocating $100 , 000 to either television or radio individually. In marketing, this is known as a synergy effect, while in statistics it is called an interaction effect",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_65"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In marketing, this is known as a synergy effect, while in statistics it is called an interaction effect. synergy interaction It turns out that linear regression can be used to answer each of these questions. We will first discuss all of these questions in a general context, and then return to them in this specific context in Section 3.4 . 3.1 Simple Linear Regression Simple linear regression lives up to its name: it is a very straightforward simple linear regression approach for predicting a quantitative response Y on the basis of a sigle predictor variable X . It assumes that there is approximately a linear relationship between X and Y . Mathematically, we can write this linear relationship as Y ≈ β 0 + β 1 X. (3.1) You might read “ ≈ ” as “is approximately modeled as” . We will sometimes describe ( 3.1 ) by saying that we are regressing Y on X (or Y onto X ). For example, X may represent TV advertising and Y may represent sales . Then we can regress sales onto TV by fitting the model sales ≈ β 0 + β 1 × TV . In Equation 3.1 , β 0 and β 1 are two unknown constants that represent the intercept and slope terms in the linear model. Together, β 0 and β 1 are intercept slope known as the model coefficients or parameters . Once we have used our coefficient parameter training data to produce estimates ˆ β 0 and ˆ β 1 for the model coefficients, we can predict future sales on the basis of a particular value of TV advertising by computing ˆ y = ˆ β 0 + ˆ β 1 x, (3.2) where ˆ y indicates a prediction of Y on the basis of X = x . Here we use a hat symbol, ˆ , to denote the estimated value for an unknown parameter or coefficient, or to denote the predicted value of the response. 3.1.1 Estimating the Coefficients In practice, β 0 and β 1 are unknown. So before we can use ( 3.1 ) to make predictions, we must use data to estimate the coefficients. Let ( x 1 , y 1 ) , ( x 2 , y 2 ) , , ( x n , y n ) represent n observation pairs, each of which consists of a measurement of X and a measurement of Y",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_66"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Let ( x 1 , y 1 ) , ( x 2 , y 2 ) , , ( x n , y n ) represent n observation pairs, each of which consists of a measurement of X and a measurement of Y . In the Advertising example, this data set cosists of the TV advertising budget and product sales in n = 200 different markets. (Recall that the data are displayed in Figure 2.1 .) Our goal is to obtain coefficient estimates ˆ β 0 and ˆ β 1 such that the linear model ( 3.1 ) fits the available data well—that is, so that y i ≈ ˆ β 0 + ˆ β 1 x i for i = 1 , , n . In other words, we want to find an intercept ˆ β 0 and a slope ˆ β 1 such that the resulting line is as close as possible to the n = 200 data points. There are a number of ways of measuring closeness . However, by far the most comon approach involves minimizing the least squares criterion, and we take least squares that approach in this chapter. Alternative approaches will be considered in Chapter 6 . Let ˆ y i = ˆ β 0 + ˆ β 1 x i be the prediction for Y based on the i th value of X . Then e i = y i − ˆ y i represents the i th residual —this is the difference between residual the i th observed response value and the i th response value that is predicted by our linear model. We define the residual sum of squares (RSS) as residual sum of squares RSS = e 2 1 + e 2 2 + · · · + e 2 n , or equivalently as RSS = ( y 1 − ˆ β 0 − ˆ β 1 x 1 ) 2 +( y 2 − ˆ β 0 − ˆ β 1 x 2 ) 2 + · · · +( y n − ˆ β 0 − ˆ β 1 x n ) 2 . (3.3) The least squares approach chooses ˆ β 0 and ˆ β 1 to minimize the RSS. Using some calculus, one can show that the minimizers are ˆ β 1 = ) n i =1 ( x i − ̄ x )( y i − ̄ y ) ) n i =1 ( x i − ̄ x ) 2 , ˆ β 0 = ̄ y − ˆ β 1 ̄ x, (3.4) 0 50 100 150 200 250 300 5 10 15 20 25 TV Sales FIGURE 3.1. For the Advertising data, the least squares fit for the regression of sales onto TV is shown. The fit is found by minimizing the residual sum of squares. Each grey line segment represents a residual",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_67"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For the Advertising data, the least squares fit for the regression of sales onto TV is shown. The fit is found by minimizing the residual sum of squares. Each grey line segment represents a residual. In this case a linear fit captures the essence of the relationship, although it overestimates the trend in the left of the plot. where ̄ y ≡ 1 n ) n i =1 y i and ̄ x ≡ 1 n ) n i =1 x i are the sample means. In other words, ( 3.4 ) defines the least squares coefficient estimates for simple linear regression. Figure 3.1 displays the simple linear regression fit to the Advertising data, where ˆ β 0 = 7 . 03 and ˆ β 1 = 0 . 0475 . In other words, according to this approximation, an additional $1 , 000 spent on TV advertising is assciated with selling approximately 47 . 5 additional units of the product. In Figure 3.2 , we have computed RSS for a number of values of β 0 and β 1 , using the advertising data with sales as the response and TV as the preditor. In each plot, the red dot represents the pair of least squares estimates ( ˆ β 0 , ˆ β 1 ) given by ( 3.4 ). These values clearly minimize the RSS. 3.1.2 Assessing the Accuracy of the Coefficient Estimates Recall from ( 2.1 ) that we assume that the true relationship between X and Y takes the form Y = f ( X ) + ε for some unknown function f , where ε is a mean-zero random error term. If f is to be approximated by a linear function, then we can write this relationship as Y = β 0 + β 1 X + ε. (3.5) Here β 0 is the intercept term—that is, the expected value of Y when X = 0 , and β 1 is the slope—the average increase in Y associated with a one-unit increase in X . The error term is a catch-all for what we miss with this simple model: the true relationship is probably not linear, there may be other variables that cause variation in Y , and there may be measurement error. We typically assume that the error term is independent of X . FIGURE 3.2. Contour and three-dimensional plots of the RSS on the Advertising data, using sales as the response and TV as the predictor",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_68"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We typically assume that the error term is independent of X . FIGURE 3.2. Contour and three-dimensional plots of the RSS on the Advertising data, using sales as the response and TV as the predictor. The red dots correspond to the least squares estimates ˆ β 0 and ˆ β 1 , given by ( 3.4 ). The model given by ( 3.5 ) defines the population regression line , which population regression line is the best linear approximation to the true relationship between X and Y . 1 The least squares regression coefficient estimates ( 3.4 ) characterize the least squares line ( 3.2 ). The left-hand panel of Figure 3.3 displays these least squares line two lines in a simple simulated example. We created 100 random X s, and generated 100 corresponding Y s from the model Y = 2 + 3 X + ε, (3.6) where ε was generated from a normal distribution with mean zero. The red line in the left-hand panel of Figure 3.3 displays the true relationship, f ( X ) = 2 + 3 X , while the blue line is the least squares estimate based on the observed data. The true relationship is generally not known for real data, but the least squares line can always be computed using the coefficient estimates given in ( 3.4 ). In other words, in real applications, we have access to a set of observations from which we can compute the least squares line; however, the population regression line is unobserved. In the right-hand panel of Figure 3.3 we have generated ten different data sets from the model given by ( 3.6 ) and plotted the corresponding ten least squares lines. Notice that different data sets generated from the same true model result in slightly different least squares lines, but the unobserved population regression line does not change. At first glance, the difference between the population regression line and the least squares line may seem subtle and confusing",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_69"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". At first glance, the difference between the population regression line and the least squares line may seem subtle and confusing. We only have one data set, and so what does it mean that two different lines describe the relationship between the predictor and the response? Fundamentally, the concept of these two lines is a natural extension of the standard statistical approach of using information from a sample to estimate characteristics of a large population. For example, suppose that we are interested in knowing 1 The assumption of linearity is often a useful working model. However, despite what many textbooks might tell us, we seldom believe that the true relationship is linear. β 0 β 1 2.11 2.15 2.2 2.3 2.5 2.5 3 3 5 6 7 8 9 0.03 0.04 0.05 0.06 RSS β 1 β 0 −2 −1 0 1 2 −10 −5 0 5 10 X Y −2 −1 0 1 2 −10 −5 0 5 10 X Y FIGURE 3.3. A simulated data set. Left: The red line represents the true relationship, f ( X ) = 2 + 3 X , which is known as the population regression line. The blue line is the least squares line; it is the least squares estimate for f ( X ) based on the observed data, shown in black. Right: The population regression line is again shown in red, and the least squares line in dark blue. In light blue, ten least squares lines are shown, each computed on the basis of a separate random set of observations. Each least squares line is different, but on average, the least squares lines are quite close to the population regression line. the population mean μ of some random variable Y . Unfortunately, μ is unknown, but we do have access to n observations from Y , y 1 , , y n , which we can use to estimate μ . A reasonable estimate is ˆ μ = ̄ y , where ̄ y = 1 n ) n i =1 y i is the sample mean. The sample mean and the population mean are different, but in general the sample mean will provide a good estimate of the population mean. In the same way, the unknown coefficients β 0 and β 1 in linear regression define the population regression line",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_70"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In the same way, the unknown coefficients β 0 and β 1 in linear regression define the population regression line. We seek to estimate these unknown coefficients using ˆ β 0 and ˆ β 1 given in ( 3.4 ). These coefficient estimates define the least squares line. The analogy between linear regression and estimation of the mean of a random variable is an apt one based on the concept of bias . If we use the bias sample mean ˆ μ to estimate μ , this estimate is unbiased , in the sense that unbiased on average, we expect ˆ μ to equal μ . What exactly does this mean? It means that on the basis of one particular set of observations y 1 , , y n , ˆ μ might overestimate μ , and on the basis of another set of observations, ˆ μ might underestimate μ . But if we could average a huge number of estimates of μ obtained from a huge number of sets of observations, then this average would exactly equal μ . Hence, an unbiased estimator does not systematically oveor under-estimate the true parameter. The property of unbiasedness holds for the least squares coefficient estimates given by ( 3.4 ) as well: if we estimate β 0 and β 1 on the basis of a particular data set, then our estimates won’t be exactly equal to β 0 and β 1 . But if we could average the estimates obtained over a huge number of data sets, then the average of these estimates would be spot on! In fact, we can see from the righhand panel of Figure 3.3 that the average of many least squares lines, each estimated from a separate data set, is pretty close to the true population regression line. We continue the analogy with the estimation of the population mean μ of a random variable Y . A natural question is as follows: how accurate is the sample mean ˆ μ as an estimate of μ ? We have established that the average of ˆ μ ’s over many data sets will be very close to μ , but that a single estimate ˆ μ may be a substantial underestimate or overestimate of μ",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_71"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". How far off will that single estimate of ˆ μ be? In general, we answer this question by computing the standard error of ˆ μ , written as SE(ˆ μ ) . We have standard error the well-known formula Var (ˆ μ ) = SE(ˆ μ ) 2 = σ 2 n , (3.7) where σ is the standard deviation of each of the realizations y i of Y . 2 Roughly speaking, the standard error tells us the average amount that this estimate ˆ μ differs from the actual value of μ . Equation 3.7 also tells us how this deviation shrinks with n —the more observations we have, the smaller the standard error of ˆ μ . In a similar vein, we can wonder how close ˆ β 0 and ˆ β 1 are to the true values β 0 and β 1 . To compute the standard errors associated with ˆ β 0 and ˆ β 1 , we use the following formulas: SE( ˆ β 0 ) 2 = σ 2 3 1 n + ̄ x 2 ) n i =1 ( x i − ̄ x ) 2 4 , SE( ˆ β 1 ) 2 = σ 2 ) n i =1 ( x i − ̄ x ) 2 , (3.8) where σ 2 = Var ( ε ) . For these formulas to be strictly valid, we need to assume that the errors ε i for each observation have common variance σ 2 and are uncorrelated. This is clearly not true in Figure 3.1 , but the formula still turns out to be a good approximation. Notice in the formula that SE( ˆ β 1 ) is smaller when the x i are more spread out; intuitively we have more leverage to estimate a slope when this is the case. We also see that SE( ˆ β 0 ) would be the same as SE(ˆ μ ) if ̄ x were zero (in which case ˆ β 0 would be equal to ̄ y ). In general, σ 2 is not known, but can be estimated from the data. This estimate of σ is kn own as the re sidual standard error , and is given by the formula residual standard error RSE = 5 RSS / ( n − 2) . Strictly speaking, when σ 2 is estimated from the data we should write 6 SE( ˆ β 1 ) to indicate that an estimate has been made, but for simplicity of notation we will drop this extra “hat”. Standard errors can be used to compute confidence intervals",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_72"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Standard errors can be used to compute confidence intervals . A 95 % confidence interval confidence interval is defined as a range of values such that with 95 % probability, the range will contain the true unknown value of the paraeter. The range is defined in terms of lower and upper limits computed from the sample of data. A 95% confidence interval has the following proerty: if we take repeated samples and construct the confidence interval for each sample, 95% of the intervals will contain the true unknown value of the parameter. For linear regression, the 95 % confidence interval for β 1 approximately takes the form ˆ β 1 ± 2 · SE(ˆ β 1 ) . (3.9) 2 This formula holds provided that the n observations are uncorrelated. That is, there is approximately a 95 % chance that the interval 7 ˆ β 1 − 2 · SE(ˆ β 1 ) , ˆ β 1 + 2 · SE(ˆ β 1 ) 8 (3.10) will contain the true value of β 1 . 3 Similarly, a confidence interval for β 0 approximately takes the form ˆ β 0 ± 2 · SE(ˆ β 0 ) . (3.11) In the case of the advertising data, the 95 % confidence interval for β 0 is [6 . 130 , 7 . 935] and the 95 % confidence interval for β 1 is [0 . 042 , 0 . 053] . Therefore, we can conclude that in the absence of any advertising, sales will, on average, fall somewhere between 6 , 130 and 7 , 935 units. Furthermore, for each $1 , 000 increase in television advertising, there will be an average increase in sales of between 42 and 53 units. Standard errors can also be used to perform hypothesis tests on the hypothesis test coefficients. The most common hypothesis test involves testing the null hypothesis of null hypothesis H 0 : There is no relationship between X and Y (3.12) versus the alternative hypothesis alternative hypothesis H a : There is some relationship between X and Y . (3.13) Mathematically, this corresponds to testing H 0 : β 1 = 0 versus H a : β 1 ̸ = 0 , since if β 1 = 0 then the model ( 3.5 ) reduces to Y = β 0 + ε , and X is not associated with Y",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_73"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (3.13) Mathematically, this corresponds to testing H 0 : β 1 = 0 versus H a : β 1 ̸ = 0 , since if β 1 = 0 then the model ( 3.5 ) reduces to Y = β 0 + ε , and X is not associated with Y . To test the null hypothesis, we need to determine whether ˆ β 1 , our estimate for β 1 , is sufficiently far from zero that we can be confident that β 1 is non-zero. How far is far enough? This of course depends on the accuracy of ˆ β 1 —that is, it depends on SE( ˆ β 1 ) . If SE( ˆ β 1 ) is small, then even relatively small values of ˆ β 1 may provide strong evidence that β 1 ̸ = 0 , and hence that there is a relationship between X and Y . In contrast, if SE( ˆ β 1 ) is large, then ˆ β 1 must be large in absolute value in order for us to reject the null hypothesis. In practice, we compute a t -statistic , t -statistic given by t = ˆ β 1 − 0 SE( ˆ β 1 ) , (3.14) 3 Approximately for several reasons. Equation 3.10 relies on the assumption that the errors are Gaussian. Also, the factor of 2 in front of the SE( ˆ β 1 ) term will vary slightly depending on the number of observations n in the linear regression. To be precise, rather than the number 2, ( 3.10 ) should contain the 97.5 % quantile of a t -distribution with n − 2 degrees of freedom. Details of how to compute the 95 % confidence interval precisely in R will be provided later in this chapter. Coef fi cient Std. error t -statistic p -value Intercept 7.0325 0.4578 15.36 < 0 . 0001 TV 0.0475 0.0027 17.67 < 0 . 0001 TABLE 3.1. For the Advertising data, coefficients of the least squares model for the regression of number of units sold on TV advertising budget. An increase of $1 , 000 in the TV advertising budget is associated with an increase in sales by around 50 units. (Recall that the sales variable is in thousands of units, and the TV variable is in thousands of dollars.) which measures the number of standard deviations that ˆ β 1 is away from 0",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_74"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (Recall that the sales variable is in thousands of units, and the TV variable is in thousands of dollars.) which measures the number of standard deviations that ˆ β 1 is away from 0 . If there really is no relationship between X and Y , then we expect that ( 3.14 ) will have a t -distribution with n − 2 degrees of freedom. The t -distribution has a bell shape and for values of n greater than approximately 30 it is quite similar to the standard normal distribution. Consequently, it is a simple matter to compute the probability of observing any number equal to | t | or larger in absolute value, assuming β 1 = 0 . We call this probability the p -value . Roughly speaking, we interpret the p -value as follows: a small p -value p -value indicates that it is unlikely to observe such a substantial association between the predictor and the response due to chance, in the absence of any real association between the predictor and the response. Hence, if we see a small p -value, then we can infer that there is an association between the predictor and the response. We reject the null hypothesis —that is, we declare a relationship to exist between X and Y —if the p -value is small enough. Typical p -value cutoffs for rejecting the null hypothesis are 5% or 1%, although this topic will be explored in much greater detail in Chater 13 . When n = 30 , these correspond to t -statistics ( 3.14 ) of around 2 and 2.75, respectively. Table 3.1 provides details of the least squares model for the regression of number of units sold on TV advertising budget for the Advertising data. Notice that the coefficients for ˆ β 0 and ˆ β 1 are very large relative to their standard errors, so the t -statistics are also large; the probabilities of seeing such values if H 0 is true are virtually zero. Hence we can conclude that β 0 ̸ = 0 and β 1 ̸ = 0",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_75"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Hence we can conclude that β 0 ̸ = 0 and β 1 ̸ = 0 . 4 3.1.3 Assessing the Accuracy of the Model Once we have rejected the null hypothesis ( 3.12 ) in favor of the alternative hypothesis ( 3.13 ), it is natural to want to quantify the extent to which the model fits the data . The quality of a linear regression fit is typically assessed using two related quantities: the residual standard error (RSE) and the R 2 R 2 statistic. 4 In Table 3.1 , a small p -value for the intercept indicates that we can reject the null hypothesis that β 0 = 0 , and a small p -value for TV indicates that we can reject the null hypothesis that β 1 = 0 . Rejecting the latter null hypothesis allows us to conclude that there is a relationship between TV and sales . Rejecting the former allows us to conclude that in the absence of TV expenditure, sales are non-zero. Quantity Value Residual standard error 3.26 R 2 0.612 F -statistic 312.1 TABLE 3.2. For the Advertising data, more information about the least squares model for the regression of number of units sold on TV advertising budget. Table 3.2 displays the RSE, the R 2 statistic, and the F -statistic (to be described in Section 3.2.2 ) for the linear regression of number of units sold on TV advertising budget. Residual Standard Error Recall from the model ( 3.5 ) that associated with each observation is an error term ε . Due to the presence of these error terms, even if we knew the true regression line (i.e. even if β 0 and β 1 were known), we would not be able to perfectly predict Y from X . The RSE is an estimate of the standard deviation of ε . Roughly speaking, it is the average amount that the response will deviate from the true regression line. It is computed using the formula RSE = 9 1 n − 2 RSS = : ; ; < 1 n − 2 n 0 i =1 ( y i − ˆ y i ) 2 . (3.15) Note that RSS was defined in Section 3.1.1 , and is given by the formula RSS = n 0 i =1 ( y i − ˆ y i ) 2 . (3.16) In the case of the advertising data, we see from the linear regression output in Table 3.2 that the RSE is 3 . 26",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_76"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (3.16) In the case of the advertising data, we see from the linear regression output in Table 3.2 that the RSE is 3 . 26 . In other words, actual sales in each market deviate from the true regression line by approximately 3 , 260 units, on average. Another way to think about this is that even if the model were correct and the true values of the unknown coefficients β 0 and β 1 were known exactly, any prediction of sales on the basis of TV advertising would still be off by about 3 , 260 units on average. Of course, whether or not 3 , 260 units is an acceptable prediction error depends on the problem context. In the advertising data set, the mean value of sales over all markets is approximately 14 , 000 units, and so the percentage error is 3 , 260 / 14 , 000 = 23 %. The RSE is considered a measure of the lack of fit of the model ( 3.5 ) to the data. If the predictions obtained using the model are very close to the true outcome values—that is, if ˆ y i ≈ y i for i = 1 , , n —then ( 3.15 ) will be small, and we can conclude that the model fits the data very well. On the other hand, if ˆ y i is very far from y i for one or more observations, then the RSE may be quite large, indicating that the model doesn’t fit the data well. R 2 Statistic The RSE provides an absolute measure of lack of fit of the model ( 3.5 ) to the data. But since it is measured in the units of Y , it is not always clear what constitutes a good RSE. The R 2 statistic provides an alternative measure of fit. It takes the form of a proportion —the proportion of variance explained—and so it always takes on a value between 0 and 1 , and is independent of the scale of Y . To calculate R 2 , we use the formula R 2 = TSS − RSS TSS = 1 − RSS TSS (3.17) where TSS = ) ( y i − ̄ y ) 2 is the total sum of squares , and RSS is defined total sum of squares in ( 3.16 ). TSS measures the total variance in the response Y , and can be thought of as the amount of variability inherent in the response before the regression is performed",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_77"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". TSS measures the total variance in the response Y , and can be thought of as the amount of variability inherent in the response before the regression is performed. In contrast, RSS measures the amount of variability that is left unexplained after performing the regression. Hence, TSS − RSS measures the amount of variability in the response that is explained (or removed) by performing the regression, and R 2 measures the proportion of variability in Y that can be explained using X . An R 2 statistic that is close to 1 indicates that a large proportion of the variability in the response is explained by the regression. A number near 0 indicates that the regression does not explain much of the variability in the response; this might occur because the linear model is wrong, or the error variance σ 2 is high, or both. In Table 3.2 , the R 2 was 0 . 61 , and so just under two-thirds of the variability in sales is explained by a linear regression on TV . The R 2 statistic ( 3.17 ) has an interpretational advantage over the RSE ( 3.15 ), since unlike the RSE, it always lies between 0 and 1. However, it can still be challenging to determine what is a good R 2 value, and in general, this will depend on the application. For instance, in certain problems in physics, we may know that the data truly comes from a linear model with a small residual error. In this case, we would expect to see an R 2 value that is extremely close to 1 , and a substantially smaller R 2 value might indicate a serious problem with the experiment in which the data were generated. On the other hand, in typical applications in biology, psychology, marketing, and other domains, the linear model ( 3.5 ) is at best an extremely rough approximation to the data, and residual errors due to other unmeasured factors are often very large. In this setting, we would expect only a very small proportion of the variance in the response to be explained by the predictor, and an R 2 value well below 0",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_78"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In this setting, we would expect only a very small proportion of the variance in the response to be explained by the predictor, and an R 2 value well below 0 . 1 might be more realistic! The R 2 statistic is a measure of the linear relationship between X and Y . Recall that correlation , defined as correlation Cor ( X, Y ) = ) n i =1 ( x i − x )( y i − y ) 5 ) n i =1 ( x i − x ) 2 5 ) n i =1 ( y i − y ) 2 , (3.18) is also a measure of the linear relationship between X and Y . 5 This sugests that we might be able to use r = Cor ( X, Y ) instead of R 2 in order to assess the fit of the linear model. In fact, it can be shown that in the simple 5 We note that in fact, the right-hand side of ( 3.18 ) is the sample correlation; thus, it would be more correct to write ! Cor ( X, Y ) ; however, we omit the “hat” for ease of notation. Simple regression of sales on radio Coefficient Std. error t -statistic p -value Intercept 9.312 0.563 16.54 < 0 . 0001 radio 0.203 0.020 9.92 < 0 . 0001 Simple regression of sales on newspaper Coefficient Std. error t -statistic p -value Intercept 12.351 0.621 19.88 < 0 . 0001 newspaper 0.055 0.017 3.30 0 . 00115 TABLE 3.3. More simple linear regression models for the Advertising data. Coefficients of the simple linear regression model for number of units sold on Top: radio advertising budget and Bottom: newspaper advertising budget. A $ 1 , 000 icrease in spending on radio advertising is associated with an average increase in sales by around 203 units, while the same increase in spending on newspaper avertising is associated with an average increase in sales by around 55 units. (Note that the sales variable is in thousands of units, and the radio and newspaper variables are in thousands of dollars.) linear regression setting, R 2 = r 2 . In other words, the squared correlation and the R 2 statistic are identical. However, in the next section we will discuss the multiple linear regression problem, in which we use several prdictors simultaneously to predict the response",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_79"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, in the next section we will discuss the multiple linear regression problem, in which we use several prdictors simultaneously to predict the response. The concept of correlation between the predictors and the response does not extend automatically to this setting, since correlation quantifies the association between a single pair of variables rather than between a larger number of variables. We will see that R 2 fills this role. 3.2 Multiple Linear Regression Simple linear regression is a useful approach for predicting a response on the basis of a single predictor variable. However, in practice we often have more than one predictor. For example, in the Advertising data, we have examined the relationship between sales and TV advertising. We also have data for the amount of money spent advertising on the radio and in newspapers, and we may want to know whether either of these two media is associated with sales. How can we extend our analysis of the advertising data in order to accommodate these two additional predictors? One option is to run three separate simple linear regressions, each of which uses a different advertising medium as a predictor. For instance, we can fit a simple linear regression to predict sales on the basis of the amount spent on radio advertisements. Results are shown in Table 3.3 (top table). We find that a $ 1 , 000 increase in spending on radio advertising is associated with an increase in sales of around 203 units. Table 3.3 (bottom table) contains the least squares coefficients for a simple linear regression of sales onto newspaper advertising budget. A $1 , 000 increase in newspaper advertising budget is associated with an increase in sales of approximately 55 units. However, the approach of fitting a separate simple linear regression model for each predictor is not entirely satisfactory. First of all, it is unclear how to make a single prediction of sales given the three advertising media budgets, since each of the budgets is associated with a separate regression equation",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_80"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". First of all, it is unclear how to make a single prediction of sales given the three advertising media budgets, since each of the budgets is associated with a separate regression equation. Second, each of the three regression equations ignores the other two media in forming estimates for the regression coefficients. We will see shortly that if the media budgets are correlated with each other in the 200 markets in our data set, then this can lead to very misleading estimates of the association between each media budget and sales. Instead of fitting a separate simple linear regression model for each prdictor, a better approach is to extend the simple linear regression model ( 3.5 ) so that it can directly accommodate multiple predictors. We can do this by giving each predictor a separate slope coefficient in a single model. In general, suppose that we have p distinct predictors. Then the multiple linear regression model takes the form Y = β 0 + β 1 X 1 + β 2 X 2 + · · · + β p X p + ε, (3.19) where X j represents the j th predictor and β j quantifies the association between that variable and the response. We interpret β j as the average effect on Y of a one unit increase in X j , holding all other predictors fixed . In the advertising example, ( 3.19 ) becomes sales = β 0 + β 1 × TV + β 2 × radio + β 3 × newspaper + ε. (3.20) 3.2.1 Estimating the Regression Coefficients As was the case in the simple linear regression setting, the regression coeficients β 0 , β 1 , , β p in ( 3.19 ) are unknown, and must be estimated. Given estimates ˆ β 0 , ˆ β 1 , , ˆ β p , we can make predictions using the formula ˆ y = ˆ β 0 + ˆ β 1 x 1 + ˆ β 2 x 2 + · · · + ˆ β p x p . (3.21) The parameters are estimated using the same least squares approach that we saw in the context of simple linear regression. We choose β 0 , β 1 , , β p to minimize the sum of squared residuals RSS = n 0 i =1 ( y i − ˆ y i ) 2 = n 0 i =1 ( y i − ˆ β 0 − ˆ β 1 x i 1 − ˆ β 2 x i 2 −· · · − ˆ β p x ip ) 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_81"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We choose β 0 , β 1 , , β p to minimize the sum of squared residuals RSS = n 0 i =1 ( y i − ˆ y i ) 2 = n 0 i =1 ( y i − ˆ β 0 − ˆ β 1 x i 1 − ˆ β 2 x i 2 −· · · − ˆ β p x ip ) 2 . (3.22) The values ˆ β 0 , ˆ β 1 , , ˆ β p that minimize ( 3.22 ) are the multiple least squares regression coefficient estimates. Unlike the simple linear regression estmates given in ( 3.4 ), the multiple regression coefficient estimates have somewhat complicated forms that are most easily represented using mtrix algebra. For this reason, we do not provide them here. Any statistical software package can be used to compute these coefficient estimates, and later in this chapter we will show how this can be done in R . Figure 3.4 X 1 X 2 Y FIGURE 3.4. In a three-dimensional setting, with two predictors and one response, the least squares regression line becomes a plane. The plane is chosen to minimize the sum of the squared vertical distances between each observation (shown in red) and the plane. illustrates an example of the least squares fit to a toy data set with p = 2 predictors. Table 3.4 displays the multiple regression coefficient estimates when TV, radio, and newspaper advertising budgets are used to predict product sales using the Advertising data. We interpret these results as follows: for a given amount of TV and newspaper advertising, spending an additional $1 , 000 on radio advertising is associated with approximately 189 units of additional sales. Comparing these coefficient estimates to those displayed in Tables 3.1 and 3.3 , we notice that the multiple regression coefficient estimates for TV and radio are pretty similar to the simple linear regression coefficient estimates. However, while the newspaper regression coefficient estimate in Table 3.3 was significantly non-zero, the coefficient estimate for newspaper in the multiple regression model is close to zero, and the corresponding p - value is no longer significant, with a value around 0 . 86",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_82"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 86 . This illustrates that the simple and multiple regression coefficients can be quite different. This difference stems from the fact that in the simple regression case, the slope term represents the average increase in product sales associated with a $1 , 000 increase in newspaper advertising, ignoring other predictors such as TV and radio . By contrast, in the multiple regression setting, the coefficient for newspaper represents the average increase in product sales associated with increasing newspaper spending by $1 , 000 while holding TV and radio fixed. Does it make sense for the multiple regression to suggest no relationship between sales and newspaper while the simple linear regression implies the Coef fi cient Std. error t -statistic p -value Intercept 2.939 0.3119 9.42 < 0 . 0001 TV 0.046 0.0014 32.81 < 0 . 0001 radio 0.189 0.0086 21.89 < 0 . 0001 newspaper − 0.001 0.0059 − 0.18 0 . 8599 TABLE 3.4. For the Advertising data, least squares coefficient estimates of the multiple linear regression of number of units sold on TV, radio, and newspaper advertising budgets. TV radio newspaper sales TV 1.0000 0.0548 0.0567 0.7822 radio 1.0000 0.3541 0.5762 newspaper 1.0000 0.2283 sales 1.0000 TABLE 3.5. Correlation matrix for TV , radio , newspaper , and sales for the Advertising data. opposite? In fact it does. Consider the correlation matrix for the three predictor variables and response variable, displayed in Table 3.5 . Notice that the correlation between radio and newspaper is 0 . 35 . This indicates that markets with high newspaper advertising tend to also have high rdio advertising. Now suppose that the multiple regression is correct and newspaper advertising is not associated with sales, but radio advertising is associated with sales. Then in markets where we spend more on radio our sales will tend to be higher, and as our correlation matrix shows, we also tend to spend more on newspaper advertising in those same makets",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_83"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Then in markets where we spend more on radio our sales will tend to be higher, and as our correlation matrix shows, we also tend to spend more on newspaper advertising in those same makets. Hence, in a simple linear regression which only examines sales versus newspaper , we will observe that higher values of newspaper tend to be asociated with higher values of sales , even though newspaper advertising is not directly associated with sales. So newspaper advertising is a surrogate for radio advertising; newspaper gets “credit” for the association between radio on sales . This slightly counterintuitive result is very common in many real life situations. Consider an absurd example to illustrate the point. Running a regression of shark attacks versus ice cream sales for data collected at a given beach community over a period of time would show a positive relationship, similar to that seen between sales and newspaper . Of course no one has (yet) suggested that ice creams should be banned at beaches to reduce shark attacks. In reality, higher temperatures cause more people to visit the beach, which in turn results in more ice cream sales and more shark attacks. A multiple regression of shark attacks onto ice cream sales and temperature reveals that, as intuition implies, ice cream sales is no longer a significant predictor after adjusting for temperature. 3.2.2 Some Important Questions When we perform multiple linear regression, we usually are interested in answering a few important questions. 1. Is at least one of the predictors X 1 , X 2 , , X p useful in predicting the response? 2. Do all the predictors help to explain Y , or is only a subset of the predictors useful? 3. How well does the model fit the data? 4. Given a set of predictor values, what response value should we predict, and how accurate is our prediction? We now address each of these questions in turn",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_84"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". How well does the model fit the data? 4. Given a set of predictor values, what response value should we predict, and how accurate is our prediction? We now address each of these questions in turn. One: Is There a Relationship Between the Response and Predictors? Recall that in the simple linear regression setting, in order to determine whether there is a relationship between the response and the predictor we can simply check whether β 1 = 0 . In the multiple regression setting with p predictors, we need to ask whether all of the regression coefficients are zero, i.e. whether β 1 = β 2 = · · · = β p = 0 . As in the simple linear regression setting, we use a hypothesis test to answer this question. We test the null hypothesis, H 0 : β 1 = β 2 = · · · = β p = 0 versus the alternative H a : at least one β j is non-zero. This hypothesis test is performed by computing the F -statistic , F -statistic F = (TSS − RSS) /p RSS / ( n − p − 1) , (3.23) where, as with simple linear regression, TSS = ) ( y i − ̄ y ) 2 and RSS = ) ( y i − ˆ y i ) 2 . If the linear model assumptions are correct, one can show that E { RSS / ( n − p − 1) } = σ 2 and that, provided H 0 is true, E { (TSS − RSS) /p } = σ 2 . Hence, when there is no relationship between the response and predictors, one would expect the F -statistic to take on a value close to 1 . On the other hand, if H a is true, then E { (TSS − RSS) /p } > σ 2 , so we expect F to be greater than 1 . The F -statistic for the multiple linear regression model obtained by rgressing sales onto radio , TV , and newspaper is shown in Table 3.6 . In this example the F -statistic is 570 . Since this is far larger than 1 , it provides compelling evidence against the null hypothesis H 0 . In other words, the large F -statistic suggests that at least one of the advertising media must be related to sales",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_85"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In other words, the large F -statistic suggests that at least one of the advertising media must be related to sales . However, what if the F -statistic had been closer to 1 ? How large does the F -statistic need to be before we can reject H 0 and Quantity Value Residual standard error 1.69 R 2 0.897 F -statistic 570 TABLE 3.6. More information about the least squares model for the regression of number of units sold on TV, newspaper, and radio advertising budgets in the Advertising data. Other information about this model was displayed in Table 3.4 . conclude that there is a relationship? It turns out that the answer depends on the values of n and p . When n is large, an F -statistic that is just a little larger than 1 might still provide evidence against H 0 . In contrast, a larger F -statistic is needed to reject H 0 if n is small. When H 0 is true and the errors ε i have a normal distribution, the F -statistic follows an F -distribution. 6 For any given value of n and p , any statistical software package can be used to compute the p -value associated with the F -statistic using this distribution. Based on this p -value, we can determine whether or not to reject H 0 . For the advertising data, the p -value associated with the F -statistic in Table 3.6 is essentially zero, so we have extremely strong evidence that at least one of the media is associated with increased sales . In ( 3.23 ) we are testing H 0 that all the coefficients are zero. Sometimes we want to test that a particular subset of q of the coefficients are zero. This corresponds to a null hypothesis H 0 : β p − q +1 = β p − q +2 = · · · = β p = 0 , where for convenience we have put the variables chosen for omission at the end of the list. In this case we fit a second model that uses all the variables except those last q . Suppose that the residual sum of squares for that model is RSS 0 . Then the appropriate F -statistic is F = (RSS 0 − RSS) /q RSS / ( n − p − 1)",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_86"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Suppose that the residual sum of squares for that model is RSS 0 . Then the appropriate F -statistic is F = (RSS 0 − RSS) /q RSS / ( n − p − 1) . (3.24) Notice that in Table 3.4 , for each individual predictor a t -statistic and a p -value were reported. These provide information about whether each individual predictor is related to the response, after adjusting for the other predictors. It turns out that each of these is exactly equivalent 7 to the F - test that omits that single variable from the model, leaving all the others in—i.e. q =1 in ( 3.24 ). So it reports the partial effect of adding that variable to the model. For instance, as we discussed earlier, these p -values indicate that TV and radio are related to sales , but that there is no evidence that newspaper is associated with sales , when TV and radio are held fixed. Given these individual p -values for each variable, why do we need to look at the overall F -statistic? After all, it seems likely that if any one of the p -values for the individual variables is very small, then at least one of the predictors is related to the response . However, this logic is flawed, especially when the number of predictors p is large. 6 Even if the errors are not normally-distributed, the F -statistic approximately follows an F -distribution provided that the sample size n is large. 7 The square of each t -statistic is the corresponding F -statistic. For instance, consider an example in which p = 100 and H 0 : β 1 = β 2 = · · · = β p = 0 is true, so no variable is truly associated with the response. In this situation, about 5 % of the p -values associated with each variable (of the type shown in Table 3.4 ) will be below 0 . 05 by chance. In other words, we expect to see approximately five small p -values even in the absence of any true association between the predictors and the response. 8 In fact, it is likely that we will observe at least one p -value below 0",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_87"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 8 In fact, it is likely that we will observe at least one p -value below 0 . 05 by chance! Hence, if we use the individual t -statistics and associated p -values in order to decide whether or not there is any association between the variables and the response, there is a very high chance that we will incorrectly conclude that there is a relationship. However, the F -statistic does not suffer from this problem because it adjusts for the number of predictors. Hence, if H 0 is true, there is only a 5 % chance that the F -statistic will result in a p - value below 0 . 05 , regardless of the number of predictors or the number of observations. The approach of using an F -statistic to test for any association between the predictors and the response works when p is relatively small, and cetainly small compared to n . However, sometimes we have a very large nuber of variables. If p > n then there are more coefficients β j to estimate than observations from which to estimate them. In this case we cannot even fit the multiple linear regression model using least squares, so the F - statistic cannot be used, and neither can most of the other concepts that we have seen so far in this chapter. When p is large, some of the approaches discussed in the next section, such as forward selection , can be used. This high-dimensional setting is discussed in greater detail in Chapter 6 . higdimensional Two: Deciding on Important Variables As discussed in the previous section, the first step in a multiple regression analysis is to compute the F -statistic and to examine the associated p - value. If we conclude on the basis of that p -value that at least one of the predictors is related to the response, then it is natural to wonder which are the guilty ones! We could look at the individual p -values as in Table 3.4 , but as discussed (and as further explored in Chapter 13 ), if p is large we are likely to make some false discoveries",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_88"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It is possible that all of the predictors are associated with the response, but it is more often the case that the response is only associated with a subset of the predictors. The task of determining which predictors are associated with the response, in order to fit a single model involving only those predictors, is referred to as variable selection . The variable selection variable selection problem is studied extensively in Chapter 6 , and so here we will provide only a brief outline of some classical approaches. Ideally, we would like to perform variable selection by trying out a lot of different models, each containing a different subset of the predictors. For instance, if p = 2 , then we can consider four models: (1) a model contaiing no variables, (2) a model containing X 1 only, (3) a model containing 8 This is related to the important concept of multiple testing , which is the focus of Chapter 13 . X 2 only, and (4) a model containing both X 1 and X 2 . We can then slect the best model out of all of the models that we have considered. How do we determine which model is best? Various statistics can be used to judge the quality of a model. These include Mallow’s C p , Akaike informMallow’s C p tion criterion (AIC), Bayesian information criterion (BIC), and adjusted Akaike information criterion Bayesian information criterion R 2 . These are discussed in more detail in Chapter 6 . We can also deteadjusted R 2 mine which model is best by plotting various model outputs, such as the residuals, in order to search for patterns. Unfortunately, there are a total of 2 p models that contain subsets of p variables. This means that even for moderate p , trying out every possible subset of the predictors is infeasible. For instance, we saw that if p = 2 , then there are 2 2 = 4 models to consider. But if p = 30 , then we must consider 2 30 = 1 , 073 , 741 , 824 models! This is not practical",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_89"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For instance, we saw that if p = 2 , then there are 2 2 = 4 models to consider. But if p = 30 , then we must consider 2 30 = 1 , 073 , 741 , 824 models! This is not practical. Therefore, unless p is very small, we cannot consider all 2 p models, and instead we need an automated and efficient approach to choose a smaller set of models to consider. There are three classical approaches for this task: • Forward selection . We begin with the null model —a model that coforward selection null model tains an intercept but no predictors. We then fit p simple linear rgressions and add to the null model the variable that results in the lowest RSS. We then add to that model the variable that results in the lowest RSS for the new two-variable model. This approach is continued until some stopping rule is satisfied. • Backward selection . We start with all variables in the model, and backward selection remove the variable with the largest p -value—that is, the variable that is the least statistically significant. The new ( p − 1) -variable model is fit, and the variable with the largest p -value is removed. This procedure continues until a stopping rule is reached. For instance, we may stop when all remaining variables have a p -value below some threshold. • Mixed selection . This is a combination of forward and backward smixed selection lection. We start with no variables in the model, and as with forward selection, we add the variable that provides the best fit. We cotinue to add variables one-by-one. Of course, as we noted with the Advertising example, the p -values for variables can become larger as new predictors are added to the model. Hence, if at any point the p -value for one of the variables in the model rises above a certain threshold, then we remove that variable from the model. We cotinue to perform these forward and backward steps until all variables in the model have a sufficiently low p -value, and all variables outside the model would have a large p -value if added to the model",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_90"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Backward selection cannot be used if p > n , while forward selection can always be used. Forward selection is a greedy approach, and might include variables early that later become redundant. Mixed selection can remedy this. Three: Model Fit Two of the most common numerical measures of model fit are the RSE and R 2 , the fraction of variance explained. These quantities are computed and interpreted in the same fashion as for simple linear regression. Recall that in simple regression, R 2 is the square of the correlation of the response and the variable. In multiple linear regression, it turns out that it equals Cor ( Y, ˆ Y ) 2 , the square of the correlation between the response and the fitted linear model; in fact one property of the fitted linear model is that it maximizes this correlation among all possible linear models. An R 2 value close to 1 indicates that the model explains a large potion of the variance in the response variable. As an example, we saw in Table 3.6 that for the Advertising data, the model that uses all three avertising media to predict sales has an R 2 of 0 . 8972 . On the other hand, the model that uses only TV and radio to predict sales has an R 2 value of 0 . 89719 . In other words, there is a small increase in R 2 if we include newspaper advertising in the model that already contains TV and radio advertising, even though we saw earlier that the p -value for newspaper avertising in Table 3.4 is not significant. It turns out that R 2 will always increase when more variables are added to the model, even if those varables are only weakly associated with the response. This is due to the fact that adding another variable always results in a decrease in the residual sum of squares on the training data (though not necessarily the testing data). Thus, the R 2 statistic, which is also computed on the training data, must increase",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_91"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Thus, the R 2 statistic, which is also computed on the training data, must increase. The fact that adding newspaper advertising to the model containing only TV and radio advertising leads to just a tiny increase in R 2 provides additional evidence that newspaper can be dropped from the model. Essentially, newspaper provides no real improvement in the model fit to the training samples, and its inclusion will likely lead to poor results on independent test samples due to overfitting. By contrast, the model containing only TV as a predictor had an R 2 of 0 . 61 (Table 3.2 ). Adding radio to the model leads to a substantial improvment in R 2 . This implies that a model that uses TV and radio expenditures to predict sales is substantially better than one that uses only TV advertiing. We could further quantify this improvement by looking at the p -value for the radio coefficient in a model that contains only TV and radio as predictors. The model that contains only TV and radio as predictors has an RSE of 1.681, and the model that also contains newspaper as a predictor has an RSE of 1.686 (Table 3.6 ). In contrast, the model that contains only TV has an RSE of 3 . 26 (Table 3.2 ). This corroborates our previous conclusion that a model that uses TV and radio expenditures to predict sales is much more accurate (on the training data) than one that only uses TV spending. Furthermore, given that TV and radio expenditures are used as predictors, there is no point in also using newspaper spending as a predictor in the model. The observant reader may wonder how RSE can increase when newspaper is added to the model given that RSS must decrease. In general RSE is defined as RSE = 9 1 n − p − 1 RSS , (3.25) Sales Radio TV FIGURE 3.5. For the Advertising data, a linear regression fit to sales using TV and radio as predictors. From the pattern of the residuals, we can see that there is a pronounced non-linear relationship in the data",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_92"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". From the pattern of the residuals, we can see that there is a pronounced non-linear relationship in the data. The positive residuals (those visible above the surface), tend to lie along the 45-degree line, where TV and Radio budgets are split evenly. The negative residuals (most not visible), tend to lie away from this line, where budgets are more lopsided. which simplifies to ( 3.15 ) for a simple linear regression. Thus, models with more variables can have higher RSE if the decrease in RSS is small relative to the increase in p . In addition to looking at the RSE and R 2 statistics just discussed, it can be useful to plot the data. Graphical summaries can reveal problems with a model that are not visible from numerical statistics. For example, Figure 3.5 displays a three-dimensional plot of TV and radio versus sales . We see that some observations lie above and some observations lie below the least squares regression plane. In particular, the linear model seems to overestimate sales for instances in which most of the advertising money was spent exclusively on either TV or radio . It underestimates sales for instances where the budget was split between the two media. This prnounced non-linear pattern suggests a synergy or interaction effect between interaction the advertising media, whereby combining the media together results in a bigger boost to sales than using any single medium. In Section 3.3.2 , we will discuss extending the linear model to accommodate such synergistic effects through the use of interaction terms. Four: Predictions Once we have fit the multiple regression model, it is straightforward to apply ( 3.21 ) in order to predict the response Y on the basis of a set of values for the predictors X 1 , X 2 , , X p . However, there are three sorts of uncertainty associated with this prediction. 1. The coefficient estimates ˆ β 0 , ˆ β 1 , , ˆ β p are estimates for β 0 , β 1 , , β p",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_93"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, there are three sorts of uncertainty associated with this prediction. 1. The coefficient estimates ˆ β 0 , ˆ β 1 , , ˆ β p are estimates for β 0 , β 1 , , β p . That is, the least squares plane ˆ Y = ˆ β 0 + ˆ β 1 X 1 + · · · + ˆ β p X p is only an estimate for the true population regression plane f ( X ) = β 0 + β 1 X 1 + · · · + β p X p . The inaccuracy in the coefficient estimates is related to the reducible error from Chapter 2 . We can compute a confidence interval in order to determine how close ˆ Y will be to f ( X ) . 2. Of course, in practice assuming a linear model for f ( X ) is almost always an approximation of reality, so there is an additional source of potentially reducible error which we call model bias . So when we use a linear model, we are in fact estimating the best linear approximation to the true surface. However, here we will ignore this discrepancy, and operate as if the linear model were correct. 3. Even if we knew f ( X ) —that is, even if we knew the true values for β 0 , β 1 , , β p —the response value cannot be predicted perfectly because of the random error ε in the model ( 3.20 ). In Chapter 2 , we referred to this as the irreducible error . How much will Y vary from ˆ Y ? We use prediction intervals to answer this question. Prediction intervals are always wider than confidence intervals, because they incorporate both the error in the estimate for f ( X ) (the reducible error) and the uncertainty as to how much an individual point will differ from the population regression plane (the irreducible error). We use a confidence interval to quantify the uncertainty surrounding confidence interval the average sales over a large number of cities. For example, given that $100 , 000 is spent on TV advertising and $20 , 000 is spent on radio advertising in each city, the 95 % confidence interval is [10 , 985 , 11 , 528] . We interpret this to mean that 95 % of intervals of this form will contain the true value of f ( X )",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_94"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We interpret this to mean that 95 % of intervals of this form will contain the true value of f ( X ) . 9 On the other hand, a prediction interval can be used to quantify the prediction interval uncertainty surrounding sales for a particular city. Given that $100 , 000 is spent on TV advertising and $20 , 000 is spent on radio advertising in that city the 95 % prediction interval is [7 , 930 , 14 , 580] . We interpret this to mean that 95 % of intervals of this form will contain the true value of Y for this city. Note that both intervals are centered at 11 , 256 , but that the prediction interval is substantially wider than the confidence interval, reflecting the increased uncertainty about sales for a given city in comparison to the average sales over many locations. 9 In other words, if we collect a large number of data sets like the Advertising data set, and we construct a confidence interval for the average sales on the basis of each data set (given $100 , 000 in TV and $20 , 000 in radio advertising), then 95 % of these confidence intervals will contain the true value of average sales . 3.3 Other Considerations in the Regression Model 3.3.1 Qualitative Predictors In our discussion so far, we have assumed that all variables in our linear regression model are quantitative . But in practice, this is not necessarily the case; often some predictors are qualitative . For example, the Credit data set displayed in Figure 3.6 records variables for a number of credit card holders. The response is balance (average credit card debt for each individual) and there are several quantitative predictors: age , cards (number of credit cards), education (years of education), income (in thousands of dollars), limit (credit limit), and rating (credit rating). Each panel of Figure 3.6 is a scatterplot for a pair of variables whose idetities are given by the corresponding row and column labels",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_95"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Each panel of Figure 3.6 is a scatterplot for a pair of variables whose idetities are given by the corresponding row and column labels. For example, the scatterplot directly to the right of the word “Balance” depicts balance versus age , while the plot directly to the right of “Age” corresponds to age versus cards . In addition to these quantitative variables, we also have four qualitative variables: own (house ownership), student (student status), status (marital status), and region (East, West or South). Predictors with Only Two Levels Suppose that we wish to investigate differences in credit card balance btween those who own a house and those who don’t, ignoring the other varables for the moment. If a qualitative predictor (also known as a factor ) factor only has two levels , or possible values, then incorporating it into a regrelevel sion model is very simple. We simply create an indicator or dummy variable dummy variable that takes on two possible numerical values. 10 For example, based on the own variable, we can create a new variable that takes the form x i = = 1 if i th person owns a house 0 if i th person does not own a house , (3.26) and use this variable as a predictor in the regression equation. This results in the model y i = β 0 + β 1 x i + ε i = = β 0 + β 1 + ε i if i th person owns a house β 0 + ε i if i th person does not . (3.27) Now β 0 can be interpreted as the average credit card balance among those who do not own, β 0 + β 1 as the average credit card balance among those who do own their house, and β 1 as the average difference in credit card balance between owners and non-owners. Table 3.7 displays the coefficient estimates and other information assciated with the model ( 3.27 ). The average credit card debt for non-owners is estimated to be $509 . 80 , whereas owners are estimated to carry $19 . 73 in additional debt for a total of $509 . 80 + $19 . 73 = $529 . 53",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_96"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The average credit card debt for non-owners is estimated to be $509 . 80 , whereas owners are estimated to carry $19 . 73 in additional debt for a total of $509 . 80 + $19 . 73 = $529 . 53 . However, we 10 In the machine learning community, the creation of dummy variables to handle qualitative predictors is known as “one-hot encoding”. Balance 20 40 60 80 100 5 10 15 20 2000 8000 14000 0 500 1500 20 40 60 80 100 Age Cards 2 4 6 8 5 10 15 20 Education Income 50 100 150 2000 8000 14000 Limit 0 500 1500 2 4 6 8 50 100 150 200 600 1000 200 600 1000 Rating FIGURE 3.6. The Credit data set contains information about balance , age , cards , education , income , limit , and rating for a number of potential cutomers. notice that the p -value for the dummy variable is very high. This indicates that there is no statistical evidence of a difference in average credit card balance based on house ownership. The decision to code owners as 1 and non-owners as 0 in ( 3.27 ) is abitrary, and has no effect on the regression fit, but does alter the intepretation of the coefficients. If we had coded non-owners as 1 and owers as 0 , then the estimates for β 0 and β 1 would have been 529 . 53 and − 19 . 73 , respectively, leading once again to a prediction of credit card debt of $529 . 53 − $19 . 73 = $509 . 80 for non-owners and a prediction of $529 . 53 for owners. Alternatively, instead of a 0 / 1 coding scheme, we could create a dummy variable x i = = 1 if i th person owns a house − 1 if i th person does not own a house and use this variable in the regression equation. This results in the model y i = β 0 + β 1 x i + ε i = = β 0 + β 1 + ε i if i th person owns a house β 0 − β 1 + ε i if i th person does not own a house. Coef fi cient Std. error t -statistic p -value Intercept 509.80 33.13 15.389 < 0 . 0001 own[Yes] 19.73 46.05 0.429 0.6690 TABLE 3.7. Least squares coefficient estimates associated with the regression of balance onto own in the Credit data set. The linear model is given in ( 3.27 )",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_97"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 0001 own[Yes] 19.73 46.05 0.429 0.6690 TABLE 3.7. Least squares coefficient estimates associated with the regression of balance onto own in the Credit data set. The linear model is given in ( 3.27 ). That is, ownership is encoded as a dummy variable, as in ( 3.26 ). Now β 0 can be interpreted as the overall average credit card balance (inoring the house ownership effect), and β 1 is the amount by which house owners and non-owners have credit card balances that are above and below the average, respectively. 11 In this example, the estimate for β 0 is $519 . 665 , halfway between the non-owner and owner averages of $509 . 80 and $529 . 53 . The estimate for β 1 is $9 . 865 , which is half of $19 . 73 , the average difference between owners and non-owners. It is important to note that the final prdictions for the credit balances of owners and non-owners will be identical regardless of the coding scheme used. The only difference is in the way that the coefficients are interpreted. Qualitative Predictors with More than Two Levels When a qualitative predictor has more than two levels, a single dummy variable cannot represent all possible values. In this situation, we can create additional dummy variables. For example, for the region variable we create two dummy variables. The first could be x i 1 = = 1 if i th person is from the South 0 if i th person is not from the South , (3.28) and the second could be x i 2 = = 1 if i th person is from the West 0 if i th person is not from the West . (3.29) Then both of these variables can be used in the regression equation, in order to obtain the model y i = β 0 + β 1 x i 1 + β 2 x i 2 + ε i =      β 0 + β 1 + ε i if i th person is from the South β 0 + β 2 + ε i if i th person is from the West β 0 + ε i if i th person is from the East",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_98"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". ( 3.30) Now β 0 can be interpreted as the average credit card balance for individuals from the East, β 1 can be interpreted as the difference in the average balance between people from the South versus the East, and β 2 can be interpreted as the difference in the average balance between those from the West versus the East. There will always be one fewer dummy variable than the number of levels. The level with no dummy variable—East in this example—is known as the baseline . baseline 11 Technically β 0 is half the sum of the average debt for house owners and the average debt for non-house owners. Hence, β 0 is exactly equal to the overall average only if the two groups have an equal number of members. Coef fi cient Std. error t -statistic p -value Intercept 531.00 46.32 11.464 < 0 . 0001 region[South] − 12.50 56.68 − 0.221 0.8260 region[West] − 18.69 65.02 − 0.287 0.7740 TABLE 3.8. Least squares coefficient estimates associated with the regression of balance onto region in the Credit data set. The linear model is given in ( 3.30 ). That is, region is encoded via two dummy variables ( 3.28 ) and ( 3.29 ). From Table 3.8 , we see that the estimated balance for the baseline, East, is $531 . 00 . It is estimated that those in the South will have $18 . 69 less debt than those in the East, and that those in the West will have $12 . 50 less debt than those in the East. However, the p -values associated with the coefficient estimates for the two dummy variables are very large, suggesting no statistical evidence of a real difference in average credit card balance between South and East or between West and East. 12 Once again, the level selected as the baseline category is arbitrary, and the final predictions for each group will be the same regardless of this choice. However, the coefficients and their p -values do depend on the choice of dummy variable coding. Rather than rely on the individual coefficients, we can use an F -test to test H 0 : β 1 = β 2 = 0 ; this does not depend on the coding",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_99"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Rather than rely on the individual coefficients, we can use an F -test to test H 0 : β 1 = β 2 = 0 ; this does not depend on the coding. This F -test has a p -value of 0 . 96 , indicating that we cannot reject the null hypothesis that there is no relationship between balance and region . Using this dummy variable approach presents no difficulties when icorporating both quantitative and qualitative predictors. For example, to regress balance on both a quantitative variable such as income and a quaitative variable such as student , we must simply create a dummy variable for student and then fit a multiple regression model using income and the dummy variable as predictors for credit card balance. There are many different ways of coding qualitative variables besides the dummy variable approach taken here. All of these approaches lead to equivalent model fits, but the coefficients are different and have different interpretations, and are designed to measure particular contrasts . This topic contrast is beyond the scope of the book. 3.3.2 Extensions of the Linear Model The standard linear regression model ( 3.19 ) provides interpretable results and works quite well on many real-world problems. However, it makes seeral highly restrictive assumptions that are often violated in practice. Two of the most important assumptions state that the relationship between the predictors and response are additive and linear . The additivity assumption additive linear means that the association between a predictor X j and the response Y does not depend on the values of the other predictors. The linearity assumption states that the change in the response Y associated with a one-unit change in X j is constant, regardless of the value of X j . In later chapters of this book, we examine a number of sophisticated methods that relax these two 12 There could still in theory be a difference between South and West, although the data here does not suggest any difference. assumptions",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_100"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". assumptions. Here, we briefly examine some common classical approaches for extending the linear model. Removing the Additive Assumption In our previous analysis of the Advertising data, we concluded that both TV and radio seem to be associated with sales . The linear models that formed the basis for this conclusion assumed that the effect on sales of increasing one advertising medium is independent of the amount spent on the other media. For example, the linear model ( 3.20 ) states that the average increase in sales associated with a one-unit increase in TV is always β 1 , regardless of the amount spent on radio . However, this simple model may be incorrect. Suppose that spending money on radio advertising actually increases the effectiveness of TV avertising, so that the slope term for TV should increase as radio increases. In this situation, given a fixed budget of $100 , 000 , spending half on radio and half on TV may increase sales more than allocating the entire amount to either TV or to radio . In marketing, this is known as a synergy effect, and in statistics it is referred to as an interaction effect. Figure 3.5 sugests that such an effect may be present in the advertising data. Notice that when levels of either TV or radio are low, then the true sales are lower than predicted by the linear model. But when advertising is split between the two media, then the model tends to underestimate sales . Consider the standard linear regression model with two variables, Y = β 0 + β 1 X 1 + β 2 X 2 + ε. According to this model, a one-unit increase in X 1 is associated with an average increase in Y of β 1 units. Notice that the presence of X 2 does not alter this statement—that is, regardless of the value of X 2 , a onunit increase in X 1 is associated with a β 1 -unit increase in Y . One way of extending this model is to include a third predictor, called an interaction term , which is constructed by computing the product of X 1 and X 2 . This results in the model Y = β 0 + β 1 X 1 + β 2 X 2 + β 3 X 1 X 2 + ε",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_101"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This results in the model Y = β 0 + β 1 X 1 + β 2 X 2 + β 3 X 1 X 2 + ε. (3.31) How does inclusion of this interaction term relax the additive assumption? Notice that ( 3.31 ) can be rewritten as Y = β 0 + ( β 1 + β 3 X 2 ) X 1 + β 2 X 2 + ε (3.32) = β 0 + ̃ β 1 X 1 + β 2 X 2 + ε where ̃ β 1 = β 1 + β 3 X 2 . Since ̃ β 1 is now a function of X 2 , the association between X 1 and Y is no longer constant: a change in the value of X 2 will change the association between X 1 and Y . A similar argument shows that a change in the value of X 1 changes the association between X 2 and Y . For example, suppose that we are interested in studying the productiity of a factory. We wish to predict the number of units produced on the basis of the number of production lines and the total number of workers . It seems likely that the effect of increasing the number of production lines Coef fi cient Std. error t -statistic p -value Intercept 6.7502 0.248 27.23 < 0 . 0001 TV 0.0191 0.002 12.70 < 0 . 0001 radio 0.0289 0.009 3.24 0.0014 TV × radio 0.0011 0.000 20.73 < 0 . 0001 TABLE 3.9. For the Advertising data, least squares coefficient estimates assciated with the regression of sales onto TV and radio , with an interaction term, as in ( 3.33 ). will depend on the number of workers, since if no workers are available to operate the lines, then increasing the number of lines will not increase production. This suggests that it would be appropriate to include an inteaction term between lines and workers in a linear model to predict units . Suppose that when we fit the model, we obtain units ≈ 1 . 2 + 3 . 4 × lines + 0 . 22 × workers + 1 . 4 × ( lines × workers ) = 1 . 2 + (3 . 4 + 1 . 4 × workers ) × lines + 0 . 22 × workers . In other words, adding an additional line will increase the number of units produced by 3 . 4 + 1 . 4 × workers . Hence the more workers we have, the stronger will be the effect of lines . We now return to the Advertising example",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_102"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 4 + 1 . 4 × workers . Hence the more workers we have, the stronger will be the effect of lines . We now return to the Advertising example. A linear model that uses radio , TV , and an interaction between the two to predict sales takes the form sales = β 0 + β 1 × TV + β 2 × radio + β 3 × ( radio × TV ) + ε = β 0 + ( β 1 + β 3 × radio ) × TV + β 2 × radio + ε. (3.33) We can interpret β 3 as the increase in the effectiveness of TV advertising associated with a one-unit increase in radio advertising (or vice-versa). The coefficients that result from fitting the model ( 3.33 ) are given in Table 3.9 . The results in Table 3.9 strongly suggest that the model that includes the interaction term is superior to the model that contains only main effects . main effect The p -value for the interaction term, TV × radio , is extremely low, indicating that there is strong evidence for H a : β 3 ̸ = 0 . In other words, it is clear that the true relationship is not additive. The R 2 for the model ( 3.33 ) is 96.8 %, compared to only 89.7 % for the model that predicts sales using TV and radio without an interaction term. This means that (96 . 8 − 89 . 7) / (100 − 89 . 7) = 69 % of the variability in sales that remains after fitting the aditive model has been explained by the interaction term. The coefficient estimates in Table 3.9 suggest that an increase in TV advertising of $1 , 000 is associated with increased sales of ( ˆ β 1 + ˆ β 3 × radio ) × 1 , 000 = 19+1 . 1 × radio units. And an increase in radio advertising of $1 , 000 will be associated with an increase in sales of ( ˆ β 2 + ˆ β 3 × TV ) × 1 , 000 = 29 + 1 . 1 × TV units. In this example, the p -values associated with TV , radio , and the interation term all are statistically significant (Table 3.9 ), and so it is obvious that all three variables should be included in the model. However, it is sometimes the case that an interaction term has a very small p -value, but the associated main effects (in this case, TV and radio ) do not",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_103"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, it is sometimes the case that an interaction term has a very small p -value, but the associated main effects (in this case, TV and radio ) do not. The hiearchical principle states that if we include an interaction in a model, we hierarchical principle should also include the main effects, even if the p -values associated with their coefficients are not significant. In other words, if the interaction btween X 1 and X 2 seems important, then we should include both X 1 and X 2 in the model even if their coefficient estimates have large p -values. The rationale for this principle is that if X 1 × X 2 is related to the response, then whether or not the coefficients of X 1 or X 2 are exactly zero is of litle interest. Also X 1 × X 2 is typically correlated with X 1 and X 2 , and so leaving them out tends to alter the meaning of the interaction. In the previous example, we considered an interaction between TV and radio , both of which are quantitative variables. However, the concept of interactions applies just as well to qualitative variables, or to a combination of quantitative and qualitative variables. In fact, an interaction between a qualitative variable and a quantitative variable has a particularly nice interpretation. Consider the Credit data set from Section 3.3.1 , and suppose that we wish to predict balance using the income (quantitative) and student (qualitative) variables. In the absence of an interaction term, the model takes the form balance i ≈ β 0 + β 1 × income i + = β 2 if i th person is a student 0 if i th person is not a student = β 1 × income i + = β 0 + β 2 if i th person is a student β 0 if i th person is not a student . (3.34) Notice that this amounts to fitting two parallel lines to the data, one for students and one for non-students. The lines for students and non-students have different intercepts, β 0 + β 2 versus β 0 , but the same slope, β 1 . This is illustrated in the left-hand panel of Figure 3.7",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_104"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The lines for students and non-students have different intercepts, β 0 + β 2 versus β 0 , but the same slope, β 1 . This is illustrated in the left-hand panel of Figure 3.7 . The fact that the lines are parallel means that the average effect on balance of a one-unit increase in income does not depend on whether or not the individual is a student. This represents a potentially serious limitation of the model, since in fact a change in income may have a very different effect on the credit card balance of a student versus a non-student. This limitation can be addressed by adding an interaction variable, crated by multiplying income with the dummy variable for student . Our model now becomes balance i ≈ β 0 + β 1 × income i + = β 2 + β 3 × income i if student 0 if not student = = ( β 0 + β 2 ) + ( β 1 + β 3 ) × income i if student β 0 + β 1 × income i if not student . (3.35) Once again, we have two different regression lines for the students and the non-students. But now those regression lines have different intercepts, β 0 + β 2 versus β 0 , as well as different slopes, β 1 + β 3 versus β 1 . This allows for the possibility that changes in income may affect the credit card balances of students and non-students differently. The right-hand panel of Figure 3.7 0 50 100 150 200 600 1000 1400 Income Balance 0 50 100 150 200 600 1000 1400 Income Balance student non−student FIGURE 3.7. For the Credit data, the least squares lines are shown for prdiction of balance from income for students and non-students. Left: The model ( 3.34 ) was fit. There is no interaction between income and student . Right: The model ( 3.35 ) was fit. There is an interaction term between income and student . shows the estimated relationships between income and balance for students and non-students in the model ( 3.35 ). We note that the slope for students is lower than the slope for non-students. This suggests that increases in income are associated with smaller increases in credit card balance among students as compared to non-students",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_105"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This suggests that increases in income are associated with smaller increases in credit card balance among students as compared to non-students. Non-linear Relationships As discussed previously, the linear regression model ( 3.19 ) assumes a linear relationship between the response and predictors. But in some cases, the true relationship between the response and the predictors may be nolinear. Here we present a very simple way to directly extend the linear model to accommodate non-linear relationships, using polynomial regression . In polynomial regression later chapters, we will present more complex approaches for performing non-linear fits in more general settings. Consider Figure 3.8 , in which the mpg (gas mileage in miles per gallon) versus horsepower is shown for a number of cars in the Auto data set. The orange line represents the linear regression fit. There is a pronounced reltionship between mpg and horsepower , but it seems clear that this relatioship is in fact non-linear: the data suggest a curved relationship. A simple approach for incorporating non-linear associations in a linear model is to include transformed versions of the predictors. For example, the points in Figure 3.8 seem to have a quadratic shape, suggesting that a model of the quadratic form mpg = β 0 + β 1 × horsepower + β 2 × horsepower 2 + ε (3.36) may provide a better fit. Equation 3.36 involves predicting mpg using a non-linear function of horsepower . But it is still a linear model! That is, ( 3.36 ) is simply a multiple linear regression model with X 1 = horsepower and X 2 = horsepower 2 . So we can use standard linear regression software to estimate β 0 , β 1 , and β 2 in order to produce a non-linear fit. The blue curve in Figure 3.8 shows the resulting quadratic fit to the data. The quadratic 50 100 150 200 10 20 30 40 50 Horsepower Miles per gallon Linear Degree 2 Degree 5 FIGURE 3.8. The Auto data set. For a number of cars, mpg and horsepower are shown. The linear regression fit is shown in orange",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_106"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The Auto data set. For a number of cars, mpg and horsepower are shown. The linear regression fit is shown in orange. The linear regression fit for a model that includes horsepower 2 is shown as a blue curve. The linear regression fit for a model that includes all polynomials of horsepower up to fifth-degree is shown in green. Coef fi cient Std. error t -statistic p -value Intercept 56.9001 1.8004 31.6 < 0 . 0001 horsepower − 0.4662 0.0311 − 15.0 < 0 . 0001 horsepower 2 0.0012 0.0001 10.1 < 0 . 0001 TABLE 3.10. For the Auto data set, least squares coefficient estimates associated with the regression of mpg onto horsepower and horsepower 2 . fit appears to be substantially better than the fit obtained when just the linear term is included. The R 2 of the quadratic fit is 0 . 688 , compared to 0 . 606 for the linear fit, and the p -value in Table 3.10 for the quadratic term is highly significant. If including horsepower 2 led to such a big improvement in the model, why not include horsepower 3 , horsepower 4 , or even horsepower 5 ? The green curve in Figure 3.8 displays the fit that results from including all polynomials up to fifth degree in the model ( 3.36 ). The resulting fit seems unnecessarily wiggly—that is, it is unclear that including the additional terms really has led to a better fit to the data. The approach that we have just described for extending the linear model to accommodate non-linear relationships is known as polynomial regresion , since we have included polynomial functions of the predictors in the regression model. We further explore this approach and other non-linear extensions of the linear model in Chapter 7 . 3.3.3 Potential Problems When we fit a linear regression model to a particular data set, many prolems may occur. Most common among these are the following: 1. Non-linearity of the response-predictor relationships. 2. Correlation of error terms. 3. Non-constant variance of error terms. 4. Outliers. 5. High-leverage points. 6. Collinearity",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_107"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Non-linearity of the response-predictor relationships. 2. Correlation of error terms. 3. Non-constant variance of error terms. 4. Outliers. 5. High-leverage points. 6. Collinearity. In practice, identifying and overcoming these problems is as much an art as a science. Many pages in countless books have been written on this topic. Since the linear regression model is not our primary focus here, we will provide only a brief summary of some key points. 1. Non-linearity of the Data 5 10 15 20 25 30 −15 −10 −5 0 5 10 15 20 Fitted values Residuals Residual Plot for Linear Fit 323 330 334 15 20 25 30 35 −15 −10 −5 0 5 10 15 Fitted values Residuals Residual Plot for Quadratic Fit 334 323 155 FIGURE 3.9. Plots of residuals versus predicted (or fitted) values for the Auto data set. In each plot, the red line is a smooth fit to the residuals, intended to make it easier to identify a trend. Left: A linear regression of mpg on horsepower . A strong pattern in the residuals indicates non-linearity in the data. Right: A linear regression of mpg on horsepower and horsepower 2 . There is little pattern in the residuals. The linear regression model assumes that there is a straight-line reltionship between the predictors and the response. If the true relationship is far from linear, then virtually all of the conclusions that we draw from the fit are suspect. In addition, the prediction accuracy of the model can be significantly reduced. Residual plots are a useful graphical tool for identifying non-linearity. residual plot Given a simple linear regression model, we can plot the residuals, e i = y i − ˆ y i , versus the predictor x i . In the case of a multiple regression model, since there are multiple predictors, we instead plot the residuals versus the predicted (or fitted ) values ˆ y i . Ideally, the residual plot will show no fitted discernible pattern. The presence of a pattern may indicate a problem with some aspect of the linear model",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_108"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Ideally, the residual plot will show no fitted discernible pattern. The presence of a pattern may indicate a problem with some aspect of the linear model. The left panel of Figure 3.9 displays a residual plot from the linear rgression of mpg onto horsepower on the Auto data set that was illustrated in Figure 3.8 . The red line is a smooth fit to the residuals, which is displayed in order to make it easier to identify any trends. The residuals exhibit a clear U-shape, which provides a strong indication of non-linearity in the data. In contrast, the right-hand panel of Figure 3.9 displays the residual plot that results from the model ( 3.36 ), which contains a quadratic term. There appears to be little pattern in the residuals, suggesting that the quadratic term improves the fit to the data. If the residual plot indicates that there are non-linear associations in the data, then a simple approac h i s to use non-linear transformations of the predictors, such as log X , √ X , and X 2 , in the regression model. In the later chapters of this book, we will discuss other more advanced non-linear approaches for addressing this issue. 2. Correlation of Error Terms An important assumption of the linear regression model is that the error terms, ε 1 , ε 2 , , ε n , are uncorrelated. What does this mean? For instance, if the errors are uncorrelated, then the fact that ε i is positive provides little or no information about the sign of ε i +1 . The standard errors that are computed for the estimated regression coefficients or the fitted values are based on the assumption of uncorrelated error terms. If in fact there is correlation among the error terms, then the estimated standard errors will tend to underestimate the true standard errors. As a result, confidence and prediction intervals will be narrower than they should be. For example, a 95 % confidence interval may in reality have a much lower probability than 0 . 95 of containing the true value of the parameter",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_109"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For example, a 95 % confidence interval may in reality have a much lower probability than 0 . 95 of containing the true value of the parameter. In addition, p - values associated with the model will be lower than they should be; this could cause us to erroneously conclude that a parameter is statistically significant. In short, if the error terms are correlated, we may have an unwarranted sense of confidence in our model. As an extreme example, suppose we accidentally doubled our data, leaing to observations and error terms identical in pairs. If we ignored this, our standard error calculations would be as if we had a sample of size 2 n , when in fact we have only n samples. Our estimated parameters would be the same for the 2 n samples as for the n samples, but the confidence intervals would be narrower by a factor of √ 2 ! Why might correlations among the error terms occur? Such correlations frequently occur in the context of time series data, which consists of otime series servations for which measurements are obtained at discrete points in time. In many cases, observations that are obtained at adjacent time points will have positively correlated errors. In order to determine if this is the case for a given data set, we can plot the residuals from our model as a function of time. If the errors are uncorrelated, then there should be no discernible pa 0 20 40 60 80 100 −3 −1 0 1 2 3 ρ =0.0 Residual 0 20 40 60 80 100 −4 −2 0 1 2 ρ =0.5 Residual 0 20 40 60 80 100 −1.5 −0.5 0.5 1.5 ρ =0.9 Residual Observation FIGURE 3.10. Plots of residuals from simulated time series data sets generated with differing levels of correlation ρ between error terms for adjacent time points. tern. On the other hand, if the error terms are positively correlated, then we may see tracking in the residuals—that is, adjacent residuals may have tracking similar values. Figure 3.10 provides an illustration. In the top panel, we see the residuals from a linear regression fit to data generated with uncorrlated errors",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_110"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Figure 3.10 provides an illustration. In the top panel, we see the residuals from a linear regression fit to data generated with uncorrlated errors. There is no evidence of a time-related trend in the residuals. In contrast, the residuals in the bottom panel are from a data set in which adjacent errors had a correlation of 0 . 9 . Now there is a clear pattern in the residuals—adjacent residuals tend to take on similar values. Finally, the center panel illustrates a more moderate case in which the residuals had a correlation of 0 . 5 . There is still evidence of tracking, but the pattern is less clear. Many methods have been developed to properly take account of corrlations in the error terms in time series data. Correlation among the error terms can also occur outside of time series data. For instance, consider a study in which individuals’ heights are predicted from their weights. The assumption of uncorrelated errors could be violated if some of the indviduals in the study are members of the same family, eat the same diet, or have been exposed to the same environmental factors. In general, the assumption of uncorrelated errors is extremely important for linear regresion as well as for other statistical methods, and good experimental design is crucial in order to mitigate the risk of such correlations. 10 15 20 25 30 −10 −5 0 5 10 15 Fitted values Residuals Response Y 998 975 845 2.4 2.6 2.8 3.0 3.2 3.4 −0.8 −0.6 −0.4 −0.2 0.0 0.2 0.4 Fitted values Residuals Response log(Y) 437 671 605 FIGURE 3.11. Residual plots. In each plot, the red line is a smooth fit to the residuals, intended to make it easier to identify a trend. The blue lines track the outer quantiles of the residuals, and emphasize patterns. Left: The funnel shape indicates heteroscedasticity. Right: The response has been log transformed, and there is now no evidence of heteroscedasticity. 3",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_111"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Left: The funnel shape indicates heteroscedasticity. Right: The response has been log transformed, and there is now no evidence of heteroscedasticity. 3. Non-constant Variance of Error Terms Another important assumption of the linear regression model is that the error terms have a constant variance, Var ( ε i ) = σ 2 . The standard errors, confidence intervals, and hypothesis tests associated with the linear model rely upon this assumption. Unfortunately, it is often the case that the variances of the error terms are non-constant. For instance, the variances of the error terms may increase with the value of the response. One can identify non-constant variances in the errors, or heteroscedasticity , from the presence of a funnel shape in heterscedasticity the residual plot. An example is shown in the left-hand panel of Figure 3.11 , in which the magnitude of the residuals tends to increase with the fitted values. When faced with this problem, one possible solution is to tranform the response Y using a concave function such as log Y or √ Y . Such a transformation results in a greater amount of shrinkage of the larger rsponses, leading to a reduction in heteroscedasticity. The right-hand panel of Figure 3.11 displays the residual plot after transforming the response using log Y . The residuals now appear to have constant variance, though there is some evidence of a slight non-linear relationship in the data. Sometimes we have a good idea of the variance of each response. For example, the i th response could be an average of n i raw observations. If each of these raw observations is uncorrelated with variance σ 2 , then their average has variance σ 2 i = σ 2 /n i . In this case a simple remedy is to fit our model by weighted least squares , with weights proportional to the inverse weighted least squares variances—i.e. w i = n i in this case. Most linear regression software allows for observation weights. 4",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_112"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". w i = n i in this case. Most linear regression software allows for observation weights. 4. Outliers An outlier is a point for which y i is far from the value predicted by the outlier −2 −1 0 1 2 −4 −2 0 2 4 6 20 −2 0 2 4 6 −1 0 1 2 3 4 Fitted Values Residuals 20 −2 0 2 4 6 0 2 4 6 Fitted Values Studentized Residuals 20 X Y FIGURE 3.12. Left: The least squares regression line is shown in red, and the regression line after removing the outlier is shown in blue. Center: The residual plot clearly identifies the outlier. Right: The outlier has a studentized residual of 6 ; typically we expect values between − 3 and 3 . model. Outliers can arise for a variety of reasons, such as incorrect recording of an observation during data collection. The red point (observation 20) in the left-hand panel of Figure 3.12 illustrates a typical outlier. The red solid line is the least squares regression fit, while the blue dashed line is the least squares fit after removal of the outlier. In this case, removing the outlier has little effect on the least squares line: it leads to almost no change in the slope, and a miniscule reduction in the intercept. It is typical for an outlier that does not have an unusual predictor value to have little effect on the least squares fit. However, even if an outlier does not have much effect on the least squares fit, it can cause other problems. For instance, in this example, the RSE is 1 . 09 when the outlier is included in the regression, but it is only 0 . 77 when the outlier is removed. Since the RSE is used to compute all confidence intervals and p -values, such a dramatic increase caused by a single data point can have implications for the interpretation of the fit. Similarly, inclusion of the outlier causes the R 2 to decline from 0 . 892 to 0 . 805 . Residual plots can be used to identify outliers. In this example, the oulier is clearly visible in the residual plot illustrated in the center panel of Figure 3.12",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_113"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 892 to 0 . 805 . Residual plots can be used to identify outliers. In this example, the oulier is clearly visible in the residual plot illustrated in the center panel of Figure 3.12 . But in practice, it can be difficult to decide how large a resiual needs to be before we consider the point to be an outlier. To address this problem, instead of plotting the residuals, we can plot the studentized residuals , computed by dividing each residual e i by its estimated standard studentized residual error. Observations whose studentized residuals are greater than 3 in abslute value are possible outliers. In the right-hand panel of Figure 3.12 , the outlier’s studentized residual exceeds 6 , while all other observations have studentized residuals between − 2 and 2 . If we believe that an outlier has occurred due to an error in data colletion or recording, then one solution is to simply remove the observation. However, care should be taken, since an outlier may instead indicate a deficiency with the model, such as a missing predictor. 5. High Leverage Points We just saw that outliers are observations for which the response y i is unusual given the predictor x i . In contrast, observations with high leverage high leverage have an unusual value for x i . For example, observation 41 in the left-hand −2 −1 0 1 2 3 4 0 5 10 20 41 −2 −1 0 1 2 −2 −1 0 1 2 0.00 0.05 0.10 0.15 0.20 0.25 −1 0 1 2 3 4 5 Leverage Studentized Residuals 20 41 X Y X 1 X 2 FIGURE 3.13. Left: Observation 41 is a high leverage point, while 20 is not. The red line is the fit to all the data, and the blue line is the fit with observation 41 removed. Center: The red observation is not unusual in terms of its X 1 value or its X 2 value, but still falls outside the bulk of the data, and hence has high leverage. Right: Observation 41 has a high leverage and a high residual. panel of Figure 3.13 has high leverage, in that the predictor value for this observation is large relative to the other observations",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_114"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Right: Observation 41 has a high leverage and a high residual. panel of Figure 3.13 has high leverage, in that the predictor value for this observation is large relative to the other observations. (Note that the data displayed in Figure 3.13 are the same as the data displayed in Figure 3.12 , but with the addition of a single high leverage observation.) The red solid line is the least squares fit to the data, while the blue dashed line is the fit produced when observation 41 is removed. Comparing the left-hand panels of Figures 3.12 and 3.13 , we observe that removing the high leverage observation has a much more substantial impact on the least squares line than removing the outlier. In fact, high leverage observations tend to have a sizable impact on the estimated regression line. It is cause for concern if the least squares line is heavily affected by just a couple of observations, because any problems with these points may invalidate the entire fit. For this reason, it is important to identify high leverage observations. In a simple linear regression, high leverage observations are fairly easy to identify, since we can simply look for observations for which the predictor value is outside of the normal range of the observations. But in a multiple linear regression with many predictors, it is possible to have an observation that is well within the range of each individual predictor’s values, but that is unusual in terms of the full set of predictors. An example is shown in the center panel of Figure 3.13 , for a data set with two predictors, X 1 and X 2 . Most of the observations’ predictor values fall within the blue dashed ellipse, but the red observation is well outside of this range. But neither its value for X 1 nor its value for X 2 is unusual. So if we examine just X 1 or just X 2 , we will fail to notice this high leverage point",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_115"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". But neither its value for X 1 nor its value for X 2 is unusual. So if we examine just X 1 or just X 2 , we will fail to notice this high leverage point. This problem is more pronounced in multiple regression settings with more than two predictors, because then there is no simple way to plot all dimensions of the data simultaneously. In order to quantify an observation’s leverage, we compute the leverage statistic . A large value of this statistic indicates an observation with high leverage statistic leverage. For a simple linear regression, h i = 1 n + ( x i − ̄ x ) 2 ) n i ′ =1 ( x i ′ − ̄ x ) 2 . (3.37) 2000 4000 6000 8000 12000 30 40 50 60 70 80 Limit Age 2000 4000 6000 8000 12000 200 400 600 800 Limit Rating FIGURE 3.14. Scatterplots of the observations from the Credit data set. Left: A plot of age versus limit . These two variables are not collinear. Right: A plot of rating versus limit . There is high collinearity. It is clear from this equation that h i increases with the distance of x i from ̄ x . There is a simple extension of h i to the case of multiple predictors, though we do not provide the formula here. The leverage statistic h i is always between 1 /n and 1 , and the average leverage for all the observations is always equal to ( p + 1) /n . So if a given observation has a leverage statistic that greatly exceeds ( p +1) /n , then we may suspect that the corresponding point has high leverage. The right-hand panel of Figure 3.13 provides a plot of the studentized residuals versus h i for the data in the left-hand panel of Figure 3.13 . Oservation 41 stands out as having a very high leverage statistic as well as a high studentized residual. In other words, it is an outlier as well as a high leverage observation. This is a particularly dangerous combination! This plot also reveals the reason that observation 20 had relatively little effect on the least squares fit in Figure 3.12 : it has low leverage. 6",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_116"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This is a particularly dangerous combination! This plot also reveals the reason that observation 20 had relatively little effect on the least squares fit in Figure 3.12 : it has low leverage. 6. Collinearity Collinearity refers to the situation in which two or more predictor variables collinearity are closely related to one another. The concept of collinearity is illustrated in Figure 3.14 using the Credit data set. In the left-hand panel of Fiure 3.14 , the two predictors limit and age appear to have no obvious reltionship. In contrast, in the right-hand panel of Figure 3.14 , the predictors limit and rating are very highly correlated with each other, and we say that they are collinear . The presence of collinearity can pose problems in the regression context, since it can be difficult to separate out the indvidual effects of collinear variables on the response. In other words, since limit and rating tend to increase or decrease together, it can be difficult to determine how each one separately is associated with the response, balance . Figure 3.15 illustrates some of the difficulties that can result from collineaity. The left-hand panel of Figure 3.15 is a contour plot of the RSS ( 3.22 ) associated with different possible coefficient estimates for the regression of balance on limit and age . Each ellipse represents a set of coefficients 21.25 21.5 21.8 0.16 0.17 0.18 0.19 −5 −4 −3 −2 −1 0 21.5 21.8 −0.1 0.0 0.1 0.2 0 1 2 3 4 5 β Limit β Limit β Age β Rating FIGURE 3.15. Contour plots for the RSS values as a function of the parameters β for various regressions involving the Credit data set. In each plot, the black dots represent the coefficient values corresponding to the minimum RSS. Left: A contour plot of RSS for the regression of balance onto age and limit . The minimum value is well defined. Right: A contour plot of RSS for the regression of balance onto rating and limit . Because of the collinearity, there are many pairs ( β Limit , β Rating ) with a similar value for RSS",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_117"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Right: A contour plot of RSS for the regression of balance onto rating and limit . Because of the collinearity, there are many pairs ( β Limit , β Rating ) with a similar value for RSS. that correspond to the same RSS, with ellipses nearest to the center taing on the lowest values of RSS. The black dots and associated dashed lines represent the coefficient estimates that result in the smallest possible RSS—in other words, these are the least squares estimates. The axes for limit and age have been scaled so that the plot includes possible coeffcient estimates that are up to four standard errors on either side of the least squares estimates. Thus the plot includes all plausible values for the coefficients. For example, we see that the true limit coefficient is almost certainly somewhere between 0 . 15 and 0 . 20 . In contrast, the right-hand panel of Figure 3.15 displays contour plots of the RSS associated with possible coefficient estimates for the regression of balance onto limit and rating , which we know to be highly collinear. Now the contours run along a narrow valley; there is a broad range of values for the coefficient estimates that result in equal values for RSS. Hence a small change in the data could cause the pair of coefficient values that yield the smallest RSS—that is, the least squares estimates—to move anywhere along this valley. This results in a great deal of uncertainty in the coefficient estimates. Notice that the scale for the limit coefficient now runs from roughly − 0 . 2 to 0 . 2 ; this is an eight-fold increase over the plausible range of the limit coefficient in the regression with age . Interestingly, even though the limit and rating coefficients now have much more individual uncertainty, they will almost certainly lie somewhere in this contour valley. For example, we would not expect the true value of the limit and rating coefficients to be − 0 . 1 and 1 respectively, even though such a value is plausible for each coefficient individually",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_118"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For example, we would not expect the true value of the limit and rating coefficients to be − 0 . 1 and 1 respectively, even though such a value is plausible for each coefficient individually. Since collinearity reduces the accuracy of the estimates of the regression coefficients, it causes the standard error for ˆ β j to grow. Recall that the t -statistic for each predictor is calculated by dividing ˆ β j by its standard Coef fic ie n t Std. error t -statistic p -value Intercept − 173.411 43.828 − 3.957 < 0 . 0001 Model 1 age − 2.292 0.672 − 3.407 0 . 0007 limit 0.173 0.005 34.496 < 0 . 0001 Intercept − 377.537 45.254 − 8.343 < 0 . 0001 Model 2 rating 2.202 0.952 2.312 0.0213 limit 0.025 0.064 0.384 0.7012 TABLE 3.11. The results for two multiple regression models involving the Credit data set are shown. Model 1 is a regression of balance on age and limit , and Model 2 a regression of balance on rating and limit . The standard error of ˆ β limit increases 12-fold in the second regression, due to collinearity. error. Consequently, collinearity results in a decline in the t -statistic. As a result, in the presence of collinearity, we may fail to reject H 0 : β j = 0 . This means that the power of the hypothesis test—the probability of correctly power detecting a non-zero coefficient—is reduced by collinearity. Table 3.11 compares the coefficient estimates obtained from two separate multiple regression models. The first is a regression of balance on age and limit , and the second is a regression of balance on rating and limit . In the first regression, both age and limit are highly significant with very small p - values. In the second, the collinearity between limit and rating has caused the standard error for the limit coefficient estimate to increase by a factor of 12 and the p -value to increase to 0 . 701 . In other words, the importance of the limit variable has been masked due to the presence of collinearity",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_119"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 701 . In other words, the importance of the limit variable has been masked due to the presence of collinearity. To avoid such a situation, it is desirable to identify and address potential collinearity problems while fitting the model. A simple way to detect collinearity is to look at the correlation matrix of the predictors. An element of this matrix that is large in absolute value indicates a pair of highly correlated variables, and therefore a collinearity problem in the data. Unfortunately, not all collinearity problems can be detected by inspection of the correlation matrix: it is possible for collineaity to exist between three or more variables even if no pair of variables has a particularly high correlation. We call this situation multicollinearity . multcollinearity Instead of inspecting the correlation matrix, a better way to assess multcollinearity is to compute the variance inflation factor (VIF). The VIF is variance inflation factor the ratio of the variance of ˆ β j when fitting the full model divided by the variance of ˆ β j if fit on its own. The smallest possible value for VIF is 1 , which indicates the complete absence of collinearity. Typically in practice there is a small amount of collinearity among the predictors. As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity. The VIF for each variable can be computed using the formula VIF( ˆ β j ) = 1 1 − R 2 X j | X − j , where R 2 X j | X − j is the R 2 from a regression of X j onto all of the other predictors. If R 2 X j | X − j is close to one, then collinearity is present, and so the VIF will be large. In the Credit data, a regression of balance on age , rating , and limit indicates that the predictors have VIF values of 1.01, 160.67, and 160.59. As we suspected, there is considerable collinearity in the data! When faced with the problem of collinearity, there are two simple soltions. The first is to drop one of the problematic variables from the regresion",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_120"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The first is to drop one of the problematic variables from the regresion. This can usually be done without much compromise to the regression fit, since the presence of collinearity implies that the information that this variable provides about the response is redundant in the presence of the other variables. For instance, if we regress balance onto age and limit , without the rating predictor, then the resulting VIF values are close to the minimum possible value of 1 , and the R 2 drops from 0 . 754 to 0 . 75 . So dropping rating from the set of predictors has effectively solved the collinearity problem without compromising the fit. The second solution is to combine the collinear variables together into a single predictor. For istance, we might take the average of standardized versions of limit and rating in order to create a new variable that measures credit worthiness . 3.4 The Marketing Plan We now briefly return to the seven questions about the Advertising data that we set out to answer at the beginning of this chapter. 1. Is there a relationship between sales and advertising budget? This question can be answered by fitting a multiple regression model of sales onto TV , radio , and newspaper , as in ( 3.20 ), and testing the hypothesis H 0 : β TV = β radio = β newspaper = 0 . In Section 3.2.2 , we showed that the F -statistic can be used to determine whether or not we should reject this null hypothesis. In this case the p -value corresponding to the F -statistic in Table 3.6 is very low, indicating clear evidence of a relationship between advertising and sales. 2. How strong is the relationship? We discussed two measures of model accuracy in Section 3.1.3 . First, the RSE estimates the standard deviation of the response from the population regression line. For the Advertising data, the RSE is 1 . 69 units while the mean value for the response is 14 . 022 , indicating a percentage error of roughly 12 %",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_121"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For the Advertising data, the RSE is 1 . 69 units while the mean value for the response is 14 . 022 , indicating a percentage error of roughly 12 %. Second, the R 2 statistic records the percentage of variability in the response that is explained by the predictors. The predictors explain almost 90 % of the variance in sales . The RSE and R 2 statistics are displayed in Table 3.6 . 3. Which media are associated with sales? To answer this question, we can examine the p -values associated with each predictor’s t -statistic (Section 3.1.2 ). In the multiple linear rgression displayed in Table 3.4 , the p -values for TV and radio are low, but the p -value for newspaper is not. This suggests that only TV and radio are related to sales . In Chapter 6 we explore this question in greater detail. 4. How large is the association between each medium and sales? We saw in Section 3.1.2 that the standard error of ˆ β j can be used to construct confidence intervals for β j . For the Advertising data, we can use the results in Table 3.4 to compute the 95 % confidence intevals for the coefficients in a multiple regression model using all three media budgets as predictors. The confidence intervals are as follows: (0 . 043 , 0 . 049) for TV , (0 . 172 , 0 . 206) for radio , and ( − 0 . 013 , 0 . 011) for newspaper . The confidence intervals for TV and radio are narrow and far from zero, providing evidence that these media are related to sales . But the interval for newspaper includes zero, indicating that the variable is not statistically significant given the values of TV and radio . We saw in Section 3.3.3 that collinearity can result in very wide stadard errors. Could collinearity be the reason that the confidence iterval associated with newspaper is so wide? The VIF scores are 1 . 005 , 1 . 145 , and 1 . 145 for TV , radio , and newspaper , suggesting no evidence of collinearity. In order to assess the association of each medium individually on sales, we can perform three separate simple linear regressions",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_122"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In order to assess the association of each medium individually on sales, we can perform three separate simple linear regressions. Rsults are shown in Tables 3.1 and 3.3 . There is evidence of an etremely strong association between TV and sales and between radio and sales . There is evidence of a mild association between newspaper and sales , when the values of TV and radio are ignored. 5. How accurately can we predict future sales? The response can be predicted using ( 3.21 ). The accuracy assocated with this estimate depends on whether we wish to predict an individual response, Y = f ( X ) + ε , or the average response, f ( X ) (Section 3.2.2 ). If the former, we use a prediction interval, and if the latter, we use a confidence interval. Prediction intervals will aways be wider than confidence intervals because they account for the uncertainty associated with ε , the irreducible error. 6. Is the relationship linear? In Section 3.3.3 , we saw that residual plots can be used in order to identify non-linearity. If the relationships are linear, then the residual plots should display no pattern. In the case of the Advertising data, we observe a non-linear effect in Figure 3.5 , though this effect could also be observed in a residual plot. In Section 3.3.2 , we discussed the inclusion of transformations of the predictors in the linear regression model in order to accommodate non-linear relationships. 7. Is there synergy among the advertising media? The standard linear regression model assumes an additive relatioship between the predictors and the response. An additive model is easy to interpret because the association between each predictor and the response is unrelated to the values of the other predictors. However, the additive assumption may be unrealistic for certain data sets. In Section 3.3.2 , we showed how to include an interaction term in the regression model in order to accommodate non-additive reltionships. A small p -value associated with the interaction term indcates the presence of such relationships",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_123"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A small p -value associated with the interaction term indcates the presence of such relationships. Figure 3.5 suggested that the Advertising data may not be additive. Including an interaction term in the model results in a substantial increase in R 2 , from around 90 % to almost 97 %. 3.5 Comparison of Linear Regression with K -Nearest Neighbors As discussed in Chapter 2 , linear regression is an example of a parametric approach because it assumes a linear functional form for f ( X ) . Parametric methods have several advantages. They are often easy to fit, because one need estimate only a small number of coefficients. In the case of linear rgression, the coefficients have simple interpretations, and tests of statistical significance can be easily performed. But parametric methods do have a disadvantage: by construction, they make strong assumptions about the form of f ( X ) . If the specified functional form is far from the truth, and prediction accuracy is our goal, then the parametric method will perform poorly. For instance, if we assume a linear relationship between X and Y but the true relationship is far from linear, then the resulting model will provide a poor fit to the data, and any conclusions drawn from it will be suspect. In contrast, non-parametric methods do not explicitly assume a parmetric form for f ( X ) , and thereby provide an alternative and more flexble approach for performing regression. We discuss various non-parametric methods in this book. Here we consider one of the simplest and best-known non-parametric methods, K -nearest neighbors regression (KNN regression). K -nearest neighbors regression The KNN regression method is closely related to the KNN classifier dicussed in Chapter 2 . Given a value for K and a prediction point x 0 , KNN regression first identifies the K training observations that are closest to x 0 , represented by N 0 . It then estimates f ( x 0 ) using the average of all the training responses in N 0 . In other words, ˆ f ( x 0 ) = 1 K 0 x i ∈N 0 y i",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_124"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It then estimates f ( x 0 ) using the average of all the training responses in N 0 . In other words, ˆ f ( x 0 ) = 1 K 0 x i ∈N 0 y i . Figure 3.16 illustrates two KNN fits on a data set with p = 2 predictors. The fit with K = 1 is shown in the left-hand panel, while the right-hand panel corresponds to K = 9 . We see that when K = 1 , the KNN fit perfectly interpolates the training observations, and consequently takes the form of a step function. When K = 9 , the KNN fit still is a step function, but averaging over nine observations results in much smaller regions of constant prediction, and consequently a smoother fit. In general, the optimal value for K will depend on the bias-variance tradeoff , which we introduced in Chapter 2 . A small value for K provides the most flexible fit, which will have low bias but high variance. This variance is due to the fact that the prediction in a given region is entirely dependent on just one observation. y y x 1 x 1 x 2 x 2 y y y FIGURE 3.16. Plots of ˆ f ( X ) using KNN regression on a two-dimensional data set with 64 observations (orange dots). Left: K = 1 results in a rough step function fit. Right: K = 9 produces a much smoother fit. In contrast, larger values of K provide a smoother and less variable fit; the prediction in a region is an average of several points, and so changing one observation has a smaller effect. However, the smoothing may cause bias by masking some of the structure in f ( X ) . In Chapter 5 , we introduce several approaches for estimating test error rates. These methods can be used to identify the optimal value of K in KNN regression. In what setting will a parametric approach such as least squares linear rgression outperform a non-parametric approach such as KNN regression? The answer is simple: the parametric approach will outperform the noparametric approach if the parametric form that has been selected is close to the true form of f . Figure 3.17 provides an example with data generated from a one-dimensional linear regression model",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_125"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Figure 3.17 provides an example with data generated from a one-dimensional linear regression model. The black solid lines reresent f ( X ) , while the blue curves correspond to the KNN fits using K = 1 and K = 9 . In this case, the K = 1 predictions are far too variable, while the smoother K = 9 fit is much closer to f ( X ) . However, since the true relationship is linear, it is hard for a non-parametric approach to compete with linear regression: a non-parametric approach incurs a cost in variance that is not offset by a reduction in bias. The blue dashed line in the lefhand panel of Figure 3.18 represents the linear regression fit to the same data. It is almost perfect. The right-hand panel of Figure 3.18 reveals that linear regression outperforms KNN for this data. The green solid line, ploted as a function of 1 /K , represents the test set mean squared error (MSE) for KNN. The KNN errors are well above the black dashed line, which is the test MSE for linear regression. When the value of K is large, then KNN performs only a little worse than least squares regression in terms of MSE. It performs far worse when K is small. In practice, the true relationship between X and Y is rarely exactly liear. Figure 3.19 examines the relative performances of least squares regresion and KNN under increasing levels of non-linearity in the relationship between X and Y . In the top row, the true relationship is nearly linear. In this case we see that the test MSE for linear regression is still superior −1.0 −0.5 0.0 0.5 1.0 1 2 3 4 −1.0 −0.5 0.0 0.5 1.0 1 2 3 4 y y x x FIGURE 3.17. Plots of ˆ f ( X ) using KNN regression on a one-dimensional data set with 50 observations. The true relationship is given by the black solid line. Left: The blue curve corresponds to K = 1 and interpolates (i.e. passes directly through) the training data. Right: The blue curve corresponds to K = 9 , and represents a smoother fit. −1.0 −0.5 0.0 0.5 1.0 1 2 3 4 0.2 0.5 1.0 0.00 0.05 0.10 0.15 Mean Squared Error y x 1/K FIGURE 3.18",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_126"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Right: The blue curve corresponds to K = 9 , and represents a smoother fit. −1.0 −0.5 0.0 0.5 1.0 1 2 3 4 0.2 0.5 1.0 0.00 0.05 0.10 0.15 Mean Squared Error y x 1/K FIGURE 3.18. The same data set shown in Figure 3.17 is investigated further. Left: The blue dashed line is the least squares fit to the data. Since f ( X ) is in fact linear (displayed as the black line), the least squares regression line provides a very good estimate of f ( X ) . Right: The dashed horizontal line represents the least squares test set MSE, while the green solid line corresponds to the MSE for KNN as a function of 1 /K (on the log scale). Linear regression achieves a lower test MSE than does KNN regression, since f ( X ) is in fact linear. For KNN regression, the best results occur with a very large value of K , corresponding to a small value of 1 /K . −1.0 −0.5 0.0 0.5 1.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 0.2 0.5 1.0 0.00 0.02 0.04 0.06 0.08 Mean Squared Error −1.0 −0.5 0.0 0.5 1.0 1.0 1.5 2.0 2.5 3.0 3.5 0.2 0.5 1.0 0.00 0.05 0.10 0.15 Mean Squared Error y y x x 1/K 1/K FIGURE 3.19. Top Left: In a setting with a slightly non-linear relationship between X and Y (solid black line), the KNN fits with K = 1 (blue) and K = 9 (red) are displayed. Top Right: For the slightly non-linear data, the test set MSE for least squares regression (horizontal black) and KNN with various values of 1 /K (green) are displayed. Bottom Left and Bottom Right: As in the top panel, but with a strongly non-linear relationship between X and Y . to that of KNN for low values of K . However, for K ≥ 4 , KNN ouperforms linear regression. The second row illustrates a more substantial deviation from linearity. In this situation, KNN substantially outperforms linear regression for all values of K . Note that as the extent of non-linearity increases, there is little change in the test set MSE for the non-parametric KNN method, but there is a large increase in the test set MSE of linear regression",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_127"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Figures 3.18 and 3.19 display situations in which KNN performs slightly worse than linear regression when the relationship is linear, but much beter than linear regression for nonlinear situations. In a real life situation in which the true relationship is unknown, one might suspect that KNN should be favored over linear regression because it will at worst be slightly inferior to linear regression if the true relationship is linear, and may give substantially better results if the true relationship is non-linear. But in rality, even when the true relationship is highly non-linear, KNN may still provide inferior results to linear regression. In particular, both Figures 3.18 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=1 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=2 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=3 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=4 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=10 0.2 0.5 1.0 0.0 0.2 0.4 0.6 0.8 1.0 p=20 Mean Squared Error 1/K FIGURE 3.20. Test MSE for linear regression (black dashed lines) and KNN (green curves) as the number of variables p increases. The true function is nolinear in the first variable, as in the lower panel in Figure 3.19 , and does not depend on the additional variables. The performance of linear regression deterorates slowly in the presence of these additional noise variables, whereas KNN’s performance degrades much more quickly as p increases. and 3.19 illustrate settings with p = 1 predictor. But in higher dimensions, KNN often performs worse than linear regression. Figure 3.20 considers the same strongly non-linear situation as in the second row of Figure 3.19 , except that we have added additional noise predictors that are not associated with the response. When p = 1 or p = 2 , KNN outperforms linear regression. But for p = 3 the results are mixed, and for p ≥ 4 linear regression is superior to KNN. In fact, the increase in dimension has only caused a small deterioration in the linear regression test set MSE, but it has caused more than a ten-fold increase in the MSE for KNN",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_128"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In fact, the increase in dimension has only caused a small deterioration in the linear regression test set MSE, but it has caused more than a ten-fold increase in the MSE for KNN. This decrease in performance as the dimension increases is a common problem for KNN, and results from the fact that in higher dimensions there is effectively a reduction in sample size. In this data set there are 50 training observations; when p = 1 , this provides enough information to accurately estimate f ( X ) . However, spreading 50 observations over p = 20 dimensions results in a phenomenon in which a given observation has no nearby neighbors —this is the so-called curse of dimensionality . That is, curse of dmensionality the K observations that are nearest to a given test observation x 0 may be very far away from x 0 in p -dimensional space when p is large, leading to a very poor prediction of f ( x 0 ) and hence a poor KNN fit. As a general rule, parametric methods will tend to outperform non-parametric approaches when there is a small number of observations per predictor. Even when the dimension is small, we might prefer linear regression to KNN from an interpretability standpoint. If the test MSE of KNN is only slightly lower than that of linear regression, we might be willing to forego a little bit of prediction accuracy for the sake of a simple model that can be described in terms of just a few coefficients, and for which p -values are available. 3.6 Lab: Linear Regression 3.6.1 Importing packages We import our standard libraries at this top level. In [1]: import numpy as np import pandas as pd from matplotlib.pyplot import subplots New imports Throughout this lab we will introduce new functions and libraries. However, we will import them here to emphasize these are the new code objects in this lab. Keeping imports near the top of a notebook makes the code more readable, since scanning the first few lines tells us what libraries are used",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_129"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Keeping imports near the top of a notebook makes the code more readable, since scanning the first few lines tells us what libraries are used. In [2]: import statsmodels.api as sm We will provide relevant details about the functions below as they are needed. Besides importing whole modules, it is also possible to import only a few items from a given module. This will help keep the namespace clean. namespace We will use a few specific objects from the statsmodels package which we statsmodels import here. In [3]: from statsmodels.stats.outliers_influence \\ import variance_inflation_factor as VIF from statsmodels.stats.anova import anova_lm As one of the import statements above is quite a long line, we inserted a line break \\ to ease readability. We will also use some functions written for the labs in this book in the ISLP package. In [4]: from ISLP import load_data from ISLP.models import (ModelSpec as MS, summarize, poly) Inspecting Objects and Namespaces The function dir() provides a list of objects in a namespace. dir() In [5]: dir() Out[5]: [ 'In' , 'MS' , '_' , '__' , '___' , '__builtin__' , '__builtins__' , 'poly' , 'quit' , 'sm' , 'summarize' ] This shows you everything that Python can find at the top level. There are certain objects like __builtins__ that contain references to built-in functions like print() . Every python object has its own notion of namespace, also accessible with dir() . This will include both the attributes of the object as well as any methods associated with it. For instance, we see 'sum' in the listing for an array. In [6]: A = np.array([3,5,11]) dir(A) Out[6]: 'strides' , 'sum' , 'swapaxes' , This indicates that the object A.sum exists. In this case it is a method that can be used to compute the sum of the array A as can be seen by typing A.sum? . In [7]: A.sum() Out[7]: 19 3.6.2 Simple Linear Regression In this section we will construct model matrices (also called design matrces) using the ModelSpec() transform from ISLP.models",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_130"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [7]: A.sum() Out[7]: 19 3.6.2 Simple Linear Regression In this section we will construct model matrices (also called design matrces) using the ModelSpec() transform from ISLP.models . We will use the Boston housing data set, which is contained in the ISLP package. The Boston dataset records medv (median house value) for 506 neighborhoods around Boston. We will build a regression model to prdict medv using 13 predictors such as rmvar (average number of rooms per house), age (proportion of owner-occupied units built prior to 1940), and lstat (percent of households with low socioeconomic status). We will use statsmodels for this task, a Python package that implements several comonly used regression methods. We have included a simple loading function load_data() in the ISLP pacload_data() age: In [8]: Boston = load_data( \"Boston\" ) Boston.columns Out[8]: Index([ 'crim' , 'zn' , 'indus' , 'chas' , 'nox' , 'rm' , 'age' , 'dis' , 'rad' , 'tax' , 'ptratio' , 'black' , 'lstat' , 'medv' ], dtype= 'object' ) Type Boston? to find out more about these data. We start by using the sm.OLS() function to fit a simple linear regression sm.OLS() model. Our response will be medv and lstat will be the single predictor. For this model, we can create the model matrix by hand. In [9]: X = pd.DataFrame({ 'intercept' : np.ones(Boston.shape[0]), 'lstat' : Boston[ 'lstat' ]}) X[:4] Out[9]: intercept lstat 0 1.0 4.98 1 1.0 9.14 2 1.0 4.03 3 1.0 2.94 We extract the response, and fit the model. In [10]: y = Boston[ 'medv' ] model = sm.OLS(y, X) results = model.fit() Note that sm.OLS() does not fit the model; it specifies the model, and then model.fit() does the actual fitting. Our ISLP function summarize() produces a simple table of the paramsummarize() ter estimates, their standard errors, t-statistics and p-values. The function takes a single argument, such as the object results returned here by the fit method, and returns such a summary",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_131"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The function takes a single argument, such as the object results returned here by the fit method, and returns such a summary. In [11]: summarize(results) Out[11]: coef std err t P>|t| intercept 34.5538 0.563 61.415 0.0 lstat -0.9500 0.039 -24.528 0.0 Before we describe other methods for working with fitted models, we outline a more useful and general framework for constructing a model mtrix X . Using Transformations: Fit and Transform Our model above has a single predictor, and constructing X was straighforward. In practice we often fit models with more than one predictor, typically selected from an array or data frame. We may wish to introduce transformations to the variables before fitting the model, specify interations between variables, and expand some particular variables into sets of variables (e.g. polynomials). The sklearn package has a particular notion sklearn for this type of task: a transform . A transform is an object that is created with some parameters as arguments. The object has two main methods: fit() and transform() . .fit() .transform() We provide a general approach for specifying models and constructing the model matrix through the transform ModelSpec() in the ISLP library. ModelSpec() ModelSpec() (renamed MS() in the preamble) creates a transform object, and then a pair of methods transform() and fit() are used to construct a corresponding model matrix. We first describe this process for our simple regression model using a single predictor lstat in the Boston data frame, but will use it repeatedly in more complex tasks in this and other labs in this book. In our case the transform is created by the expression design = MS(['lstat']) . The fit() method takes the original array and may do some initial coputations on it, as specified in the transform object. For example, it may compute means and standard deviations for centering and scaling. The transform() method applies the fitted transformation to the array of data, and produces the model matrix",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_132"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For example, it may compute means and standard deviations for centering and scaling. The transform() method applies the fitted transformation to the array of data, and produces the model matrix. In [12]: design = MS([ 'lstat' ]) design = design.fit(Boston) X = design.transform(Boston) X[:4] Out[12]: intercept lstat 0 1.0 4.98 1 1.0 9.14 2 1.0 4.03 3 1.0 2.94 In this simple case, the fit() method does very little; it simply checks that the variable 'lstat' specified in design exists in Boston . Then transform() constructs the model matrix with two columns: an intercept and the varable lstat . These two operations can be combined with the fit_transform() method. .fit_ transform() In [13]: design = MS([ 'lstat' ]) X = design.fit_transform(Boston) X[:4] Out[13]: intercept lstat 0 1.0 4.98 1 1.0 9.14 2 1.0 4.03 3 1.0 2.94 Note that, as in the previous code chunk when the two steps were done separately, the design object is changed as a result of the fit() operation. The power of this pipeline will become clearer when we fit more complex models that involve interactions and transformations. Let’s return to our fitted regression model. The object results has several methods that can be used for inference. We already presented a function summarize() for showing the essentials of the fit. For a full and somewhat exhaustive summary of the fit, we can use the summary() method (output not shown). In [14]: results.summary() The fitted coefficients can also be retrieved as the params attribute of results . In [15]: results.params Out[15]: intercept 34.553841 lstat -0.950049 dtype: float64 The get_prediction() method can be used to obtain predictions, and .get_ prediction() produce confidence intervals and prediction intervals for the prediction of medv for given values of lstat . We first create a new data frame, in this case containing only the varable lstat , with the values for this variable at which we wish to make predictions. We then use the transform() method of design to create the corresponding model matrix",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_133"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We then use the transform() method of design to create the corresponding model matrix. In [16]: new_df = pd.DataFrame({ 'lstat' :[5, 10, 15]}) newX = design.transform(new_df) newX Out[16]: intercept lstat 0 1.0 5 1 1.0 10 2 1.0 15 Next we compute the predictions at newX , and view them by extracting the predicted_mean attribute. In [17]: new_predictions = results.get_prediction(newX); new_predictions.predicted_mean Out[17]: array([29.80359411, 25.05334734, 20.30310057]) We can produce confidence intervals for the predicted values. In [18]: new_predictions.conf_int(alpha=0.05) Out[18]: array([[29.00741194, 30.59977628], [24.47413202, 25.63256267], [19.73158815, 20.87461299]]) Prediction intervals are computing by setting obs=True : In [19]: new_predictions.conf_int(obs=True, alpha=0.05) Out[19]: array([[17.56567478, 42.04151344], [12.82762635, 37.27906833], [ 8.0777421 , 32.52845905]]) For instance, the 95% confidence interval associated with an lstat value of 10 is (24.47, 25.63), and the 95% prediction interval is (12.82, 37.28). As expected, the confidence and prediction intervals are centered around the same point (a predicted value of 25.05 for medv when lstat equals 10), but the latter are substantially wider. Next we will plot medv and lstat using DataFrame.plot.scatter() , and .plot. scatter() wish to add the regression line to the resulting plot. Defining Functions While there is a function within the ISLP package that adds a line to an existing plot, we take this opportunity to define our first function to do so. def In [20]: def abline(ax, b, m): \"Add a line with slope m and intercept b to ax\" xlim = ax.get_xlim() ylim = [m * xlim[0] + b, m * xlim[1] + b] ax.plot(xlim, ylim) A few things are illustrated above. First we see the syntax for defining a function: def funcname() . The function has arguments ax, b, m where ax is an axis object for an exisiting plot, b is the intercept and m is the slope of the desired line",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_134"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The function has arguments ax, b, m where ax is an axis object for an exisiting plot, b is the intercept and m is the slope of the desired line. Other plotting options can be passed on to ax.plot by including additional optional arguments as follows: In [21]: def abline(ax, b, m, *args, **kwargs): \"Add a line with slope m and intercept b to ax\" xlim = ax.get_xlim() ylim = [m * xlim[0] + b, m * xlim[1] + b] ax.plot(xlim, ylim, *args, **kwargs) The addition of *args allows any number of non-named arguments to abline , while *kwargs allows any number of named arguments (such as linewidth=3 ) to abline . In our function, we pass these arguments verbatim to ax.plot above. Readers interested in learning more about functions are referred to the section on defining functions in docs.python.org/tutorial . Let’s use our new function to add this regression line to a plot of medv vs. lstat . In [22]: ax = Boston.plot.scatter( 'lstat' , 'medv' ) abline(ax, results.params[0], results.params[1], 'r--' , linewidth=3) Thus, the final call to ax.plot() is ax.plot(xlim, ylim, 'r--', linewidth=3) . We have used the argument 'r--' to produce a red dashed line, and added an argument to make it of width 3. There is some evidence for non-linearity in the relationship between lstat and medv . We will explore this issue later in this lab. As mentioned above, there is an existing function to add a line to a plot — ax.axline() — but knowing how to write such functions empowers us to create more expressive displays. Next we examine some diagnostic plots, several of which were discussed in Section 3.3.3 . We can find the fitted values and residuals of the fit as attributes of the results object. Various influence measures describing the regression model are computed with the get_influence() method. As we .get_ influence() will not use the fig component returned as the first value from subplots() , we simply capture the second returned value in ax below",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_135"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As we .get_ influence() will not use the fig component returned as the first value from subplots() , we simply capture the second returned value in ax below. In [23]: ax = subplots(figsize=(8,8))[1] ax.scatter(results.fittedvalues , results.resid) ax.set_xlabel( 'Fitted value' ) ax.set_ylabel( 'Residual' ) ax.axhline(0, c= 'k' , ls= '--' ); We add a horizontal line at 0 for reference using the ax.axhline() method, .axhline() indicating it should be black ( c='k' ) and have a dashed linestyle ( ls='--' ). On the basis of the residual plot (not shown), there is some evidence of non-linearity. Leverage statistics can be computed for any number of predictors using the hat_matrix_diag attribute of the value returned by the get_influence() method. In [24]: infl = results.get_influence() ax = subplots(figsize=(8,8))[1] ax.scatter(np.arange(X.shape[0]), infl.hat_matrix_diag) ax.set_xlabel( 'Index' ) ax.set_ylabel( 'Leverage' ) np.argmax(infl.hat_matrix_diag) Out[24]: 374 The np.argmax() function identifies the index of the largest element of an np.argmax() array, optionally computed over an axis of the array. In this case, we maxmized over the entire array to determine which observation has the largest leverage statistic. 3.6.3 Multiple Linear Regression In order to fit a multiple linear regression model using least squares, we again use the ModelSpec() transform to construct the required model matrix and response. The arguments to ModelSpec() can be quite general, but in this case a list of column names suffice. We consider a fit here with the two variables lstat and age . In [25]: X = MS([ 'lstat' , 'age' ]).fit_transform(Boston) model1 = sm.OLS(y, X) results1 = model1.fit() summarize(results1) Out[25]: coef std err t P>|t| intercept 33.2228 0.731 45.458 0.000 lstat -1.0321 0.048 -21.416 0.000 age 0.0345 0.012 2.826 0.005 Notice how we have compacted the first line into a succinct expression describing the construction of X",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_136"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The Boston data set contains 12 variables, and so it would be cumbersome to have to type all of these in order to perform a regression using all of the predictors. Instead, we can use the following short-hand: .columns. drop() In [26]: terms = Boston.columns.drop( 'medv' ) terms Out[26]: Index([ 'crim' , 'zn' , 'indus' , 'chas' , 'nox' , 'rm' , 'age' , 'dis' , 'rad' , 'tax' , 'ptratio' , 'lstat' ], dtype= 'object' ) We can now fit the model with all the variables in terms using the same model matrix builder. In [27]: X = MS(terms).fit_transform(Boston) model = sm.OLS(y, X) results = model.fit() summarize(results) Out[27]: coef std err t P>|t| intercept 41.6173 4.936 8.431 0.000 crim -0.1214 0.033 -3.678 0.000 zn 0.0470 0.014 3.384 0.001 indus 0.0135 0.062 0.217 0.829 chas 2.8400 0.870 3.264 0.001 nox -18.7580 3.851 -4.870 0.000 rm 3.6581 0.420 8.705 0.000 age 0.0036 0.013 0.271 0.787 dis -1.4908 0.202 -7.394 0.000 rad 0.2894 0.067 4.325 0.000 tax -0.0127 0.004 -3.337 0.001 ptratio -0.9375 0.132 -7.091 0.000 lstat -0.5520 0.051 -10.897 0.000 What if we would like to perform a regression using all of the variables but one? For example, in the above regression output, age has a high p -value. So we may wish to run a regression excluding this predictor. The following syntax results in a regression using all predictors except age (output not shown). In [28]: minus_age = Boston.columns.drop([ 'medv' , 'age' ]) Xma = MS(minus_age).fit_transform(Boston) model1 = sm.OLS(y, Xma) summarize(model1.fit()) 3.6.4 Multivariate Goodness of Fit We can access the individual components of results by name ( dir(results) shows us what is available). Hence results.rsquared gives us the R 2 , and np.sqrt(results.scale) gives us the RSE. Variance inflation factors (section 3.3.3 ) are sometimes useful to assess the effect of collinearity in the model matrix of a regression model. We will compute the VIFs in our multiple regression fit, and use the opportunity to introduce the idea of list comprehension",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_137"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We will compute the VIFs in our multiple regression fit, and use the opportunity to introduce the idea of list comprehension . list comprhension List Comprehension Often we encounter a sequence of objects which we would like to transform for some other task. Below, we compute the VIF for each feature in our X matrix and produce a data frame whose index agrees with the columns of X . The notion of list comprehension can often make such a task easier. List comprehensions are simple and powerful ways to form lists of Python objects. The language also supports dictionary and generator comprehesion, though these are beyond our scope here. Let’s look at an example. We compute the VIF for each of the variables in the model matrix X , using the function variance_inflation_factor() . variance_ inflation_ factor() In [29]: vals = [VIF(X, i) for i in range(1, X.shape[1])] vif = pd.DataFrame({ 'vif' :vals}, index=X.columns[1:]) vif Out[29]: vif crim 1.767 zn 2.298 indus 3.987 chas 1.071 nox 4.369 rm 1.913 age 3.088 dis 3.954 rad 7.445 tax 9.002 ptratio 1.797 lstat 2.871 The function VIF() takes two arguments: a dataframe or array, and a varable column index. In the code above we call VIF() on the fly for all columns in X . We have excluded column 0 above (the intercept), which is not of iterest. In this case the VIFs are not that exciting. The object vals above could have been constructed with the following for loop: In [30]: vals = [] for i in range(1, X.values.shape[1]): vals.append(VIF(X.values, i)) List comprehension allows us to perform such repetitive operations in a more straightforward way. 3.6.5 Interaction Terms It is easy to include interaction terms in a linear model using ModelSpec() . Including a tuple (\"lstat\",\"age\") tells the model matrix builder to include an interaction term between lstat and age",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_138"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Including a tuple (\"lstat\",\"age\") tells the model matrix builder to include an interaction term between lstat and age . In [31]: X = MS([ 'lstat' , 'age' , ( 'lstat' , 'age' )]).fit_transform(Boston) model2 = sm.OLS(y, X) summarize(model2.fit()) Out[31]: coef std err t P>|t| intercept 36.0885 1.470 24.553 0.000 lstat -1.3921 0.167 -8.313 0.000 age -0.0007 0.020 -0.036 0.971 lstat:age 0.0042 0.002 2.244 0.025 3.6.6 Non-linear Transformations of the Predictors The model matrix builder can include terms beyond just column names and interactions. For instance, the poly() function supplied in ISLP specifies poly() that columns representing polynomial functions of its first argument are added to the model matrix. In [32]: X = MS([poly( 'lstat' , degree=2), 'age' ]).fit_transform(Boston) model3 = sm.OLS(y, X) results3 = model3.fit() summarize(results3) Out[32]: coef std err t P>|t| intercept 17.7151 0.781 22.681 0.000 poly(lstat, degree=2)[0] -179.2279 6.733 -26.620 0.000 poly(lstat, degree=2)[1] 72.9908 5.482 13.315 0.000 age 0.0703 0.011 6.471 0.000 The effectively zero p -value associated with the quadratic term (i.e. the third row above) suggests that it leads to an improved model. By default, poly() creates a basis matrix for inclusion in the model mtrix whose columns are orthogonal polynomials , which are designed for storthogonal polynomial ble least squares computations. 13 Alternatively, had we included an argment raw=True in the above call to poly() , the basis matrix would consist simply of lstat and lstat**2 . Since either of these bases represent quadratic polynomials, the fitted values would not change in this case, just the polnomial coefficients. Also by default, the columns created by poly() do not include an intercept column as that is automatically added by MS() . We use the anova_lm() function to further quantify the extent to which anova_lm() the quadratic fit is superior to the linear fit",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_139"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We use the anova_lm() function to further quantify the extent to which anova_lm() the quadratic fit is superior to the linear fit. In [33]: anova_lm(results1, results3) Out[33]: df_resid ssr df_diff ss_diff F Pr(>F) 0 503.0 19168.13 0.0 NaN NaN NaN 1 502.0 14165.61 1.0 5002.52 177.28 7.47e-35 Here results1 represents the linear submodel containing predictors lstat and age , while results3 corresponds to the larger model above with a quadratic term in lstat . The anova_lm() function performs a hypothesis test comparing the two models. The null hypothesis is that the quadratic term in the bigger model is not needed, and the alternative hypothesis is that the bigger model is superior. Here the F -statistic is 177.28 and the associated p -value is zero. In this case the F -statistic is the square of the t -statistic for the quadratic term in the linear model summary for results3 — a consequence of the fact that these nested models differ by one degree of 13 Actually, poly() is a wrapper for the workhorse and standalone function Poly() that does the work in building the model matrix. freedom. This provides very clear evidence that the quadratic polynomial in lstat improves the linear model. This is not surprising, since earlier we saw evidence for non-linearity in the relationship between medv and lstat . The function anova_lm() can take more than two nested models as input, in which case it compares every successive pair of models. That also explains why their are NaN s in the first row above, since there is no previous model with which to compare the first. In [34]: ax = subplots(figsize=(8,8))[1] ax.scatter(results3.fittedvalues , results3.resid) ax.set_xlabel( 'Fitted value' ) ax.set_ylabel( 'Residual' ) ax.axhline(0, c= 'k' , ls= '--' ) We see that when the quadratic term is included in the model, there is little discernible pattern in the residuals. In order to create a cubic or higher-degree polynomial fit, we can simply change the degree argument to poly()",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_140"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In order to create a cubic or higher-degree polynomial fit, we can simply change the degree argument to poly() . 3.6.7 Qualitative Predictors Here we use the Carseats data, which is included in the ISLP package. We will attempt to predict Sales (child car seat sales) in 400 locations based on a number of predictors. In [35]: Carseats = load_data( 'Carseats' ) Carseats.columns Out[35]: Index([ 'Sales' , 'CompPrice' , 'Income' , 'Advertising' , 'Population' , 'Price' , 'ShelveLoc' , 'Age' , 'Education' , 'Urban' , 'US' ], dtype= 'object' ) The Carseats data includes qualitative predictors such as ShelveLoc , an indicator of the quality of the shelving location — that is, the space within a store in which the car seat is displayed. The predictor ShelveLoc takes on three possible values, Bad , Medium , and Good . Given a qualitative variable such as ShelveLoc , ModelSpec() generates dummy variables automatically. These variables are often referred to as a one-hot encoding of the categorical one-hot encoding feature. Their columns sum to one, so to avoid collinearity with an intecept, the first column is dropped. Below we see the column ShelveLoc[Bad] has been dropped, since Bad is the first level of ShelveLoc . Below we fit a multiple regression model that includes some interaction terms",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_141"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Below we see the column ShelveLoc[Bad] has been dropped, since Bad is the first level of ShelveLoc . Below we fit a multiple regression model that includes some interaction terms. In [36]: allvars = list(Carseats.columns.drop( 'Sales' )) y = Carseats[ 'Sales' ] final = allvars + [( 'Income' , 'Advertising' ), ( 'Price' , 'Age' )] X = MS(final).fit_transform(Carseats) model = sm.OLS(y, X) summarize(model.fit()) Out[36]: coef std err t P>|t| intercept 6.5756 1.009 6.519 0.000 CompPrice 0.0929 0.004 22.567 0.000 Income 0.0109 0.003 4.183 0.000 Advertising 0.0702 0.023 3.107 0.002 Population 0.0002 0.000 0.433 0.665 Price -0.1008 0.007 -13.549 0.000 ShelveLoc[Good] 4.8487 0.153 31.724 0.000 ShelveLoc[Medium] 1.9533 0.126 15.531 0.000 Age -0.0579 0.016 -3.633 0.000 Education -0.0209 0.020 -1.063 0.288 Urban[Yes] 0.1402 0.112 1.247 0.213 US[Yes] -0.1576 0.149 -1.058 0.291 Income:Advertising 0.0008 0.000 2.698 0.007 Price:Age 0.0001 0.000 0.801 0.424 In the first line above, we made allvars a list, so that we could add the interaction terms two lines down. Our model-matrix builder has created a ShelveLoc[Good] dummy variable that takes on a value of 1 if the shelving location is good, and 0 otherwise. It has also created a ShelveLoc[Medium] dummy variable that equals 1 if the shelving location is medium, and 0 oterwise. A bad shelving location corresponds to a zero for each of the two dummy variables. The fact that the coefficient for ShelveLoc[Good] in the regression output is positive indicates that a good shelving location is assciated with high sales (relative to a bad location). And ShelveLoc[Medium] has a smaller positive coefficient, indicating that a medium shelving loction leads to higher sales than a bad shelving location, but lower sales than a good shelving location. 3.7 Exercises Conceptual 1. Describe the null hypotheses to which the p -values given in Table 3.4 correspond. Explain what conclusions you can draw based on these p -values",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_142"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 3.7 Exercises Conceptual 1. Describe the null hypotheses to which the p -values given in Table 3.4 correspond. Explain what conclusions you can draw based on these p -values. Your explanation should be phrased in terms of sales , TV , radio , and newspaper , rather than in terms of the coefficients of the linear model. 2. Carefully explain the differences between the KNN classifier and KNN regression methods. 3. Suppose we have a data set with five predictors, X 1 = GPA, X 2 = IQ, X 3 = Level ( 1 for College and 0 for High School), X 4 = Interation between GPA and IQ, and X 5 = Interaction between GPA and Level. The response is starting salary after graduation (in thousands of dollars). Suppose we use least squares to fit the model, and get ˆ β 0 = 50 , ˆ β 1 = 20 , ˆ β 2 = 0 . 07 , ˆ β 3 = 35 , ˆ β 4 = 0 . 01 , ˆ β 5 = − 10 . (a) Which answer is correct, and why? i. For a fixed value of IQ and GPA, high school graduates earn more, on average, than college graduates. ii. For a fixed value of IQ and GPA, college graduates earn more, on average, than high school graduates. iii. For a fixed value of IQ and GPA, high school graduates earn more, on average, than college graduates provided that the GPA is high enough. iv. For a fixed value of IQ and GPA, college graduates earn more, on average, than high school graduates provided that the GPA is high enough. (b) Predict the salary of a college graduate with IQ of 110 and a GPA of 4 . 0 . (c) True or false: Since the coefficient for the GPA/IQ interaction term is very small, there is very little evidence of an interaction effect. Justify your answer. 4. I collect a set of data ( n = 100 observations) containing a single predictor and a quantitative response. I then fit a linear regression model to the data, as well as a separate cubic regression, i.e. Y = β 0 + β 1 X + β 2 X 2 + β 3 X 3 + ε . (a) Suppose that the true relationship between X and Y is linear, i.e. Y = β 0 + β 1 X + ε",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_143"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Y = β 0 + β 1 X + β 2 X 2 + β 3 X 3 + ε . (a) Suppose that the true relationship between X and Y is linear, i.e. Y = β 0 + β 1 X + ε . Consider the training residual sum of squares (RSS) for the linear regression, and also the training RSS for the cubic regression. Would we expect one to be lower than the other, would we expect them to be the same, or is there not enough information to tell? Justify your answer. (b) Answer (a) using test rather than training RSS. (c) Suppose that the true relationship between X and Y is not linear, but we don’t know how far it is from linear. Consider the training RSS for the linear regression, and also the training RSS for the cubic regression. Would we expect one to be lower than the other, would we expect them to be the same, or is there not enough information to tell? Justify your answer. (d) Answer (c) using test rather than training RSS. 5. Consider the fitted values that result from performing linear regresion without an intercept. In this setting, the i th fitted value takes the form ˆ y i = x i ˆ β, where ˆ β = > n 0 i =1 x i y i ? / > n 0 i ′ =1 x 2 i ′ ? . (3.38) Show that we can write ˆ y i = n 0 i ′ =1 a i ′ y i ′ . What is a i ′ ? Note: We interpret this result by saying that the fitted values from linear regression are linear combinations of the response values. 6. Using ( 3.4 ), argue that in the case of simple linear regression, the least squares line always passes through the point ( ̄ x, ̄ y ) . 7. It is claimed in the text that in the case of simple linear regression of Y onto X , the R 2 statistic ( 3.17 ) is equal to the square of the correlation between X and Y ( 3.18 ). Prove that this is the case. For simplicity, you may assume that ̄ x = ̄ y = 0 . Applied 8. This question involves the use of simple linear regression on the Auto data set. (a) Use the sm.OLS() function to perform a simple linear regression with mpg as the response and horsepower as the predictor. Use the summarize() function to print the results. Comment on the output. For example: i",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_144"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Use the summarize() function to print the results. Comment on the output. For example: i. Is there a relationship between the predictor and the rsponse? ii. How strong is the relationship between the predictor and the response? iii. Is the relationship between the predictor and the response positive or negative? iv. What is the predicted mpg associated with a horsepower of 98? What are the associated 95 % confidence and prediction intervals? (b) Plot the response and the predictor in a new set of axes ax . Use the ax.axline() method or the abline() function defined in the lab to display the least squares regression line. (c) Produce some of diagnostic plots of the least squares regression fit as described in the lab. Comment on any problems you see with the fit. 9. This question involves the use of multiple linear regression on the Auto data set. (a) Produce a scatterplot matrix which includes all of the variables in the data set. (b) Compute the matrix of correlations between the variables using the DataFrame.corr() method. .corr() (c) Use the sm.OLS() function to perform a multiple linear regression with mpg as the response and all other variables except name as the predictors. Use the summarize() function to print the results. Comment on the output. For instance: i. Is there a relationship between the predictors and the rsponse? Use the anova_lm() function from statsmodels to answer this question. ii. Which predictors appear to have a statistically significant relationship to the response? iii. What does the coefficient for the year variable suggest? (d) Produce some of diagnostic plots of the linear regression fit as described in the lab. Comment on any problems you see with the fit. Do the residual plots suggest any unusually large outliers? Does the leverage plot identify any observations with unusually high leverage? (e) Fit some models with interactions as described in the lab",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_145"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Do any interactions appear to be statistically significant? (f) Try a fe w d ifferent transformations of the variables, such as log( X ) , √ X , X 2 . Comment on your findings. 10. This question should be answered using the Carseats data set. (a) Fit a multiple regression model to predict Sales using Price , Urban , and US . (b) Provide an interpretation of each coefficient in the model. Be careful—some of the variables in the model are qualitative! (c) Write out the model in equation form, being careful to handle the qualitative variables properly. (d) For which of the predictors can you reject the null hypothesis H 0 : β j = 0 ? (e) On the basis of your response to the previous question, fit a smaller model that only uses the predictors for which there is evidence of association with the outcome. (f) How well do the models in (a) and (e) fit the data? (g) Using the model from (e), obtain 95 % confidence intervals for the coefficient(s). (h) Is there evidence of outliers or high leverage observations in the model from (e)? 11. In this problem we will investigate the t -statistic for the null hypotesis H 0 : β = 0 in simple linear regression without an intercept. To begin, we generate a predictor x and a response y as follows. rng = np.random.default_rng(1) x = rng.normal(size=100) y = 2 * x + rng.normal(size=100) (a) Perform a simple linear regression of y onto x , without an itercept. Report the coefficient estimate ˆ β , the standard error of this coefficient estimate, and the t -statistic and p -value assocated with the null hypothesis H 0 : β = 0 . Comment on these results. (You can perform regression without an intercept using the keywords argument intercept=False to ModelSpec() .) (b) Now perform a simple linear regression of x onto y without an intercept, and report the coefficient estimate, its standard error, and the corresponding t -statistic and p -values associated with the null hypothesis H 0 : β = 0 . Comment on these results",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_146"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Comment on these results. (c) What is the relationship between the results obtained in (a) and (b)? (d) For the regression of Y onto X without an intercept, the t - statistic for H 0 : β = 0 takes the form ˆ β/ SE( ˆ β ) , where ˆ β is given by ( 3.38 ), and where SE( ˆ β ) = @ ) n i =1 ( y i − x i ˆ β ) 2 ( n − 1) ) n i ′ =1 x 2 i ′ . (These formulas are slightly different from those given in Setions 3.1.1 and 3.1.2 , since here we are performing regression without an intercept.) Show algebraically, and confirm numercally in R , that the t -statistic can be written as ( √ n − 1) ) n i =1 x i y i 5 ( ) n i =1 x 2 i )( ) n i ′ =1 y 2 i ′ ) − ( ) n i ′ =1 x i ′ y i ′ ) 2 . (e) Using the results from (d), argue that the t -statistic for the rgression of y onto x is the same as the t -statistic for the regression of x onto y . (f) In R , show that when regression is performed with an intercept, the t -statistic for H 0 : β 1 = 0 is the same for the regression of y onto x as it is for the regression of x onto y . 12. This problem involves simple linear regression without an intercept. (a) Recall that the coefficient estimate ˆ β for the linear regression of Y onto X without an intercept is given by ( 3.38 ). Under what circumstance is the coefficient estimate for the regression of X onto Y the same as the coefficient estimate for the regression of Y onto X ? (b) Generate an example in Python with n = 100 observations in which the coefficient estimate for the regression of X onto Y is different from the coefficient estimate for the regression of Y onto X . (c) Generate an example in Python with n = 100 observations in which the coefficient estimate for the regression of X onto Y is the same as the coefficient estimate for the regression of Y onto X . 13. In this exercise you will create some simulated data and will fit simple linear regression models to it. Make sure to use the default random number generator with seed set to 1 prior to starting part (a) to ensure consistent results",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_147"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Make sure to use the default random number generator with seed set to 1 prior to starting part (a) to ensure consistent results. (a) Using the normal() method of your random number generator, create a vector, x , containing 100 observations drawn from a N (0 , 1) distribution. This represents a feature, X . (b) Using the normal() method, create a vector, eps , containing 100 observations drawn from a N (0 , 0 . 25) distribution—a normal distribution with mean zero and variance 0 . 25 . (c) Using x and eps , generate a vector y according to the model Y = − 1 + 0 . 5 X + ε. (3.39) What is the length of the vector y ? What are the values of β 0 and β 1 in this linear model? (d) Create a scatterplot displaying the relationship between x and y . Comment on what you observe. (e) Fit a least squares linear model to predict y using x . Comment on the model obtained. How do ˆ β 0 and ˆ β 1 compare to β 0 and β 1 ? (f) Display the least squares line on the scatterplot obtained in (d). Draw the population regression line on the plot, in a different color. Use the legend() method of the axes to create an apprpriate legend. (g) Now fit a polynomial regression model that predicts y using x and x 2 . Is there evidence that the quadratic term improves the model fit? Explain your answer. (h) Repeat (a)–(f) after modifying the data generation process in such a way that there is less noise in the data. The model ( 3.39 ) should remain the same. You can do this by decreasing the varance of the normal distribution used to generate the error term ε in (b). Describe your results. (i) Repeat (a)–(f) after modifying the data generation process in such a way that there is more noise in the data. The model ( 3.39 ) should remain the same. You can do this by increasing the variance of the normal distribution used to generate the error term ε in (b). Describe your results. (j) What are the confidence intervals for β 0 and β 1 based on the original data set, the noisier data set, and the less noisy data set? Comment on your results. 14",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_148"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Describe your results. (j) What are the confidence intervals for β 0 and β 1 based on the original data set, the noisier data set, and the less noisy data set? Comment on your results. 14. This problem focuses on the collinearity problem. (a) Perform the following commands in Python : rng = np.random.default_rng(10) x1 = rng.uniform(0, 1, size=100) x2 = 0.5 * x1 + rng.normal(size=100) / 10 y = 2 + 2 * x1 + 0.3 * x2 + rng.normal(size=100) The last line corresponds to creating a linear model in which y is a function of x1 and x2 . Write out the form of the linear model. What are the regression coefficients? (b) What is the correlation between x1 and x2 ? Create a scatterplot displaying the relationship between the variables. (c) Using this data, fit a least squares regression to predict y using x1 and x2 . Describe the results obtained. What are ˆ β 0 , ˆ β 1 , and ˆ β 2 ? How do these relate to the true β 0 , β 1 , and β 2 ? Can you reject the null hypothesis H 0 : β 1 = 0 ? How about the null hypothesis H 0 : β 2 = 0 ? (d) Now fit a least squares regression to predict y using only x1 . Comment on your results. Can you reject the null hypothesis H 0 : β 1 = 0 ? (e) Now fit a least squares regression to predict y using only x2 . Comment on your results. Can you reject the null hypothesis H 0 : β 1 = 0 ? (f) Do the results obtained in (c)–(e) contradict each other? Explain your answer. (g) Suppose we obtain one additional observation, which was unfotunately mismeasured. We use the function np.concatenate() to np.conctenate() add this additional observation to each of x1 , x2 and y . x1 = np.concatenate([x1, [0.1]]) x2 = np.concatenate([x2, [0.8]]) y = np.concatenate([y, [6]]) Re-fit the linear models from (c) to (e) using this new data. What effect does this new observation have on the each of the models? In each model, is this observation an outlier? A high-leverage point? Both? Explain your answers. 15. This problem involves the Boston data set, which we saw in the lab for this chapter",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_149"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 15. This problem involves the Boston data set, which we saw in the lab for this chapter. We will now try to predict per capita crime rate using the other variables in this data set. In other words, per capita crime rate is the response, and the other variables are the predictors. (a) For each predictor, fit a simple linear regression model to predict the response. Describe your results. In which of the models is there a statistically significant association between the predictor and the response? Create some plots to back up your assertions. (b) Fit a multiple regression model to predict the response using all of the predictors. Describe your results. For which predictors can we reject the null hypothesis H 0 : β j = 0 ? (c) How do your results from (a) compare to your results from (b)? Create a plot displaying the univariate regression coefficients from (a) on the x -axis, and the multiple regression coefficients from (b) on the y -axis. That is, each predictor is displayed as a single point in the plot. Its coefficient in a simple linear regresion model is shown on the x -axis, and its coefficient estimate in the multiple linear regression model is shown on the y -axis. (d) Is there evidence of non-linear association between any of the predictors and the response? To answer this question, for each predictor X , fit a model of the form Y = β 0 + β 1 X + β 2 X 2 + β 3 X 3 + ε. 4 Classification The linear regression model discussed in Chapter 3 assumes that the rsponse variable Y is quantitative. But in many situations, the response variable is instead qualitative . For example, eye color is qualitative. Oqualitative ten qualitative variables are referred to as categorical ; we will use these terms interchangeably. In this chapter, we study approaches for predicting qualitative responses, a process that is known as classification",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_150"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In this chapter, we study approaches for predicting qualitative responses, a process that is known as classification . Predicting classification a qualitative response for an observation can be referred to as classifying that observation, since it involves assigning the observation to a category, or class. On the other hand, often the methods used for classification first predict the probability that the observation belongs to each of the catgories of a qualitative variable, as the basis for making the classification. In this sense they also behave like regression methods. There are many possible classification techniques, or classifiers , that one classifier might use to predict a qualitative response. We touched on some of these in Sections 2.1.5 and 2.2.3 . In this chapter we discuss some widely-used classifiers: logistic regression , linear discriminant analysis , quadratic dilogistic regression linear discriminant analysis criminant analysis , naive Bayes , and K -nearest neighbors . The discussion quadratic discriminant analysis naive Bayes K -nearest neighbors of logistic regression is used as a jumping-off point for a discussion of geeralized linear models , and in particular, Poisson regression . We discuss generalized linear models Poisson regression more computer-intensive classification methods in later chapters: these iclude generalized additive models (Chapter 7 ); trees, random forests, and boosting (Chapter 8 ); and support vector machines (Chapter 9 ). 4.1 An Overview of Classification Classification problems occur often, perhaps even more so than regression problems. Some examples include: 135 1. A person arrives at the emergency room with a set of symptoms that could possibly be attributed to one of three medical conditions. Which of the three conditions does the individual have? 2. An online banking service must be able to determine whether or not a transaction being performed on the site is fraudulent, on the basis of the user’s IP address, past transaction history, and so forth. 3",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_151"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 3. On the basis of DNA sequence data for a number of patients with and without a given disease, a biologist would like to figure out which DNA mutations are deleterious (disease-causing) and which are not. Just as in the regression setting, in the classification setting we have a set of training observations ( x 1 , y 1 ) , , ( x n , y n ) that we can use to build a classifier. We want our classifier to perform well not only on the training data, but also on test observations that were not used to train the classifier. In this chapter, we will illustrate the concept of classification using the simulated Default data set. We are interested in predicting whether an individual will default on his or her credit card payment, on the basis of annual income and monthly credit card balance. The data set is displayed in Figure 4.1 . In the left-hand panel of Figure 4.1 , we have plotted annual income and monthly credit card balance for a subset of 10 , 000 individuals. The individuals who defaulted in a given month are shown in orange, and those who did not in blue. (The overall default rate is about 3 %, so we have plotted only a fraction of the individuals who did not default.) It appears that individuals who defaulted tended to have higher credit card balances than those who did not. In the center and right-hand panels of Figure 4.1 , two pairs of boxplots are shown. The first shows the distribution of balance split by the binary default variable; the second is a similar plot for income . In this chapter, we learn how to build a model to predict default ( Y ) for any given value of balance ( X 1 ) and income ( X 2 ). Since Y is not quantitative, the simple linear regression model of Chapter 3 is not a good choice: we will elaborate on this further in Section 4.2 . It is worth noting that Figure 4.1 displays a very pronounced relatioship between the predictor balance and the response default . In most real applications, the relationship between the predictor and the response will not be nearly so strong",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_152"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In most real applications, the relationship between the predictor and the response will not be nearly so strong. However, for the sake of illustrating the classifiction procedures discussed in this chapter, we use an example in which the relationship between the predictor and the response is somewhat exaggeated. 4.2 Why Not Linear Regression? We have stated that linear regression is not appropriate in the case of a qualitative response. Why not? Suppose that we are trying to predict the medical condition of a patient in the emergency room on the basis of her symptoms. In this simplified example, there are three possible diagnoses: stroke , drug overdose , and",
    "chunk_id": "an_introduction_to_statistical_learning_page-15-134.json_chunk_153"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "2 4 6 8 10 2e+07 4e+07 6e+07 8e+07 Number of Predictors Residual Sum of Squares 2 4 6 8 10 0.0 0.2 0.4 0.6 0.8 1.0 Number of Predictors R 2 FIGURE 6.1. For each possible model containing a subset of the ten predictors in the Credit data set, the RSS and R 2 are displayed. The red frontier tracks the best model for a given number of predictors, according to RSS and R 2 . Though the data set contains only ten predictors, the x -axis ranges from 1 to 11 , since one of the variables is categorical and takes on three values, leading to the creation of two dummy variables. Then the model M k fit on the full training set is delivered for the chosen k . These approaches are discussed in Section 6.1.3 . An application of best subset selection is shown in Figure 6.1 . Each plotted point corresponds to a least squares regression model fit using a different subset of the 10 predictors in the Credit data set, discussed in Chapter 3 . Here the variable region is a three-level qualitative variable, and so is represented by two dummy variables, which are selected seprately in this case. Hence, there are a total of 11 possible variables which can be included in the model. We have plotted the RSS and R 2 statistics for each model, as a function of the number of variables. The red curves connect the best models for each model size, according to RSS or R 2 . The figure shows that, as expected, these quantities improve as the number of variables increases; however, from the three-variable model on, there is little improvement in RSS and R 2 as a result of including additional predictors. Although we have presented best subset selection here for least squares regression, the same ideas apply to other types of models, such as logistic regression. In the case of logistic regression, instead of ordering models by RSS in Step 2 of Algorithm 6.1 , we instead use the deviance , a measure deviance that plays the role of RSS for a broader class of models",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The deviance is negative two times the maximized log-likelihood; the smaller the deviance, the better the fit. While best subset selection is a simple and conceptually appealing aproach, it suffers from computational limitations. The number of possible models that must be considered grows rapidly as p increases. In general, there are 2 p models that involve subsets of p predictors. So if p = 10 , then there are approximately 1,000 possible models to be considered, and if p = 20 , then there are over one million possibilities! Consequently, best suset selection becomes computationally infeasible for values of p greater than Algorithm 6.2 Forward stepw i se s el e ction 1. Let M 0 denote the null model, which contains no predictors. 2. For k = 0 , , p − 1 : (a) Consider all p − k models that augment the predictors in M k with one additional predictor. (b) Choose the best among these p − k models, and call it M k +1 . Here best is defined as having smallest RSS or highest R 2 . 3. Select a single best model from among M 0 , , M p using the prdiction error on a validation set, C p (AIC), BIC, or adjusted R 2 . Or use the cross-validation m e thod. around 40 , even with extremely fast modern computers. There are comptational shortcuts—so called branch-and-bound techniques—for eliminaing some choices, but these have their limitations as p gets large. They also only work for least squares linear regression. We present computationally efficient alternatives to best subset selection next. 6.1.2 Stepwise Selection For computational reasons, best subset selection cannot be applied with very large p . Best subset selection may also suffer from statistical problems when p is large. The larger the search space, the higher the chance of finding models that look good on the training data, even though they might not have any predictive power on future data. Thus an enormous search space can lead to overfitting and high variance of the coefficient estimates",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Thus an enormous search space can lead to overfitting and high variance of the coefficient estimates. For both of these reasons, stepwise methods, which explore a far more restricted set of models, are attractive alternatives to best subset selection. Forward Stepwise Selection Forward stepwise selection is a computationally efficient alternative to best forward stepwise selection subset selection. While the best subset selection procedure considers all 2 p possible models containing subsets of the p predictors, forward stewise considers a much smaller set of models. Forward stepwise selection begins with a model containing no predictors, and then adds predictors to the model, one-at-a-time, until all of the predictors are in the model. In particular, at each step the variable that gives the greatest additional improvement to the fit is added to the model. More formally, the forward stepwise selection procedure is given in Algorithm 6.2 . Unlike best subset selection, which involved fitting 2 p models, forward stepwise selection involves fitting one null model, along with p − k models in the k th iteration, for k = 0 , , p − 1 . This amounts to a total of 1 + ) p − 1 k =0 ( p − k ) = 1+ p ( p +1) / 2 models. This is a substantial difference: when # Variables Best subset Forward stepwise One rating rating Two rating , income rating , income Three rating , income , student rating , income , student Four cards , income rating , income , student , limit student , limit TABLE 6.1. The first four selected models for best subset selection and forward stepwise selection on the Credit data set. The first three models are identical but the fourth models differ. p = 20 , best subset selection requires fitting 1 , 048 , 576 models, whereas forward stepwise selection requires fitting only 211 models. 2 In Step 2(b) of Algorithm 6.2 , we must identify the best model from among those p − k that augment M k with one additional predictor. We can do this by simply choosing the model with the lowest RSS or the highest R 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We can do this by simply choosing the model with the lowest RSS or the highest R 2 . However, in Step 3, we must identify the best model among a set of models with different numbers of variables. This is more challenging, and is discussed in Section 6.1.3 . Forward stepwise selection’s computational advantage over best subset selection is clear. Though forward stepwise tends to do well in practice, it is not guaranteed to find the best possible model out of all 2 p moels containing subsets of the p predictors. For instance, suppose that in a given data set with p = 3 predictors, the best possible one-variable model contains X 1 , and the best possible two-variable model instead contains X 2 and X 3 . Then forward stepwise selection will fail to select the best possible two-variable model, because M 1 will contain X 1 , so M 2 must also contain X 1 together with one additional variable. Table 6.1 , which shows the first four selected models for best subset and forward stepwise selection on the Credit data set, illustrates this phnomenon. Both best subset selection and forward stepwise selection choose rating for the best one-variable model and then include income and student for the twand three-variable models. However, best subset selection rplaces rating by cards in the four-variable model, while forward stepwise selection must maintain rating in its four-variable model. In this example, Figure 6.1 indicates that there is not much difference between the threand four-variable models in terms of RSS, so either of the four-variable models will likely be adequate. Forward stepwise selection can be applied even in the high-dimensional setting where n < p ; however, in this case, it is possible to construct sumodels M 0 , , M n − 1 only, since each submodel is fit using least squares, which will not yield a unique solution if p ≥ n",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Backward Stepwise Selection Like forward stepwise selection, backward stepwise selection provides an backward stepwise selection 2 Though forward stepwise selection considers p ( p + 1) / 2 + 1 models, it performs a guided search over model space, and so the effective model space considered contains substantially more than p ( p + 1) / 2 + 1 models. efficient alternative to best subset selection. However, unlike forward stewise selection, it begins with the full least squares model containing all p predictors, and then iteratively removes the least useful predictor, one-aa-time. Details are given in Algorithm 6.3 . Algorithm 6.3 Backward stepw i se s election 1. Let M p denote the full model, which contains all p predictors. 2. For k = p, p − 1 , , 1 : (a) Consider all k models that contain all but one of the predictors in M k , for a total of k − 1 predictors. (b) Choose the best among these k models, and call it M k − 1 . Here best is defined as having smallest RSS or highest R 2 . 3. Select a single best model from among M 0 , , M p using the prdiction error on a validation set, C p (AIC), BIC, or adjusted R 2 . Or use the cross-validation m e thod. Like forward stepwise selection, the backward selection approach searches through only 1+ p ( p +1) / 2 models, and so can be applied in settings where p is too large to apply best subset selection. 3 Also like forward stepwise selection, backward stepwise selection is not guaranteed to yield the best model containing a subset of the p predictors. Backward selection requires that the number of samples n is larger than the number of variables p (so that the full model can be fit). In contrast, forward stepwise can be used even when n < p , and so is the only viable subset method when p is very large. Hybrid Approaches The best subset, forward stepwise, and backward stepwise selection aproaches generally give similar but not identical models",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Hybrid Approaches The best subset, forward stepwise, and backward stepwise selection aproaches generally give similar but not identical models. As another aternative, hybrid versions of forward and backward stepwise selection are available, in which variables are added to the model sequentially, in analogy to forward selection. However, after adding each new variable, the method may also remove any variables that no longer provide an improvement in the model fit. Such an approach attempts to more closely mimic best suset selection while retaining the computational advantages of forward and backward stepwise selection. 6.1.3 Choosing the Optimal Model Best subset selection, forward selection, and backward selection result in the creation of a set of models, each of which contains a subset of the p 3 Like forward stepwise selection, backward stepwise selection performs a guided search over model space, and so effectively considers substantially more than 1 + p ( p + 1) / 2 models. predictors. To apply these methods, we need a way to determine which of these models is best . As we discussed in Section 6.1.1 , the model containing all of the predictors will always have the smallest RSS and the largest R 2 , since these quantities are related to the training error. Instead, we wish to choose a model with a low test error. As is evident here, and as we show in Chapter 2 , the training error can be a poor estimate of the test error. Therefore, RSS and R 2 are not suitable for selecting the best model among a collection of models with different numbers of predictors. In order to select the best model with respect to test error, we need to estimate this test error. There are two common approaches: 1. We can indirectly estimate test error by making an adjustment to the training error to account for the bias due to overfitting. 2. We can directly estimate the test error, using either a validation set approach or a cross-validation approach, as discussed in Chapter 5 . We consider both of these approaches below",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 2. We can directly estimate the test error, using either a validation set approach or a cross-validation approach, as discussed in Chapter 5 . We consider both of these approaches below. C p , AIC, BIC, and Adjusted R 2 We show in Chapter 2 that the training set MSE is generally an undeestimate of the test MSE. (Recall that MSE = RSS /n .) This is because when we fit a model to the training data using least squares, we specifcally estimate the regression coefficients such that the training RSS (but not the test RSS) is as small as possible. In particular, the training error will decrease as more variables are included in the model, but the test error may not. Therefore, training set RSS and training set R 2 cannot be used to select from among a set of models with different numbers of variables. However, a number of techniques for adjusting the training error for the model size are available. These approaches can be used to select among a set of models with different numbers of variables. We now consider four such approaches: C p , Akaike information criterion (AIC), Bayesian information C p Akaike information criterion criterion (BIC), and adjusted R 2 . Figure 6.2 displays C p , BIC, and adjusted Bayesian information criterion adjusted R 2 R 2 for the best model of each size produced by best subset selection on the Credit data set. For a fitted least squares model containing d predictors, the C p estimate of test MSE is computed using the equation C p = 1 n ' RSS + 2 d ˆ σ 2 ( , (6.2) where ˆ σ 2 is an estimate of the variance of the error ε associated with each response measurement in ( 6.1 ). 4 Typically ˆ σ 2 is estimated using the full model containing all predictors. Essentially, the C p statistic adds a penalty of 2 d ˆ σ 2 to the training RSS in order to adjust for the fact that the training error tends to underestimate the test error",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Essentially, the C p statistic adds a penalty of 2 d ˆ σ 2 to the training RSS in order to adjust for the fact that the training error tends to underestimate the test error. Clearly, the penalty increases as the number of predictors in the model increases; this is intended to adjust 4 Mallow’s C p is sometimes defined as C ′ p = RSS / ˆ σ 2 + 2 d − n . This is equivalent to the definition given above in the sense that C p = 1 n ˆ σ 2 ( C ′ p + n ) , and so the model with smallest C p also has smallest C ′ p . 2 4 6 8 10 10000 15000 20000 25000 30000 Number of Predictors C p 2 4 6 8 10 10000 15000 20000 25000 30000 Number of Predictors BIC 2 4 6 8 10 0.86 0.88 0.90 0.92 0.94 0.96 Number of Predictors Adjusted R 2 FIGURE 6.2. C p , BIC, and adjusted R 2 are shown for the best models of each size for the Credit data set (the lower frontier in Figure 6.1 ). C p and BIC are estimates of test MSE. In the middle plot we see that the BIC estimate of test error shows an increase after four variables are selected. The other two plots are rather flat after four variables are included. for the corresponding decrease in training RSS. Though it is beyond the scope of this book, one can show that if ˆ σ 2 is an unbiased estimate of σ 2 in ( 6.2 ), then C p is an unbiased estimate of test MSE. As a consequence, the C p statistic tends to take on a small value for models with a low test error, so when determining which of a set of models is best, we choose the model with the lowest C p value. In Figure 6.2 , C p selects the six-variable model containing the predictors income , limit , rating , cards , age and student . The AIC criterion is defined for a large class of models fit by maximum likelihood. In the case of the model ( 6.1 ) with Gaussian errors, maximum likelihood and least squares are the same thing. In this case AIC is given by AIC = 1 n ' RSS + 2 d ˆ σ 2 ( , where, for simplicity, we have omitted irrelevant constants",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In this case AIC is given by AIC = 1 n ' RSS + 2 d ˆ σ 2 ( , where, for simplicity, we have omitted irrelevant constants. 5 Hence for least squares models, C p and AIC are proportional to each other, and so only C p is displayed in Figure 6.2 . BIC is derived from a Bayesian point of view, but ends up looking similar to C p (and AIC) as well. For the least squares model with d predictors, the BIC is, up to irrelevant constants, given by BIC = 1 n ' RSS + log( n ) d ˆ σ 2 ( . (6.3) Like C p , the BIC will tend to take on a small value for a model with a low test error, and so generally we select the model that has the lowest BIC value. Notice that BIC replaces the 2 d ˆ σ 2 used by C p with a log( n ) d ˆ σ 2 term, where n is the number of observations. Since log n > 2 for any n > 7 , 5 There are two formulas for AIC for least squares regression. The formula that we provide here requires an expression for σ 2 , which we obtain using the full model cotaining all predictors. The second formula is appropriate when σ 2 is unknown and we do not want to explicitly estimate it; that formula has a log( RSS ) term instead of an RSS term. Detailed derivations of these two formulas are outside of the scope of this book. the BIC statistic generally places a heavier penalty on models with many variables, and hence results in the selection of smaller models than C p . In Figure 6.2 , we see that this is indeed the case for the Credit data set; BIC chooses a model that contains only the four predictors income , limit , cards , and student . In this case the curves are very flat and so there does not appear to be much difference in accuracy between the four-variable and six-variable models. The adjusted R 2 statistic is another popular approach for selecting among a set of models that contain different numbers of variables. Recall from Chapter 3 that the usual R 2 is defined as 1 − RSS / TSS, where TSS = ) ( y i − y ) 2 is the total sum of squares for the response",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Recall from Chapter 3 that the usual R 2 is defined as 1 − RSS / TSS, where TSS = ) ( y i − y ) 2 is the total sum of squares for the response. Since RSS always decreases as more variables are added to the model, the R 2 always increases as more variables are added. For a least squares model with d variables, the adjusted R 2 statistic is calculated as Adjusted R 2 = 1 − RSS / ( n − d − 1) TSS / ( n − 1) . (6.4) Unlike C p , AIC, and BIC, for which a small value indicates a model with a low test error, a large value of adjusted R 2 indicates a model with a small test error. Maximizing the adjusted R 2 is equivalent to minimizing RSS n − d − 1 . While RSS always decreases as the number of variables in the model increases, RSS n − d − 1 may increase or decrease, due to the presence of d in the denominator. The intuition behind the adjusted R 2 is that once all of the correct variables have been included in the model, adding additional noise variables will lead to only a very small decrease in RSS. Since adding noise variables leads to an increase in d , such variables will lead to an increase in RSS n − d − 1 , and consequently a decrease in the adjusted R 2 . Therefore, in theory, the model with the largest adjusted R 2 will have only correct variables and no noise variables. Unlike the R 2 statistic, the adjusted R 2 statistic pays a price for the inclusion of unnecessary variables in the model. Figure 6.2 displays the adjusted R 2 for the Credit data set. Using this statistic results in the selection of a model that contains seven variables, adding own to the model selected by C p and AIC. C p , AIC, and BIC all have rigorous theoretical justifications that are beyond the scope of this book. These justifications rely on asymptotic aguments (scenarios where the sample size n is very large). Despite its poularity, and even though it is quite intuitive, the adjusted R 2 is not as well motivated in statistical theory as AIC, BIC, and C p . All of these measures are simple to use and compute",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". All of these measures are simple to use and compute. Here we have presented their formulas in the case of a linear model fit using least squares; however, AIC and BIC can also be defined for more general types of models. Validation and Cross-Validation As an alternative to the approaches just discussed, we can directly estmate the test error using the validation set and cross-validation methods discussed in Chapter 5 . We can compute the validation set error or the cross-validation error for each model under consideration, and then select 2 4 6 8 10 100 120 140 160 180 200 220 Number of Predictors Square Root of BIC 2 4 6 8 10 100 120 140 160 180 200 220 Number of Predictors Validation Set Error 2 4 6 8 10 100 120 140 160 180 200 220 Number of Predictors Cross−Validation Error FIGURE 6.3. For the Credit data set, three quantities are displayed for the best model containing d predictors, for d ranging from 1 to 11 . The overall best model, based on each of these quantities, is shown as a blue cross. Left: Square root of BIC. Center: Validation set errors. Right: Cross-validation errors. the model for which the resulting estimated test error is smallest. This prcedure has an advantage relative to AIC, BIC, C p , and adjusted R 2 , in that it provides a direct estimate of the test error, and makes fewer assumptions about the true underlying model. It can also be used in a wider range of model selection tasks, even in cases where it is hard to pinpoint the model degrees of freedom (e.g. the number of predictors in the model) or hard to estimate the error variance σ 2 . Note that when cross-validation is used, the sequence of models M k in Algorithms 6.1 – 6.3 is determined separately for each training fold, and the validation errors are averaged over all folds for each model size k . This means, for example with best-subset regression, that M k , the best subset of size k , can differ across the folds. Once the best size k is chosen, we find the best model of that size on the full data set",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Once the best size k is chosen, we find the best model of that size on the full data set. In the past, performing cross-validation was computationally prohibitive for many problems with large p and/or large n , and so AIC, BIC, C p , and adjusted R 2 were more attractive approaches for choosing among a set of models. However, nowadays with fast computers, the computations required to perform cross-validation are hardly ever an issue. Thus, crosvalidation is a very attractive approach for selecting from among a number of models under consideration. Figure 6.3 displays, as a function of d , the BIC, validation set errors, and cross-validation errors on the Credit data, for the best d -variable model. The validation errors were calculated by randomly selecting three-quarters of the observations as the training set, and the remainder as the validtion set. The cross-validation errors were computed using k = 10 folds. In this case, the validation and cross-validation methods both result in a six-variable model. However, all three approaches suggest that the four-, five-, and six-variable models are roughly equivalent in terms of their test errors. In fact, the estimated test error curves displayed in the center and righhand panels of Figure 6.3 are quite flat. While a three-variable model clearly has lower estimated test error than a two-variable model, the estimated test errors of the 3- to 11-variable models are quite similar. Furthermore, if we repeated the validation set approach using a different split of the data into a training set and a validation set, or if we repeated cross-validation using a different set of cross-validation folds, then the precise model with the lowest estimated test error would surely change. In this setting, we can select a model using the one-standard-error rule",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In this setting, we can select a model using the one-standard-error rule . We first calculate the onstandarerror rule standard error of the estimated test MSE for each model size, and then select the smallest model for which the estimated test error is within one standard error of the lowest point on the curve. The rationale here is that if a set of models appear to be more or less equally good, then we might as well choose the simplest model—that is, the model with the smallest number of predictors. In this case, applying the one-standard-error rule to the validation set or cross-validation approach leads to selection of the three-variable model. 6.2 Shrinkage Methods The subset selection methods described in Section 6.1 involve using least squares to fit a linear model that contains a subset of the predictors. As an alternative, we can fit a model containing all p predictors using a technique that constrains or regularizes the coefficient estimates, or equivalently, that shrinks the coefficient estimates towards zero. It may not be immediately obvious why such a constraint should improve the fit, but it turns out that shrinking the coefficient estimates can significantly reduce their variance. The two best-known techniques for shrinking the regression coefficients towards zero are ridge regression and the lasso . 6.2.1 Ridge Regression Recall from Chapter 3 that the least squares fitting procedure estimates β 0 , β 1 , , β p using the values that minimize RSS = n 0 i =1   y i − β 0 − p 0 j =1 β j x ij   2 . Ridge regression is very similar to least squares, except that the coefficients ridge regression are estimated by minimizing a slightly different quantity. In particular, the ridge regression coefficient estimates ˆ β R are the values that minimize n 0 i =1   y i − β 0 − p 0 j =1 β j x ij   2 + λ p 0 j =1 β 2 j = RSS + λ p 0 j =1 β 2 j , (6.5) where λ ≥ 0 is a tuning parameter , to be determined separately. Equtuning parameter tion 6.5 trades off two different criteria",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Equtuning parameter tion 6.5 trades off two different criteria. As with least squares, ridge regresion seeks coefficient estimates that fit the data well, by making the RSS small. However, the second term, λ ) j β 2 j , called a shrinkage penalty , is shrinkage penalty small when β 1 , , β p are close to zero, and so it has the effect of shrinking the estimates of β j towards zero. The tuning parameter λ serves to control 1e−02 1e+00 1e+02 1e+04 −300 −100 0 100 200 300 400 Standardized Coefficients Income Limit Rating Student 0.0 0.2 0.4 0.6 0.8 1.0 −300 −100 0 100 200 300 400 Standardized Coefficients λ ∥ ˆ β R λ ∥ 2 / ∥ ˆ β ∥ 2 FIGURE 6.4. The standardized ridge regression coefficients are displayed for the Credit data set, as a function of λ and ∥ ˆ β R λ ∥ 2 / ∥ ˆ β ∥ 2 . the relative impact of these two terms on the regression coefficient estmates. When λ = 0 , the penalty term has no effect, and ridge regression will produce the least squares estimates. However, as λ →∞ , the impact of the shrinkage penalty grows, and the ridge regression coefficient estimates will approach zero. Unlike least squares, which generates only one set of cefficient estimates, ridge regression will produce a different set of coefficient estimates, ˆ β R λ , for each value of λ . Selecting a good value for λ is critical; we defer this discussion to Section 6.2.3 , where we use cross-validation. Note that in ( 6.5 ), the shrinkage penalty is applied to β 1 , , β p , but not to the intercept β 0 . We want to shrink the estimated association of each variable with the response; however, we do not want to shrink the intercept, which is simply a measure of the mean value of the response when x i 1 = x i 2 = = x ip = 0 . If we assume that the variables—that is, the columns of the data matrix X —have been centered to have mean zero before ridge regression is performed, then the estimated intercept will take the form ˆ β 0 = ̄ y = ) n i =1 y i /n",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". An Application to the Credit Data In Figure 6.4 , the ridge regression coefficient estimates for the Credit data set are displayed. In the left-hand panel, each curve corresponds to the ridge regression coefficient estimate for one of the ten variables, plotted as a function of λ . For example, the black solid line represents the ridge regression estimate for the income coefficient, as λ is varied. At the extreme left-hand side of the plot, λ is essentially zero, and so the corresponding ridge coefficient estimates are the same as the usual least squares estmates. But as λ increases, the ridge coefficient estimates shrink towards zero. When λ is extremely large, then all of the ridge coefficient estimates are basically zero; this corresponds to the null model that contains no prdictors. In this plot, the income , limit , rating , and student variables are displayed in distinct colors, since these variables tend to have by far the largest coefficient estimates. While the ridge coefficient estimates tend to decrease in aggregate as λ increases, individual coefficients, such as rating and income , may occasionally increase as λ increases. The right-hand panel of Figure 6.4 displays the same ridge coefficient estimates as the left-hand panel, but instead of displaying λ on the x -axis, we now display ∥ ˆ β R λ ∥ 2 / ∥ ˆ β ∥ 2 , where ˆ β denotes the vector of least squares coefficient estimates. The notation ∥ β ∥ 2 denote s the l 2 no rm (pronounced l 2 norm “ell 2”) of a vector, and is defined as ∥ β ∥ 2 = G ) p j =1 β j 2 . It measures the distance of β from zero. As λ increases, the l 2 norm of ˆ β R λ will always decrease, and so will ∥ ˆ β R λ ∥ 2 / ∥ ˆ β ∥ 2 . The latter quantity ranges from 1 (when λ = 0 , in which case the ridge regression coefficient estimate is the same as the least squares estimate, and so their l 2 norms are the same) to 0 (when λ = ∞ , in which case the ridge regression coefficient estimate is a vector of zeros, with l 2 norm equal to zero)",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Therefore, we can think of the x -axis in the right-hand panel of Figure 6.4 as the amount that the ridge regression coefficient estimates have been shrunken towards zero; a small value indicates that they have been shrunken very close to zero. The standard least squares coefficient estimates discussed in Chapter 3 are scale equivariant : multiplying X j by a constant c simply leads to a scale equivariant scaling of the least squares coefficient estimates by a factor of 1 /c . In other words, regardless of how the j th predictor is scaled, X j ˆ β j will remain the same. In contrast, the ridge regression coefficient estimates can change sustantially when multiplying a given predictor by a constant. For instance, consider the income variable, which is measured in dollars. One could resonably have measured income in thousands of dollars, which would result in a reduction in the observed values of income by a factor of 1,000. Now due to the sum of squared coefficients term in the ridge regression formulation ( 6.5 ), such a change in scale will not simply cause the ridge regression cefficient estimate for income to change by a factor of 1,000. In other words, X j ˆ β R j,λ will depend not only on the value of λ , but also on the scaling of the j th predictor. In fact, the value of X j ˆ β R j,λ may even depend on the scaling of the other predictors! Therefore, it is best to apply ridge regression after standardizing the predictors , using the formula ̃ x ij = x ij G 1 n ) n i =1 ( x ij − x j ) 2 , (6.6) so that they are all on the same scale. In ( 6.6 ), the denominator is the estimated standard deviation of the j th predictor. Consequently, all of the standardized predictors will have a standard deviation of one. As a rsult the final fit will not depend on the scale on which the predictors are measured. In Figure 6.4 , the y -axis displays the standardized ridge regresion coefficient estimates—that is, the coefficient estimates that result from performing ridge regression using standardized predictors",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Why Does Ridge Regression Improve Over Least Squares? Ridge regression’s advantage over least squares is rooted in the bias-variance trade-off . As λ increases, the flexibility of the ridge regression fit decreases, leading to decreased variance but increased bias. This is illustrated in the left-hand panel of Figure 6.5 , using a simulated data set containing p = 45 predictors and n = 50 observations. The green curve in the left-hand panel 1e−01 1e+01 1e+03 0 10 20 30 40 50 60 Mean Squared Error 0.0 0.2 0.4 0.6 0.8 1.0 0 10 20 30 40 50 60 Mean Squared Error λ ∥ ˆ β R λ ∥ 2 / ∥ ˆ β ∥ 2 FIGURE 6.5. Squared bias (black), variance (green), and test mean squared error (purple) for the ridge regression predictions on a simulated data set, as a function of λ and ∥ ˆ β R λ ∥ 2 / ∥ ˆ β ∥ 2 . The horizontal dashed lines indicate the minimum possible MSE. The purple crosses indicate the ridge regression models for which the MSE is smallest. of Figure 6.5 displays the variance of the ridge regression predictions as a function of λ . At the least squares coefficient estimates, which correspond to ridge regression with λ = 0 , the variance is high but there is no bias. But as λ increases, the shrinkage of the ridge coefficient estimates leads to a substantial reduction in the variance of the predictions, at the expense of a slight increase in bias. Recall that the test mean squared error (MSE), ploted in purple, is closely related to the variance plus the squared bias. For values of λ up to about 10 , the variance decreases rapidly, with very little increase in bias, plotted in black. Consequently, the MSE drops consideably as λ increases from 0 to 10 . Beyond this point, the decrease in variance due to increasing λ slows, and the shrinkage on the coefficients causes them to be significantly underestimated, resulting in a large increase in the bias. The minimum MSE is achieved at approximately λ = 30",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The minimum MSE is achieved at approximately λ = 30 . Interestingly, because of its high variance, the MSE associated with the least squares fit, when λ = 0 , is almost as high as that of the null model for which all coefficient estimates are zero, when λ = ∞ . However, for an intermediate value of λ , the MSE is considerably lower. The right-hand panel of Figure 6.5 displays the same curves as the lefhand panel, this time plotted against the l 2 norm of the ridge regression coefficient estimates divided by the l 2 norm of the least squares estimates. Now as we move from left to right, the fits become more flexible, and so the bias decreases and the variance increases. In general, in situations where the relationship between the response and the predictors is close to linear, the least squares estimates will have low bias but may have high variance. This means that a small change in the training data can cause a large change in the least squares coefficient estimates. In particular, when the number of variables p is almost as large as the number of observations n , as in the example in Figure 6.5 , the least squares estimates will be extremely variable. And if p > n , then the least squares estimates do not even have a unique solution, whereas ridge regression can still perform well by trading off a small increase in bias for a large decrease in variance. Hence, ridge regression works best in situations where the least squares estimates have high variance. Ridge regression also has substantial computational advantages over best subset selection, which requires searching through 2 p models. As we dicussed previously, even for moderate values of p , such a search can be computationally infeasible. In contrast, for any fixed value of λ , ridge rgression only fits a single model, and the model-fitting procedure can be performed quite quickly",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In contrast, for any fixed value of λ , ridge rgression only fits a single model, and the model-fitting procedure can be performed quite quickly. In fact, one can show that the computations rquired to solve ( 6.5 ), simultaneously for all values of λ , are almost identical to those for fitting a model using least squares. 6.2.2 The Lasso Ridge regression does have one obvious disadvantage. Unlike best subset, forward stepwise, and backward stepwise selection, which will generally select models that involve just a subset of the variables, ridge regression will include all p predictors in the final model. The penalty λ ) β 2 j in ( 6.5 ) will shrink all of the coefficients towards zero, but it will not set any of them exactly to zero (unless λ = ∞ ). This may not be a problem for prediction accuracy, but it can create a challenge in model interpretation in settings in which the number of variables p is quite large. For example, in the Credit data set, it appears that the most important variables are income , limit , rating , and student . So we might wish to build a model including just these predictors. However, ridge regression will always generate a model involving all ten predictors. Increasing the value of λ will tend to reduce the magnitudes of the coefficients, but will not result in exclusion of any of the variables. The lasso is a relatively recent alternative to ridge regression that ovelasso comes this disadvantage. The lasso coefficients, ˆ β L λ , minimize the quantity n 0 i =1   y i − β 0 − p 0 j =1 β j x ij   2 + λ p 0 j =1 | β j | = RSS + λ p 0 j =1 | β j | . (6.7) Comparing ( 6.7 ) to ( 6.5 ), we see that the lasso and ridge regression have similar formulations. The only difference is that the β 2 j term in the ridge regression penalty ( 6.5 ) has been replaced by | β j | in the lasso penalty ( 6.7 ). In statistical parlance, the lasso uses an l 1 (pronounced “ell 1”) penalty instead of an l 2 penalty. The l 1 norm of a coefficient vector β is given by ∥ β ∥ 1 = ) | β j |",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_19"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In statistical parlance, the lasso uses an l 1 (pronounced “ell 1”) penalty instead of an l 2 penalty. The l 1 norm of a coefficient vector β is given by ∥ β ∥ 1 = ) | β j | . As with ridge regression, the lasso shrinks the coefficient estimates twards zero. However, in the case of the lasso, the l 1 penalty has the effect of forcing some of the coefficient estimates to be exactly equal to zero when the tuning parameter λ is sufficiently large. Hence, much like best subset slection, the lasso performs variable selection . As a result, models generated from the lasso are generally much easier to interpret than those produced by ridge regression. We say that the lasso yields sparse models—that is, sparse models that involve only a subset of the variables. As in ridge regression, selecting a good value of λ for the lasso is critical; we defer this discussion to Section 6.2.3 , where we use cross-validation. 20 50 100 200 500 2000 5000 −200 0 100 200 300 400 Standardized Coefficients 0.0 0.2 0.4 0.6 0.8 1.0 −300 −100 0 100 200 300 400 Standardized Coefficients Income Limit Rating Student λ ∥ ˆ β L λ ∥ 1 / ∥ ˆ β ∥ 1 FIGURE 6.6. The standardized lasso coefficients on the Credit data set are shown as a function of λ and ∥ ˆ β L λ ∥ 1 / ∥ ˆ β ∥ 1 . As an example, consider the coefficient plots in Figure 6.6 , which are geerated from applying the lasso to the Credit data set. When λ = 0 , then the lasso simply gives the least squares fit, and when λ becomes sufficiently large, the lasso gives the null model in which all coefficient estimates equal zero. However, in between these two extremes, the ridge regression and lasso models are quite different from each other. Moving from left to right in the right-hand panel of Figure 6.6 , we observe that at first the lasso rsults in a model that contains only the rating predictor. Then student and limit enter the model almost simultaneously, shortly followed by income . Eventually, the remaining variables enter the model",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_20"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Then student and limit enter the model almost simultaneously, shortly followed by income . Eventually, the remaining variables enter the model. Hence, depending on the value of λ , the lasso can produce a model involving any number of varables. In contrast, ridge regression will always include all of the variables in the model, although the magnitude of the coefficient estimates will depend on λ . Another Formulation for Ridge Regression and the Lasso One can show that the lasso and ridge regression coefficient estimates solve the problems minimize β      n 0 i =1   y i − β 0 − p 0 j =1 β j x ij   2      subject to p 0 j =1 | β j | ≤ s (6.8) and minimize β      n 0 i =1   y i − β 0 − p 0 j =1 β j x ij   2      subject to p 0 j =1 β 2 j ≤ s, (6.9) respectively. In other words, for every value of λ , there is some s such that the Equations ( 6.7 ) and ( 6.8 ) will give the same lasso coefficient estimates. Similarly, for every value of λ there is a corresponding s such that Equtions ( 6.5 ) and ( 6.9 ) will give the same ridge regression coefficient estimates. When p = 2 , then ( 6.8 ) indicates that the lasso coefficient estimates have the smallest RSS out of all points that lie within the diamond defined by | β 1 | + | β 2 | ≤ s . Similarly, the ridge regression estimates have the smallest RSS out of all points that lie within the circle defined by β 2 1 + β 2 2 ≤ s . We can think of ( 6.8 ) as follows. When we perform the lasso we are trying to find the set of coefficient estimates that lead to the smallest RSS, subject to the constraint that there is a budget s for how large ) p j =1 | β j | can be. When s is extremely large, then this budget is not very restrictive, and so the coefficient estimates can be large. In fact, if s is large enough that the least squares solution falls within the budget, then ( 6.8 ) will simply yield the least squares solution. In contrast, if s is small, then ) p j =1 | β j | must be small in order to avoid violating the budget",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_21"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In contrast, if s is small, then ) p j =1 | β j | must be small in order to avoid violating the budget. Similarly, ( 6.9 ) indicates that when we perform ridge regression, we seek a set of coefficient estimates such that the RSS is as small as possible, subject to the requirement that ) p j =1 β 2 j not exceed the budget s . The formulations ( 6.8 ) and ( 6.9 ) reveal a close connection between the lasso, ridge regression, and best subset selection. Consider the problem minimize β      n 0 i =1   y i − β 0 − p 0 j =1 β j x ij   2      subject to p 0 j =1 I ( β j ̸ = 0) ≤ s. (6.10) Here I ( β j ̸ = 0) is an indicator variable: it takes on a value of 1 if β j ̸ = 0 , and equals zero otherwise. Then ( 6.10 ) amounts to finding a set of coefficient estimates such that RSS is as small as possible, subject to the constraint that no more than s coefficients can be nonzero. The problem ( 6.10 ) is equivalent to best subset selection. Unfortunately, solving ( 6.10 ) is coputationally infeasible when p is large, since it requires considering all ' p s ( models containing s predictors. Therefore, we can interpret ridge regression and the lasso as computationally feasible alternatives to best subset seletion that replace the intractable form of the budget in ( 6.10 ) with forms that are much easier to solve. Of course, the lasso is much more closely related to best subset selection, since the lasso performs feature selection for s sufficiently small in ( 6.8 ), while ridge regression does not. The Variable Selection Property of the Lasso Why is it that the lasso, unlike ridge regression, results in coefficient estmates that are exactly equal to zero? The formulations ( 6.8 ) and ( 6.9 ) can be used to shed light on the issue. Figure 6.7 illustrates the situation. The least squares solution is marked as ˆ β , while the blue diamond and circle represent the lasso and ridge regression constraints in ( 6.8 ) and ( 6.9 ), rspectively",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_22"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The least squares solution is marked as ˆ β , while the blue diamond and circle represent the lasso and ridge regression constraints in ( 6.8 ) and ( 6.9 ), rspectively. If s is sufficiently large, then the constraint regions will contain ˆ β , and so the ridge regression and lasso estimates will be the same as the least squares estimates. (Such a large value of s corresponds to λ = 0 in ( 6.5 ) and ( 6.7 ).) However, in Figure 6.7 the least squares estimates lie ouside of the diamond and the circle, and so the least squares estimates are not the same as the lasso and ridge regression estimates. Each of the ellipses centered around ˆ β represents a contour : this means contour that all of the points on a particular ellipse have the same RSS value. As FIGURE 6.7. Contours of the error and constraint functions for the lasso (left) and ridge regression (right) . The solid blue areas are the constraint regions, | β 1 | + | β 2 | ≤ s and β 2 1 + β 2 2 ≤ s , while the red ellipses are the contours of the RSS. the ellipses expand away from the least squares coefficient estimates, the RSS increases. Equations ( 6.8 ) and ( 6.9 ) indicate that the lasso and ridge regression coefficient estimates are given by the first point at which an ellipse contacts the constraint region. Since ridge regression has a circular constraint with no sharp points, this intersection will not generally occur on an axis, and so the ridge regression coefficient estimates will be exclusively non-zero. However, the lasso constraint has corners at each of the axes, and so the ellipse will often intersect the constraint region at an axis. When this occurs, one of the coefficients will equal zero. In higher dimensions, many of the coefficient estimates may equal zero simultaneously. In Figure 6.7 , the intersection occurs at β 1 = 0 , and so the resulting model will only include β 2 . In Figure 6.7 , we considered the simple case of p = 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_23"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In Figure 6.7 , the intersection occurs at β 1 = 0 , and so the resulting model will only include β 2 . In Figure 6.7 , we considered the simple case of p = 2 . When p = 3 , then the constraint region for ridge regression becomes a sphere, and the constraint region for the lasso becomes a polyhedron. When p > 3 , the constraint for ridge regression becomes a hypersphere, and the constraint for the lasso becomes a polytope. However, the key ideas depicted in Fiure 6.7 still hold. In particular, the lasso leads to feature selection when p > 2 due to the sharp corners of the polyhedron or polytope. Comparing the Lasso and Ridge Regression It is clear that the lasso has a major advantage over ridge regression, in that it produces simpler and more interpretable models that involve only a subset of the predictors. However, which method leads to better prediction accuracy? Figure 6.8 displays the variance, squared bias, and test MSE of the lasso applied to the same simulated data as in Figure 6.5 . Clearly the lasso leads to qualitatively similar behavior to ridge regression, in that as λ increases, the variance decreases and the bias increases. In the right-hand 0.02 0.10 0.50 2.00 10.00 50.00 0 10 20 30 40 50 60 Mean Squared Error 0.0 0.2 0.4 0.6 0.8 1.0 0 10 20 30 40 50 60 R 2 on Training Data Mean Squared Error λ FIGURE 6.8. Left: Plots of squared bias (black), variance (green), and test MSE (purple) for the lasso on a simulated data set. Right: Comparison of squared bias, variance, and test MSE between lasso (solid) and ridge (dotted). Both are plotted against their R 2 on the training data, as a common form of indexing. The crosses in both plots indicate the lasso model for which the MSE is smallest. panel of Figure 6.8 , the dotted lines represent the ridge regression fits. Here we plot both against their R 2 on the training data. This is another useful way to index models, and can be used to compare models with different types of regularization, as is the case here",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_24"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Here we plot both against their R 2 on the training data. This is another useful way to index models, and can be used to compare models with different types of regularization, as is the case here. In this example, the lasso and ridge regression result in almost identical biases. However, the variance of ridge regression is slightly lower than the variance of the lasso. Consequently, the minimum MSE of ridge regression is slightly smaller than that of the lasso. However, the data in Figure 6.8 were generated in such a way that all 45 predictors were related to the response—that is, none of the true coefficients β 1 , , β 45 equaled zero. The lasso implicitly assumes that a number of the coefficients truly equal zero. Consequently, it is not surprising that ridge regression outperforms the lasso in terms of prediction error in this setting. Figure 6.9 illustrates a similar situation, except that now the response is a function of only 2 out of 45 predictors. Now the lasso tends to outperform ridge regression in terms of bias, variance, and MSE. These two examples illustrate that neither ridge regression nor the lasso will universally dominate the other. In general, one might expect the lasso to perform better in a setting where a relatively small number of predictors have substantial coefficients, and the remaining predictors have coefficients that are very small or that equal zero. Ridge regression will perform better when the response is a function of many predictors, all with coefficients of roughly equal size. However, the number of predictors that is related to the response is never known a priori for real data sets. A technique such as cross-validation can be used in order to determine which approach is better on a particular data set. As with ridge regression, when the least squares estimates have excesively high variance, the lasso solution can yield a reduction in variance at the expense of a small increase in bias, and consequently can geneate more accurate predictions",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_25"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Unlike ridge regression, the lasso performs variable selection, and hence results in models that are easier to interpret. 0.02 0.10 0.50 2.00 10.00 50.00 0 20 40 60 80 100 Mean Squared Error 0.4 0.5 0.6 0.7 0.8 0.9 1.0 0 20 40 60 80 100 R 2 on Training Data Mean Squared Error λ FIGURE 6.9. Left: Plots of squared bias (black), variance (green), and test MSE (purple) for the lasso. The simulated data is similar to that in Figure 6.8 , except that now only two predictors are related to the response. Right: Comparison of squared bias, variance, and test MSE between lasso (solid) and ridge (dotted). Both are plotted against their R 2 on the training data, as a common form of indexing. The crosses in both plots indicate the lasso model for which the MSE is smallest. There are very efficient algorithms for fitting both ridge and lasso models; in both cases the entire coefficient paths can be computed with about the same amount of work as a single least squares fit. We will explore this further in the lab at the end of this chapter. A Simple Special Case for Ridge Regression and the Lasso In order to obtain a better intuition about the behavior of ridge regression and the lasso, consider a simple special case with n = p , and X a diaonal matrix with 1 ’s on the diagonal and 0 ’s in all off-diagonal elements. To simplify the problem further, assume also that we are performing regresion without an intercept. With these assumptions, the usual least squares problem simplifies to finding β 1 , , β p that minimize p 0 j =1 ( y j − β j ) 2 . (6.11) In this case, the least squares solution is given by ˆ β j = y j",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_26"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (6.11) In this case, the least squares solution is given by ˆ β j = y j . And in this setting, ridge regression amounts to finding β 1 , , β p such that p 0 j =1 ( y j − β j ) 2 + λ p 0 j =1 β 2 j (6.12) is minimized, and the lasso amounts to finding the coefficients such that p 0 j =1 ( y j − β j ) 2 + λ p 0 j =1 | β j | (6.13) −1.5 −0.5 0.0 0.5 1.0 1.5 −1.5 −0.5 0.5 1.5 Coefficient Estimate Ridge Least Squares −1.5 −0.5 0.0 0.5 1.0 1.5 −1.5 −0.5 0.5 1.5 Coefficient Estimate Lasso Least Squares y j y j FIGURE 6.10. The ridge regression and lasso coefficient estimates for a simple setting with n = p and X a diagonal matrix with 1 ’s on the diagonal. Left: The ridge regression coefficient estimates are shrunken proportionally towards zero, relative to the least squares estimates. Right: The lasso coefficient estimates are soft-thresholded towards zero. is minimized. One can show that in this setting, the ridge regression estmates take the form ˆ β R j = y j / (1 + λ ) , (6.14) and the lasso estimates take the form ˆ β L j =      y j − λ/ 2 if y j > λ/ 2; y j + λ/ 2 if y j < − λ/ 2; 0 if | y j | ≤ λ/ 2 . (6.15) Figure 6.10 displays the situation. We can see that ridge regression and the lasso perform two very different types of shrinkage. In ridge regression, each least squares coefficient estimate is shrunken by the same proportion. In contrast, the lasso shrinks each least squares coefficient towards zero by a constant amount, λ/ 2 ; the least squares coefficients that are less than λ/ 2 in absolute value are shrunken entirely to zero. The type of shrinage performed by the lasso in this simple setting ( 6.15 ) is known as softhresholding . The fact that some lasso coefficients are shrunken entirely to softhresholding zero explains why the lasso performs feature selection",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_27"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The fact that some lasso coefficients are shrunken entirely to softhresholding zero explains why the lasso performs feature selection. In the case of a more general data matrix X , the story is a little more complicated than what is depicted in Figure 6.10 , but the main ideas still hold approximately: ridge regression more or less shrinks every dimension of the data by the same proportion, whereas the lasso more or less shrinks all coefficients toward zero by a similar amount, and sufficiently small cefficients are shrunken all the way to zero. Bayesian Interpretation of Ridge Regression and the Lasso We now show that one can view ridge regression and the lasso through a Bayesian lens. A Bayesian viewpoint for regression assumes that the coefficient vector β has some prior distribution, say p ( β ) , where β = ( β 0 , β 1 , , β p ) T . The likelihood of the data can be written as f ( Y | X, β ) , −3 −2 −1 0 1 2 3 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 −3 −2 −1 0 1 2 3 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 β j β j g ( β j ) g ( β j ) FIGURE 6.11. Left: Ridge regression is the posterior mode for β under a Gausian prior. Right: The lasso is the posterior mode for β under a double-exponential prior. where X = ( X 1 , , X p ) . Multiplying the prior distribution by the likelhood gives us (up to a proportionality constant) the posterior distribution , posterior distribution which takes the form p ( β | X, Y ) ∝ f ( Y | X, β ) p ( β | X ) = f ( Y | X, β ) p ( β ) , where the proportionality above follows from Bayes’ theorem, and the equality above follows from the assumption that X is fixed. We assume the usual linear model, Y = β 0 + X 1 β 1 + · · · + X p β p + ε, and suppose that the errors are independent and drawn from a normal ditribution. Furthermore, assume that p ( β ) = F p j =1 g ( β j ) , for some density function g",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_28"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Furthermore, assume that p ( β ) = F p j =1 g ( β j ) , for some density function g . It turns out that ridge regression and the lasso follow naturally from two special cases of g : • If g is a Gaussian distribution with mean zero and standard deviation a function of λ , then it follows that the posterior mode for β —that posterior mode is, the most likely value for β , given the data—is given by the ridge regression solution. (In fact, the ridge regression solution is also the posterior mean.) • If g is a double-exponential (Laplace) distribution with mean zero and scale parameter a function of λ , then it follows that the posterior mode for β is the lasso solution. (However, the lasso solution is not the posterior mean, and in fact, the posterior mean does not yield a sparse coefficient vector.) The Gaussian and double-exponential priors are displayed in Figure 6.11 . Therefore, from a Bayesian viewpoint, ridge regression and the lasso follow directly from assuming the usual linear model with normal errors, together with a simple prior distribution for β . Notice that the lasso prior is steeply peaked at zero, while the Gaussian is flatter and fatter at zero. Hence, the lasso expects a priori that many of the coefficients are (exactly) zero, while ridge assumes the coefficients are randomly distributed about zero. 5e−03 5e−02 5e−01 5e+00 25.0 25.2 25.4 25.6 Cross−Validation Error 5e−03 5e−02 5e−01 5e+00 −300 −100 0 100 300 Standardized Coefficients λ λ FIGURE 6.12. Left: Cross-validation errors that result from applying ridge regression to the Credit data set with various values of λ . Right: The coefficient estimates as a function of λ . The vertical dashed lines indicate the value of λ selected by cross-validation",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_29"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Right: The coefficient estimates as a function of λ . The vertical dashed lines indicate the value of λ selected by cross-validation. 6.2.3 Selecting the Tuning Parameter Just as the subset selection approaches considered in Section 6.1 require a method to determine which of the models under consideration is best, implementing ridge regression and the lasso requires a method for selecting a value for the tuning parameter λ in ( 6.5 ) and ( 6.7 ), or equivalently, the value of the constraint s in ( 6.9 ) and ( 6.8 ). Cross-validation provides a siple way to tackle this problem. We choose a grid of λ values, and compute the cross-validation error for each value of λ , as described in Chapter 5 . We then select the tuning parameter value for which the cross-validation error is smallest. Finally, the model is re-fit using all of the available observations and the selected value of the tuning parameter. Figure 6.12 displays the choice of λ that results from performing leavone-out cross-validation on the ridge regression fits from the Credit data set. The dashed vertical lines indicate the selected value of λ . In this case the value is relatively small, indicating that the optimal fit only involves a small amount of shrinkage relative to the least squares solution. In addition, the dip is not very pronounced, so there is rather a wide range of values that would give a very similar error. In a case like this we might simply use the least squares solution. Figure 6.13 provides an illustration of ten-fold cross-validation applied to the lasso fits on the sparse simulated data from Figure 6.9 . The left-hand panel of Figure 6.13 displays the cross-validation error, while the right-hand panel displays the coefficient estimates. The vertical dashed lines indicate the point at which the cross-validation error is smallest",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_30"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The vertical dashed lines indicate the point at which the cross-validation error is smallest. The two colored lines in the right-hand panel of Figure 6.13 represent the two predictors that are related to the response, while the grey lines represent the unrlated predictors; these are often referred to as signal and noise variables, signal respectively. Not only has the lasso correctly given much larger coeffcient estimates to the two signal predictors, but also the minimum crosvalidation error corresponds to a set of coefficient estimates for which only the signal variables are non-zero. Hence cross-validation together with the lasso has correctly identified the two signal variables in the model, even though this is a challenging setting, with p = 45 variables and only n = 50 0.0 0.2 0.4 0.6 0.8 1.0 0 200 600 1000 1400 Cross−Validation Error 0.0 0.2 0.4 0.6 0.8 1.0 −5 0 5 10 15 Standardized Coefficients ∥ ˆ β L λ ∥ 1 / ∥ ˆ β ∥ 1 ∥ ˆ β L λ ∥ 1 / ∥ ˆ β ∥ 1 FIGURE 6.13. Left : Ten-fold cross-validation MSE for the lasso, applied to the sparse simulated data set from Figure 6.9 . Right: The corresponding lasso coefficient estimates are displayed. The two signal variables are shown in color, and the noise variables are in gray. The vertical dashed lines indicate the lasso fit for which the cross-validation error is smallest. observations. In contrast, the least squares solution—displayed on the far right of the right-hand panel of Figure 6.13 —assigns a large coefficient estimate to only one of the two signal variables. 6.3 Dimension Reduction Methods The methods that we have discussed so far in this chapter have controlled variance in two different ways, either by using a subset of the original varables, or by shrinking their coefficients toward zero. All of these methods are defined using the original predictors, X 1 , X 2 , , X p . We now explore a class of approaches that transform the predictors and then fit a least squares model using the transformed variables",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_31"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We now explore a class of approaches that transform the predictors and then fit a least squares model using the transformed variables. We will refer to these tecniques as dimension reduction methods. dimension reduction Let Z 1 , Z 2 , , Z M represent M < p linear combinations of our original linear combination p predictors. That is, Z m = p 0 j =1 φ jm X j (6.16) for some constants φ 1 m , φ 2 m , φ pm , m = 1 , , M . We can then fit the linear regression model y i = θ 0 + M 0 m =1 θ m z im + ε i , i = 1 , , n, (6.17) using least squares. Note that in ( 6.17 ), the regression coefficients are given by θ 0 , θ 1 , , θ M . If the constants φ 1 m , φ 2 m , , φ pm are chosen wisely, then such dimension reduction approaches can often outperform least squares regression. In other words, fitting ( 6.17 ) using least squares can lead to better results than fitting ( 6.1 ) using least squares. The term dimension reduction comes from the fact that this approach reduces the problem of estimating the p +1 coefficients β 0 , β 1 , , β p to the 10 20 30 40 50 60 70 0 5 10 15 20 25 30 35 Population Ad Spending FIGURE 6.14. The population size ( pop ) and ad spending ( ad ) for 100 different cities are shown as purple circles. The green solid line indicates the first principal component, and the blue dashed line indicates the second principal component. simpler problem of estimating the M + 1 coefficients θ 0 , θ 1 , , θ M , where M < p . In other words, the dimension of the problem has been reduced from p + 1 to M + 1 . Notice that from ( 6.16 ), M 0 m =1 θ m z im = M 0 m =1 θ m p 0 j =1 φ jm x ij = p 0 j =1 M 0 m =1 θ m φ jm x ij = p 0 j =1 β j x ij , where β j = M 0 m =1 θ m φ jm . (6.18) Hence ( 6.17 ) can be thought of as a special case of the original linear regression model given by ( 6.1 ). Dimension reduction serves to constrain the estimated β j coefficients, since now they must take the form ( 6.18 ). This constraint on the form of the coefficients has the potential to bias the coefficient estimates",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_32"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This constraint on the form of the coefficients has the potential to bias the coefficient estimates. However, in situations where p is large relative to n , selecting a value of M ≪ p can significantly reduce the variance of the fitted coefficients. If M = p , and all the Z m are linearly independent, then ( 6.18 ) poses no constraints. In this case, no dimension reduction occurs, and so fitting ( 6.17 ) is equivalent to performing least squares on the original p predictors. All dimension reduction methods work in two steps. First, the tranformed predictors Z 1 , Z 2 , , Z M are obtained. Second, the model is fit using these M predictors. However, the choice of Z 1 , Z 2 , , Z M , or equialently, the selection of the φ jm ’s, can be achieved in different ways. In this chapter, we will consider two approaches for this task: principal components and partial least squares . 6.3.1 Principal Components Regression Principal components analysis (PCA) is a popular approach for deriving principal components analysis a low-dimensional set of features from a large set of variables. PCA is discussed in greater detail as a tool for unsupervised learning in Chapter 12 . Here we describe its use as a dimension reduction technique for regression. An Overview of Principal Components Analysis PCA is a technique for reducing the dimension of an n × p data matrix X . The first principal component direction of the data is that along which the observations vary the most . For instance, consider Figure 6.14 , which shows population size ( pop ) in tens of thousands of people, and ad spending for a particular company ( ad ) in thousands of dollars, for 100 cities. 6 The green solid line represents the first principal component direction of the data. We can see by eye that this is the direction along which there is the greatest variability in the data",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_33"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 6 The green solid line represents the first principal component direction of the data. We can see by eye that this is the direction along which there is the greatest variability in the data. That is, if we projected the 100 observations onto this line (as shown in the left-hand panel of Figure 6.15 ), then the resulting projected observations would have the largest possible variance; projecting the observations onto any other line would yield projected observations with lower variance. Projecting a point onto a line simply involves finding the location on the line which is closest to the point. The first principal component is displayed graphically in Figure 6.14 , but how can it be summarized mathematically? It is given by the formula Z 1 = 0 . 839 × ( pop − pop ) + 0 . 544 × ( ad − ad ) . (6.19) Here φ 11 = 0 . 839 and φ 21 = 0 . 544 are the principal component loadings, which define the direction referred to abo ve. In ( 6.19 ), pop indicates the mean of all pop values in this data set, and ad indicates the mean of all avertising spending. The idea is that out of every possible linear combination of pop and ad such that φ 2 11 + φ 2 21 = 1 , this particular linear combination yields the highest variance: i.e. this is the linear combination for which Var( φ 11 × ( pop − pop ) + φ 21 × ( ad − ad )) is maximized. It is necessary to consider only linear combinations of the form φ 2 11 + φ 2 21 = 1 , since otherwise we could increase φ 11 and φ 21 arbitrarily in order to blow up the variance. In ( 6.19 ), the two loadings are both positive and have similar size, and so Z 1 is almost an average of the two variables. Since n = 100 , pop and ad are vectors of length 100 , and so is Z 1 in ( 6.19 ). For instance, z i 1 = 0 . 839 × ( pop i − pop ) + 0 . 544 × ( ad i − ad ) . (6.20) The values of z 11 , , z n 1 are known as the principal component scores , and can be seen in the right-hand panel of Figure 6.15",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_34"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 839 × ( pop i − pop ) + 0 . 544 × ( ad i − ad ) . (6.20) The values of z 11 , , z n 1 are known as the principal component scores , and can be seen in the right-hand panel of Figure 6.15 . There is also another interpretation of PCA: the first principal compnent vector defines the line that is as close as possible to the data. For instance, in Figure 6.14 , the first principal component line minimizes the sum of the squared perpendicular distances between each point and the line. These distances are plotted as dashed line segments in the left-hand 6 This dataset is distinct from the Advertising data discussed in Chapter 3 . 20 30 40 50 5 10 15 20 25 30 Population Ad Spending −20 −10 0 10 20 −10 −5 0 5 10 1st Principal Component 2nd Principal Component FIGURE 6.15. A subset of the advertising data. The mean pop and ad budgets are indicated with a blue circle. Left: The first principal component direction is shown in green. It is the dimension along which the data vary the most, and it also defines the line that is closest to all n of the observations. The distances from each observation to the principal component are represented using the black dashed line segments. The blue dot represents ( pop , ad ) . Right: The left-hand panel has been rotated so that the first principal component direction coincides with the x-axis. panel of Figure 6.15 , in which the crosses represent the projection of each point onto the first principal component line. The first principal component has been chosen so that the projected observations are as close as possible to the original observations. In the right-hand panel of Figure 6.15 , the left-hand panel has been rotated so that the first principal component direction coincides with the x -axis. It is possible to show that the first principal component score for the i th observation, given in ( 6.20 ), is the distance in the x -direction of the i th cross from zero",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_35"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It is possible to show that the first principal component score for the i th observation, given in ( 6.20 ), is the distance in the x -direction of the i th cross from zero. So for example, the point in the bottom-left corner of the left-hand panel of Figure 6.15 has a large negative principal component score, z i 1 = − 26 . 1 , while the point in the top-right corner has a large positive score, z i 1 = 18 . 7 . These scores can be computed directly using ( 6.20 ). We can think of the values of the principal component Z 1 as singlnumber summaries of the joint pop and ad budgets for each lo cat ion. In this example, if z i 1 = 0 . 839 × ( pop i − pop ) + 0 . 544 × ( ad i − ad ) < 0 , then this indicates a city with below-average population size and beloaverage ad spending. A positive score suggests the opposite. How well can a single number represent both pop and ad ? In this case, Figure 6.14 indicates that pop and ad have approximately a linear relationship, and so we might expect that a single-number summary will work well. Figure 6.16 displays z i 1 versus both pop and ad . 7 The plots show a strong relationship between the first principal component and the two features. In other words, the first principal component appears to capture most of the information contained in the pop and ad predictors. So far we have concentrated on the first principal component. In geeral, one can construct up to p distinct principal components. The second 7 The principal components were calculated after first standardizing both pop and ad , a common approach. Hence, the x-axes on Figures 6.15 and 6.16 are not on the same scale. −3 −2 −1 0 1 2 3 20 30 40 50 60 1st Principal Component Population −3 −2 −1 0 1 2 3 5 10 15 20 25 30 1st Principal Component Ad Spending FIGURE 6.16. Plots of the first principal component scores z i 1 versus pop and ad . The relationships are strong. principal component Z 2 is a linear combination of the variables that is ucorrelated with Z 1 , and has largest variance subject to this constraint",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_36"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The relationships are strong. principal component Z 2 is a linear combination of the variables that is ucorrelated with Z 1 , and has largest variance subject to this constraint. The second principal component direction is illustrated as a dashed blue line in Figure 6.14 . It turns out that the zero correlation condition of Z 1 with Z 2 is equivalent to the condition that the direction must be perpendicular , or perpedicular orthogonal , to the first principal component direction. The second principal orthogonal component is given by the formula Z 2 = 0 . 544 × ( pop − pop ) − 0 . 839 × ( ad − ad ) . Since the advertising data has two predictors, the first two principal coponents contain all of the information that is in pop and ad . However, by construction, the first component will contain the most information. Cosider, for example, the much larger variability of z i 1 (the x -axis) versus z i 2 (the y -axis) in the right-hand panel of Figure 6.15 . The fact that the second principal component scores are much closer to zero indicates that this component captures far less information. As another illustration, Fiure 6.17 displays z i 2 versus pop and ad . There is little relationship between the second principal component and these two predictors, again suggesting that in this case, one only needs the first principal component in order to accurately represent the pop and ad budgets. With two-dimensional data, such as in our advertising example, we can construct at most two principal components. However, if we had other predictors, such as population age, income level, education, and so forth, then additional components could be constructed. They would successively maximize variance, subject to the constraint of being uncorrelated with the preceding components",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_37"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". They would successively maximize variance, subject to the constraint of being uncorrelated with the preceding components. The Principal Components Regression Approach The principal components regression (PCR) approach involves construcprincipal components regression ing the first M principal components, Z 1 , , Z M , and then using these components as the predictors in a linear regression model that is fit uing least squares. The key idea is that often a small number of principal components suffice to explain most of the variability in the data, as well as the relationship with the response. In other words, we assume that the −1.0 −0.5 0.0 0.5 1.0 20 30 40 50 60 2nd Principal Component Population −1.0 −0.5 0.0 0.5 1.0 5 10 15 20 25 30 2nd Principal Component Ad Spending FIGURE 6.17. Plots of the second principal component scores z i 2 versus pop and ad . The relationships are weak. 0 10 20 30 40 0 10 20 30 40 50 60 70 Number of Components Mean Squared Error 0 10 20 30 40 0 50 100 150 Number of Components Mean Squared Error Squared Bias Test MSE Variance FIGURE 6.18. PCR was applied to two simulated data sets. In each panel, the horizontal dashed line represents the irreducible error. Left: Simulated data from Figure 6.8 . Right: Simulated data from Figure 6.9 . directions in which X 1 , , X p show the most variation are the directions that are associated with Y . While this assumption is not guaranteed to be true, it often turns out to be a reasonable enough approximation to give good results. If the assumption underlying PCR holds, then fitting a least squares model to Z 1 , , Z M will lead to better results than fitting a least squares model to X 1 , , X p , since most or all of the information in the data that relates to the response is contained in Z 1 , , Z M , and by estimating only M ≪ p coefficients we can mitigate overfitting",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_38"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In the advertising data, the first principal component explains most of the variance in both pop and ad , so a principal component regression that uses this single variable to predict some response of interest, such as sales , will likely perform quite well. Figure 6.18 displays the PCR fits on the simulated data sets from Fiures 6.8 and 6.9 . Recall that both data sets were generated using n = 50 observations and p = 45 predictors. However, while the response in the first data set was a function of all the predictors, the response in the seond data set was generated using only two of the predictors. The curves are plotted as a function of M , the number of principal components used as predictors in the regression model. As more principal components are used 0 10 20 30 40 0 10 20 30 40 50 60 70 PCR Number of Components Mean Squared Error Squared Bias Test MSE Variance 0.0 0.2 0.4 0.6 0.8 1.0 0 10 20 30 40 50 60 70 Ridge Regression and Lasso Shrinkage Factor Mean Squared Error FIGURE 6.19. PCR, ridge regression, and the lasso were applied to a simlated data set in which the first five principal components of X contain all the information about the response Y . In each panel, the irreducible error Var( ε ) is shown as a horizontal dashed line. Left: Results for PCR. Right: Results for lasso (solid) and ridge regression (dotted). The x -axis displays the shrinkage factor of the coefficient estimates, defined as the l 2 norm of the shrunken coefficient estimates divided by the l 2 norm of the least squares estimate. in the regression model, the bias decreases, but the variance increases. This results in a typical U-shape for the mean squared error. When M = p = 45 , then PCR amounts simply to a least squares fit using all of the original predictors. The figure indicates that performing PCR with an appropriate choice of M can result in a substantial improvement over least squares, epecially in the left-hand panel",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_39"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The figure indicates that performing PCR with an appropriate choice of M can result in a substantial improvement over least squares, epecially in the left-hand panel. However, by examining the ridge regression and lasso results in Figures 6.5 , 6.8 , and 6.9 , we see that PCR does not perform as well as the two shrinkage methods in this example. The relatively worse performance of PCR in Figure 6.18 is a consequence of the fact that the data were generated in such a way that many princpal components are required in order to adequately model the response. In contrast, PCR will tend to do well in cases when the first few principal components are sufficient to capture most of the variation in the predictors as well as the relationship with the response. The left-hand panel of Fiure 6.19 illustrates the results from another simulated data set designed to be more favorable to PCR. Here the response was generated in such a way that it depends exclusively on the first five principal components. Now the bias drops to zero rapidly as M , the number of principal components used in PCR, increases. The mean squared error displays a clear minimum at M = 5 . The right-hand panel of Figure 6.19 displays the results on these data using ridge regression and the lasso. All three methods offer a signiicant improvement over least squares. However, PCR and ridge regression slightly outperform the lasso. We note that even though PCR provides a simple way to perform rgression using M < p predictors, it is not a feature selection method. This is because each of the M principal components used in the regression is a linear combination of all p of the original features. For instance, in ( 6.19 ), Z 1 was a linear combination of both pop and ad",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_40"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For instance, in ( 6.19 ), Z 1 was a linear combination of both pop and ad . Therefore, while PCR oten performs quite well in many practical settings, it does not result in the 2 4 6 8 10 −300 −100 0 100 200 300 400 Number of Components Standardized Coefficients Income Limit Rating Student 2 4 6 8 10 20000 40000 60000 80000 Number of Components Cross−Validation MSE FIGURE 6.20. Left: PCR standardized coefficient estimates on the Credit data set for different values of M . Right: The ten-fold cross-validation MSE obtained using PCR, as a function of M . development of a model that relies upon a small set of the original features. In this sense, PCR is more closely related to ridge regression than to the lasso. In fact, one can show that PCR and ridge regression are very closely related. One can even think of ridge regression as a continuous version of PCR! 8 In PCR, the number of principal components, M , is typically chosen by cross-validation. The results of applying PCR to the Credit data set are shown in Figure 6.20 ; the right-hand panel displays the cross-validation erors obtained, as a function of M . On these data, the lowest cross-validation error occurs when there are M = 10 components; this corresponds to amost no dimension reduction at all, since PCR with M = 11 is equivalent to simply performing least squares. When performing PCR, we generally recommend standardizing each prdictor, using ( 6.6 ), prior to generating the principal components. This stadardization ensures that all variables are on the same scale. In the absence of standardization, the high-variance variables will tend to play a larger role in the principal components obtained, and the scale on which the varables are measured will ultimately have an effect on the final PCR model. However, if the variables are all measured in the same units (say, kilograms, or inches), then one might choose not to standardize them",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_41"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, if the variables are all measured in the same units (say, kilograms, or inches), then one might choose not to standardize them. 6.3.2 Partial Least Squares The PCR approach that we just described involves identifying linear combnations, or directions , that best represent the predictors X 1 , , X p . These directions are identified in an unsupervised way, since the response Y is not used to help determine the principal component directions. That is, the response does not supervise the identification of the principal compnents. Consequently, PCR suffers from a drawback: there is no guarantee 8 More details can be found in Section 3.5 of The Elements of Statistical Learning by Hastie, Tibshirani, and Friedman. 20 30 40 50 60 5 10 15 20 25 30 Population Ad Spending FIGURE 6.21. For the advertising data, the first PLS direction (solid line) and first PCR direction (dotted line) are shown. that the directions that best explain the predictors will also be the best directions to use for predicting the response. Unsupervised methods are discussed further in Chapter 12 . We now present partial least squares (PLS), a supervised alternative to partial least squares PCR. Like PCR, PLS is a dimension reduction method, which first identifies a new set of features Z 1 , , Z M that are linear combinations of the original features, and then fits a linear model via least squares using these M new features. But unlike PCR, PLS identifies these new features in a supervised way—that is, it makes use of the response Y in order to identify new features that not only approximate the old features well, but also that are related to the response . Roughly speaking, the PLS approach attempts to find directions that help explain both the response and the predictors. We now describe how the first PLS direction is computed. After stadardizing the p predictors, PLS computes the first direction Z 1 by setting each φ j 1 in ( 6.16 ) equal to the coefficient from the simple linear regression of Y onto X j",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_42"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". After stadardizing the p predictors, PLS computes the first direction Z 1 by setting each φ j 1 in ( 6.16 ) equal to the coefficient from the simple linear regression of Y onto X j . One can show that this coefficient is proportional to the corelation between Y and X j . Hence, in computing Z 1 = ) p j =1 φ j 1 X j , PLS places the highest weight on the variables that are most strongly related to the response. Figure 6.21 displays an example of PLS on a synthetic dataset with Sales in each of 100 regions as the response, and two predictors; Population Size and Advertising Spending. The solid green line indicates the first PLS drection, while the dotted line shows the first principal component direction. PLS has chosen a direction that has less change in the ad dimension per unit change in the pop dimension, relative to PCA. This suggests that pop is more highly correlated with the response than is ad . The PLS direction does not fit the predictors as closely as does PCA, but it does a better job explaining the response. To identify the second PLS direction we first adjust each of the variables for Z 1 , by regressing each variable on Z 1 and taking residuals . These resiuals can be interpreted as the remaining information that has not been explained by the first PLS direction. We then compute Z 2 using this o thogonalized data in exactly the same fashion as Z 1 was computed based on the original data. This iterative approach can be repeated M times to identify multiple PLS components Z 1 , , Z M . Finally, at the end of this procedure, we use least squares to fit a linear model to predict Y using Z 1 , , Z M in exactly the same fashion as for PCR. As with PCR, the number M of partial least squares directions used in PLS is a tuning parameter that is typically chosen by cross-validation. We generally standardize the predictors and response before performing PLS. PLS is popular in the field of chemometrics, where many variables arise from digitized spectrometry signals",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_43"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We generally standardize the predictors and response before performing PLS. PLS is popular in the field of chemometrics, where many variables arise from digitized spectrometry signals. In practice it often performs no better than ridge regression or PCR. While the supervised dimension reduction of PLS can reduce bias, it also has the potential to increase variance, so that the overall benefit of PLS relative to PCR is a wash. 6.4 Considerations in High Dimensions 6.4.1 High-Dimensional Data Most traditional statistical techniques for regression and classification are intended for the low-dimensional setting in which n , the number of olodimensional servations, is much greater than p , the number of features. This is due in part to the fact that throughout most of the field’s history, the bulk of scentific problems requiring the use of statistics have been low-dimensional. For instance, consider the task of developing a model to predict a patient’s blood pressure on the basis of his or her age, sex, and body mass index (BMI). There are three predictors, or four if an intercept is included in the model, and perhaps several thousand patients for whom blood pressure and age, sex, and BMI are available. Hence n ≫ p , and so the problem is low-dimensional. (By dimension here we are referring to the size of p .) In the past 20 years, new technologies have changed the way that data are collected in fields as diverse as finance, marketing, and medicine. It is now commonplace to collect an almost unlimited number of feature mesurements ( p very large). While p can be extremely large, the number of observations n is often limited due to cost, sample availability, or other considerations. Two examples are as follows: 1. Rather than predicting blood pressure on the basis of just age, sex, and BMI, one might also collect measurements for half a million sigle nucleotide polymorphisms (SNPs; these are individual DNA mtations that are relatively common in the population) for inclusion in the predictive model",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_44"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Then n ≈ 200 and p ≈ 500 , 000 . 2. A marketing analyst interested in understanding people’s online shoping patterns could treat as features all of the search terms entered by users of a search engine. This is sometimes known as the “bag-owords” model. The same researcher might have access to the search histories of only a few hundred or a few thousand search engine users who have consented to share their information with the researcher. For a given user, each of the p search terms is scored present ( 0 ) or absent ( 1 ), creating a large binary feature vector. Then n ≈ 1 , 000 and p is much larger. Data sets containing more features than observations are often referred to as high-dimensional . Classical approaches such as least squares linear higdimensional regression are not appropriate in this setting. Many of the issues that arise in the analysis of high-dimensional data were discussed earlier in this book, since they apply also when n > p : these include the role of the bias-variance trade-off and the danger of overfitting. Though these issues are always relvant, they can become particularly important when the number of features is very large relative to the number of observations. We have defined the high-dimensional setting as the case where the nuber of features p is larger than the number of observations n . But the cosiderations that we will now discuss certainly also apply if p is slightly smaller than n , and are best always kept in mind when performing supevised learning. 6.4.2 What Goes Wrong in High Dimensions? In order to illustrate the need for extra care and specialized techniques for regression and classification when p > n , we begin by examining what can go wrong if we apply a statistical technique not intended for the higdimensional setting. For this purpose, we examine least squares regression. But the same concepts apply to logistic regression, linear discriminant anaysis, and other classical statistical approaches",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_45"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For this purpose, we examine least squares regression. But the same concepts apply to logistic regression, linear discriminant anaysis, and other classical statistical approaches. When the number of features p is as large as, or larger than, the number of observations n , least squares as described in Chapter 3 cannot (or rather, should not ) be performed. The reason is simple: regardless of whether or not there truly is a relationship between the features and the response, least squares will yield a set of coefficient estimates that result in a perfect fit to the data, such that the residuals are zero. An example is shown in Figure 6.22 with p = 1 feature (plus an intercept) in two cases: when there are 20 observations, and when there are only two observations. When there are 20 observations, n > p and the least squares regression line does not perfectly fit the data; instead, the regression line seeks to approximate the 20 observations as well as possible. On the other hand, when there are only two observations, then regardless of the values of those observations, the regression line will fit the data exactly. This is problematic because this perfect fit will almost certainly lead to overfitting of the data. In other words, though it is possible to perfectly fit the training data in the high-dimensional setting, the resulting linear model will perform extremely poorly on an independent test set, and therefore does not constitute a useful model. In fact, we can see that this happened in Figure 6.22 : the least squares line obtained in the right-hand panel will perform very poorly on a test set comprised of the observations in the lefhand panel. The problem is simple: when p > n or p ≈ n , a simple least squares regression line is too flexible and hence overfits the data. Figure 6.23 further illustrates the risk of carelessly applying least squares when the number of features p is large",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_46"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Figure 6.23 further illustrates the risk of carelessly applying least squares when the number of features p is large. Data were simulated with n = 20 observations, and regression was performed with between 1 and 20 features, −1.5 −1.0 −0.5 0.0 0.5 1.0 −10 −5 0 5 10 −1.5 −1.0 −0.5 0.0 0.5 1.0 −10 −5 0 5 10 X X Y Y FIGURE 6.22. Left: Least squares regression in the low-dimensional setting. Right: Least squares regression with n = 2 observations and two parameters to be estimated (an intercept and a coefficient). 5 10 15 0.2 0.4 0.6 0.8 1.0 Number of Variables R 2 5 10 15 0.0 0.2 0.4 0.6 0.8 Number of Variables Training MSE 5 10 15 1 5 50 500 Number of Variables Test MSE FIGURE 6.23. On a simulated example with n = 20 training observations, features that are completely unrelated to the outcome are added to the model. Left: The R 2 increases to 1 as more features are included. Center: The training set MSE decreases to 0 as more features are included. Right: The test set MSE increases as more features are included. each of which was completely unrelated to the response. As shown in the figure, the model R 2 increases to 1 as the number of features included in the model increases, and correspondingly the training set MSE decreases to 0 as the number of features increases, even though the features are completely unrelated to the response . On the other hand, the MSE on an independent test set becomes extremely large as the number of features included in the model increases, because including the additional predictors leads to a vast increase in the variance of the coefficient estimates. Looking at the test set MSE, it is clear that the best model contains at most a few variables. However, someone who carelessly examines only the R 2 or the training set MSE might erroneously conclude that the model with the greatest number of variables is best",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_47"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, someone who carelessly examines only the R 2 or the training set MSE might erroneously conclude that the model with the greatest number of variables is best. This indicates the importance of applying extra care when analyzing data sets with a large number of variables, and of always evaluating model performance on an independent test set. 1 16 21 0 1 2 3 4 5 1 28 51 0 1 2 3 4 5 1 70 111 0 1 2 3 4 5 p = 20 p = 50 p = 2000 Degrees of Freedom Degrees of Freedom Degrees of Freedom FIGURE 6.24. The lasso was performed with n = 100 observations and three values of p , the number of features. Of the p features, 20 were associated with the response. The boxplots show the test MSEs that result using three different values of the tuning parameter λ in ( 6.7 ). For ease of interpretation, rather than reporting λ , the degrees of freedom are reported; for the lasso this turns out to be simply the number of estimated non-zero coefficients. When p = 20 , the lowest test MSE was obtained with the smallest amount of regularization. When p = 50 , the lowest test MSE was achieved when there is a substantial amount of regularization. When p = 2 , 000 the lasso performed poorly regardless of the amount of regularization, due to the fact that only 20 of the 2,000 features truly are associated with the outcome. In Section 6.1.3 , we saw a number of approaches for adjusting the training set RSS or R 2 in order to account for the number of variables used to fit a least squares model. Unfortunately, the C p , AIC, and BIC approaches are not appropriate in the high-dimensional setting, because estimating ˆ σ 2 is problematic. (For instance, the formula for ˆ σ 2 from Chapter 3 yields an estimate ˆ σ 2 = 0 in this setting.) Similarly, problems arise in the application of adjusted R 2 in the high-dimensional setting, since one can easily obtain a model with an adjusted R 2 value of 1. Clearly, alternative approaches that are better-suited to the high-dimensional setting are required",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_48"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Clearly, alternative approaches that are better-suited to the high-dimensional setting are required. 6.4.3 Regression in High Dimensions It turns out that many of the methods seen in this chapter for fitting less flexible least squares models, such as forward stepwise selection, ridge regression, the lasso, and principal components regression, are particularly useful for performing regression in the high-dimensional setting. Essentially, these approaches avoid overfitting by using a less flexible fitting approach than least squares. Figure 6.24 illustrates the performance of the lasso in a simple simulated example. There are p = 20 , 50 , or 2 , 000 features, of which 20 are truly associated with the outcome. The lasso was performed on n = 100 training observations, and the mean squared error was evaluated on an independent test set. As the number of features increases, the test set error increases. When p = 20 , the lowest validation set error was achieved when λ in ( 6.7 ) was small; however, when p was larger then the lowest validation set error was achieved using a larger value of λ . In each boxplot, rather than reporting the values of λ used, the degrees of freedom of the resulting lasso solution is displayed; this is simply the number of non-zero coefficient estimates in the lasso solution, and is a measure of the flexibility of the lasso fit. Figure 6.24 highlights three important points: (1) regularization or shrinkage plays a key role in high-dimensional problems, (2) appropriate tuning parameter selection is crucial for good predictive performance, and (3) the test error tends to increase as the dimensionality of the problem (i.e. the number of features or predictors) increases, unless the additional features are truly associated with the response. The third point above is in fact a key principle in the analysis of higdimensional data, which is known as the curse of dimensionality",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_49"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The third point above is in fact a key principle in the analysis of higdimensional data, which is known as the curse of dimensionality . One might curse of dmensionality think that as the number of features used to fit a model increases, the quality of the fitted model will increase as well. However, comparing the left-hand and right-hand panels in Figure 6.24 , we see that this is not necessarily the case: in this example, the test set MSE almost doubles as p increases from 20 to 2,000. In general, adding additional signal features that are truly associated with the response will improve the fitted model , in the sense of leading to a reduction in test set error. However, adding noise features that are not truly associated with the response will lead to a deterioration in the fitted model, and consequently an increased test set error. This is because noise features increase the dimensionality of the problem, exacerbating the risk of overfitting (since noise features may be assigned nonzero coefficients due to chance associations with the response on the training set) without any potential upside in terms of improved test set error. Thus, we see that new technologies that allow for the collection of measurements for thousands or millions of features are a double-edged sword: they can lead to improved predictive models if these features are in fact relevant to the problem at hand, but will lead to worse results if the features are not relevant. Even if they are relevant, the variance incurred in fitting their coefficients may outweigh the reduction in bias that they bring. 6.4.4 Interpreting Results in High Dimensions When we perform the lasso, ridge regression, or other regression procdures in the high-dimensional setting, we must be quite cautious in the way that we report the results obtained. In Chapter 3 , we learned about multcollinearity , the concept that the variables in a regression might be corrlated with each other",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_50"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In Chapter 3 , we learned about multcollinearity , the concept that the variables in a regression might be corrlated with each other. In the high-dimensional setting, the multicollinearity problem is extreme: any variable in the model can be written as a linear combination of all of the other variables in the model. Essentially, this means that we can never know exactly which variables (if any) truly are predictive of the outcome, and we can never identify the best coefficients for use in the regression. At most, we can hope to assign large regression coefficients to variables that are correlated with the variables that truly are predictive of the outcome. For instance, suppose that we are trying to predict blood pressure on the basis of half a million SNPs, and that forward stepwise selection indicates that 17 of those SNPs lead to a good predictive model on the training data. It would be incorrect to conclude that these 17 SNPs predict blood pressure more effectively than the other SNPs not included in the model. There are likely to be many sets of 17 SNPs that would predict blood pressure just as well as the selected model. If we were to obtain an independent data set and perform forward stepwise selection on that data set, we would likely obtain a model containing a different, and perhaps even non-overlapping, set of SNPs. This does not detract from the value of the model obtained— for instance, the model might turn out to be very effective in predicting blood pressure on an independent set of patients, and might be clinically useful for physicians. But we must be careful not to overstate the results obtained, and to make it clear that what we have identified is simply one of many possible models for predicting blood pressure, and that it must be further validated on independent data sets. It is also important to be particularly careful in reporting errors and mesures of model fit in the high-dimensional setting. We have seen that when p > n , it is easy to obtain a useless model that has zero residuals",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_51"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We have seen that when p > n , it is easy to obtain a useless model that has zero residuals. Therfore, one should never use sum of squared errors, p-values, R 2 statistics, or other traditional measures of model fit on the training data as evidence of a good model fit in the high-dimensional setting. For instance, as we saw in Figure 6.23 , one can easily obtain a model with R 2 = 1 when p > n . Reporting this fact might mislead others into thinking that a statistically valid and useful model has been obtained, whereas in fact this provides absolutely no evidence of a compelling model. It is important to instead report results on an independent test set, or cross-validation errors. For instance, the MSE or R 2 on an independent test set is a valid measure of model fit, but the MSE on the training set certainly is not. 6.5 Lab: Linear Models and Regularization Methods In this lab we implement many of the techniques discussed in this chapter. We import some of our libraries at this top level. In [1]: import numpy as np import pandas as pd from matplotlib.pyplot import subplots from statsmodels.api import OLS import sklearn.model_selection as skm import sklearn.linear_model as skl from sklearn.preprocessing import StandardScaler from ISLP import load_data from ISLP.models import ModelSpec as MS from functools import partial We again collect the new imports needed for this lab. In [2]: from sklearn.pipeline import Pipeline from sklearn.decomposition import PCA from sklearn.cross_decomposition import PLSRegression from ISLP.models import \\ (Stepwise, sklearn_selected , sklearn_selection_path) !pip install l0bnb from l0bnb import fit_path We have installed the package l0bnb on the fly. Note the escaped !pip install — this is run as a separate system command. 6.5.1 Subset Selection Methods Here we implement methods that reduce the number of parameters in a model by restricting the model to a subset of the input variables. Forward Selection We will apply the forward-selection approach to the Hitters data",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_52"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Forward Selection We will apply the forward-selection approach to the Hitters data. We wish to predict a baseball player’s Salary on the basis of various statistics assciated with performance in the previous year. First of all, we note that the Salary variable is missing for some of the players. The np.isnan() function can be used to identify the missing onp.isnan() servations. It returns an array of the same shape as the input vector, with a True for any elements that are missing, and a False for non-missing eements. The sum() method can then be used to count all of the missing sum() elements. In [3]: Hitters = load_data( 'Hitters' ) np.isnan(Hitters[ 'Salary' ]).sum() Out[3]: 59 We see that Salary is missing for 59 players. The dropna() method of data frames removes all of the rows that have missing values in any variable (by default — see Hitters.dropna? ). In [4]: Hitters = Hitters.dropna(); Hitters.shape Out[4]: (263, 20) We first choose the best model using forward selection based on C p ( 6.2 ). This score is not built in as a metric to sklearn . We therefore define a function to compute it ourselves, and use it as a scorer. By default, sklearn tries to maximize a score, hence our scoring function computes the negative C p statistic. In [5]: def nCp(sigma2, estimator, X, Y): \"Negative Cp statistic\" n, p = X.shape Yhat = estimator.predict(X) RSS = np.sum((Y - Yhat)**2) return -(RSS + 2 * p * sigma2) / n We need to estimate the residual variance σ 2 , which is the first argument in our scoring function above. We will fit the biggest model, using all the variables, and estimate σ 2 based on its MSE. In [6]: design = MS(Hitters.columns.drop( 'Salary' )).fit(Hitters) Y = np.array(Hitters[ 'Salary' ]) X = design.transform(Hitters) sigma2 = OLS(Y,X).fit().scale The function sklearn_selected() expects a scorer with just three argments — the last three in the definition of nCp() above. We use the function partial() first seen in Section 5.3.3 to freeze the first argument with our estimate of σ 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_53"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We use the function partial() first seen in Section 5.3.3 to freeze the first argument with our estimate of σ 2 . In [7]: neg_Cp = partial(nCp, sigma2) We can now use neg_Cp() as a scorer for model selection. Along with a score we need to specify the search strategy. This is done through the object Stepwise() in the ISLP.models package. The method Stepwise.first_peak() runs forward stepwise until any further additions to the model do not result in an improvement in the evaluation score. Similarly, the method Stepwise.fixed_steps() runs a fixed number of steps of stepwise search. In [8]: strategy = Stepwise.first_peak(design, direction= 'forward' , max_terms=len(design.t e rm s )) We now fit a linear regression model with Salary as outcome using foward selection. To do so, we use the function sklearn_selected() from the sklearn_ selected() ISLP.models package. This takes a model from statsmodels along with a search strategy and selects a model with its fit method. Without specifing a scoring argument, the score defaults to MSE, and so all 19 variables will be selected (output not shown). In [9]: hitters_MSE = sklearn_selected(OLS, strategy) hitters_MSE.fit(Hitters, Y) hitters_MSE.selected_state_ Using neg_Cp results in a smaller model, as expected, with just 10 varables selected. In [10]: hitters_Cp = sklearn_selected(OLS, strategy, scoring=neg_Cp) hitters_Cp.fit(Hitters, Y) hitters_Cp.selected_state_ Out[10]: ( 'Assists' , 'AtBat' , 'CAtBat' , 'CRBI' , 'CRuns' , 'CWalks' , 'Division' , 'Hits' , 'PutOuts' , 'Walks' ) Choosing Among Models Using the Validation Set Approach and Cross-Validation As an alternative to using C p , we might try cross-validation to select a model in forward selection. For this, we need a method that stores the full path of models found in forward selection, and allows predictions for each of these. This can be done with the sklearn_selection_path() estimsklearn_ selection_ path() tor from ISLP.models",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_54"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This can be done with the sklearn_selection_path() estimsklearn_ selection_ path() tor from ISLP.models . The function cross_val_predict() from ISLP.models cross_val_ predict() computes the cross-validated predictions for each of the models along the path, which we can use to evaluate the cross-validated MSE along the path. Here we define a strategy that fits the full forward selection path. While there are various parameter choices for sklearn_selection_path() , we use the defaults here, which selects the model at each step based on the biggest reduction in RSS. In [11]: strategy = Stepwise.fixed_steps(design, len(design.terms), direction= 'forward' ) full_path = sklearn_selection_path(OLS, strategy) We now fit the full forward-selection path on the Hitters data and copute the fitted values. In [12]: full_path.fit(Hitters, Y) Yhat_in = full_path.predict(Hitters) Yhat_in.shape Out[12]: (263, 20) This gives us an array of fitted values — 20 steps in all, including the fitted mean for the null model — which we can use to evaluate in-sample MSE. As expected, the in-sample MSE improves each step we take, indicaing we must use either the validation or cross-validation approach to select the number of steps. We fix the y-axis to range from 50,000 to 250,000 to compare to the cross-validation and validation set MSE below, as well as other methods such as ridge regression, lasso and principal components regression. In [13]: mse_fig, ax = subplots(figsize=(8,8)) insample_mse = ((Yhat_in - Y[:,None])**2).mean(0) n_steps = insample_mse.shape[0] ax.plot(np.arange(n_steps), insample_mse , 'k' , # color black label= 'In-sample' ) ax.set_ylabel( 'MSE' , fontsize=20) ax.set_xlabel( '# steps of forward stepwise' , fontsize=20) ax.set_xticks(np.arange(n_steps)[::2]) ax.legend() ax.set_ylim([50000,250000]); Notice the expression None in Y[:,None] above. This adds an axis (dimesion) to the one-dimensional array Y , which allows it to be recycled when subtracted from the two-dimensional Yhat_in",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_55"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This adds an axis (dimesion) to the one-dimensional array Y , which allows it to be recycled when subtracted from the two-dimensional Yhat_in . We are now ready to use cross-validation to estimate test error along the model path. We must use only the training observations to perform all aspects of model-fitting — including variable selection. Therefore, the determination of which model of a given size is best must be made using only the training observations in each training fold. This point is subtle but important. If the full data set is used to select the best subset at each step, then the validation set errors and cross-validation errors that we obtain will not be accurate estimates of the test error. We now compute the cross-validated predicted values using 5-fold crosvalidation. In [14]: K = 5 kfold = skm.KFold(K, random_state=0, shuffle=True) Yhat_cv = skm.cross_val_predict(full_path, Hitters, Y, cv=kfold) Yhat_cv.shape skm.KFold() skm.cross_ val_predict() Out[14]: (263, 20) The prediction matrix Yhat_cv is the same shape as Yhat_in ; the difference is that the predictions in each row, corresponding to a particular sample index, were made from models fit on a training fold that did not include that row. At each model along the path, we compute the MSE in each of the crosvalidation folds. These we will average to get the mean MSE, and can also use the individual values to compute a crude estimate of the standard error of the mean. 9 Hence we must know the test indices for each cross-validation split. This can be found by using the split() method of kfold . Because we fixed the random state above, whenever we split any array with the same number of rows as Y we recover the same training and test indices, though we simply ignore the training indices below",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_56"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [15]: cv_mse = [] for train_idx, test_idx in kfold.split(Y): errors = (Yhat_cv[test_idx] - Y[test_idx,None])**2 cv_mse.append(errors.mean(0)) # column means cv_mse = np.array(cv_mse).T cv_mse.shape Out[15]: (20, 5) 9 The estimate is crude because the five error estimates are based on overlapping training sets, and hence are not independent. We now add the cross-validation error estimates to our MSE plot. We include the mean error across the five folds, and the estimate of the standard error of the mean. In [16]: ax.errorbar(np.arange(n_steps), cv_mse.mean(1), cv_mse.std(1) / np.sqrt(K), label= 'Cross-validated' , c= 'r' ) # color red ax.set_ylim([50000,250000]) ax.legend() mse_fig To repeat the above using the validation set approach, we simply change our cv argument to a validation set: one random split of the data into a test and training. We choose a test size of 20%, similar to the size of each test set in 5-fold cross-validation. skm.Shuffle Split() In [17]: validation = skm.ShuffleSplit(n_splits=1, test_size=0.2, random_state=0) for train_idx, test_idx in validation.split(Y): full_path.fit(Hitters.iloc[train_idx], Y[train_idx]) Yhat_val = full_path.predict(Hitters.iloc[test_idx]) errors = (Yhat_val - Y[test_idx,None])**2 validation_mse = errors.mean(0) As for the in-sample MSE case, the validation set approach does not provide standard errors. In [18]: ax.plot(np.arange(n_steps), validation_mse , 'b--' , # color blue, broken line label= 'Validation' ) ax.set_xticks(np.arange(n_steps)[::2]) ax.set_ylim([50000,250000]) ax.legend() mse_fig Best Subset Selection Forward stepwise is a greedy selection procedure; at each step it augments the current set by including one additional variable. We now apply best subset selection to the Hitters data, which for every subset size, searches for the best set of predictors. We will use a package called l0bnb to perform best subset selection",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_57"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We now apply best subset selection to the Hitters data, which for every subset size, searches for the best set of predictors. We will use a package called l0bnb to perform best subset selection. Instead of constraining the subset to be a given size, this package produces a path of solutions using the subset size as a penalty rather than a constraint. Although the distinction is subtle, the difference comes when we crosvalidate. In [19]: D = design.fit_transform(Hitters) D = D.drop( 'intercept' , axis=1) X = np.asarray(D) Here we excluded the first column corresponding to the intercept, as l0bnb will fit the intercept separately. We can find a path using the fit_path() function. In [20]: path = fit_path(X, Y, max_nonzeros=X.shape[1]) The function fit_path() returns a list whose values include the fitted coefficients as B , an intercept as B0 , as well as a few other attributes related to the particular path algorithm used. Such details are beyond the scope of this book. In [21]: path[3] Out[21]: { 'B' : array([0. , 3.254844, 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0.677753 , 0. , 0. , 0. , 0. , 0. , 0. , 0. ]), 'B0' : -38.98216739555494, 'lambda_0' : 0.011416248027450194, 'M' : 0.5829861733382011, 'Time_exceeded' : False} In the example above, we see that at the fourth step in the path, we have two nonzero coefficients in 'B' , corresponding to the value 0 . 114 for the penalty parameter lambda_0 . We could make predictions using this sequence of fits on a validation set as a function of lambda_0 , or with more work using cross-validation. 6.5.2 Ridge Regression and the Lasso We will use the sklearn.linear_model package (for which we use skl as shorthand below) to fit ridge and lasso regularized linear models on the Hitters data. We start with the model matrix X (without an intercept) that we computed in the previous section on best subset regression. Ridge Regression We will use the function skl.ElasticNet() to fit both ridge and the lasso",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_58"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Ridge Regression We will use the function skl.ElasticNet() to fit both ridge and the lasso. To skl.Elastic Net() fit a path of ridge regressions models, we use skl.ElasticNet.path() , which skl.Elastic Net.path() can fit both ridge and lasso, as well as a hybrid mixture; ridge regression corresponds to l1_ratio=0 . It is good practice to standardize the columns of X in these applications, if the variables are measured in different units. Since skl.ElasticNet() does no normalization, we have to take care of that ourselves. Since we standardize first, in order to find coefficient estimates on the original scale, we must unstandardize the coefficient estimates. The parameter λ in ( 6.5 ) and ( 6.7 ) is called alphas in sklearn . In order to be consistent with the rest of this chapter, we use lambdas rather than alphas in what follows. 10 10 At the time of publication, ridge fits like the one in code chunk [22] issue unwarranted convergence warning messages; we expect these to disappear as this package matures. In [22]: Xs = X - X.mean(0)[None,:] X_scale = X.std(0) Xs = Xs / X_scale[None,:] lambdas = 10**np.linspace(8, -2, 100) / Y.std() soln_array = skl.ElasticNet.path(Xs, Y, l1_ratio=0., alphas=lambdas)[1] soln_array.shape Out[22]: (19, 100) Here we extract the array of coefficients corresponding to the solutions along the regularization path. By default the skl.ElasticNet.path method fits a path along an automatically selected range of λ values, except for the case when l1_ratio=0 , which results in ridge regression (as is the case here). 11 So here we have chosen to implement the function over a grid of values ranging from λ = 10 8 to λ = 10 − 2 scaled by the standard deviation of y , essentially covering the full range of scenarios from the null model containing only the intercept, to the least squares fit. Associated with each value of λ is a vector of ridge regression coefficients, that can be accessed by a column of soln_array",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_59"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Associated with each value of λ is a vector of ridge regression coefficients, that can be accessed by a column of soln_array . In this case, soln_array is a 19 × 100 matrix, with 19 rows (one for each predictor) and 100 columns (one for each value of λ ). We transpose this matrix and turn it into a data frame to facilitate viewing and plotting. In [23]: soln_path = pd.DataFrame(soln_array.T, columns=D.columns, index=-np.log(lambdas)) soln_path.index.name = 'negative log(lambda)' soln_path Out[23]: AtBat Hits HmRun Runs negative log(lambda) -12.310855 0.000800 0.000889 0.000695 0.000851 -12.078271 0.001010 0.001122 0.000878 0.001074 -11.845686 0.001274 0.001416 0.001107 0.001355 -11.613102 0.001608 0.001787 0.001397 0.001710 -11.380518 0.002029 0.002255 0.001763 0.002158 100 rows × 19 columns We plot the paths to get a sense of how the coefficients vary with λ . To control the location of the legend we first set legend to False in the plot method, adding it afterward with the legend() method of ax . In [24]: path_fig, ax = subplots(figsize=(8,8)) soln_path.plot(ax=ax, legend=False) ax.set_xlabel( '$-\\log(\\lambda)$' , fontsize=20) 11 The reason is rather technical; for all models except ridge, we can find the smallest value of λ for which all coefficients are zero. For ridge this value is ∞ . ax.set_ylabel( 'Standardized coefficients' , fontsize=20) ax.legend(loc= 'upper left' ); (We have used latex formatting in the horizontal label, in order to format the Greek λ appropriately.) We expect the coefficient estimates to be much smaller, in terms of l 2 norm, when a large value of λ is used, as compared to when a small value of λ is used. (Recall that the l 2 norm is the square root of the sum of squared coefficient values.) We display the coefficients at the 40 th step, where λ is 25.535",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_60"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (Recall that the l 2 norm is the square root of the sum of squared coefficient values.) We display the coefficients at the 40 th step, where λ is 25.535. In [25]: beta_hat = soln_path.loc[soln_path.index[39]] lambdas[39], beta_hat Out[25]: (25.535, AtBat 5.433750 Hits 6.223582 HmRun 4.585498 Runs 5.880855 RBI 6.195921 Walks 6.277975 Years 5.299767 Let’s compute the l 2 norm of the standardized coefficients. In [26]: np.linalg.norm(beta_hat) Out[26]: 24.17 In contrast, here is the l 2 norm when λ is 2.44e-01. Note the much larger l 2 norm of the coefficients associated with this smaller value of λ . In [27]: beta_hat = soln_path.loc[soln_path.index[59]] lambdas[59], np.linalg.norm(beta_hat) Out[27]: (0.2437, 160.4237) Above we normalized X upfront, and fit the ridge model using Xs . The Pipeline() object in sklearn provides a clear way to separate feature nomalization from the fitting of the ridge model itself. In [28]: ridge = skl.ElasticNet(alpha=lambdas[59], l1_ratio=0) scaler = StandardScaler(with_mean=True, with_std=True) pipe = Pipeline(steps=[( 'scaler' , scaler), ( 'ridge' , ridge)]) pipe.fit(X, Y) We show that it gives the same l 2 norm as in our previous fit on the standardized data. In [29]: np.linalg.norm(ridge.coef_) Out[29]: 160.4237 Notice that the operation pipe.fit(X, Y) above has changed the ridge object, and in particular has added attributes such as coef_ that were not there before. Estimating Test Error of Ridge Regression Choosing an a priori value of λ for ridge regression is difficult if not ipossible. We will want to use the validation method or cross-validation to select the tuning parameter. The reader may not be surprised that the Pipeline() approach can be used in skm.cross_validate() with either a validation method (i.e. validation ) or k -fold cross-validation. We fix the random state of the splitter so that the results obtained will be reproducible",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_61"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". validation ) or k -fold cross-validation. We fix the random state of the splitter so that the results obtained will be reproducible. In [30]: validation = skm.ShuffleSplit(n_splits=1, test_size=0.5, random_state=0) ridge.alpha = 0.01 results = skm.cross_validate(ridge, X, Y, scoring= 'neg_mean_squared_error' , cv=validation) -results[ 'test_score' ] Out[30]: array([134214.0]) The test MSE is 1.342e+05. Note that if we had instead simply fit a model with just an intercept, we would have predicted each test observation using the mean of the training observations. We can get the same result by fitting a ridge regression model with a very large value of λ . Note that 1e10 means 10 10 . In [31]: ridge.alpha = 1e10 results = skm.cross_validate(ridge, X, Y, scoring= 'neg_mean_squared_error' , cv=validation) -results[ 'test_score' ] Out[31]: array([231788.32]) Obviously choosing λ = 0 . 01 is arbitrary, so we will use cross-validation or the validation-set approach to choose the tuning parameter λ . The object GridSearchCV() allows exhaustive grid search to choose such a parameter. Grid SearchCV() We first use the validation set method to choose λ . In [32]: param_grid = { 'ridge__alpha' : lambdas} grid = skm.GridSearchCV(pipe, param_grid , cv=validation, scoring= 'neg_mean_squared_error' ) grid.fit(X, Y) grid.best_params_[ 'ridge__alpha' ] grid.best_estimator_ Out[32]: Pipeline(steps=[( 'scaler' , StandardScaler()), ( 'ridge' , ElasticNet(alpha=0.005899, l1_ratio=0))]) Alternatively, we can use 5-fold cross-validation. In [33]: grid = skm.GridSearchCV(pipe, param_grid, cv=kfold, scoring= 'neg_mean_squared_error' ) grid.fit(X, Y) grid.best_params_[ 'ridge__alpha' ] grid.best_estimator_ Recall we set up the kfold object for 5-fold cross-validation on page 271 . We now plot the cross-validated MSE as a function of − log( λ ) , which has shrinkage decreasing from left to right",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_62"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We now plot the cross-validated MSE as a function of − log( λ ) , which has shrinkage decreasing from left to right. In [34]: ridge_fig, ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(lambdas), -grid.cv_results_[ 'mean_test_score' ], yerr=grid.cv_results_[ 'std_test_score' ] / np.sqrt(K)) ax.set_ylim([50000,250000]) ax.set_xlabel( '$-\\log(\\lambda)$' , fontsize=20) ax.set_ylabel( 'Cross-validated MSE' , fontsize=20); One can cross-validate different metrics to choose a parameter. The dfault metric for skl.ElasticNet() is test R 2 . Let’s compare R 2 to MSE for cross-validation here. In [35]: grid_r2 = skm.GridSearchCV(pipe, param_grid , cv=kfold) grid_r2.fit(X, Y) Finally, let’s plot the results for cross-validated R 2 . In [36]: r2_fig, ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(lambdas), grid_r2.cv_results_[ 'mean_test_score' ], yerr=grid_r2.cv_results_[ 'std_test_score' ] / np.sqrt(K) ) ax.set_xlabel( '$-\\log(\\lambda)$' , fontsize=20) ax.set_ylabel( 'Cross-validated $R^2$' , fontsize=20); Fast Cross-Validation for Solution Paths The ridge, lasso, and elastic net can be efficiently fit along a sequence of λ values, creating what is known as a solution path or regularization path . Hence there is specialized code to fit such paths, and to choose a suitable value of λ using cross-validation. Even with identical splits the results will not agree exactly with our grid above because the standardization of each feature in grid is carried out on each fold, while in pipeCV below it is carried out only once. Nevertheless, the results are similar as the normalization is relatively stable across folds. In [37]: ridgeCV = skl.ElasticNetCV(alphas=lambdas, l1_ratio=0, cv=kfold) pipeCV = Pipeline(steps=[( 'scaler' , scaler), ( 'ridge' , ridgeCV)]) pipeCV.fit(X, Y) Let’s produce a plot again of the cross-validation error to see that it is similar to using skm.GridSearchCV",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_63"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [38]: tuned_ridge = pipeCV.named_steps[ 'ridge' ] ridgeCV_fig , ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(lambdas), tuned_ridge.mse_path_.mean(1), yerr=tuned_ridge.mse_path_.std(1) / np.sqrt(K)) ax.axvline(-np.log(tuned_ridge.alpha_), c= 'k' , ls= '--' ) ax.set_ylim([50000,250000]) ax.set_xlabel( '$-\\log(\\lambda)$' , fontsize=20) ax.set_ylabel( 'Cross-validated MSE' , fontsize=20); We see that the value of λ that results in the smallest cross-validation error is 1.19e-02, available as the value tuned_ridge.alpha_ . What is the test MSE associated with this value of λ ? In [39]: np.min(tuned_ridge.mse_path_.mean(1)) Out[39]: 115526.71 This represents a further improvement over the test MSE that we got using λ = 4 . Finally, tuned_ridge.coef_ has the coefficients fit on the entire data set at this value of λ . In [40]: tuned_ridge.coef_ Out[40]: array([-222.80877051, 238.77246614, 3.21103754, -2.93050845, 3.64888723, 108.90953869, -50.81896152, -105.15731984, 122.00714801, 57.1859509 , 210.35170348, 118.05683748, -150.21959435, 30.36634231, -61.62459095, 77.73832472, 40.07350744, -25.02151514, -13.68429544]) As expected, none of the coefficients are zero—ridge regression does not perform variable selection! Evaluating Test Error of Cross-Validated Ridge Choosing λ using cross-validation provides a single regression estimator, similar to fitting a linear regression model as we saw in Chapter 3 . It is therefore reasonable to estimate what its test error is. We run into a prolem here in that cross-validation will have touched all of its data in choosing λ , hence we have no further data to estimate test error. A compromise is to do an initial split of the data into two disjoint sets: a training set and a test set. We then fit a cross-validation tuned ridge regression on the traiing set, and evaluate its performance on the test set. We might call this cross-validation nested within the validation set approach. A priori there is no reason to use half of the data for each of the two sets in validation",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_64"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We might call this cross-validation nested within the validation set approach. A priori there is no reason to use half of the data for each of the two sets in validation. Below, we use 75% for training and 25% for test, with the estimator being ridge regression tuned using 5-fold cross-validation. This can be achieved in code as follows: In [41]: outer_valid = skm.ShuffleSplit(n_splits=1, test_size=0.25, random_state=1) inner_cv = skm.KFold(n_splits=5, shuffle=True, random_state=2) ridgeCV = skl.ElasticNetCV(alphas=lambdas, l1_ratio=0, cv=inner_cv) pipeCV = Pipeline(steps=[( 'scaler' , scaler), ( 'ridge' , ridgeCV)]); In [42]: results = skm.cross_validate(pipeCV, X, Y, cv=outer_valid , scoring= 'neg_mean_squared_error' ) -results[ 'test_score' ] Out[42]: array([132393.84]) The Lasso We saw that ridge regression with a wise choice of λ can outperform least squares as well as the null model on the Hitters data set. We now ask whether the lasso can yield either a more accurate or a more interpretable model than ridge regression. In order to fit a lasso model, we once again use the ElasticNetCV() function; however, this time we use the argument l1_ratio=1 . Other than that change, we proceed just as we did in fitting a ridge model. In [43]: lassoCV = skl.ElasticNetCV(n_alphas=100, l1_ratio=1, cv=kfold) pipeCV = Pipeline(steps=[( 'scaler' , scaler), ( 'lasso' , lassoCV)]) pipeCV.fit(X, Y) tuned_lasso = pipeCV.named_steps[ 'lasso' ] tuned_lasso.alpha_ Out[43]: 3.147 In [44]: lambdas, soln_array = skl.Lasso.path(Xs, Y, l1_ratio=1, n_alphas=100)[:2] soln_path = pd.DataFrame(soln_array.T, columns=D.columns, i ndex=-np. log(lambdas)) We can see from the coefficient plot of the standardized coefficients that depending on the choice of tuning parameter, some of the coefficients will be exactly equal to zero",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_65"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". log(lambdas)) We can see from the coefficient plot of the standardized coefficients that depending on the choice of tuning parameter, some of the coefficients will be exactly equal to zero. In [45]: path_fig, ax = subplots(figsize=(8,8)) soln_path.plot(ax=ax, legend=False) ax.legend(loc= 'upper left' ) ax.set_xlabel( '$-\\log(\\lambda)$' , fontsize=20) ax.set_ylabel( 'Standardized coefficiients' , fontsize=20); The smallest cross-validated error is lower than the test set MSE of the null model and of least squares, and very similar to the test MSE of 115526.71 of ridge regression (page 278 ) with λ chosen by cross-validation. In [46]: np.min(tuned_lasso.mse_path_.mean(1)) Out[46]: 114690.73 Let’s again produce a plot of the cross-validation error. In [47]: lassoCV_fig , ax = subplots(figsize=(8,8)) ax.errorbar(-np.log(tuned_lasso.alphas_), tuned_lasso.mse_path_.mean(1), yerr=tuned_lasso.mse_path_.std(1) / np.sqrt(K)) ax.axvline(-np.log(tuned_lasso.alpha_), c= 'k' , ls= '--' ) ax.set_ylim([50000,250000]) ax.set_xlabel( '$-\\log(\\lambda)$' , fontsize=20) ax.set_ylabel( 'Cross-validated MS E ' , fontsize=20); However, the lasso has a substantial advantage over ridge regression in that the resulting coefficient estimates are sparse. Here we see that 6 of the 19 coefficient estimates are exactly zero. So the lasso model with λ chosen by cross-validation contains only 13 variables. In [48]: tuned_lasso.coef_ Out[48]: array([-210.01008773, 243.4550306 , 0. , 0. , 0. , 97.69397357, -41.52283116, -0. , 0. , 39.62298193, 205.75273856, 124.55456561, -126.29986768, 15.70262427, -59.50157967, 75.24590036, 21.62698014, -12.04423675, -0. ]) As in ridge regression, we could evaluate the test error of cross-validated lasso by first splitting into test and training sets and internally running cross-validation on the training set. We leave this as an exercise. 6.5.3 PCR and PLS Regression Principal Components Regression Principal components regression (PCR) can be performed using PCA() from PCA() the sklearn.decomposition module",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_66"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 6.5.3 PCR and PLS Regression Principal Components Regression Principal components regression (PCR) can be performed using PCA() from PCA() the sklearn.decomposition module. We now apply PCR to the Hitters data, in order to predict Salary . Again, ensure that the missing values have been removed from the data, as described in Section 6.5.1 . We use LinearRegression() to fit the regression model here. Note that Linear Regression() it fits an intercept by default, unlike the OLS() function seen earlier in Section 6.5.1 . In [49]: pca = PCA(n_components=2) linreg = skl.LinearRegression() pipe = Pipeline([( 'pca' , pca), ( 'linreg' , linreg)]) pipe.fit(X, Y) pipe.named_steps[ 'linreg' ].coef_ Out[49]: array([0.09846131, 0.4758765 ]) When performing PCA, the results vary depending on whether the data has been standardized or not. As in the earlier examples, this can be acomplished by including an additional step in the pipeline. In [50]: pipe = Pipeline([( 'scaler' , scaler), ( 'pca' , pca), ( 'linreg' , linreg)]) pipe.fit(X, Y) pipe.named_steps[ 'linreg' ].coef_ Out[50]: array([106.36859204, -21.60350456]) We can of course use CV to choose the number of components, by using skm.GridSearchCV , in this case fixing the parameters to vary the n_components . In [51]: param_grid = { 'pca__n_components' : range(1, 20)} grid = skm.GridSearchCV(pipe, param_grid , cv=kfold, scoring= 'neg_mean_squared_error' ) grid.fit(X, Y) Let’s plot the results as we have for other methods. In [52]: pcr_fig, ax = subplots(figsize=(8,8)) n_comp = param_grid[ 'pca__n_components' ] ax.errorbar(n_comp, -grid.cv_results_[ 'mean_test_score' ], grid.cv_results_[ 'std_test_score' ] / np.sqrt(K)) ax.set_ylabel( 'Cross-validated MSE' , fontsize=20) ax.set_xlabel( '# principal components' , fontsize=20) ax.set_xticks(n_comp[::2]) ax.set_ylim([50000,250000]); We see that the smallest cross-validation error occurs when 17 compnents are used",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_67"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, from the plot we also see that the cross-validation error is roughly the same when only one component is included in the model. This suggests that a model that uses just a small number of coponents might suffice. The CV score is provided for each possible number of components from 1 to 19 inclusive. The PCA() method complains if we try to fit an intercept only with n_components=0 so we also compute the MSE for just the null model with these splits. In [53]: Xn = np.zeros((X.shape[0], 1)) cv_null = skm.cross_validate(linreg, Xn, Y, cv=kfold, scoring= 'neg_mean_squared_error' ) -cv_null[ 'test_score' ].mean() Out[53]: 204139.31 The explained_variance_ratio_ attribute of our PCA object provides the percentage of variance explained in the predictors and in the response using different numbers of components. This concept is discussed in greater detail in Section 12.2 . In [54]: pipe.named_steps[ 'pca' ].explained_variance_ratio_ Out[54]: array([0.3831424 , 0.21841076]) Briefly, we can think of this as the amount of information about the preditors that is captured using M principal components. For example, setting M = 1 only captures 38.31% of the variance, while M = 2 captures an aditional 21.84%, for a total of 60.15% of the variance. By M = 6 it increases to 88.63%. Beyond this the increments continue to diminish, until we use all M = p = 19 components, which captures all 100% of the variance. Partial Least Squares Partial least squares (PLS) is implemented in the PLSRegression() function. PLS Regression() In [55]: pls = PLSRegression(n_components=2, scale=True) pls.fit(X, Y) As was the case in PCR, we will want to use CV to choose the number of components. In [56]: param_grid = { 'n_components' :range(1, 20)} grid = skm.GridSearchCV(pls, param_grid, cv=kfold, scoring= 'neg_mean_squared_error' ) grid.fit(X, Y) As for our other methods, we plot the MSE",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_68"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [56]: param_grid = { 'n_components' :range(1, 20)} grid = skm.GridSearchCV(pls, param_grid, cv=kfold, scoring= 'neg_mean_squared_error' ) grid.fit(X, Y) As for our other methods, we plot the MSE. In [57]: pls_fig, ax = subplots(figsize=(8,8)) n_comp = param_grid[ 'n_components' ] ax.errorbar(n_comp, -grid.cv_results_[ 'mean_test_score' ], grid.cv_results_[ 'std_test_score' ] / np.sqrt(K)) ax.set_ylabel( 'Cross-validated MSE' , fontsize=20) ax.set_xlabel( '# principal components' , fontsize=20) ax.set_xticks(n_comp[::2]) ax.set_ylim([50000,250000]); CV error is minimized at 12, though there is little noticable difference between this point and a much lower number like 2 or 3 components. 6.6 Exercises Conceptual 1. We perform best subset, forward stepwise, and backward stepwise selection on a single data set. For each approach, we obtain p + 1 models, containing 0 , 1 , 2 , , p predictors. Explain your answers: (a) Which of the three models with k predictors has the smallest training RSS? (b) Which of the three models with k predictors has the smallest test RSS? (c) True or False: i. The predictors in the k -variable model identified by forward stepwise are a subset of the predictors in the ( k +1) -variable model identified by forward stepwise selection. ii. The predictors in the k -variable model identified by bacward stepwise are a subset of the predictors in the ( k + 1) - variable model identified by backward stepwise selection. iii. The predictors in the k -variable model identified by bacward stepwise are a subset of the predictors in the ( k + 1) - variable model identified by forward stepwise selection. iv. The predictors in the k -variable model identified by forward stepwise are a subset of the predictors in the ( k +1) -variable model identified by backward stepwise selection. v. The predictors in the k -variable model identified by best subset are a subset of the predictors in the ( k + 1) -variable model identified by best subset selection. 2. For parts (a) through (c), indicate which of i",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_69"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 2. For parts (a) through (c), indicate which of i. through iv. is correct. Justify your answer. (a) The lasso, relative to least squares, is: i. More flexible and hence will give improved prediction acuracy when its increase in bias is less than its decrease in variance. ii. More flexible and hence will give improved prediction accracy when its increase in variance is less than its decrease in bias. iii. Less flexible and hence will give improved prediction accracy when its increase in bias is less than its decrease in variance. iv. Less flexible and hence will give improved prediction accracy when its increase in variance is less than its decrease in bias. (b) Repeat (a) for ridge regression relative to least squares. (c) Repeat (a) for non-linear methods relative to least squares. 3. Suppose we estimate the regression coefficients in a linear regression model by minimizing n 0 i =1   y i − β 0 − p 0 j =1 β j x ij   2 subject to p 0 j =1 | β j | ≤ s for a particular value of s . For parts (a) through (e), indicate which of i. through v. is correct. Justify your answer. (a) As we increase s from 0, the training RSS will: i. Increase initially, and then eventually start decreasing in an inverted U shape. ii. Decrease initially, and then eventually start increasing in a U shape. iii. Steadily increase. iv. Steadily decrease. v. Remain constant. (b) Repeat (a) for test RSS. (c) Repeat (a) for variance. (d) Repeat (a) for (squared) bias. (e) Repeat (a) for the irreducible error. 4. Suppose we estimate the regression coefficients in a linear regression model by minimizing n 0 i =1   y i − β 0 − p 0 j =1 β j x ij   2 + λ p 0 j =1 β 2 j for a particular value of λ . For parts (a) through (e), indicate which of i. through v. is correct. Justify your answer. (a) As we increase λ from 0, the training RSS will: i. Increase initially, and then eventually start decreasing in an inverted U shape. ii. Decrease initially, and then eventually start increasing in a U shape. iii. Steadily increase. iv. Steadily decrease",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_70"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". ii. Decrease initially, and then eventually start increasing in a U shape. iii. Steadily increase. iv. Steadily decrease. v. Remain constant. (b) Repeat (a) for test RSS. (c) Repeat (a) for variance. (d) Repeat (a) for (squared) bias. (e) Repeat (a) for the irreducible error. 5. It is well-known that ridge regression tends to give similar coefficient values to correlated variables, whereas the lasso may give quite diferent coefficient values to correlated variables. We will now explore this property in a very simple setting. Suppose that n = 2 , p = 2 , x 11 = x 12 , x 21 = x 22 . Furthermore, suppose that y 1 + y 2 = 0 and x 11 + x 21 = 0 and x 12 + x 22 = 0 , so that the estimate for the intercept in a least squares, ridge regression, or lasso model is zero: ˆ β 0 = 0 . (a) Write out the ridge regression optimization problem in this seting. (b) Argue that in this setting, the ridge coefficient estimates satisfy ˆ β 1 = ˆ β 2 . (c) Write out the lasso optimization problem in this setting. (d) Argue that in this setting, the lasso coefficients ˆ β 1 and ˆ β 2 are not unique—in other words, there are many possible solutions to the optimization problem in (c). Describe these solutions. 6. We will now explore ( 6.12 ) and ( 6.13 ) further. (a) Consider ( 6.12 ) with p = 1 . For some choice of y 1 and λ > 0 , plot (6.12) as a function of β 1 . Your plot should confirm that ( 6.12 ) is solved by ( 6.14 ). (b) Consider ( 6.13 ) with p = 1 . For some choice of y 1 and λ > 0 , plot (6.13) as a function of β 1 . Your plot should confirm that ( 6.13 ) is solved by ( 6.15 ). 7. We will now derive the Bayesian connection to the lasso and ridge regression discussed in Section 6.2.2 . (a) Suppose that y i = β 0 + ) p j =1 x ij β j + ε i where ε 1 , , ε n are indpendent and identically distributed from a N (0 , σ 2 ) distribution. Write out the likelihood for the data",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_71"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (a) Suppose that y i = β 0 + ) p j =1 x ij β j + ε i where ε 1 , , ε n are indpendent and identically distributed from a N (0 , σ 2 ) distribution. Write out the likelihood for the data. (b) Assume the following prior for β : β 1 , , β p are independent and identically distributed according to a double-exponential distribution with mean 0 and common scale parameter b : i.e. p ( β ) = 1 2 b exp( −| β | /b ) . Write out the posterior for β in this setting. (c) Argue that the lasso estimate is the mode for β under this poterior distribution. (d) Now assume the following prior for β : β 1 , , β p are independent and identically distributed according to a normal distribution with mean zero and variance c . Write out the posterior for β in this setting. (e) Argue that the ridge regression estimate is both the mode and the mean for β under this posterior distribution. Applied 8. In this exercise, we will generate simulated data, and will then use this data to perform forward and backward stepwise selection. (a) Create a random number generator and use its normal() method to generate a predictor X of length n = 100 , as well as a noise vector ε of length n = 100 . (b) Generate a response vector Y of length n = 100 according to the model Y = β 0 + β 1 X + β 2 X 2 + β 3 X 3 + ε, where β 0 , β 1 , β 2 , and β 3 are constants of your choice. (c) Use forward stepwise selection in order to select a model contaiing the predictors X, X 2 , , X 10 . What is the model obtained according to C p ? Report the coefficients of the model obtained. (d) Repeat (c), using backwards stepwise selection. How does your answer compare to the results in (c)? (e) Now fit a lasso model to the simulated data, again using X, X 2 , , X 10 as predictors. Use cross-validation to select the optimal value of λ . Create plots of the cross-validation error as a function of λ . Report the resulting coefficient estimates, and discuss the results obtained",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_72"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Use cross-validation to select the optimal value of λ . Create plots of the cross-validation error as a function of λ . Report the resulting coefficient estimates, and discuss the results obtained. (f) Now generate a response vector Y according to the model Y = β 0 + β 7 X 7 + ε, and perform forward stepwise selection and the lasso. Discuss the results obtained. 9. In this exercise, we will predict the number of applications received using the other variables in the College data set. (a) Split the data set into a training set and a test set. (b) Fit a linear model using least squares on the training set, and report the test error obtained. (c) Fit a ridge regression model on the training set, with λ chosen by cross-validation. Report the test error obtained. (d) Fit a lasso model on the training set, with λ chosen by crosvalidation. Report the test error obtained, along with the nuber of non-zero coefficient estimates. (e) Fit a PCR model on the training set, with M chosen by crosvalidation. Report the test error obtained, along with the value of M selected by cross-validation. (f) Fit a PLS model on the training set, with M chosen by crosvalidation. Report the test error obtained, along with the value of M selected by cross-validation. (g) Comment on the results obtained. How accurately can we prdict the number of college applications received? Is there much difference among the test errors resulting from these five aproaches? 10. We have seen that as the number of features used in a model increases, the training error will necessarily decrease, but the test error may not. We will now explore this in a simulated data set. (a) Generate a data set with p = 20 features, n = 1 , 000 observtions, and an associated quantitative response vector generated according to the model Y = Xβ + ε, where β has some elements that are exactly equal to zero. (b) Split your data set into a training set containing 100 observations and a test set containing 900 observations",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_73"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (b) Split your data set into a training set containing 100 observations and a test set containing 900 observations. (c) Perform best subset selection on the training set, and plot the training set MSE associated with the best model of each size. (d) Plot the test set MSE associated with the best model of each size. (e) For which model size does the test set MSE take on its minimum value? Comment on your results. If it takes on its minimum value for a model containing only an intercept or a model containing all of the features, then play around with the way that you are generating the data in (a) until you come up with a scenario in which the test set MSE is minimized for an intermediate model size. (f) How does the model at which the test set MSE is minimized compare to the true model used to generate the data? Comment on the coefficient values. (g) Create a plot displaying G) p j =1 ( β j − ˆ β r j ) 2 for a range of values of r , where ˆ β r j is the j th coefficient estimate for the best model containing r coefficients. Comment on what you observe. How does this compare to the test MSE plot from (d)? 11. We will now try to predict per capita crime rate in the Boston data set. (a) Try out some of the regression methods explored in this chapter, such as best subset selection, the lasso, ridge regression, and PCR. Present and discuss results for the approaches that you consider. (b) Propose a model (or set of models) that seem to perform well on this data set, and justify your answer. Make sure that you are evaluating model performance using validation set error, crosvalidation, or some other reasonable alternative, as opposed to using training error. (c) Does your chosen model involve all of the features in the data set? Why or why not? 7 Moving Beyond Linearity So far in this book, we have mostly focused on linear models. Linear models are relatively simple to describe and implement, and have advantages over other approaches in terms of interpretation and inference",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_74"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Linear models are relatively simple to describe and implement, and have advantages over other approaches in terms of interpretation and inference. However, stadard linear regression can have significant limitations in terms of preditive power. This is because the linearity assumption is almost always an approximation, and sometimes a poor one. In Chapter 6 we see that we can improve upon least squares using ridge regression, the lasso, principal coponents regression, and other techniques. In that setting, the improvement is obtained by reducing the complexity of the linear model, and hence the variance of the estimates. But we are still using a linear model, which can only be improved so far! In this chapter we relax the linearity assumption while still attempting to maintain as much interpretability as possible. We do this by examining very simple extensions of linear models like polynmial regression and step functions, as well as more sophisticated approaches such as splines, local regression, and generalized additive models. • Polynomial regression extends the linear model by adding extra prdictors, obtained by raising each of the original predictors to a power. For example, a cubic regression uses three variables, X , X 2 , and X 3 , as predictors. This approach provides a simple way to provide a nolinear fit to data. • Step functions cut the range of a variable into K distinct regions in order to produce a qualitative variable. This has the effect of fitting a piecewise constant function. • Regression splines are more flexible than polynomials and step funtions, and in fact are an extension of the two. They involve dividing the range of X into K distinct regions. Within each region, a polnomial function is fit to the data. However, these polynomials are 289 constrained so that they join smoothly at the region boundaries, or knots . Provided that the interval is divided into enough regions, this can produce an extremely flexible fit",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_75"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Provided that the interval is divided into enough regions, this can produce an extremely flexible fit. • Smoothing splines are similar to regression splines, but arise in a slightly different situation. Smoothing splines result from minimizing a residual sum of squares criterion subject to a smoothness penalty. • Local regression is similar to splines, but differs in an important way. The regions are allowed to overlap, and indeed they do so in a very smooth way. • Generalized additive models allow us to extend the methods above to deal with multiple predictors. In Sections 7.1 – 7.6 , we present a number of approaches for modeling the relationship between a response Y and a single predictor X in a flexible way. In Section 7.7 , we show that these approaches can be seamlessly itegrated in order to model a response Y as a function of several predictors X 1 , , X p . 7.1 Polynomial Regression Historically, the standard way to extend linear regression to settings in which the relationship between the predictors and the response is nolinear has been to replace the standard linear model y i = β 0 + β 1 x i + ε i with a polynomial function y i = β 0 + β 1 x i + β 2 x 2 i + β 3 x 3 i + · · · + β d x d i + ε i , (7.1) where ε i is the error term. This approach is known as polynomial regression , polynomial regression and in fact we saw an example of this method in Section 3.3.2 . For large enough degree d , a polynomial regression allows us to produce an extremely non-linear curve. Notice that the coefficients in ( 7.1 ) can be easily estimated using least squares linear regression because this is just a standard linear model with predictors x i , x 2 i , x 3 i , , x d i . Generally speaking, it is unusual to use d greater than 3 or 4 because for large values of d , the polynomial curve can become overly flexible and can take on some very strange shapes. This is especially true near the boundary of the X variable",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_76"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This is especially true near the boundary of the X variable. The left-hand panel in Figure 7.1 is a plot of wage against age for the Wage data set, which contains income and demographic information for males who reside in the central Atlantic region of the United States. We see the results of fitting a degree-4 polynomial using least squares (solid blue curve). Even though this is a linear regression model like any other, the individual coefficients are not of particular interest. Instead, we look at the entire fitted function across a grid of 63 values for age from 18 to 80 in order to understand the relationship between age and wage",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_77"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 20 30 40 50 60 70 80 50 100 150 200 250 300 Age Wage Degree−4 Polynomial 20 30 40 50 60 70 80 0.00 0.05 0.10 0.15 0.20 Age | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_78"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | ||| || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_79"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | || | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | || | | || | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | || | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_80"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | || | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | Pr ( Wage > 250 | Age ) FIGURE 7.1",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_81"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The Wage data. Left: The solid blue curve is a degree-4 polynomial of wage (in thousands of dollars) as a function of age , fit by least squares. The dashed curves indicate an estimated 95 % confidence interval. Right: We model the binary event wage>250 using logistic regression, again with a degree-4 polynomial. The fitted posterior probability of wage exceeding $250 , 000 is shown in blue, along with an estimated 95 % confidence interval. In Figure 7.1 , a pair of dashed curves accompanies the fit; these are ( 2 × ) standard error curves. Let’s see how these arise. Suppose we have computed the fit at a particular value of age , x 0 : ˆ f ( x 0 ) = ˆ β 0 + ˆ β 1 x 0 + ˆ β 2 x 2 0 + ˆ β 3 x 3 0 + ˆ β 4 x 4 0 . (7.2) What is the variance of the fit, i.e. Var ˆ f ( x 0 ) ? Least squares returns variance estimates for each of the fitted coefficients ˆ β j , as well as the covariances between pairs of coefficient estimates. We can use these to compute the estimated variance of ˆ f ( x 0 ) . 1 The estimated pointwise standard error of ˆ f ( x 0 ) is the square-root of this variance. This computation is repeated at each reference point x 0 , and we plot the fitted curve, as well as twice the standard error on either side of the fitted curve. We plot twice the standard error because, for normally distributed error terms, this quantity corresponds to an approximate 95 % confidence interval. It seems like the wages in Figure 7.1 are from two distinct populations: there appears to be a high earners group earning more than $250 , 000 per annum, as well as a low earners group. We can treat wage as a binary variable by splitting it into these two groups. Logistic regression can then be used to predict this binary response, using polynomial functions of age 1 If ˆ C is the 5 × 5 covariance matrix of the ˆ β j , and if l T 0 = (1 , x 0 , x 2 0 , x 3 0 , x 4 0 ) , then Var [ ˆ f ( x 0 )] = l T 0 ˆ C l 0 .",
    "chunk_id": "an_introduction_to_statistical_learning_page-229-288.json_chunk_82"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "as predictors. In other words, we fit the model Pr( y i > 250 | x i ) = exp( β 0 + β 1 x i + β 2 x 2 i + · · · + β d x d i ) 1 + exp( β 0 + β 1 x i + β 2 x 2 i + · · · + β d x d i ) . (7.3) The result is shown in the right-hand panel of Figure 7.1 . The gray marks on the top and bottom of the panel indicate the ages of the high earners and the low earners. The solid blue curve indicates the fitted probabilities of being a high earner, as a function of age . The estimated 95 % confidence interval is shown as well. We see that here the confidence intervals are fairly wide, especially on the right-hand side. Although the sample size for this data set is substantial ( n = 3 , 000 ), there are only 79 high earners, which results in a high variance in the estimated coefficients and consequently wide confidence intervals. 7.2 Step Functions Using polynomial functions of the features as predictors in a linear model imposes a global structure on the non-linear function of X . We can instead use step functions in order to avoid imposing such a global structure. Here step function we break the range of X into bins , and fit a different constant in each bin. This amounts to converting a continuous variable into an ordered categorical variable . ordered categorical variable In greater detail, we create cutpoints c 1 , c 2 , , c K in the range of X , and then construct K + 1 new variables C 0 ( X ) = I ( X < c 1 ) , C 1 ( X ) = I ( c 1 ≤ X < c 2 ) , C 2 ( X ) = I ( c 2 ≤ X < c 3 ) , C K − 1 ( X ) = I ( c K − 1 ≤ X < c K ) , C K ( X ) = I ( c K ≤ X ) , (7.4) where I ( · ) is an indicator function that returns a 1 if the condition is true, indicator function and returns a 0 otherwise. For example, I ( c K ≤ X ) equals 1 if c K ≤ X , and equals 0 otherwise. These are sometimes called dummy variables. Notice that for any value of X , C 0 ( X ) + C 1 ( X ) + · · · + C K ( X ) = 1 , since X must be in exactly one of the K + 1 intervals",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". These are sometimes called dummy variables. Notice that for any value of X , C 0 ( X ) + C 1 ( X ) + · · · + C K ( X ) = 1 , since X must be in exactly one of the K + 1 intervals. We then use least squares to fit a linear model using C 1 ( X ) , C 2 ( X ) , , C K ( X ) as predictors 2 : y i = β 0 + β 1 C 1 ( x i ) + β 2 C 2 ( x i ) + · · · + β K C K ( x i ) + ε i . (7.5) For a given value of X , at most one of C 1 , C 2 , , C K can be non-zero. Note that when X < c 1 , all of the predictors in ( 7.5 ) are zero, so β 0 can 2 We exclude C 0 ( X ) as a predictor in ( 7.5 ) because it is redundant with the intercept. This is similar to the fact that we need only two dummy variables to code a qualitative variable with three levels, provided that the model will contain an intercept. The decision to exclude C 0 ( X ) instead of some other C k ( X ) in ( 7.5 ) is arbitrary. Alternatively, we could include C 0 ( X ) , C 1 ( X ) , , C K ( X ) , and exclude the intercept",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 20 30 40 50 60 70 80 50 100 150 200 250 300 Age Wage Piecewise Constant 20 30 40 50 60 70 80 0.00 0.05 0.10 0.15 0.20 Age | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | || | | | | | | || | | || ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | ||",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | ||| || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | || | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | || | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | | | | | | | | | | | || | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | || | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | Pr ( Wage > 250 | Age ) FIGURE 7.2",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The Wage data. Left: The solid curve displays the fitted value from a least squares regression of wage (in thousands of dollars) using step functions of age . The dashed curves indicate an estimated 95 % confidence interval. Right: We model the binary event wage>250 using logistic regression, again using step functions of age . The fitted posterior probability of wage exceeding $250 , 000 is shown, along with an estimated 95 % confidence interval. be interpreted as the mean value of Y for X < c 1 . By comparison, ( 7.5 ) predicts a response of β 0 + β j for c j ≤ X < c j +1 , so β j represents the average increase in the response for X in c j ≤ X < c j +1 relative to X < c 1 . An example of fitting step functions to the Wage data from Figure 7.1 is shown in the left-hand panel of Figure 7.2 . We also fit the logistic regression model Pr( y i > 250 | x i ) = exp( β 0 + β 1 C 1 ( x i ) + · · · + β K C K ( x i )) 1 + exp( β 0 + β 1 C 1 ( x i ) + · · · + β K C K ( x i )) (7.6) in order to predict the probability that an individual is a high earner on the basis of age . The right-hand panel of Figure 7.2 displays the fitted posterior probabilities obtained using this approach. Unfortunately, unless there are natural breakpoints in the predictors, piecewise-constant functions can miss the action. For example, in the lefhand panel of Figure 7.2 , the first bin clearly misses the increasing trend of wage with age . Nevertheless, step function approaches are very popular in biostatistics and epidemiology, among other disciplines. For example, 5-year age groups are often used to define the bins. 7.3 Basis Functions Polynomial and piecewise-constant regression models are in fact special cases of a basis function approach. The idea is to have at hand a fabasis function ily of functions or transformations that can be applied to a variable X : b 1 ( X ) , b 2 ( X ) , , b K ( X )",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The idea is to have at hand a fabasis function ily of functions or transformations that can be applied to a variable X : b 1 ( X ) , b 2 ( X ) , , b K ( X ) . Instead of fitting a linear model in X , we fit the model y i = β 0 + β 1 b 1 ( x i ) + β 2 b 2 ( x i ) + β 3 b 3 ( x i ) + · · · + β K b K ( x i ) + ε i . (7.7) Note that the basis functions b 1 ( · ) , b 2 ( · ) , , b K ( · ) are fixed and known. (In other words, we choose the functions ahead of time.) For polynomial regression, the basis functions are b j ( x i ) = x j i , and for piecewise constant functions they are b j ( x i ) = I ( c j ≤ x i < c j +1 ) . We can think of ( 7.7 ) as a standard linear model with predictors b 1 ( x i ) , b 2 ( x i ) , , b K ( x i ) . Hence, we can use least squares to estimate the unknown regression coefficients in ( 7.7 ). Importantly, this means that all of the inference tools for linear models that are discussed in Chapter 3 , such as standard errors for the coefficient estimates and F-statistics for the model’s overall significance, are available in this setting. Thus far we have considered the use of polynomial functions and piecwise constant functions for our basis functions; however, many alternatives are possible. For instance, we can use wavelets or Fourier series to construct basis functions. In the next section, we investigate a very common choice for a basis function: regression splines . regression spline 7.4 Regression Splines Now we discuss a flexible class of basis functions that extends upon the polynomial regression and piecewise constant regression approaches that we have just seen. 7.4.1 Piecewise Polynomials Instead of fitting a high-degree polynomial over the entire range of X , piecwise polynomial regression involves fitting separate low-degree polynomials piecewise polynomial regression over different regions of X",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For example, a piecewise cubic polynomial works by fitting a cubic regression model of the form y i = β 0 + β 1 x i + β 2 x 2 i + β 3 x 3 i + ε i , (7.8) where the coefficients β 0 , β 1 , β 2 , and β 3 differ in different parts of the range of X . The points where the coefficients change are called knots . knot For example, a piecewise cubic with no knots is just a standard cubic polynomial, as in ( 7.1 ) with d = 3 . A piecewise cubic polynomial with a single knot at a point c takes the form y i = = β 01 + β 11 x i + β 21 x 2 i + β 31 x 3 i + ε i if x i < c β 02 + β 12 x i + β 22 x 2 i + β 32 x 3 i + ε i if x i ≥ c. In other words, we fit two different polynomial functions to the data, one on the subset of the observations with x i < c , and one on the subset of the observations with x i ≥ c . The first polynomial function has coefficients 20 30 40 50 60 70 50 100 150 200 250 Age Wage Piecewise Cubic 20 30 40 50 60 70 50 100 150 200 250 Age Wage Continuous Piecewise Cubic 20 30 40 50 60 70 50 100 150 200 250 Age Wage Cubic Spline 20 30 40 50 60 70 50 100 150 200 250 Age Wage Linear Spline FIGURE 7.3. Various piecewise polynomials are fit to a subset of the Wage data, with a knot at age=50 . Top Left: The cubic polynomials are unconstrained. Top Right: The cubic polynomials are constrained to be continuous at age=50 . Bottom Left: The cubic polynomials are constrained to be continuous, and to have continuous first and second derivatives. Bottom Right: A linear spline is shown, which is constrained to be continuous. β 01 , β 11 , β 21 , and β 31 , and the second has coefficients β 02 , β 12 , β 22 , and β 32 . Each of these polynomial functions can be fit using least squares applied to simple functions of the original predictor. Using more knots leads to a more flexible piecewise polynomial. In geeral, if we place K different knots throughout the range of X , then we will end up fitting K + 1 different cubic polynomials. Note that we do not need to use a cubic polynomial",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In geeral, if we place K different knots throughout the range of X , then we will end up fitting K + 1 different cubic polynomials. Note that we do not need to use a cubic polynomial. For example, we can instead fit piecewise linear functions. In fact, our piecewise constant functions of Section 7.2 are piecewise polynomials of degree 0! The top left panel of Figure 7.3 shows a piecewise cubic polynomial fit to a subset of the Wage data, with a single knot at age=50 . We immediately see a problem: the function is discontinuous and looks ridiculous! Since each polynomial has four parameters, we are using a total of eight degrees of freedom in fitting this piecewise polynomial model. degrees of freedom 7.4.2 Constraints and Splines The top left panel of Figure 7.3 looks wrong because the fitted curve is just too flexible. To remedy this problem, we can fit a piecewise polynomial under the constraint that the fitted curve must be continuous. In other words, there cannot be a jump when age=50 . The top right plot in Figure 7.3 shows the resulting fit. This looks better than the top left plot, but the shaped join looks unnatural. In the lower left plot, we have added two additional constraints: now both the first and second derivatives of the piecewise polynomials are continuous derivative at age=50 . In other words, we are requiring that the piecewise polynomial be not only continuous when age=50 , but also very smooth . Each constraint that we impose on the piecewise cubic polynomials effectively frees up one degree of freedom, by reducing the complexity of the resulting piecewise polynomial fit. So in the top left plot, we are using eight degrees of fredom, but in the bottom left plot we imposed three constraints (continuity, continuity of the first derivative, and continuity of the second derivative) and so are left with five degrees of freedom. The curve in the bottom left plot is called a cubic spline . 3 In general, a cubic spline with K knots uses cubic spline a total of 4 + K degrees of freedom",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The curve in the bottom left plot is called a cubic spline . 3 In general, a cubic spline with K knots uses cubic spline a total of 4 + K degrees of freedom. In Figure 7.3 , the lower right plot is a linear spline , which is continuous linear spline at age=50 . The general definition of a degred spline is that it is a piecewise degred polynomial, with continuity in derivatives up to degree d − 1 at each knot. Therefore, a linear spline is obtained by fitting a line in each region of the predictor space defined by the knots, requiring continuity at each knot. In Figure 7.3 , there is a single knot at age=50 . Of course, we could add more knots, and impose continuity at each. 7.4.3 The Spline Basis Representation The regression splines that we just saw in the previous section may have seemed somewhat complex: how can we fit a piecewise degred polynomial under the constraint that it (and possibly its first d − 1 derivatives) be continuous? It turns out that we can use the basis model ( 7.7 ) to represent a regression spline. A cubic spline with K knots can be modeled as y i = β 0 + β 1 b 1 ( x i ) + β 2 b 2 ( x i ) + · · · + β K +3 b K +3 ( x i ) + ε i , (7.9) for an appropriate choice of basis functions b 1 , b 2 , , b K +3 . The model ( 7.9 ) can then be fit using least squares. Just as there were several ways to represent polynomials, there are also many equivalent ways to represent cubic splines using different choices of basis functions in ( 7.9 ). The most direct way to represent a cubic spline using ( 7.9 ) is to start off with a basis for a cubic polynomial—namely, x, x 2 , and x 3 —and then add one truncated power basis function per knot. truncated power basis 3 Cubic splines are popular because most human eyes cannot detect the discontinuity at the knots. 20 30 40 50 60 70 50 100 150 200 250 Age Wage Natural Cubic Spline Cubic Spline FIGURE 7.4. A cubic spline and a natural cubic spline, with three knots, fit to a subset of the Wage data. The dashed lines denote the knot locations",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A cubic spline and a natural cubic spline, with three knots, fit to a subset of the Wage data. The dashed lines denote the knot locations. A truncated power basis function is defined as h ( x, ξ ) = ( x − ξ ) 3 + = K ( x − ξ ) 3 if x > ξ 0 otherwise , (7.10) where ξ is the knot. One can show that adding a term of the form β 4 h ( x, ξ ) to the model ( 7.8 ) for a cubic polynomial will lead to a discontinuity in only the third derivative at ξ ; the function will remain continuous, with continuous first and second derivatives, at each of the knots. In other words, in order to fit a cubic spline to a data set with K knots, we perform least squares regression with an intercept and 3 + K predictors, of the form X, X 2 , X 3 , h ( X, ξ 1 ) , h ( X, ξ 2 ) , , h ( X, ξ K ) , where ξ 1 , , ξ K are the knots. This amounts to estimating a total of K + 4 regression coeffcients; for this reason, fitting a cubic spline with K knots uses K +4 degrees of freedom. Unfortunately, splines can have high variance at the outer range of the predictors—that is, when X takes on either a very small or very large value. Figure 7.4 shows a fit to the Wage data with three knots. We see that the confidence bands in the boundary region appear fairly wild. A natral spline is a regression spline with additional boundary constraints : the natural spline function is required to be linear at the boundary (in the region where X is smaller than the smallest knot, or larger than the largest knot). This addtional constraint means that natural splines generally produce more stable estimates at the boundaries. In Figure 7.4 , a natural cubic spline is also displayed as a red line. Note that the corresponding confidence intervals are narrower. 7.4.4 Choosing the Number and Locations of the Knots When we fit a spline, where should we place the knots? The regression spline is most flexible in regions that contain a lot of knots, because in those regions the polynomial coefficients can change rapidly",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Hence, one 20 30 40 50 60 70 80 50 100 150 200 250 300 Age Wage Natural Cubic Spline 20 30 40 50 60 70 80 0.00 0.05 0.10 0.15 0.20 Age | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | || | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | || | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "|| | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | || | || | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | || | | | ||| || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | || | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | |",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | ||| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | ||| | | | | | | | | | | | || | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | || | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | || | || | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | || | | || | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ||",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || || | | | | | | | | | | | | | | | | | | | || | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | || | | || | Pr ( Wage > 250 | Age ) FIGURE 7.5",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A natural cubic spline function with four degrees of freedom is fit to the Wage data. Left: A spline is fit to wage (in thousands of dollars) as a function of age . Right: Logistic regression is used to model the binary event wage>250 as a function of age . The fitted posterior probability of wage exceeding $250 , 000 is shown. The dashed lines denote the knot locations. option is to place more knots in places where we feel the function might vary most rapidly, and to place fewer knots where it seems more stable. While this option can work well, in practice it is common to place knots in a uniform fashion. One way to do this is to specify the desired degrees of freedom, and then have the software automatically place the corresponding number of knots at uniform quantiles of the data. Figure 7.5 shows an example on the Wage data. As in Figure 7.4 , we have fit a natural cubic spline with three knots, except this time the knot locations were chosen automatically as the 25th, 50th, and 75th percentiles of age . This was specified by requesting four degrees of freedom. The agument by which four degrees of freedom leads to three interior knots is somewhat technical. 4 How many knots should we use, or equivalently how many degrees of freedom should our spline contain? One option is to try out different nubers of knots and see which produces the best looking curve. A somewhat more objective approach is to use cross-validation, as discussed in Chaters 5 and 6 . With this method, we remove a portion of the data (say 10 %), fit a spline with a certain number of knots to the remaining data, and then use the spline to make predictions for the held-out portion. We repeat this process multiple times until each observation has been left out once, and 4 There are actually five knots, including the two boundary knots. A cubic spline with five knots has nine degrees of freedom. But natural cubic splines have two additional natural constraints at each boundary to enforce linearity, resulting in 9 − 4 = 5 degrees of freedom",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". But natural cubic splines have two additional natural constraints at each boundary to enforce linearity, resulting in 9 − 4 = 5 degrees of freedom. Since this includes a constant, which is absorbed in the intercept, we count it as four degrees of freedom. 2 4 6 8 10 1600 1620 1640 1660 1680 Degrees of Freedom of Natural Spline Mean Squared Error 2 4 6 8 10 1600 1620 1640 1660 1680 Degrees of Freedom of Cubic Spline Mean Squared Error FIGURE 7.6. Ten-fold cross-validated mean squared errors for selecting the degrees of freedom when fitting splines to the Wage data. The response is wage and the predictor age . Left: A natural cubic spline. Right: A cubic spline. then compute the overall cross-validated RSS . This procedure can be rpeated for different numbers of knots K . Then the value of K giving the smallest RSS is chosen. Figure 7.6 shows ten-fold cross-validated mean squared errors for splines with various degrees of freedom fit to the Wage data. The left-hand panel corresponds to a natural cubic spline and the right-hand panel to a cbic spline. The two methods produce almost identical results, with clear evidence that a one-degree fit (a linear regression) is not adequate. Both curves flatten out quickly, and it seems that three degrees of freedom for the natural spline and four degrees of freedom for the cubic spline are quite adequate. In Section 7.7 we fit additive spline models simultaneously on several variables at a time. This could potentially require the selection of degrees of freedom for each variable. In cases like this we typically adopt a more pragmatic approach and set the degrees of freedom to a fixed number, say four, for all terms. 7.4.5 Comparison to Polynomial Regression Figure 7.7 compares a natural cubic spline with 15 degrees of freedom to a degre15 polynomial on the Wage data set. The extra flexibility in the polnomial produces undesirable results at the boundaries, while the natural cubic spline still provides a reasonable fit to the data",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The extra flexibility in the polnomial produces undesirable results at the boundaries, while the natural cubic spline still provides a reasonable fit to the data. Regression splines often give superior results to polynomial regression. This is because unlike polynomials, which must use a high degree (exponent in the highest monmial term, e.g. X 15 ) to produce flexible fits, splines introduce flexibility by increasing the number of knots but keeping the degree fixed. Generally, this approach produces more stable estimates. Splines also allow us to place more knots, and hence flexibility, over regions where the function f seems to be changing rapidly, and fewer knots where f appears more stable. 20 30 40 50 60 70 80 50 100 150 200 250 300 Age Wage Natural Cubic Spline Polynomial FIGURE 7.7. On the Wage data set, a natural cubic spline with 15 degrees of freedom is compared to a degre15 polynomial. Polynomials can show wild behavior, especially near the tails. 7.5 Smoothing Splines In the last section we discussed regression splines, which we create by speifying a set of knots, producing a sequence of basis functions, and then using least squares to estimate the spline coefficients. We now introduce a somewhat different approach that also produces a spline. 7.5.1 An Overview of Smoothing Splines In fitting a smooth curve to a set of data, what we really want to do is find some function, say g ( x ) , that fits the observed data well: that is, we want RSS = ) n i =1 ( y i − g ( x i )) 2 to be small. However, there is a problem with this approach. If we don’t put any constraints on g ( x i ) , then we can always make RSS zero simply by choosing g such that it interpolates all of the y i . Such a function would woefully overfit the data—it would be far too flexible. What we really want is a function g that makes RSS small, but that is also smooth . How might we ensure that g is smooth? There are a number of ways to do this",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_19"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". What we really want is a function g that makes RSS small, but that is also smooth . How might we ensure that g is smooth? There are a number of ways to do this. A natural approach is to find the function g that minimizes n 0 i =1 ( y i − g ( x i )) 2 + λ L g ′′ ( t ) 2 dt (7.11) where λ is a nonnegative tuning parameter . The function g that minimizes ( 7.11 ) is known as a smoothing spline . smoothing spline What does ( 7.11 ) mean? Equation 7.11 takes the “Loss+Penalty” fomulation that we encounter in the context of ridge regression and the lasso in Chapter 6 . The term ) n i =1 ( y i − g ( x i )) 2 is a loss function that encouloss function ages g to fit the data well, and the term λ M g ′′ ( t ) 2 dt is a penalty term that penalizes the variability in g . The notation g ′′ ( t ) indicates the second derivative of the function g . The first derivative g ′ ( t ) measures the slope of a function at t , and the second derivative corresponds to the amount by which the slope is changing. Hence, broadly speaking, the second derivative of a function is a measure of its roughness : it is large in absolute value if g ( t ) is very wiggly near t , and it is close to zero otherwise. (The second derivative of a straight line is zero; note that a line is perfectly smooth.) The M notation is an integral , which we can think of as a summation over the range of t . In other words, M g ′′ ( t ) 2 dt is simply a measure of the total change in the function g ′ ( t ) , over its entire range. If g is very smooth, then g ′ ( t ) will be close to constant and M g ′′ ( t ) 2 dt will take on a small value. Conversely, if g is jumpy and variable then g ′ ( t ) will vary significantly and M g ′′ ( t ) 2 dt will take on a large value. Therefore, in ( 7.11 ), λ M g ′′ ( t ) 2 dt ecourages g to be smooth. The larger the value of λ , the smoother g will be. When λ = 0 , then the penalty term in ( 7.11 ) has no effect, and so the function g will be very jumpy and will exactly interpolate the training observations",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_20"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". When λ = 0 , then the penalty term in ( 7.11 ) has no effect, and so the function g will be very jumpy and will exactly interpolate the training observations. When λ →∞ , g will be perfectly smooth—it will just be a straight line that passes as closely as possible to the training points. In fact, in this case, g will be the linear least squares line, since the loss function in ( 7.11 ) amounts to minimizing the residual sum of squares. For an intermediate value of λ , g will approximate the training observations but will be somewhat smooth. We see that λ controls the bias-variance trade-off of the smoothing spline. The function g ( x ) that minimizes ( 7.11 ) can be shown to have some spcial properties: it is a piecewise cubic polynomial with knots at the unique values of x 1 , , x n , and continuous first and second derivatives at each knot. Furthermore, it is linear in the region outside of the extreme knots. In other words, the function g ( x ) that minimizes ( 7.11 ) is a natural cubic spline with knots at x 1 , , x n ! However, it is not the same natural cubic spline that one would get if one applied the basis function approach dscribed in Section 7.4.3 with knots at x 1 , , x n —rather, it is a shrunken version of such a natural cubic spline, where the value of the tuning prameter λ in ( 7.11 ) controls the level of shrinkage. 7.5.2 Choosing the Smoothing Parameter λ We have seen that a smoothing spline is simply a natural cubic spline with knots at every unique value of x i . It might seem that a smoothing spline will have far too many degrees of freedom, since a knot at each data point allows a great deal of flexibility. But the tuning parameter λ controls the roughness of the smoothing spline, and hence the effective degrees of freedom . It is possible to show that as λ increases from 0 to ∞ , the effective effective degrees of freedom degrees of freedom, which we write df λ , decrease from n to 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_21"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It is possible to show that as λ increases from 0 to ∞ , the effective effective degrees of freedom degrees of freedom, which we write df λ , decrease from n to 2 . In the context of smoothing splines, why do we discuss effective degrees of freedom instead of degrees of freedom? Usually degrees of freedom refer to the number of free parameters, such as the number of coefficients fit in a polynomial or cubic spline. Although a smoothing spline has n parameters and hence n nominal degrees of freedom, these n parameters are heavily constrained or shrunk down. Hence df λ is a measure of the flexibility of the smoothing spline—the higher it is, the more flexible (and the lower-bias but higher-variance) the smoothing spline. The definition of effective degrees of freedom is somewhat technical. We can write ˆ g λ = S λ y , (7.12) where ˆ g λ is the solution to ( 7.11 ) for a particular choice of λ —that is, it is an n -vector containing the fitted values of the smoothing spline at the training points x 1 , , x n . Equation 7.12 indicates that the vector of fitted values when applying a smoothing spline to the data can be written as a n × n matrix S λ (for which there is a formula) times the response vector y . Then the effective degrees of freedom is defined to be df λ = n 0 i =1 { S λ } ii , (7.13) the sum of the diagonal elements of the matrix S λ . In fitting a smoothing spline, we do not need to select the number or location of the knots—there will be a knot at each training observation, x 1 , , x n . Instead, we have another problem: we need to choose the value of λ . It should come as no surprise that one possible solution to this problem is cross-validation. In other words, we can find the value of λ that makes the cross-validated RSS as small as possible",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_22"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It should come as no surprise that one possible solution to this problem is cross-validation. In other words, we can find the value of λ that makes the cross-validated RSS as small as possible. It turns out that the leavone-out cross-validation error (LOOCV) can be computed very efficiently for smoothing splines, with essentially the same cost as computing a single fit, using the following formula: RSS cv ( λ ) = n 0 i =1 ( y i − ˆ g ( − i ) λ ( x i )) 2 = n 0 i =1 3 y i − ˆ g λ ( x i ) 1 −{ S λ } ii 4 2 . The notation ˆ g ( − i ) λ ( x i ) indicates the fitted value for this smoothing spline evaluated at x i , where the fit uses all of the training observations except for the i th observation ( x i , y i ) . In contrast, ˆ g λ ( x i ) indicates the smoothing spline function fit to all of the training observations and evaluated at x i . This remarkable formula says that we can compute each of these leavone-out fits using only ˆ g λ , the original fit to all of the data! 5 We have a very similar formula ( 5.2 ) on page 205 in Chapter 5 for least squares linear regression. Using ( 5.2 ), we can very quickly perform LOOCV for the regression splines discussed earlier in this chapter, as well as for least squares regression using arbitrary basis functions. Figure 7.8 shows the results from fitting a smoothing spline to the Wage data. The red curve indicates the fit obtained from pre-specifying that we would like a smoothing spline with 16 effective degrees of freedom. The blue curve is the smoothing spline obtained when λ is chosen using LOOCV; in this case, the value of λ chosen results in 6 . 8 effective degrees of freedom (computed using ( 7.13 )). For this data, there is little discernible difference between the two smoothing splines, beyond the fact that the one with 16 degrees of freedom seems slightly wigglier. Since there is little difference between the two fits, the smoothing spline fit with 6",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_23"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Since there is little difference between the two fits, the smoothing spline fit with 6 . 8 degrees of freedom 5 The exact formulas for computing ˆ g ( x i ) and S λ are very technical; however, efficient algorithms are available for computing these quantities. 20 30 40 50 60 70 80 0 50 100 200 300 Age Wage Smoothing Spline 16 Degrees of Freedom 6.8 Degrees of Freedom (LOOCV) FIGURE 7.8. Smoothing spline fits to the Wage data. The red curve results from specifying 16 effective degrees of freedom. For the blue curve, λ was found automatically by leave-one-out cross-validation, which resulted in 6 . 8 effective degrees of freedom. is preferable, since in general simpler models are better unless the data provides evidence in support of a more complex model. 7.6 Local Regression Local regression is a different approach for fitting flexible non-linear funlocal regression tions, which involves computing the fit at a target point x 0 using only the nearby training observations. Figure 7.9 illustrates the idea on some simlated data, with one target point near 0 . 4 , and another near the boundary at 0 . 05 . In this figure the blue line represents the function f ( x ) from which the data were generated, and the light orange line corresponds to the local regression estimate ˆ f ( x ) . Local regression is described in Algorithm 7.1 . Note that in Step 3 of Algorithm 7.1 , the weights K i 0 will differ for each value of x 0 . In other words, in order to obtain the local regression fit at a new point, we need to fit a new weighted least squares regression model by minimizing ( 7.14 ) for a new set of weights. Local regression is sometimes referred to as a memory-based procedure, because like nearest-neighbors, we need all the training data each time we wish to compute a prediction. We will avoid getting into the technical details of local regression here—there are books written on the topic",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_24"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We will avoid getting into the technical details of local regression here—there are books written on the topic. In order to perform local regression, there are a number of choices to be made, such as how to define the weighting function K , and whether to fit a linear, constant, or quadratic regression in Step 3. (Equation 7.14 corresponds to a linear regression.) While all of these choices make some difference, the most important choice is the span s , which is the proportion of points used to compute the local regression at x 0 , as defined in Step 1 above. The span plays a role like that of the tuning parameter λ in smoot 0.0 0.2 0.4 0.6 0.8 1.0 −1.0 −0.5 0.0 0.5 1.0 1.5 O O O O O OO O O O O O O O O OOO O O O O O O O O O O O O OO O O O O O O OO O O O O O O O O O O OO O O O O O OO O O O O O O O O O O O O O O O O O O O O O O OO O O O O O O O O O OO O O O O O O O O O O O OO O O O O O O O O OOO O O O O 0.0 0.2 0.4 0.6 0.8 1.0 −1.0 −0.5 0.0 0.5 1.0 1.5 O O O O O OO O O O O O O O O OOO O O O O O O O O O O O O OO O O O O O O OO O O O O O O O O O O OO O O O O O OO O O O O O O O O O O O O O O O O O O O O O O OO O O O O O O O O O OO O O O O O O O O O O O O O O O OO O O O O O O OO O O O O O O O O O O OO O O O O O OO O O O O O O O O O O O O Local Regression FIGURE 7.9. Local regression illustrated on some simulated data, where the blue curve represents f ( x ) from which the data were generated, and the light orange curve corresponds to the local regression estimate ˆ f ( x ) . The orange colored points are local to the target point x 0 , represented by the orange vertical line. The yellow bell-shape superimposed on the plot indicates weights assigned to each point, decreasing to zero with distance from the target point. The fit ˆ f ( x 0 ) at x 0 is obtained by fitting a weighted linear regression (orange line segment), and using the fitted value at x 0 (orange solid dot) as the estimate ˆ f ( x 0 ) . ing splines: it controls the flexibility of the non-linear fit",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_25"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". ing splines: it controls the flexibility of the non-linear fit. The smaller the value of s , the more local and wiggly will be our fit; alternatively, a very large value of s will lead to a global fit to the data using all of the traiing observations. We can again use cross-validation to choose s , or we can specify it directly. Figure 7.10 displays local linear regression fits on the Wage data, using two values of s : 0 . 7 and 0 . 2 . As expected, the fit obtained using s = 0 . 7 is smoother than that obtained using s = 0 . 2 . The idea of local regression can be generalized in many different ways. In a setting with multiple features X 1 , X 2 , , X p , one very useful generaization involves fitting a multiple linear regression model that is global in some variables, but local in another, such as time. Such varying coefficient models are a useful way of adapting a model to the most recently gathered varying coefficient model data. Local regression also generalizes very naturally when we want to fit models that are local in a pair of variables X 1 and X 2 , rather than one. We can simply use two-dimensional neighborhoods, and fit bivariate linear regression models using the observations that are near each target point in two-dimensional space. Theoretically the same approach can be implmented in higher dimensions, using linear regressions fit to p -dimensional neighborhoods. However, local regression can perform poorly if p is much larger than about 3 or 4 because there will generally be very few training observations close to x 0 . Nearest-neighbors regression, discussed in Chater 3 , suffers from a similar problem in high dimensions. Algorithm 7.1 Local Regressi on At X = x 0 1. Gather the fraction s = k/n of training points whose x i are closest to x 0 . 2. Assign a weight K i 0 = K ( x i , x 0 ) to each point in this neighborhood, so that the point furthest from x 0 has weight zero, and the closest has the highest weight. All but these k nearest neighbors get weight zero. 3",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_26"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". All but these k nearest neighbors get weight zero. 3. Fit a weighted least squares regression of the y i on the x i using the aforementioned weights, by finding ˆ β 0 and ˆ β 1 that minimize n 0 i =1 K i 0 ( y i − β 0 − β 1 x i ) 2 . (7.14) 4. The fitted value at x 0 is given by ˆ f ( x 0 ) = ˆ β 0 + ˆ β 1 x 0 . 20 30 40 50 60 70 80 0 50 100 200 300 Age Wage Local Linear Regression Span is 0.2 (16.4 Degrees of Freedom) Span is 0.7 (5.3 Degrees of Freedom) FIGURE 7.10. Local linear fits to the Wage data. The span specifies the fraction of the data used to compute the fit at each target point. 7.7 Generalized Additive Models In Sections 7.1 – 7.6 , we present a number of approaches for flexibly predicing a response Y on the basis of a single predictor X . These approaches can be seen as extensions of simple linear regression. Here we explore the prolem of flexibly predicting Y on the basis of several predictors, X 1 , , X p . This amounts to an extension of multiple linear regression. Generalized additive models (GAMs) provide a general framework for generalized additive model extending a standard linear model by allowing non-linear functions of each of the variables, while maintaining additivity . Just like linear models, GAMs additivity can be applied with both quantitative and qualitative responses. We first 2003 2005 2007 2009 −30 −20 −10 0 10 20 30 20 30 40 50 60 70 80 −50 −40 −30 −20 −10 0 10 20 −30 −20 −10 0 10 20 30 40 <HS HS <Coll Coll >Coll f 1 ( year ) f 2 ( age ) f 3 ( education ) year age education FIGURE 7.11. For the Wage data, plots of the relationship between each feature and the response, wage , in the fitted model ( 7.16 ). Each plot displays the fitted function and pointwise standard errors. The first two functions are natural splines in year and age , with four and five degrees of freedom, respectively. The third function is a step function, fit to the qualitative variable education",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_27"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The first two functions are natural splines in year and age , with four and five degrees of freedom, respectively. The third function is a step function, fit to the qualitative variable education . examine GAMs for a quantitative response in Section 7.7.1 , and then for a qualitative response in Section 7.7.2 . 7.7.1 GAMs for Regression Problems A natural way to extend the multiple linear regression model y i = β 0 + β 1 x i 1 + β 2 x i 2 + · · · + β p x ip + ε i in order to allow for non-linear relationships between each feature and the response is to replace each linear component β j x ij with a (smooth) nolinear function f j ( x ij ) . We would then write the model as y i = β 0 + p 0 j =1 f j ( x ij ) + ε i = β 0 + f 1 ( x i 1 ) + f 2 ( x i 2 ) + · · · + f p ( x ip ) + ε i . (7.15) This is an example of a GAM. It is called an additive model because we calculate a separate f j for each X j , and then add together all of their contributions. In Sections 7.1 – 7.6 , we discuss many methods for fitting functions to a single variable. The beauty of GAMs is that we can use these methods as building blocks for fitting an additive model. In fact, for most of the methods that we have seen so far in this chapter, this can be done fairly trivially. Take, for example, natural splines, and consider the task of fitting the model wage = β 0 + f 1 ( year ) + f 2 ( age ) + f 3 ( education ) + ε (7.16) on the Wage data. Here year and age are quantitative variables, while the variable education is qualitative with five levels: <HS , HS , <Coll , Coll , >Coll , referring to the amount of high school or college education that an indiviual has completed. We fit the first two functions using natural splines. We 2003 2005 2007 2009 −30 −20 −10 0 10 20 30 20 30 40 50 60 70 80 −50 −40 −30 −20 −10 0 10 20 −30 −20 −10 0 10 20 30 40 <HS HS <Coll Coll >Coll f 1 ( year ) f 2 ( age ) f 3 ( education ) year age education FIGURE 7.12",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_28"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Details are as in Figure 7.11 , but now f 1 and f 2 are smoothing splines with four and five degrees of freedom, respectively. fit the third function using a separate constant for each level, via the usual dummy variable approach of Section 3.3.1 . Figure 7.11 shows the results of fitting the model ( 7.16 ) using least squares. This is easy to do, since as discussed in Section 7.4 , natural splines can be constructed using an appropriately chosen set of basis functions. Hence the entire model is just a big regression onto spline basis variables and dummy variables, all packed into one big regression matrix. Figure 7.11 can be easily interpreted. The left-hand panel indicates that holding age and education fixed, wage tends to increase slightly with year ; this may be due to inflation. The center panel indicates that holding education and year fixed, wage tends to be highest for intermediate vaues of age , and lowest for the very young and very old. The right-hand panel indicates that holding year and age fixed, wage tends to increase with education : the more educated a person is, the higher their salary, on average. All of these findings are intuitive. Figure 7.12 shows a similar triple of plots, but this time f 1 and f 2 are smoothing splines with four and five degrees of freedom, respectively. Fiting a GAM with a smoothing spline is not quite as simple as fitting a GAM with a natural spline, since in the case of smoothing splines, least squares cannot be used. However, standard software such as the Python package pygam can be used to fit GAMs using smoothing splines, via an approach pygam known as backfitting . This method fits a model involving multiple predibackfitting tors by repeatedly updating the fit for each predictor in turn, holding the others fixed. The beauty of this approach is that each time we update a function, we simply apply the fitting method for that variable to a partial residual . 6 The fitted functions in Figures 7.11 and 7.12 look rather similar",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_29"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 6 The fitted functions in Figures 7.11 and 7.12 look rather similar. In most situations, the differences in the GAMs obtained using smoothing splines versus natural splines are small. 6 A partial residual for X 3 , for example, has the form r i = y i − f 1 ( x i 1 ) − f 2 ( x i 2 ) . If we know f 1 and f 2 , then we can fit f 3 by treating this residual as a response in a non-linear regression on X 3 . We do not have to use splines as the building blocks for GAMs: we can just as well use local regression, polynomial regression, or any combination of the approaches seen earlier in this chapter in order to create a GAM. GAMs are investigated in further detail in the lab at the end of this chapter. Pros and Cons of GAMs Before we move on, let us summarize the advantages and limitations of a GAM. L GAMs allow us to fit a non-linear f j to each X j , so that we can automatically model non-linear relationships that standard linear rgression will miss. This means that we do not need to manually try out many different transformations on each variable individually. L The non-linear fits can potentially make more accurate predictions for the response Y . L Because the model is additive, we can examine the effect of each X j on Y individually while holding all of the other variables fixed. L The smoothness of the function f j for the variable X j can be sumarized via degrees of freedom. N The main limitation of GAMs is that the model is restricted to be additive. With many variables, important interactions can be missed. However, as with linear regression, we can manually add interaction terms to the GAM model by including additional predictors of the form X j × X k . In addition we can add low-dimensional interaction functions of the form f jk ( X j , X k ) into the model; such terms can be fit using two-dimensional smoothers such as local regression, or two-dimensional splines (not covered here)",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_30"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For fully general models, we have to look for even more flexible approaches such as random forests and boosting, described in Chapter 8 . GAMs provide a useful compromise between linear and fully nonparametric models. 7.7.2 GAMs for Classification Problems GAMs can also be used in situations where Y is qualitative. For simplicity, here we assume Y takes on values 0 or 1 , and let p ( X ) = Pr( Y = 1 | X ) be the conditional probability (given the predictors) that the response equals one. Recall the logistic regression model ( 4.6 ): log * p ( X ) 1 − p ( X ) + = β 0 + β 1 X 1 + β 2 X 2 + · · · + β p X p . (7.17) The left-hand side is the log of the odds of P ( Y = 1 | X ) versus P ( Y = 0 | X ) , which ( 7.17 ) represents as a linear function of the predictors. A natural way to extend ( 7.17 ) to allow for non-linear relationships is to use the model log * p ( X ) 1 − p ( X ) + = β 0 + f 1 ( X 1 ) + f 2 ( X 2 ) + · · · + f p ( X p ) . (7.18) 2003 2005 2007 2009 −4 −2 0 2 4 20 30 40 50 60 70 80 −8 −6 −4 −2 0 2 −400 −200 0 200 400 <HS HS <Coll Coll >Coll f 1 ( year ) f 2 ( age ) f 3 ( education ) year age education FIGURE 7.13. For the Wage data, the logistic regression GAM given in ( 7.19 ) is fit to the binary response I(wage>250) . Each plot displays the fitted function and pointwise standard errors. The first function is linear in year , the second function a smoothing spline with five degrees of freedom in age , and the third a step function for education . There are very wide standard errors for the first level <HS of education . Equation 7.18 is a logistic regression GAM. It has all the same pros and cons as discussed in the previous section for quantitative responses. We fit a GAM to the Wage data in order to predict the probability that an individual’s income exceeds $250 , 000 per year. The GAM that we fit takes the form log * p ( X ) 1 − p ( X ) + = β 0 + β 1 × year + f 2 ( age ) + f 3 ( education ) , (7.19) where p ( X ) = Pr( wage > 250 | year , age , education )",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_31"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The GAM that we fit takes the form log * p ( X ) 1 − p ( X ) + = β 0 + β 1 × year + f 2 ( age ) + f 3 ( education ) , (7.19) where p ( X ) = Pr( wage > 250 | year , age , education ) . Once again f 2 is fit using a smoothing spline with five degrees of freedom, and f 3 is fit as a step function, by creating dummy variables for each of the levels of education. The resulting fit is shown in Figure 7.13 . The last panel looks suspicious, with very wide confidence intervals for level <HS . In fact, no response values equal one for that category: no individuals with less than a high school education make more than $250 , 000 per year. Hence we refit the GAM, excluding the individuals with less than a high school education. The resulting model is shown in Figure 7.14 . As in Figures 7.11 and 7.12 , all three panels have similar vertical scales. This allows us to visually assess the relative contributions of each of the variables. We observe that age and education have a much larger effect than year on the probability of being a high earner. 7.8 Lab: Non-Linear Modeling In this lab, we demonstrate some of the nonlinear models discussed in this chapter. We use the Wage data as a running example, and show that many of the complex non-linear fitting procedures discussed can easily be implemented in Python . 2003 2005 2007 2009 −4 −2 0 2 4 20 30 40 50 60 70 80 −8 −6 −4 −2 0 2 −4 −2 0 2 4 HS <Coll Coll >Coll f 1 ( year ) f 2 ( age ) f 3 ( education ) year age education FIGURE 7.14. The same model is fit as in Figure 7.13 , this time excluding the observations for which education is <HS . Now we see that increased education tends to be associated with higher salaries. As usual, we start with some of our standard imports. In [1]: import numpy as np, pandas as pd from matplotlib.pyplot import subplots import statsmodels.api as sm from ISLP import load_data from ISLP.models import (summarize, poly, ModelSpec as MS) from statsmodels.stats.anova import anova_lm We again collect the new imports needed for this lab",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_32"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Many of these are developed specifically for the ISLP package. In [2]: from pygam import (s as s_gam, l as l_gam, f as f_gam, LinearGAM, LogisticGAM) from ISLP.transforms import (BSpline, NaturalSpline) from ISLP.models import bs, ns from ISLP.pygam import (approx_lam , degrees_of_freedom , plot as plot_gam, an o v a a s a n ova_gam) 7.8.1 Polynomial Regression and Step Functions We start by demonstrating how Figure 7.1 can be reproduced. Let’s begin by loading the data. In [3]: Wage = load_data( 'Wage' ) y = Wage[ 'wage' ] age = Wage[ 'age' ] Throughout most of this lab, our response is Wage['wage'] , which we have stored as y above. As in Section 3.6.6 , we will use the poly() function to create a model matrix that will fit a 4 th degree polynomial in age . In [4]: poly_age = MS([poly( 'age' , degree=4)]).fit(Wage) M = sm.OLS(y, poly_age.transform(Wage)).fit() summarize(M) Out[4]: coef std err t P>|t| intercept 111.7036 0.729 153.283 0.000 poly(age, degree=4)[0] 447.0679 39.915 11.201 0.000 poly(age, degree=4)[1] -478.3158 39.915 -11.983 0.000 poly(age, degree=4)[2] 125.5217 39.915 3.145 0.002 poly(age, degree=4)[3] -77.9112 39.915 -1.952 0.051 This polynomial is constructed using the function poly() , which crates a special transformer Poly() (using sklearn terminology for feature transformer transformations such as PCA() seen in Section 6.5.3 ) which allows for easy evaluation of the polynomial at new data points. Here poly() is referred to as a helper function, and sets up the transformation; Poly() is the ahelper tual workhorse that computes the transformation. See also the discussion of transformations on page 118 . In the code above, the first line executes the fit() method using the dataframe Wage . This recomputes and stores as attributes any parameters needed by Poly() on the training data, and these will be used on all susequent evaluations of the transform() method. For example, it is used on the second line, as well as in the plotting function developed below",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_33"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For example, it is used on the second line, as well as in the plotting function developed below. We now create a grid of values for age at which we want predictions. In [5]: age_grid = np.linspace(age.min(), age.max(), 100) age_df = pd.DataFrame({ 'age' : age_grid}) Finally, we wish to plot the data and add the fit from the fourth-degree polynomial. As we will make several similar plots below, we first write a function to create all the ingredients and produce the plot. Our function takes in a model specification (here a basis specified by a transform), as well as a grid of age values. The function produces a fitted curve as well as 95% confidence bands. By using an argument for basis we can produce and plot the results with several different transforms, such as the splines we will see shortly. In [6]: def plot_wage_fit(age_df, basis, title): X = basis.transform(Wage) Xnew = basis.transform(age_df) M = sm.OLS(y, X).fit() preds = M.get_prediction(Xnew) bands = preds.conf_int(alpha=0.05) fig, ax = subplots(figsize=(8,8)) ax.scatter(age, y, facecolor= 'gray' , alpha=0.5) for val, ls in zip([preds.predicted_mean , bands[:,0], bands[:,1]], [ 'b' , 'r--' , 'r--' ]): ax.plot(age_df.values, val, ls, linewidth=3) ax.set_title(title, fontsize=20) ax.set_xlabel( 'Age' , fontsize=20) ax.set_ylabel( 'Wage' , fontsize=20); return ax We include an argument alpha to ax.scatter() to add some transparency to the points. This provides a visual indication of density. Notice the use of the zip() function in the for loop above (see Section 2.3.8 ). We have three lines to plot, each with different colors and line types. Here zip() conveniently bundles these together as iterators in the loop. 7 iterator We now plot the fit of the fourth-degree polynomial using this function. In [7]: plot_wage_fit(age_df, poly_age, 'Degree-4 Polynomial' ); With polynomial regression we must decide on the degree of the polynmial to use. Sometimes we just wing it, and decide to use second or third degree polynomials, simply to obtain a nonlinear fit",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_34"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Sometimes we just wing it, and decide to use second or third degree polynomials, simply to obtain a nonlinear fit. But we can make such a decision in a more systematic way. One way to do this is through hypotesis tests, which we demonstrate here. We now fit a series of models ranging from linear (degree-one) to degree-five polynomials, and look to determine the simplest model that is sufficient to explain the relationship between wage and age . We use the anova_lm() function, which performs a series of ANOVA tests. An analysis of variance or ANOVA tests the null hypothesis analysis of variance that a model M 1 is sufficient to explain the data against the alternative hypothesis that a more complex model M 2 is required. The determination is based on an F-test. To perform the test, the models M 1 and M 2 must be nested : the space spanned by the predictors in M 1 must be a subspace of the space spanned by the predictors in M 2 . In this case, we fit five diferent polynomial models and sequentially compare the simpler model to the more complex model. In [8]: models = [MS([poly( 'age' , degree=d)]) for d in range(1, 6)] Xs = [model.fit_transform(Wage) for model in models] anova_lm(*[sm.OLS(y, X_).fit() for X_ in Xs]) Out[8]: df_resid ssr df_diff ss_diff F Pr(>F) 0 2998.0 5.022e+06 0.0 NaN NaN NaN 1 2997.0 4.793e+06 1.0 228786.010 143.593 2.364e-32 2 2996.0 4.778e+06 1.0 15755.694 9.889 1.679e-03 3 2995.0 4.772e+06 1.0 6070.152 3.810 5.105e-02 7 In Python speak, an “iterator” is an object with a finite number of values, that can be iterated on, as in a loop. 4 2994.0 4.770e+06 1.0 1282.563 0.805 3.697e-01 Notice the * in the anova_lm() line above. This function takes a variable number of non-keyword arguments, in this case fitted models. When these models are provided as a list (as is done here), it must be prefixed by * . The p-value comparing the linear models[0] to the quadratic models[1] is essentially zero, indicating that a linear fit is not sufficient",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_35"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The p-value comparing the linear models[0] to the quadratic models[1] is essentially zero, indicating that a linear fit is not sufficient. 8 Similarly the p-value comparing the quadratic models[1] to the cubic models[2] is very low (0.0017), so the quadratic fit is also insufficient. The p-value comparing the cubic and degree-four polynomials, models[2] and models[3] , is approimately 5%, while the degree-five polynomial models[4] seems unnecessary because its p-value is 0.37. Hence, either a cubic or a quartic polynomial appear to provide a reasonable fit to the data, but loweor higher-order models are not justified. In this case, instead of using the anova() function, we could have obtained these p-values more succinctly by exploiting the fact that poly() creates orthogonal polynomials. In [9]: summarize(M) Out[9]: coef std err t P>|t| intercept 111.7036 0.729 153.283 0.000 poly(age, degree=4)[0] 447.0679 39.915 11.201 0.000 poly(age, degree=4)[1] -478.3158 39.915 -11.983 0.000 poly(age, degree=4)[2] 125.5217 39.915 3.145 0.002 poly(age, degree=4)[3] -77.9112 39.915 -1.952 0.051 Notice that the p-values are the same, and in fact the square of the t-statistics are equal to the F-statistics from the anova_lm() function; for example: In [10]: (-11.983)**2 Out[10]: 143.59228 However, the ANOVA method works whether or not we used orthogonal polynomials, provided the models are nested",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_36"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For example, we can use anova_lm() to compare the following three models, which all have a linear term in education and a polynomial in age of different degrees: In [11]: models = [MS([ 'education' , poly( 'age' , degree=d)]) for d in range(1, 4)] XEs = [model.fit_transform(Wage) for model in models] anova_lm(*[sm.OLS(y, X_).fit() for X_ in XEs]) Out[11]: df_resid ssr df_diff ss_diff F Pr(>F) 0 2997.0 3.902e+06 0.0 NaN NaN NaN 1 2996.0 3.759e+06 1.0 142862.701 113.992 3.838e-26 2 2995.0 3.754e+06 1.0 5926.207 4.729 2.974e-02 8 Indexing starting at zero is confusing for the polynomial degree example, since models[1] is quadratic rather than linear! As an alternative to using hypothesis tests and ANOVA, we could choose the polynomial degree using cross-validation, as discussed in Chapter 5 . Next we consider the task of predicting whether an individual earns more than $250,000 per year. We proceed much as before, except that first we create the appropriate response vector, and then apply the glm() function using the binomial family in order to fit a polynomial logistic regression model. In [12]: X = poly_age.transform(Wage) high_earn = Wage[ 'high_earn' ] = y > 250 # shorthand glm = sm.GLM(y > 250, X, family=sm.families.Binomial()) B = glm.fit() summarize(B) Out[12]: coef std err z P>|z| intercept -4.3012 0.345 -12.457 0.000 poly(age, degree=4)[0] 71.9642 26.133 2.754 0.006 poly(age, degree=4)[1] -85.7729 35.929 -2.387 0.017 poly(age, degree=4)[2] 34.1626 19.697 1.734 0.083 poly(age, degree=4)[3] -47.4008 24.105 -1.966 0.049 Once again, we make predictions using the get_prediction() method. In [13]: newX = poly_age.transform(age_df) preds = B.get_prediction(newX) bands = preds.conf_int(alpha=0.05) We now plot the estimated relationship",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_37"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [13]: newX = poly_age.transform(age_df) preds = B.get_prediction(newX) bands = preds.conf_int(alpha=0.05) We now plot the estimated relationship. In [14]: fig, ax = subplots(figsize=(8,8)) rng = np.random.default_rng(0) ax.scatter(age + 0.2 * rng.uniform(size=y.shape[0]), np.where(high_earn, 0.198, 0.002), fc= 'gray' , marker= '|' ) for val, ls in zip([preds.predicted_mean , bands[:,0], bands[:,1]], [ 'b' , 'r--' , 'r--' ]): ax.plot(age_df.values, val, ls, linewidth=3) ax.set_title( 'Degree -4 Polynomial' , fontsize=20) ax.set_xlabel( 'Age' , fontsize=20) ax.set_ylim([0,0.2]) ax.set_ylabel( 'P(Wage > 250)' , fontsize=20); We have drawn the age values corresponding to the observations with wage values above 250 as gray marks on the top of the plot, and those with wage values below 250 are shown as gray marks on the bottom of the plot. We added a small amount of noise to jitter the age values a bit so that observations with the same age value do not cover each other up. This type of plot is often called a rug plot . rug plot In order to fit a step function, as discussed in Section 7.2 , we first use the pd.qcut() function to discretize age based on quantiles. Then we use pd.qcut() pd.get_dummies() to create the columns of the model matrix for this catpd.get_ dummies() gorical variable. Note that this function will include all columns for a given categorical, rather than the usual approach which drops one of the levels. In [15]: cut_age = pd.qcut(age, 4) summarize(sm.OLS(y, pd.get_dummies(cut_age)).fit()) Out[15]: coef std err t P>|t| (17.999, 33.75] 94.1584 1.478 63.692 0.0 (33.75, 42.0] 116.6608 1.470 79.385 0.0 (42.0, 51.0] 119.1887 1.416 84.147 0.0 (51.0, 80.0] 116.5717 1.559 74.751 0.0 Here pd.qcut() automatically picked the cutpoints based on the quatiles 25%, 50% and 75%, which results in four regions. We could also have specified our own quantiles directly instead of the argument 4 . For cuts not based on quantiles we would use the pd.cut() function",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_38"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We could also have specified our own quantiles directly instead of the argument 4 . For cuts not based on quantiles we would use the pd.cut() function. The function pd.cut() pd.qcut() (and pd.cut() ) returns an ordered categorical variable. The rgression model then creates a set of dummy variables for use in the regresion. Since age is the only variable in the model, the value $94,158.40 is the average salary for those under 33.75 years of age, and the other coefficients are the average salary for those in the other age groups. We can produce predictions and plots just as we did in the case of the polynomial fit. 7.8.2 Splines In order to fit regression splines, we use transforms from the ISLP package. The actual spline evaluation functions are in the scipy.interpolate pacage; we have simply wrapped them as transforms similar to Poly() and PCA() . In Section 7.4 , we saw that regression splines can be fit by constructing an appropriate matrix of basis functions. The BSpline() function generates BSpline() the entire matrix of basis functions for splines with the specified set of knots. By default, the B-splines produced are cubic. To change the degree, use the argument degree . In [16]: bs_ = BSpline(internal_knots=[25,40,60], intercept=True).fit(age) bs_age = bs_.transform(age) bs_age.shape Out[16]: (3000, 7) This results in a seven-column matrix, which is what is expected for a cubispline basis with 3 interior knots. We can form this same matrix using the bs() object, which facilitates adding this to a model-matrix builder (as in poly() versus its workhorse Poly() ) described in Section 7.8.1 . We now fit a cubic spline model to the Wage data",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_39"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We now fit a cubic spline model to the Wage data. In [17]: bs_age = MS([bs( 'age' , internal_knots=[25,40,60])]) Xbs = bs_age.fit_transform(Wage) M = sm.OLS(y, Xbs).fit() summarize(M) Out[17]: coef std err intercept 60.494 9.460 bs(age, internal_knots=[25, 40, 60])[0] 3.980 12.538 bs(age, internal_knots=[25, 40, 60])[1] 44.631 9.626 bs(age, internal_knots=[25, 40, 60])[2] 62.839 10.755 bs(age, internal_knots=[25, 40, 60])[3] 55.991 10.706 bs(age, internal_knots=[25, 40, 60])[4] 50.688 14.402 bs(age, internal_knots=[25, 40, 60])[5] 16.606 19.126 The column names are a little cumbersome, and have caused us to trucate the printed summary. They can be set on construction using the name argument as follows. In [18]: bs_age = MS([bs( 'age' , internal_knots=[25,40,60], name= 'bs(age)' )]) Xbs = bs_age.fit_transform(Wage) M = sm.OLS(y, Xbs).fit() summarize(M) Out[18]: coef std err t P>|t| intercept 60.494 9.460 6.394 0.000 bs(age, knots)[0] 3.981 12.538 0.317 0.751 bs(age, knots)[1] 44.631 9.626 4.636 0.000 bs(age, knots)[2] 62.839 10.755 5.843 0.000 bs(age, knots)[3] 55.991 10.706 5.230 0.000 bs(age, knots)[4] 50.688 14.402 3.520 0.000 bs(age, knots)[5] 16.606 19.126 0.868 0.385 Notice that there are 6 spline coefficients rather than 7. This is because, by default, bs() assumes intercept=False , since we typically have an overall intercept in the model. So it generates the spline basis with the given knots, and then discards one of the basis functions to account for the intercept. We could also use the df (degrees of freedom) option to specify the coplexity of the spline. We see above that with 3 knots, the spline basis has 6 columns or degrees of freedom. When we specify df=6 rather than the actual knots, bs() will produce a spline with 3 knots chosen at uniform quantiles of the training data",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_40"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". When we specify df=6 rather than the actual knots, bs() will produce a spline with 3 knots chosen at uniform quantiles of the training data. We can see these chosen knots most easily using Bspline() directly: In [19]: BSpline(df=6).fit(age).internal_knots_ Out[19]: array([33.75, 42.0, 51.0]) When asking for six degrees of freedom, the transform chooses knots at ages 33.75, 42.0, and 51.0, which correspond to the 25th, 50th, and 75th percentiles of age . When using B-splines we need not limit ourselves to cubic polynomials (i.e. degree=3 ). For instance, using degree=0 results in piecewise constant functions, as in our example with pd.qcut() above. In [20]: bs_age0 = MS([bs( 'age' , df=3, degree=0)]).fit(Wage) Xbs0 = bs_age0.transform(Wage) summarize(sm.OLS(y, Xbs0).fit()) Out[20]: coef std err t P>|t| intercept 94.158 1.478 63.687 0.0 bs(age, df=3, degree=0)[0] 22.349 2.152 10.388 0.0 bs(age, df=3, degree=0)[1] 24.808 2.044 12.137 0.0 bs(age, df=3, degree=0)[2] 22.781 2.087 10.917 0.0 This fit should be compared with cell [15] where we use qcut() to create four bins by cutting at the 25%, 50% and 75% quantiles of age . Since we specified df=3 for degree-zero splines here, there will also be knots at the same three quantiles. Although the coefficients appear different, we see that this is a result of the different coding. For example, the first coefficient is identical in both cases, and is the mean response in the first bin. For the second coefficient, we have 94 . 158 + 22 . 349 = 116 . 507 ≈ 116 . 611 , the latter being the mean in the second bin in cell [15]. Here the intercept is coded by a column of ones, so the second, third and fourth coefficients are increments for those bins. Why is the sum not exactly the same? It turns out that the qcut() uses ≤ , while bs() uses < when deciding bin membership. In order to fit a natural spline, we use the NaturalSpline() transform Natural Spline() with the corresponding helper ns()",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_41"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In order to fit a natural spline, we use the NaturalSpline() transform Natural Spline() with the corresponding helper ns() . Here we fit a natural spline with five degrees of freedom (excluding the intercept) and plot the results. In [21]: ns_age = MS([ns( 'age' , df=5)]).fit(Wage) M_ns = sm.OLS(y, ns_age.transform(Wage)).fit() summarize(M_ns) Out[21]: coef std err t P>|t| intercept 60.475 4.708 12.844 0.000 ns(age, df=5)[0] 61.527 4.709 13.065 0.000 ns(age, df=5)[1] 55.691 5.717 9.741 0.000 ns(age, df=5)[2] 46.818 4.948 9.463 0.000 ns(age, df=5)[3] 83.204 11.918 6.982 0.000 ns(age, df=5)[4] 6.877 9.484 0.725 0.468 We now plot the natural spline using our plotting function. In [22]: plot_wage_fit(age_df, ns_age, 'Natural spline, df=5' ); 7.8.3 Smoothing Splines and GAMs A smoothing spline is a special case of a GAM with squared-error loss and a single feature. To fit GAMs in Python we will use the pygam package pygam which can be installed via pip install pygam . The estimator LinearGAM() LinearGAM() uses squared-error loss. The GAM is specified by associating each column of a model matrix with a particular smoothing operation: s for smoothing spline; l for linear, and f for factor or categorical variables. The argument 0 passed to s below indicates that this smoother will apply to the first column of a feature matrix. Below, we pass it a matrix with a single column: X_age . The argument lam is the penalty parameter λ as discussed in Section 7.5.2 . In [23]: X_age = np.asarray(age).reshape((-1,1)) gam = LinearGAM(s_gam(0, lam=0.6)) gam.fit(X_age, y) Out[23]: LinearGAM(callbacks=[Deviance(), Diffs()], fit_intercept=True, max_iter=100, scale=None, terms=s(0) + intercept, tol=0.0001, verbose=False) The pygam library generally expects a matrix of features so we reshape age to be a matrix (a two-dimensional array) instead of a vector (i.e. a ondimensional array). The -1 in the call to the reshape() method tells numpy to impute the size of that dimension based on the remaining entries of the shape tuple",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_42"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". a ondimensional array). The -1 in the call to the reshape() method tells numpy to impute the size of that dimension based on the remaining entries of the shape tuple. Let’s investigate how the fit changes with the smoothing parameter lam . The function np.logspace() is similar to np.linspace() but spaces points np.logspace() evenly on the log-scale. Below we vary lam from 10 − 2 to 10 6 . In [24]: fig, ax = subplots(figsize=(8,8)) ax.scatter(age, y, facecolor= 'gray' , alpha=0.5) for lam in np.logspace(-2, 6, 5): gam = LinearGAM(s_gam(0, lam=lam)).fit(X_age, y) ax.plot(age_grid, gam.predict(age_grid), label= '{:.1e}' .format(lam), linewidth=3) ax.set_xlabel( 'Age' , fontsize=20) ax.set_ylabel( 'Wage' , fontsize=20); ax.legend(title= '$\\lambda$' ); The pygam package can perform a search for an optimal smoothing prameter. In [25]: gam_opt = gam.gridsearch(X_age, y) ax.plot(age_grid, gam_opt.predict(age_grid), label= 'Grid search' , linewidth=4) ax.legend() fig Alternatively, we can fix the degrees of freedom of the smoothing spline using a function included in the ISLP.pygam package. Below we find a value of λ that gives us roughly four degrees of freedom. We note here that these degrees of freedom include the unpenalized intercept and linear term of the smoothing spline, hence there are at least two degrees of freedom. In [26]: age_term = gam.terms[0] lam_4 = approx_lam(X_age, age_term, 4) age_term.lam = lam_4 degrees_of_freedom(X_age, age_term) Out[26]: 4.000000100004728 Let’s vary the degrees of freedom in a similar plot to above. We choose the degrees of freedom as the desired degrees of freedom plus one to account for the fact that these smoothing splines always have an intercept term. Hence, a value of one for df is just a linear fit",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_43"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Hence, a value of one for df is just a linear fit. In [27]: fig, ax = subplots(figsize=(8,8)) ax.scatter(X_age, y, facecolor= 'gray' , alpha=0.3) for df in [1,3,4,8,15]: lam = approx_lam(X_age, age_term, df+1) age_term.lam = lam gam.fit(X_age, y) ax.plot(age_grid, gam.predict(age_grid), label= '{:d}' .format(df), linewidth=4) ax.set_xlabel( 'Age' , fontsize=20) ax.set_ylabel( 'Wage' , fontsize=20); ax.legend(title= 'Degrees of freedom' ); Additive Models with Several Terms The strength of generalized additive models lies in their ability to fit mutivariate regression models with more flexibility than linear models. We demonstrate two approaches: the first in a more manual fashion using naural splines and piecewise constant functions, and the second using the pygam package and smoothing splines. We now fit a GAM by hand to predict wage using natural spline functions of year and age , treating education as a qualitative predictor, as in ( 7.16 ). Since this is just a big linear regression model using an appropriate choice of basis functions, we can simply do this using the sm.OLS() function. We will build the model matrix in a more manual fashion here, since we wish to access the pieces separately when constructing partial dependence plots. In [28]: ns_age = NaturalSpline(df=4).fit(age) ns_year = NaturalSpline(df=5).fit(Wage[ 'year' ]) Xs = [ns_age.transform(age), ns_year.transform(Wage[ 'year' ]), pd.get_dummies(Wage[ 'education' ]).values] X_bh = np.hstack(Xs) gam_bh = sm.OLS(y, X_bh).fit() Here the function NaturalSpline() is the workhorse supporting the ns() helper function. We chose to use all columns of the indicator matrix for the categorical variable education , making an intercept redundant. Finally, we stacked the three component matrices horizontally to form the model matrix X_bh . We now show how to construct partial dependence plots for each of the terms in our rudimentary GAM. We can do this by hand, given grids for age and year",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_44"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We now show how to construct partial dependence plots for each of the terms in our rudimentary GAM. We can do this by hand, given grids for age and year . We simply predict with new X matrices, fixing all but one of the features at a time. In [29]: age_grid = np.linspace(age.min(), age.max(), 100) X_age_bh = X_bh.copy()[:100] X_age_bh[:] = X_bh[:].mean(0)[None,:] X_age_bh[:,:4] = ns_age.transform(age_grid) preds = gam_bh.get_prediction(X_age_bh) bounds_age = preds.conf_int(alpha=0.05) partial_age = preds.predicted_mean center = partial_age.mean() partial_age -= center bounds_age -= center fig, ax = subplots(figsize=(8,8)) ax.plot(age_grid, partial_age , 'b' , linewidth=3) ax.plot(age_grid, bounds_age[:,0], 'r--' , linewidth=3) ax.plot(age_grid, bounds_age[:,1], 'r--' , linewidth=3) ax.set_xlabel( 'Age' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of age on wage' , fontsize=20); Let’s explain in some detail what we did above. The idea is to create a new prediction matrix, where all but the columns belonging to age are constant (and set to their training-data means). The four columns for age are filled in with the natural spline basis evaluated at the 100 values in age_grid . 1. We made a grid of length 100 in age , and created a matrix X_age_bh with 100 rows and the same number of columns as X_bh . 2. We replaced every row of this matrix with the column means of the original. 3. We then replace just the first four columns representing age with the natural spline basis computed at the values in age_grid . The remaining steps should by now be familiar. We also look at the effect of year on wage ; the process is the same",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_45"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The remaining steps should by now be familiar. We also look at the effect of year on wage ; the process is the same. In [30]: year_grid = np.linspace(2003, 2009, 100) year_grid = np.linspace(Wage[ 'year' ].min(), Wage[ 'year' ].max(), 100) X_year_bh = X_bh.copy()[:100] X_year_bh[:] = X_bh[:].mean(0)[None,:] X_year_bh[:,4:9] = ns_year.transform(year_grid) preds = gam_bh.get_prediction(X_year_bh) bounds_year = preds.conf_int(alpha=0.05) partial_year = preds.predicted_mean center = partial_year.mean() partial_year -= center bounds_year -= center fig, ax = subplots(figsize=(8,8)) ax.plot(year_grid, partial_year , 'b' , linewidth=3) ax.plot(year_grid, bounds_year[:,0], 'r--' , linewidth=3) ax.plot(year_grid, bounds_year[:,1], 'r--' , linewidth=3) ax.set_xlabel( 'Year' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependen ce of year on wage' , fontsize=20); We now fit the model ( 7.16 ) using smoothing splines rather than naural splines. All of the terms in ( 7.16 ) are fit simultaneously, taking each other into account to explain the response. The pygam package only works with matrices, so we must convert the categorical series education to its array representation, which can be found with the cat.codes attribute of education . As year only has 7 unique values, we use only seven basis funtions for it. In [31]: gam_full = LinearGAM(s_gam(0) + s_gam(1, n_splines=7) + f_gam(2, lam=0)) Xgam = np.column_stack([age, Wage[ 'year' ], Wage[ 'education' ].cat.codes]) gam_full = gam_full.fit(Xgam, y) The two s_gam() terms result in smoothing spline fits, and use a default value for λ ( lam=0.6 ), which is somewhat arbitrary. For the categorical term education , specified using a f_gam() term, we specify lam=0 to avoid any shrinkage. We produce the partial dependence plot in age to see the effect of these choices. The values for the plot are generated by the pygam package",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_46"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We produce the partial dependence plot in age to see the effect of these choices. The values for the plot are generated by the pygam package. We provide a plot_gam() function for partial-dependence plots in ISLP.pygam , which plot_gam() makes this job easier than in our last example with natural splines. In [32]: fig, ax = subplots(figsize=(8,8)) plot_gam(gam_full, 0, ax=ax) ax.set_xlabel( 'Age' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of age on wage - default lam=0.6' , fontsize=20); We see that the function is somewhat wiggly. It is more natural to specify the df than a value for lam . We refit a GAM using four degrees of freedom each for age and year . Recall that the addition of one below takes into account the intercept of the smoothing spline. In [33]: age_term = gam_full.terms[0] age_term.lam = approx_lam(Xgam, age_term, df=4+1) year_term = gam_full.terms[1] year_term.lam = approx_lam(Xgam, year_term, df=4+1) gam_full = gam_full.fit(Xgam, y) Note that updating age_term.lam above updates it in gam_full.terms[0] as well! Likewise for year_term.lam . Repeating the plot for age , we see that it is much smoother. We also produce the plot for year . In [34]: fig, ax = subplots(figsize=(8,8)) plot_gam(gam_full, 1, ax=ax) ax.set_xlabel( 'Year' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of year on wage' , fo n ts ize = 2 0 ) Finally we plot education , which is categorical. The partial dependence plot is different, and more suitable for the set of fitted constants for each level of this variable. In [35]: fig, ax = subplots(figsize=(8, 8)) ax = plot_gam(gam_full, 2) ax.set_xlabel( 'Education' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of wage on education' , fontsize=20); ax.set_xticklabels(Wage[ 'education' ].cat.categories, fontsize=8); ANOVA Tests for Additive Models In all of our models, the function of year looks rather linear",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_47"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We can perform a series of ANOVA tests in order to determine which of these three models is best: a GAM that excludes year ( M 1 ), a GAM that uses a linear function of year ( M 2 ), or a GAM that uses a spline function of year ( M 3 ). In [36]: gam_0 = LinearGAM(age_term + f_gam(2, lam=0)) gam_0.fit(Xgam, y) gam_linear = LinearGAM(age_term + l_gam(1, lam=0) + f_gam(2, lam=0)) gam_linear.fit(Xgam, y) Out[36]: LinearGAM(callbacks=[Deviance(), Diffs()], fit_intercept=True, max_iter=100, scale=None, terms=s(0) + l(1) + f(2) + intercept, tol=0.0001, verbose=False) Notice our use of age_term in the expressions above. We do this because earlier we set the value for lam in this term to achieve four degrees of freedom. To directly assess the effect of year we run an ANOVA on the three models fit above. In [37]: anova_gam(gam_0, gam_linear, gam_full) Out[37]: deviance df deviance_diff df_diff F pvalue 0 3714362.366 2991.004 NaN NaN NaN NaN 1 3696745.823 2990.005 17616.543 0.999 14.265 0.002 2 3693142.930 2987.007 3602.894 2.998 0.972 0.436 We find that there is compelling evidence that a GAM with a linear function in year is better than a GAM that does not include year at all ( p -value= 0.002). However, there is no evidence that a non-linear function of year is needed ( p -value=0.435). In other words, based on the results of this ANOVA, M 2 is preferred. We can repeat the same process for age as well. We see there is very clear evidence that a non-linear term is required for age . In [38]: gam_0 = LinearGAM(year_term + f_gam(2, lam=0)) gam_linear = LinearGAM(l_gam(0, lam=0) + year_term + f_gam(2, lam=0)) gam_0.fit(Xgam, y) gam_linear.fit(Xgam, y) anova_gam(gam_0, gam_linear, gam_full) Out[38]: deviance df deviance_diff df_diff F pvalue 0 3975443.045 2991.001 NaN NaN NaN NaN 1 3850246.908 2990.001 125196.137 1.000 101.270 0.000 2 3693142.930 2987.007 157103.978 2.993 42.448 0.000 There is a (verbose) summary() method for the GAM fit",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_48"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (We do not reproduce it here.) In [39]: gam_full.summary() We can make predictions from gam objects, just like from lm objects, using the predict() method for the class gam . Here we make predictions on the training set. In [40]: Yhat = gam_full.predict(Xgam) In order to fit a logistic regression GAM, we use LogisticGAM() from LogisticGAM() pygam . In [41]: gam_logit = LogisticGAM(age_term + l_gam(1, lam=0) + f_gam(2, lam=0)) gam_logit.fit(Xgam, high_earn) Out[41]: LogisticGAM(callbacks=[Deviance(), Diffs(), Accuracy()], fit_intercept=True, max_iter=100, terms=s(0) + l(1) + f(2) + intercept, tol=0.0001, verbose=False) In [42]: fig, ax = subplots(figsize=(8, 8)) ax = plot_gam(gam_logit, 2) ax.set_xlabel( 'Education' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of wage on education' , fontsize=20); ax.set_xticklabels(Wage[ 'education' ].cat.categories, fontsize=8); The model seems to be very flat, with especially high error bars for the first category. Let’s look at the data a bit more closely. In [43]: pd.crosstab(Wage[ 'high_earn' ], Wage[ 'education' ]) We see that there are no high earners in the first category of education, meaning that the model will have a hard time fitting. We will fit a logistic regression GAM excluding all observations falling into this category. This provides more sensible results. To do so, we could subset the model matrix, though this will not remove the column from Xgam . While we can deduce which column corresponds to this feature, for reproducibility’s sake we reform the model matrix on this smaller subset. In [44]: only_hs = Wage[ 'education' ] == '1. < HS Grad' Wage_ = Wage.loc[ ∼ only_hs] Xgam_ = np.column_stack([Wage_[ 'age' ], Wage_[ 'year' ], Wage_[ 'education' ].cat.codes -1]) high_earn_ = Wage_[ 'high_earn' ] In the second-to-last line above, we subtract one from the codes of the category, due to a bug in pygam . It just relabels the education values and hence has no effect on the fit. We now fit the model",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_49"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It just relabels the education values and hence has no effect on the fit. We now fit the model. In [45]: gam_logit_ = LogisticGAM(age_term + year_term + f_gam(2, lam=0)) gam_logit_.fit(Xgam_, high_earn_) Out[45]: LogisticGAM(callbacks=[Deviance(), Diffs(), Accuracy()], fit_intercept=True, max_iter=100, terms=s(0) + s(1) + f(2) + intercept, tol=0.0001, verbose=False) Let’s look at the effect of education , year and age on high earner status now that we’ve removed those observations. In [46]: fig, ax = subplots(figsize=(8, 8)) ax = plot_gam(gam_logit_, 2) ax.set_xlabel( 'Education' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of high earner status on education ' , fontsize=20); ax.set_xticklabels(Wage[ 'education' ].cat.categories[1:], fontsize=8); In [47]: fig, ax = subplots(figsize=(8, 8)) ax = plot_gam(gam_logit_, 1) ax.set_xlabel( 'Year' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of high earner status on year' , fontsize=20); In [48]: fig, ax = subplots(figsize=(8, 8)) ax = plot_gam(gam_logit_, 0) ax.set_xlabel( 'Age' ) ax.set_ylabel( 'Effect on wage' ) ax.set_title( 'Partial dependence of high earner status on age' , fontsize=20); 7.8.4 Local Regression We illustrate the use of local regression using the lowess() function from lowess() sm.nonparametric . Some implementations of GAMs allow terms to be local regression operators; this is not the case in pygam . Here we fit local linear regression models using spans of 0.2 and 0.5; that is, each neighborhood consists of 20% or 50% of the observations. As expected, using a span of 0.5 is smoother than 0.2",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_50"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Here we fit local linear regression models using spans of 0.2 and 0.5; that is, each neighborhood consists of 20% or 50% of the observations. As expected, using a span of 0.5 is smoother than 0.2. In [49]: lowess = sm.nonparametric.lowess fig, ax = subplots(figsize=(8,8)) ax.scatter(age, y, facecolor= 'gray' , alpha=0.5) for span in [0.2, 0.5]: fitted = lowess(y, age, frac=span, xvals=age_grid) ax.plot(age_grid, fitted, label= '{:.1f}' .format(span), linewidth=4) ax.set_xlabel( 'Age' , fontsize=20) ax.set_ylabel( 'Wage' , fontsize=20); ax.legend(title= 'span' , fo ntsize=15 ); 7.9 Exercises Conceptual 1. It was mentioned in this chapter that a cubic regression spline with one knot at ξ can be obtained using a basis of the form x , x 2 , x 3 , ( x − ξ ) 3 + , where ( x − ξ ) 3 + = ( x − ξ ) 3 if x > ξ and equals 0 otherwise. We will now show that a function of the form f ( x ) = β 0 + β 1 x + β 2 x 2 + β 3 x 3 + β 4 ( x − ξ ) 3 + is indeed a cubic regression spline, regardless of the values of β 0 , β 1 , β 2 , β 3 , β 4 . (a) Find a cubic polynomial f 1 ( x ) = a 1 + b 1 x + c 1 x 2 + d 1 x 3 such that f ( x ) = f 1 ( x ) for all x ≤ ξ . Express a 1 , b 1 , c 1 , d 1 in terms of β 0 , β 1 , β 2 , β 3 , β 4 . (b) Find a cubic polynomial f 2 ( x ) = a 2 + b 2 x + c 2 x 2 + d 2 x 3 such that f ( x ) = f 2 ( x ) for all x > ξ . Express a 2 , b 2 , c 2 , d 2 in terms of β 0 , β 1 , β 2 , β 3 , β 4 . We have now established that f ( x ) is a piecewise polynomial. (c) Show that f 1 ( ξ ) = f 2 ( ξ ) . That is, f ( x ) is continuous at ξ . (d) Show that f ′ 1 ( ξ ) = f ′ 2 ( ξ ) . That is, f ′ ( x ) is continuous at ξ . (e) Show that f ′′ 1 ( ξ ) = f ′′ 2 ( ξ ) . That is, f ′′ ( x ) is continuous at ξ . Therefore, f ( x ) is indeed a cubic spline. Hint: Parts (d) and (e) of this problem require knowledge of singlvariable calculus",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_51"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". That is, f ′′ ( x ) is continuous at ξ . Therefore, f ( x ) is indeed a cubic spline. Hint: Parts (d) and (e) of this problem require knowledge of singlvariable calculus. As a reminder, given a cubic polynomial f 1 ( x ) = a 1 + b 1 x + c 1 x 2 + d 1 x 3 , the first derivative takes the form f ′ 1 ( x ) = b 1 + 2 c 1 x + 3 d 1 x 2 and the second derivative takes the form f ′′ 1 ( x ) = 2 c 1 + 6 d 1 x. 2. Suppose that a curve ˆ g is computed to smoothly fit a set of n points using the following formula: ˆ g = arg min g > n 0 i =1 ( y i − g ( x i )) 2 + λ L 7 g ( m ) ( x ) 8 2 dx ? , where g ( m ) represents the m th derivative of g (and g (0) = g ). Provide example sketches of ˆ g in each of the following scenarios. (a) λ = ∞ , m = 0 . (b) λ = ∞ , m = 1 . (c) λ = ∞ , m = 2 . (d) λ = ∞ , m = 3 . (e) λ = 0 , m = 3 . 3. Suppose we fit a curve with basis functions b 1 ( X ) = X , b 2 ( X ) = ( X − 1) 2 I ( X ≥ 1) . (Note that I ( X ≥ 1) equals 1 for X ≥ 1 and 0 otherwise.) We fit the linear regression model Y = β 0 + β 1 b 1 ( X ) + β 2 b 2 ( X ) + ε, and obtain coefficient estimates ˆ β 0 = 1 , ˆ β 1 = 1 , ˆ β 2 = − 2 . Sketch the estimated curve between X = − 2 and X = 2 . Note the intercepts, slopes, and other relevant information. 4. Suppose we fit a curve with basis functions b 1 ( X ) = I (0 ≤ X ≤ 2) − ( X − 1) I (1 ≤ X ≤ 2) , b 2 ( X ) = ( X − 3) I (3 ≤ X ≤ 4)+ I (4 < X ≤ 5) . We fit the linear regression model Y = β 0 + β 1 b 1 ( X ) + β 2 b 2 ( X ) + ε, and obtain coefficient estimates ˆ β 0 = 1 , ˆ β 1 = 1 , ˆ β 2 = 3 . Sketch the estimated curve between X = − 2 and X = 6 . Note the intercepts, slopes, and other relevant information. 5. Consider two curves, ˆ g 1 and ˆ g 2 , defined by ˆ g 1 = arg min g > n 0 i =1 ( y i − g ( x i )) 2 + λ L 7 g (3) ( x ) 8 2 dx ? , ˆ g 2 = arg min g > n 0 i =1 ( y i − g ( x i )) 2 + λ L 7 g (4) ( x ) 8 2 dx ? , where g ( m ) represents the m th derivative of g",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_52"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (a) As λ →∞ , will ˆ g 1 or ˆ g 2 have the smaller training RSS? (b) As λ →∞ , will ˆ g 1 or ˆ g 2 have the smaller test RSS? (c) For λ = 0 , will ˆ g 1 or ˆ g 2 have the smaller training and test RSS? Applied 6. In this exercise, you will further analyze the Wage data set considered throughout this chapter. (a) Perform polynomial regression to predict wage using age . Use cross-validation to select the optimal degree d for the polynmial. What degree was chosen, and how does this compare to the results of hypothesis testing using ANOVA? Make a plot of the resulting polynomial fit to the data. (b) Fit a step function to predict wage using age , and perform crosvalidation to choose the optimal number of cuts. Make a plot of the fit obtained. 7. The Wage data set contains a number of other features not explored in this chapter, such as marital status ( maritl ), job class ( jobclass ), and others. Explore the relationships between some of these other predictors and wage , and use non-linear fitting techniques in order to fit flexible models to the data. Create plots of the results obtained, and write a summary of your findings. 8. Fit some of the non-linear models investigated in this chapter to the Auto data set. Is there evidence for non-linear relationships in this data set? Create some informative plots to justify your answer. 9. This question uses the variables dis (the weighted mean of distances to five Boston employment centers) and nox (nitrogen oxides concetration in parts per 10 million) from the Boston data. We will treat dis as the predictor and nox as the response. (a) Use the poly() function from the ISLP.models module to fit a cubic polynomial regression to predict nox using dis . Report the regression output, and plot the resulting data and polynomial fits. (b) Plot the polynomial fits for a range of different polynomial degrees (say, from 1 to 10), and report the associated residual sum of squares",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_53"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (b) Plot the polynomial fits for a range of different polynomial degrees (say, from 1 to 10), and report the associated residual sum of squares. (c) Perform cross-validation or another approach to select the optmal degree for the polynomial, and explain your results. (d) Use the bs() function from the ISLP.models module to fit a rgression spline to predict nox using dis . Report the output for the fit using four degrees of freedom. How did you choose the knots? Plot the resulting fit. (e) Now fit a regression spline for a range of degrees of freedom, and plot the resulting fits and report the resulting RSS. Describe the results obtained. (f) Perform cross-validation or another approach in order to select the best degrees of freedom for a regression spline on this data. Describe your results. 10. This question relates to the College data set. (a) Split the data into a training set and a test set. Using out-of-state tuition as the response and the other variables as the predictors, perform forward stepwise selection on the training set in order to identify a satisfactory model that uses just a subset of the predictors. (b) Fit a GAM on the training data, using out-of-state tuition as the response and the features selected in the previous step as the predictors. Plot the results, and explain your findings. (c) Evaluate the model obtained on the test set, and explain the results obtained. (d) For which variables, if any, is there evidence of a non-linear relationship with the response? 11. In Section 7.7 , it was mentioned that GAMs are generally fit using a backfitting approach. The idea behind backfitting is actually quite simple. We will now explore backfitting in the context of multiple linear regression. Suppose that we would like to perform multiple linear regression, but we do not have software to do so. Instead, we only have software to perform simple linear regression",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_54"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Suppose that we would like to perform multiple linear regression, but we do not have software to do so. Instead, we only have software to perform simple linear regression. Therefore, we take the following iterative approach: we repeatedly hold all but one coefficient estmate fixed at its current value, and update only that coefficient estimate using a simple linear regression. The process is continued util convergence —that is, until the coefficient estimates stop changing. We now try this out on a toy example. (a) Generate a response Y and two predictors X 1 and X 2 , with n = 100 . (b) Write a function simple_reg() that takes two arguments outcome and feature , fits a simple linear regression model with this oucome and feature, and returns the estimated intercept and slope. (c) Initialize beta1 to take on a value of your choice. It does not matter what value you choose. (d) Keeping beta1 fixed, use your function simple_reg() to fit the model: Y − beta1 · X 1 = β 0 + β 2 X 2 + ε. Store the resulting values as beta0 and beta2 . (e) Keeping beta2 fixed, fit the model Y − beta2 · X 2 = β 0 + β 1 X 1 + ε. Store the result as beta0 and beta1 (overwriting their previous values). (f) Write a for loop to repeat (c) and (d) 1,000 times. Report the estimates of beta0 , beta1 , and beta2 at each iteration of the for loop. Create a plot in which each of these values is displayed, with beta0 , beta1 , and beta2 . (g) Compare your answer in (e) to the results of simply perforing multiple linear regression to predict Y using X 1 and X 2 . Use axline() method to overlay those multiple linear regression coefficient estimates on the plot obtained in (e). (h) On this data set, how many backfitting iterations were required in order to obtain a “good” approximation to the multiple rgression coefficient estimates? 12. This problem is a continuation of the previous exercise",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_55"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This problem is a continuation of the previous exercise. In a toy example with p = 100 , show that one can approximate the multiple linear regression coefficient estimates by repeatedly performing simple linear regression in a backfitting procedure. How many backfitting iterations are required in order to obtain a “good” approximation to the multiple regression coefficient estimates? Create a plot to justify your answer. 8 Tree-Based Methods In this chapter, we describe tree-based methods for regression and classifcation. These involve stratifying or segmenting the predictor space into a number of simple regions. In order to make a prediction for a given oservation, we typically use the mean or the mode response value for the training observations in the region to which it belongs. Since the set of splitting rules used to segment the predictor space can be summarized in a tree, these types of approaches are known as decision tree methods. decision tree Tree-based methods are simple and useful for interpretation. However, they typically are not competitive with the best supervised learning aproaches, such as those seen in Chapters 6 and 7 , in terms of prediction accuracy. Hence in this chapter we also introduce bagging , random forests , boosting , and Bayesian additive regression trees . Each of these approaches involves producing multiple trees which are then combined to yield a single consensus prediction. We will see that combining a large number of trees can often result in dramatic improvements in prediction accuracy, at the expense of some loss in interpretation. 8.1 The Basics of Decision Trees Decision trees can be applied to both regression and classification problems. We first consider regression problems, and then move on to classification. 8.1.1 Regression Trees In order to motivate regression trees , we begin with a simple example. regression tree 331 | Years < 4.5 Hits < 117.5 5.11 6.00 6.74 FIGURE 8.1",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_56"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 8.1.1 Regression Trees In order to motivate regression trees , we begin with a simple example. regression tree 331 | Years < 4.5 Hits < 117.5 5.11 6.00 6.74 FIGURE 8.1. For the Hitters data, a regression tree for predicting the log salary of a baseball player, based on the number of years that he has played in the major leagues and the number of hits that he made in the previous year. At a given internal node, the label (of the form X j < t k ) indicates the left-hand branch emanating from that split, and the right-hand branch corresponds to X j ≥ t k . For instance, the split at the top of the tree results in two large branches. The left-hand branch corresponds to Years<4.5 , and the right-hand branch corresponds to Years>=4.5 . The tree has two internal nodes and three terminal nodes, or leaves. The number in each leaf is the mean of the response for the observations that fall there. Predicting Baseball Players’ Salaries Using Regression Trees We use the Hitters data set to predict a baseball player’s Salary based on Years (the number of years that he has played in the major leagues) and Hits (the number of hits that he made in the previous year). We first remove observations that are missing Salary values, and log-transform Salary so that its distribution has more of a typical bell-shape. (Recall that Salary is measured in thousands of dollars.) Figure 8.1 shows a regression tree fit to this data. It consists of a series of splitting rules, starting at the top of the tree. The top split assigns observations having Years<4.5 to the left branch. 1 The predicted salary for these players is given by the mean response value for the players in the data set with Years<4.5 . For such players, the mean log salary is 5 . 107 , and so we make a prediction of e 5 . 107 thousands of dollars, i.e. $165,174, for these players. Players with Years>=4.5 are assigned to the right branch, and then that group is further subdivided by Hits",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_57"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 107 thousands of dollars, i.e. $165,174, for these players. Players with Years>=4.5 are assigned to the right branch, and then that group is further subdivided by Hits . Overall, the tree stratifies or segments the players into three regions of predictor space: players who have played for four or fewer years, players who have played for five or more years and who made fewer than 118 hits last year, and players who have played for five or more years and who made at least 118 hits last year. These three regions can be written as R 1 = {X | Years<4.5 }, R 2 = {X | Years>=4.5 , Hits<117.5 } , and R 3 = {X | Years>=4.5 , Hits>=117.5 }. Figure 8.2 illustrates 1 Both Years and Hits are integers in these data; the function used to fit this tree labels the splits at the midpoint between two adjacent values. Years Hits 1 117.5 238 1 4.5 24 R 1 R 3 R 2 FIGURE 8.2. The three-region partition for the Hitters data set from the regression tree illustrated in Figure 8.1 . the regions as a function of Years and Hits . The predicted salaries for these three groups are $1,000 × e 5 . 107 = $165,174, $1,000 × e 5 . 999 = $402,834, and $1,000 × e 6 . 740 = $845,346 respectively. In keeping with the tree analogy, the regions R 1 , R 2 , and R 3 are known as terminal nodes or leaves of the tree. As is the case for Figure 8.1 , decision terminal node leaf trees are typically drawn upside down , in the sense that the leaves are at the bottom of the tree. The points along the tree where the predictor space is split are referred to as internal nodes . In Figure 8.1 , the two internal internal node nodes are indicated by the text Years<4.5 and Hits<117.5 . We refer to the segments of the trees that connect the nodes as branches . branch We might interpret the regression tree displayed in Figure 8.1 as follows: Years is the most important factor in determining Salary , and players with less experience earn lower salaries than more experienced players",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_58"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Given that a player is less experienced, the number of hits that he made in the previous year seems to play little role in his salary. But among players who have been in the major leagues for five or more years, the number of hits made in the previous year does affect salary, and players who made more hits last year tend to have higher salaries. The regression tree shown in Figure 8.1 is likely an over-simplification of the true relationship between Hits , Years , and Salary . However, it has advantages over other types of regression models (such as those seen in Chapters 3 and 6 ): it is easier to interpret, and has a nice graphical representation. Prediction via Stratification of the Feature Space We now discuss the process of building a regression tree. Roughly speaking, there are two steps. 1. We divide the predictor space — that is, the set of possible values for X 1 , X 2 , , X p — into J distinct and non-overlapping regions, R 1 , R 2 , , R J .",
    "chunk_id": "an_introduction_to_statistical_learning_page-289-329.json_chunk_59"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "| t 1 t 2 t 3 t 4 R 1 R 1 R 2 R 2 R 3 R 3 R 4 R 4 R 5 R 5 X 1 X 1 X 1 X 2 X 2 X 2 X 1 ≤ t 1 X 2 ≤ t 2 X 1 ≤ t 3 X 2 ≤ t 4 FIGURE 8.3. Top Left: A partition of two-dimensional feature space that could not result from recursive binary splitting. Top Right: The output of recursive binary splitting on a two-dimensional example. Bottom Left: A tree corresponding to the partition in the top right panel. Bottom Right: A perspective plot of the prediction surface corresponding to that tree. each of the resulting regions. However, this time, instead of splitting the entire predictor space, we split one of the two previously identified regions. We now have three regions. Again, we look to split one of these three regions further, so as to minimize the RSS. The process continues until a stopping criterion is reached; for instance, we may continue until no region contains more than five observations. Once the regions R 1 , , R J have been created, we predict the response for a given test observation using the mean of the training observations in the region to which that test observation belongs. A five-region example of this approach is shown in Figure 8.3 . Tree Pruning The process described above may produce good predictions on the training set, but is likely to overfit the data, leading to poor test set performance. This is because the resulting tree might be too complex. A smaller tree with fewer splits (that is, fewer regions R 1 , , R J ) might lead to lower variance and better interpretation at the cost of a little bias. One possible alternative to the process described above is to build the tree only so long as the decrease in the RSS due to each split exceeds some (high) threshold. This strategy will result in smaller trees, but is too short-sighted since a seemingly worthless split early on in the tree might be followed by a very good split—that is, a split that leads to a large reduction in RSS later on",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Therefore, a better strategy is to grow a very large tree T 0 , and then prune it back in order to obtain a subtree . How do we determine the best prune subtree way to prune the tree? Intuitively, our goal is to select a subtree that leads to the lowest test error rate. Given a subtree, we can estimate its test error using cross-validation or the validation set approach. However, estimating the cross-validation error for every possible subtree would be too cumbersome, since there is an extremely large number of possible subtrees. Instead, we need a way to select a small set of subtrees for consideration. Cost complexity pruning —also known as weakest link pruning —gives us cost complexity pruning weakest link pruning a way to do just this. Rather than considering every possible subtree, we consider a sequence of trees indexed by a nonnegative tuning parameter α . For each value of α there corresponds a subtree T ⊂ T 0 such that | T | 0 m =1 0 i : x i ∈ R m ( y i − ˆ y Rm ) 2 + α | T | (8.4) is as small as possible. Here | T | indicates the number of terminal nodes of the tree T , R m is the rectangle (i.e. the subset of predictor space) coresponding to the m th terminal node, and ˆ y Rm is the predicted response associated with R m —that is, the mean of the training observations in R m . The tuning parameter α controls a trade-off between the subtree’s coplexity and its fit to the training data. When α = 0 , then the subtree T will simply equal T 0 , because then ( 8.4 ) just measures the training error. However, as α increases, there is a price to pay for having a tree with many terminal nodes, and so the quantity ( 8.4 ) will tend to be minimized for a smaller subtree. Equation 8.4 is reminiscent of the lasso ( 6.7 ) from Chapter 6 , in which a similar formulation was used in order to control the complexity of a linear model",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Equation 8.4 is reminiscent of the lasso ( 6.7 ) from Chapter 6 , in which a similar formulation was used in order to control the complexity of a linear model. It turns out that as we increase α from zero in ( 8.4 ), branches get pruned from the tree in a nested and predictable fashion, so obtaining the whole sequence of subtrees as a function of α is easy. We can select a value of α using a validation set or using cross-validation. We then return to the full data set and obtain the subtree corresponding to α . This process is summarized in Algorithm 8.1 . Figures 8.4 and 8.5 display the results of fitting and pruning a regression tree on the Hitters data, using nine of the features. First, we randomly divided the data set in half, yielding 132 observations in the training set and 131 observations in the test set. We then built a large regression tree on the training data and varied α in ( 8.4 ) in order to create subtrees with different numbers of terminal nodes. Finally, we performed six-fold crosvalidation in order to estimate the cross-validated MSE of the trees as Algorithm 8.1 Building a R egr essi on Tree 1. Use recursive binary splitting to grow a large tree on the training data, stopping only when each terminal node has fewer than some minimum number of observations. 2. Apply cost complexity pruning to the large tree in order to obtain a sequence of best subtrees, as a function of α . 3. Use K-fold cross-validation to choose α . That is, divide the training observations into K folds. For each k = 1 , , K : (a) Repeat Steps 1 and 2 on all but the k th fold of the training data. (b) Evaluate the mean squared prediction error on the data in the left-out k th fold, as a function of α . Average the results for each value of α , and pick α to minimize the average error. 4. Return the subtree from Step 2 that corresponds to the chosen value of α . a function of α . (We chose to perform six-fold cross-validation because 132 is an exact multiple of six.) The unpruned regression tree is shown in Figure 8.4",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". a function of α . (We chose to perform six-fold cross-validation because 132 is an exact multiple of six.) The unpruned regression tree is shown in Figure 8.4 . The green curve in Figure 8.5 shows the CV error as a function of the number of leaves, 2 while the orange curve indicates the test error. Also shown are standard error bars around the estimated errors. For reference, the training error curve is shown in black. The CV error is a reasonable approximation of the test error: the CV error takes on its minimum for a three-node tree, while the test error also dips down at the three-node tree (though it takes on its lowest value at the ten-node tree). The pruned tree containing three terminal nodes is shown in Figure 8.1 . 8.1.2 Classification Trees A classification tree is very similar to a regression tree, except that it is classification tree used to predict a qualitative response rather than a quantitative one. Rcall that for a regression tree, the predicted response for an observation is given by the mean response of the training observations that belong to the same terminal node. In contrast, for a classification tree, we predict that each observation belongs to the most commonly occurring class of training observations in the region to which it belongs. In interpreting the results of a classification tree, we are often interested not only in the class prediction corresponding to a particular terminal node region, but also in the class proportions among the training observations that fall into that region. The task of growing a classification tree is quite similar to the task of growing a regression tree. Just as in the regression setting, we use recursive 2 Although CV error is computed as a function of α , it is convenient to display the result as a function of | T | , the number of leaves; this is based on the relationship between α and | T | in the original tree grown to all the training data",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". | Years < 4.5 RBI < 60.5 Putouts < 82 Years < 3.5 Years < 3.5 Hits < 117.5 Walks < 43.5 Runs < 47.5 Walks < 52.5 RBI < 80.5 Years < 6.5 5.487 4.622 5.183 5.394 6.189 6.015 5.571 6.407 6.549 6.459 7.007 7.289 FIGURE 8.4. Regression tree analysis for the Hitters data. The unpruned tree that results from top-down greedy splitting on the training data is shown. binary splitting to grow a classification tree. However, in the classification setting, RSS cannot be used as a criterion for making the binary splits. A natural alternative to RSS is the classification error rate . Since we plan classification error rate to assign an observation in a given region to the most commonly occurring class of training observations in that region, the classification error rate is simply the fraction of the training observations in that region that do not belong to the most common class: E = 1 − max k (ˆ p mk ) . (8.5) Here ˆ p mk represents the proportion of training observations in the m th region that are from the k th class. However, it turns out that classification error is not sufficiently sensitive for tree-growing, and in practice two other measures are preferable. The Gini index is defined by Gini index G = K 0 k =1 ˆ p mk (1 − ˆ p mk ) , (8.6) a measure of total variance across the K classes. It is not hard to see that the Gini index takes on a small value if all of the ˆ p mk ’s are close to zero or one. For this reason the Gini index is referred to as a measure of 2 4 6 8 10 0.0 0.2 0.4 0.6 0.8 1.0 Tree Size Mean Squared Error Training Cross−Validation Test FIGURE 8.5. Regression tree analysis for the Hitters data. The training, cross-validation, and test MSE are shown as a function of the number of terminal nodes in the pruned tree. Standard error bands are displayed. The minimum cross-validation error occurs at a tree size of three. node purity —a small value indicates that a node contains predominantly observations from a single class",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The minimum cross-validation error occurs at a tree size of three. node purity —a small value indicates that a node contains predominantly observations from a single class. An alternative to the Gini index is entropy , given by entropy D = − K 0 k =1 ˆ p mk log ˆ p mk . (8.7) Since 0 ≤ ˆ p mk ≤ 1 , it follows that 0 ≤− ˆ p mk log ˆ p mk . One can show that the entropy will take on a value near zero if the ˆ p mk ’s are all near zero or near one. Therefore, like the Gini index, the entropy will take on a small value if the m th node is pure. In fact, it turns out that the Gini index and the entropy are quite similar numerically. When building a classification tree, either the Gini index or the entropy are typically used to evaluate the quality of a particular split, since these two approaches are more sensitive to node purity than is the classification error rate. Any of these three approaches might be used when pruning the tree, but the classification error rate is preferable if prediction accuracy of the final pruned tree is the goal. Figure 8.6 shows an example on the Heart data set. These data cotain a binary outcome HD for 303 patients who presented with chest pain. An outcome value of Yes indicates the presence of heart disease based on an angiographic test, while No means no heart disease. There are 13 preditors including Age , Sex , Chol (a cholesterol measurement), and other heart and lung function measurements. Cross-validation results in a tree with six terminal nodes. In our discussion thus far, we have assumed that the predictor varables take on continuous values. However, decision trees can be constructed even in the presence of qualitative predictor variables",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In our discussion thus far, we have assumed that the predictor varables take on continuous values. However, decision trees can be constructed even in the presence of qualitative predictor variables. For instance, in the Heart data, some of the predictors, such as Sex , Thal (Thallium stress test), | Thal:a Ca < 0.5 MaxHR < 161.5 RestBP < 157 Chol < 244 MaxHR < 156 MaxHR < 145.5 ChestPain:bc Chol < 244 Sex < 0.5 Ca < 0.5 Slope < 1.5 Age < 52 Thal:b ChestPain:a Oldpeak < 1.1 RestECG < 1 No Yes No No Yes No No No No Yes Yes No No No Yes Yes Yes Yes 5 10 15 0.0 0.1 0.2 0.3 0.4 0.5 0.6 Tree Size Error Training Cross−Validation Test | Thal:a Ca < 0.5 MaxHR < 161.5 ChestPain:bc Ca < 0.5 No No No Yes Yes Yes FIGURE 8.6. Heart data. Top: The unpruned tree. Bottom Left: Cross-validtion error, training, and test error, for different sizes of the pruned tree. Bottom Right: The pruned tree corresponding to the minimal cross-validation error. and ChestPain , are qualitative. Therefore, a split on one of these variables amounts to assigning some of the qualitative values to one branch and assigning the remaining to the other branch. In Figure 8.6 , some of the iternal nodes correspond to splitting qualitative variables. For instance, the top internal node corresponds to splitting Thal . The text Thal:a indicates that the left-hand branch coming out of that node consists of observations with the first value of the Thal variable (normal), and the right-hand node consists of the remaining observations (fixed or reversible defects). The text ChestPain:bc two splits down the tree on the left indicates that the left-hand branch coming out of that node consists of observations with the second and third values of the ChestPain variable, where the possible values are typical angina, atypical angina, non-anginal pain, and asymptomatic. Figure 8.6 has a surprising characteristic: some of the splits yield two terminal nodes that have the same predicted value",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Figure 8.6 has a surprising characteristic: some of the splits yield two terminal nodes that have the same predicted value . For instance, consider the split RestECG<1 near the bottom right of the unpruned tree. Regardless of the value of RestECG , a response value of Yes is predicted for those o servations. Why, then, is the split performed at all? The split is performed because it leads to increased node purity . That is, all 9 of the observations corresponding to the right-hand leaf have a response value of Yes , whereas 7 / 11 of those corresponding to the left-hand leaf have a response value of Yes . Why is node purity important? Suppose that we have a test obsevation that belongs to the region given by that right-hand leaf. Then we can be pretty certain that its response value is Yes . In contrast, if a test observation belongs to the region given by the left-hand leaf, then its rsponse value is probably Yes , but we are much less certain. Even though the split RestECG<1 does not reduce the classification error, it improves the Gini index and the entropy, which are more sensitive to node purity. 8.1.3 Trees Versus Linear Models Regression and classification trees have a very different flavor from the more classical approaches for regression and classification presented in Chapters 3 and 4 . In particular, linear regression assumes a model of the form f ( X ) = β 0 + p 0 j =1 X j β j , (8.8) whereas regression trees assume a model of the form f ( X ) = M 0 m =1 c m · 1 ( X ∈ R m ) (8.9) where R 1 , , R M represent a partition of feature space, as in Figure 8.3 . Which model is better? It depends on the problem at hand. If the rlationship between the features and the response is well approximated by a linear model as in ( 8.8 ), then an approach such as linear regression will likely work well, and will outperform a method such as a regression tree that does not exploit this linear structure",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". If instead there is a highly nolinear and complex relationship between the features and the response as indicated by model ( 8.9 ), then decision trees may outperform classical aproaches. An illustrative example is displayed in Figure 8.7 . The relative performances of tree-based and classical approaches can be assessed by etimating the test error, using either cross-validation or the validation set approach (Chapter 5 ). Of course, other considerations beyond simply test error may come into play in selecting a statistical learning method; for instance, in certain setings, prediction using a tree may be preferred for the sake of interpretabiity and visualization. 8.1.4 Advantages and Disadvantages of Trees Decision trees for regression and classification have a number of advantages over the more classical approaches seen in Chapters 3 and 4 : L Trees are very easy to explain to people. In fact, they are even easier to explain than linear regression! −2 −1 0 1 2 −2 −1 0 1 2 X 1 X 2 −2 −1 0 1 2 −2 −1 0 1 2 X 1 X 2 −2 −1 0 1 2 −2 −1 0 1 2 X 1 X 2 −2 −1 0 1 2 −2 −1 0 1 2 X 1 X 2 FIGURE 8.7. Top Row: A two-dimensional classification example in which the true decision boundary is linear, and is indicated by the shaded regions. A classical approach that assumes a linear boundary (left) will outperform a decision tree that performs splits parallel to the axes (right). Bottom Row: Here the true dcision boundary is non-linear. Here a linear model is unable to capture the true decision boundary (left), whereas a decision tree is successful (right). L Some people believe that decision trees more closely mirror human decision-making than do the regression and classification approaches seen in previous chapters. L Trees can be displayed graphically, and are easily interpreted even by a non-expert (especially if they are small). L Trees can easily handle qualitative predictors without the need to create dummy variables",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". L Trees can easily handle qualitative predictors without the need to create dummy variables. M Unfortunately, trees generally do not have the same level of predictive accuracy as some of the other regression and classification approaches seen in this book. M Additionally, trees can be very non-robust. In other words, a small change in the data can cause a large change in the final estimated tree. However, by aggregating many decision trees, using methods like bagging , random forests , and boosting , the predictive performance of trees can be substantially improved. We introduce these concepts in the next section. 8.2 Bagging, Random Forests, Boosting, and Bayesian Additive Regression Trees An ensemble method is an approach that combines many simple “building ensemble block” models in order to obtain a single and potentially very powerful model. These simple building block models are sometimes known as weak learners , since they may lead to mediocre predictions on their own. weak learners We will now discuss bagging, random forests, boosting, and Bayesian additive regression trees. These are ensemble methods for which the simple building block is a regression or a classification tree. 8.2.1 Bagging The bootstrap, introduced in Chapter 5 , is an extremely powerful idea. It is used in many situations in which it is hard or even impossible to directly compute the standard deviation of a quantity of interest. We see here that the bootstrap can be used in a completely different context, in order to improve statistical learning methods such as decision trees. The decision trees discussed in Section 8.1 suffer from high variance . This means that if we split the training data into two parts at random, and fit a decision tree to both halves, the results that we get could be quite different. In contrast, a procedure with low variance will yield similar results if applied repeatedly to distinct data sets; linear regression tends to have low variance, if the ratio of n to p is moderately large",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Bootstrap aggregation , or bagging , is a general-purpose procedure for reducing the bagging variance of a statistical learning method; we introduce it here because it is particularly useful and frequently used in the context of decision trees. Recall that given a set of n independent observations Z 1 , , Z n , each with variance σ 2 , the variance of the mean ̄ Z of the observations is given by σ 2 /n . In other words, averaging a set of observations reduces variance . Hence a natural way to reduce the variance and increase the test set acuracy of a statistical learning method is to take many training sets from the population, build a separate prediction model using each training set, and average the resulting predictions. In other words, we could calculate ˆ f 1 ( x ) , ˆ f 2 ( x ) , , ˆ f B ( x ) using B separate training sets, and average them in order to obtain a single low-variance statistical learning model, given by ˆ f avg ( x ) = 1 B B 0 b =1 ˆ f b ( x ) . Of course, this is not practical because we generally do not have access to multiple training sets. Instead, we can bootstrap, by taking repeated samples from the (single) training data set. In this approach we generate B different bootstrapped training data sets. We then train our method on the b th bootstrapped training set in order to get ˆ f ∗ b ( x ) , and finally average all the predictions, to obtain ˆ f bag ( x ) = 1 B B 0 b =1 ˆ f ∗ b ( x ) . 0 50 100 150 200 250 300 0.10 0.15 0.20 0.25 0.30 Number of Trees Error Test: Bagging Test: RandomForest OOB: Bagging OOB: RandomForest FIGURE 8.8. Bagging and random forest results for the Heart data. The test error (black and orange) is shown as a function of B , the nu mb er of bootstrapped training sets used. Random forests were applied with m = √ p . The dashed line indicates the test error resulting from a single classification tree. The green and blue traces show the OOB error, which in this case is — by chance — considerably lower. This is called bagging",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The green and blue traces show the OOB error, which in this case is — by chance — considerably lower. This is called bagging. While bagging can improve predictions for many regression methods, it is particularly useful for decision trees. To apply bagging to regression trees, we simply construct B regression trees using B bootstrapped training sets, and average the resulting predictions. These trees are grown deep, and are not pruned. Hence each individual tree has high variance, but low bias. Averaging these B trees reduces the variance. Bagging has been demonstrated to give impressive improvements in accuracy by combining together hundreds or even thousands of trees into a single procedure. Thus far, we have described the bagging procedure in the regression context, to predict a quantitative outcome Y . How can bagging be extended to a classification problem where Y is qualitative? In that situation, there are a few possible approaches, but the simplest is as follows. For a given test observation, we can record the class predicted by each of the B trees, and take a majority vote : the overall prediction is the most commonly occurring majority vote class among the B predictions. Figure 8.8 shows the results from bagging trees on the Heart data. The test error rate is shown as a function of B , the number of trees constructed using bootstrapped training data sets. We see that the bagging test error rate is slightly lower in this case than the test error rate obtained from a single tree. The number of trees B is not a critical parameter with bagging; using a very large value of B will not lead to overfitting. In practice we use a value of B sufficiently large that the error has settled down. Using B = 100 is sufficient to achieve good performance in this example. Out-of-Bag Error Estimation It turns out that there is a very straightforward way to estimate the test error of a bagged model, without the need to perform cross-validation or the validation set approach",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Recall that the key to bagging is that trees are repeatedly fit to bootstrapped subsets of the observations. One can show that on average, each bagged tree makes use of around two-thirds of the observations. 3 The remaining one-third of the observations not used to fit a given bagged tree are referred to as the out-of-bag (OOB) observations. We out-of-bag can predict the response for the i th observation using each of the trees in which that observation was OOB. This will yield around B/ 3 predictions for the i th observation. In order to obtain a single prediction for the i th observation, we can average these predicted responses (if regression is the goal) or can take a majority vote (if classification is the goal). This leads to a single OOB prediction for the i th observation. An OOB prediction can be obtained in this way for each of the n observations, from which the overall OOB MSE (for a regression problem) or classification error (for a classification problem) can be computed. The resulting OOB error is a valid estimate of the test error for the bagged model, since the response for each observation is predicted using only the trees that were not fit using that observation. Figure 8.8 displays the OOB error on the Heart data. It can be shown that with B sufficiently large, OOB error is virtually equivalent to leave-one-out cross-validation error. The OOB approach for estimating the test error is particularly convenient when performing bagging on large data sets for which cross-validation would be computationally onerous. Variable Importance Measures As we have discussed, bagging typically results in improved accuracy over prediction using a single tree. Unfortunately, however, it can be difficult to interpret the resulting model. Recall that one of the advantages of decision trees is the attractive and easily interpreted diagram that results, such as the one displayed in Figure 8.1",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Recall that one of the advantages of decision trees is the attractive and easily interpreted diagram that results, such as the one displayed in Figure 8.1 . However, when we bag a large number of trees, it is no longer possible to represent the resulting statistical learning procedure using a single tree, and it is no longer clear which variables are most important to the procedure. Thus, bagging improves prediction accuracy at the expense of interpretability. Although the collection of bagged trees is much more difficult to interpret than a single tree, one can obtain an overall summary of the importance of each predictor using the RSS (for bagging regression trees) or the Gini index (for bagging classification trees). In the case of bagging regression trees, we can record the total amount that the RSS ( 8.1 ) is decreased due to splits over a given predictor, averaged over all B trees. A large value indicates an important predictor. Similarly, in the context of bagging classification 3 This relates to Exercise 2 of Chapter 5 . Thal Ca ChestPain Oldpeak MaxHR RestBP Age Chol Slope Sex ExAng RestECG Fbs 0 20 40 60 80 100 Variable Importance FIGURE 8.9. A variable importance plot for the Heart data. Variable impotance is computed using the mean decrease in Gini index, and expressed relative to the maximum. trees, we can add up the total amount that the Gini index ( 8.6 ) is decreased by splits over a given predictor, averaged over all B trees. A graphical representation of the variable importances in the Heart data variable importance is shown in Figure 8.9 . We see the mean decrease in Gini index for each varable, relative to the largest. The variables with the largest mean decrease in Gini index are Thal , Ca , and ChestPain . 8.2.2 Random Forests Random forests provide an improvement over bagged trees by way of a random forest small tweak that decorrelates the trees. As in bagging, we build a number of decision trees on bootstrapped training samples",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As in bagging, we build a number of decision trees on bootstrapped training samples. But when building these decision trees, each time a split in a tree is considered, a random sample of m predictors is chosen as split candidates from the full set of p predictors. The split is allowed to use only one of those m predictors. A fresh s am ple of m predictors is taken at each split, and typically we choose m ≈ √ p —that is, the number of predictors considered at each split is approximately equal to the square root of the total number of predictors (4 out of the 13 for the Heart data). In other words, in building a random forest, at each split in the tree, the algorithm is not even allowed to consider a majority of the available predictors. This may sound crazy, but it has a clever rationale. Suppose that there is one very strong predictor in the data set, along with a nuber of other moderately strong predictors. Then in the collection of bagged trees, most or all of the trees will use this strong predictor in the top split. Consequently, all of the bagged trees will look quite similar to each other. Hence the predictions from the bagged trees will be highly correlated. Ufortunately, averaging many highly correlated quantities does not lead to as large of a reduction in variance as averaging many uncorrelated quatities. In particular, this means that bagging will not lead to a substantial reduction in variance over a single tree in this setting. Random forests overcome this problem by forcing each split to consider only a subset of the predictors. Therefore, on average ( p − m ) /p of the splits will not even consider the strong predictor, and so other predictors will have more of a chance. We can think of this process as decorrelating the trees, thereby making the average of the resulting trees less variable and hence more reliable. The main difference between bagging and random forests is the choice of predictor subset size m",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The main difference between bagging and random forests is the choice of predictor subset size m . For instance, if a random forest is built using m = p , then this a mo unts simply to bagging. On the Heart data, random forests using m = √ p leads to a reduction in both test error and OOB error over bagging (Figure 8.8 ). Using a small value of m in building a random forest will typically be helpful when we have a large number of correlated predictors. We applied random forests to a high-dimensional biological data set consisting of epression measurements of 4,718 genes measured on tissue samples from 349 patients. There are around 20,000 genes in humans, and individual genes have different levels of activity, or expression, in particular cells, tissues, and biological conditions. In this data set, each of the patient samples has a qualitative label with 15 different levels: either normal or 1 of 14 different types of cancer. Our goal was to use random forests to predict cancer type based on the 500 genes that have the largest variance in the training set. We randomly divided the observations into a training and a test set, and applied random forests to the training set for three different values of the number of splitting variables m . The results are shown in Figure 8.10 . The error rate of a single tree is 45 . 7 % , and the null rate is 75 . 4 % . 4 We see that using 400 trees is sufficient to give good performance, and that the choice m = √ p gave a small improvement in test error over bagging ( m = p ) in this example. As with bagging, random forests will not overfit if we increase B , so in practice we use a value of B sufficiently large for the error rate to have settled down. 8.2.3 Boosting We now discuss boosting , yet another approach for improving the prediboosting tions resulting from a decision tree. Like bagging, boosting is a general approach that can be applied to many statistical learning methods for rgression or classification",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Like bagging, boosting is a general approach that can be applied to many statistical learning methods for rgression or classification. Here we restrict our discussion of boosting to the context of decision trees. Recall that bagging involves creating multiple copies of the original traiing data set using the bootstrap, fitting a separate decision tree to each copy, and then combining all of the trees in order to create a single predi4 The null rate results from simply classifying each observation to the dominant class overall, which is in this case the normal class. 0 100 200 300 400 500 0.2 0.3 0.4 0.5 Number of Trees Test Classification Error m=p m=p/2 m= p FIGURE 8.10. Results from random forests for the 15-class gene expression data set with p = 500 predictors. The test error is displayed as a function of the number of trees. Each colored line corresponds to a different value of m , the number of predictors available for splitting at each interior tree node. Random forests ( m < p ) lead to a slight improvement over bagging ( m = p ). A single classification tree has an error rate of 45.7 %. tive model. Notably, each tree is built on a bootstrap data set, independent of the other trees. Boosting works in a similar way, except that the trees are grown sequentially : each tree is grown using information from previously grown trees. Boosting does not involve bootstrap sampling; instead each tree is fit on a modified version of the original data set. Consider first the regression setting. Like bagging, boosting involves cobining a large number of decision trees, ˆ f 1 , , ˆ f B . Boosting is described in Algorithm 8.2 . What is the idea behind this procedure? Unlike fitting a single large decsion tree to the data, which amounts to fitting the data hard and potentially overfitting, the boosting approach instead learns slowly . Given the current model, we fit a decision tree to the residuals from the model. That is, we fit a tree using the current residuals, rather than the outcome Y , as the rsponse",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Given the current model, we fit a decision tree to the residuals from the model. That is, we fit a tree using the current residuals, rather than the outcome Y , as the rsponse. We then add this new decision tree into the fitted function in order to update the residuals. Each of these trees can be rather small, with just a few terminal nodes, determined by the parameter d in the algorithm. By fitting small trees to the residuals, we slowly improve ˆ f in areas where it does not perform well. The shrinkage parameter λ slows the process down even further, allowing more and different shaped trees to attack the resiuals. In general, statistical learning approaches that learn slowly tend to perform well. Note that in boosting, unlike in bagging, the construction of each tree depends strongly on the trees that have already been grown. We have just described the process of boosting regression trees. Boosting classification trees proceeds in a similar but slightly more complex way, and the details are omitted here. Algorithm 8.2 Boosting for R egr essi o n Trees 1. Set ˆ f ( x ) = 0 and r i = y i for all i in the training set. 2. For b = 1 , 2 , , B , repeat: (a) Fit a tree ˆ f b with d splits ( d + 1 terminal nodes) to the training data ( X, r ) . (b) Update ˆ f by adding in a shrunken version of the new tree: ˆ f ( x ) ← ˆ f ( x ) + λ ˆ f b ( x ) . (8.10) (c) Update the residuals, r i ← r i − λ ˆ f b ( x i ) . (8.11) 3. Output the boosted model, ˆ f ( x ) = B 0 b =1 λ ˆ f b ( x ) . (8.12) Boosting has three tuning parameters: 1. The number of trees B . Unlike bagging and random forests, boosting can overfit if B is too large, although this overfitting tends to occur slowly if at all. We use cross-validation to select B . 2. The shrinkage parameter λ , a small positive number. This controls the rate at which boosting learns. Typical values are 0 . 01 or 0 . 001 , and the right choice can depend on the problem. Very small λ can require using a very large value of B in order to achieve good performance. 3",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Typical values are 0 . 01 or 0 . 001 , and the right choice can depend on the problem. Very small λ can require using a very large value of B in order to achieve good performance. 3. The number d of splits in each tree, which controls the complexity of the boosted ensemble. Often d = 1 works well, in which case each tree is a stump , consisting of a single split. In this case, the boosted stump ensemble is fitting an additive model, since each term involves only a single variable. More generally d is the interaction depth , and controls interaction depth the interaction order of the boosted model, since d splits can involve at most d variables. In Figure 8.11 , we applied boosting to the 15-class cancer gene expression data set, in order to develop a classifier that can distinguish the normal class from the 14 cancer classes. We display the test error as a function of the total number of trees and the interaction depth d . We see that simple stumps with an interaction depth of one perform well if enough of them are included. This model outperforms the depth-two model, and both ouperform a random forest. This highlights one difference between boosting and random forests: in boosting, because the growth of a particular tree takes into account the other trees that have already been grown, smaller 0 1000 2000 3000 4000 5000 0.05 0.10 0.15 0.20 0.25 Number of Trees Test Classification Error Boosting: depth=1 Boosting: depth=2 RandomForest: m= p FIGURE 8.11. Results from performing boosting and random forests on the 15-class gene expression data set in order to predict cancer versus normal . The test error is displayed as a function of the number of trees. For the two boosted models, λ = 0 . 01 . Depth-1 trees slightly outperform depth-2 trees, and both outperform the random forest, although the standard errors are around 0.02, making none of these differences significant. The test error rate for a single tree is 24 %. trees are typically sufficient",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_19"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The test error rate for a single tree is 24 %. trees are typically sufficient. Using smaller trees can aid in interpretability as well; for instance, using stumps leads to an additive model. 8.2.4 Bayesian Additive Regression Trees Finally, we discuss Bayesian additive regression trees (BART), another eBayesian additive regression trees semble method that uses decision trees as its building blocks. For simplicity, we present BART for regression (as opposed to classification). Recall that bagging and random forests make predictions from an aveage of regression trees, each of which is built using a random sample of data and/or predictors. Each tree is built separately from the others. By cotrast, boosting uses a weighted sum of trees, each of which is constructed by fitting a tree to the residual of the current fit. Thus, each new tree atempts to capture signal that is not yet accounted for by the current set of trees. BART is related to both approaches: each tree is constructed in a random manner as in bagging and random forests, and each tree tries to capture signal not yet accounted for by the current model, as in boosting. The main novelty in BART is the way in which new trees are generated. Before we introduce the BART algorithm, we define some notation. We let K denote the number of regression trees, and B the number of iterations for which the BART algorithm will be run. The notation ˆ f b k ( x ) represents the prediction at x for the k th regression tree used in the b th iteration. At the end of each iteration, the K trees from that iteration will be summed, i.e. ˆ f b ( x ) = ) K k =1 ˆ f b k ( x ) for b = 1 , , B",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_20"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". At the end of each iteration, the K trees from that iteration will be summed, i.e. ˆ f b ( x ) = ) K k =1 ˆ f b k ( x ) for b = 1 , , B . In the first iteration of the BART algorithm, all trees are initialized to have a single root node, with ˆ f 1 k ( x ) = 1 nK ) n i =1 y i , the mean of the response (a): ˆ f b − 1 k ( X ) (b): Possibility #1 for ˆ f b k ( X ) | X < 169.17 X < 114.305 X < 140.35 −0.5031 0.2667 −0.2470 0.4079 | X < 169.17 X < 114.305 X < 140.35 −0.5110 0.2693 −0.2649 0.4221 (c): Possibility #2 for ˆ f b k ( X ) (d): Possibility #3 for ˆ f b k ( X ) | X < 169.17 −0.1218 0.4079 | X < 169.17 X < 114.305 X < 106.755 X < 140.35 −0.05089 −1.03100 0.26670 −0.24700 0.40790 FIGURE 8.12. A schematic of perturbed trees from the BART algorithm. (a): The k th tree at the ( b − 1) st iteration, ˆ f b − 1 k ( X ) , is displayed. Panels (b)–(d) display three of many possibilities for ˆ f b k ( X ) , given the form of ˆ f b − 1 k ( X ) . (b): One possibility is that ˆ f b k ( X ) has the same structure as ˆ f b − 1 k ( X ) , but with different predictions at the terminal nodes. (c): Another possibility is that ˆ f b k ( X ) results from pruning ˆ f b − 1 k ( X ) . (d): Alternatively, ˆ f b k ( X ) may have more terminal nodes than ˆ f b − 1 k ( X ) . values divided by the total number of trees. Thus, ˆ f 1 ( x ) = ) K k =1 ˆ f 1 k ( x ) = 1 n ) n i =1 y i . In subsequent iterations, BART updates each of the K trees, one at a time. In the b th iteration, to update the k th tree, we subtract from each response value the predictions from all but the k th tree, in order to obtain a partial residual r i = y i − 0 k ′ <k ˆ f b k ′ ( x i ) − 0 k ′ >k ˆ f b − 1 k ′ ( x i ) for the i th observation, i = 1 , , n . Rather than fitting a fresh tree to this partial residual, BART randomly chooses a perturbation to the tree from the previous iteration ( ˆ f b − 1 k ) from a set of possible perturbations, favoring ones that improve the fit to the partial residual. There are two components to this perturbation: 1",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_21"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". There are two components to this perturbation: 1. We may change the structure of the tree by adding or pruning branches. 2. We may change the prediction in each terminal node of the tree. Figure 8.12 illustrates examples of possible perturbations to a tree. The output of BART is a collection of prediction models, ˆ f b ( x ) = K 0 k =1 ˆ f b k ( x ) , for b = 1 , 2 , , B. Algorithm 8.3 Bayesian Addi t i ve R egression Trees 1. Let ˆ f 1 1 ( x ) = ˆ f 1 2 ( x ) = · · · = ˆ f 1 K ( x ) = 1 nK ) n i =1 y i . 2. Compute ˆ f 1 ( x ) = ) K k =1 ˆ f 1 k ( x ) = 1 n ) n i =1 y i . 3. For b = 2 , , B : (a) For k = 1 , 2 , , K : i. For i = 1 , , n , compute the current partial residual r i = y i − 0 k ′ <k ˆ f b k ′ ( x i ) − 0 k ′ >k ˆ f b − 1 k ′ ( x i ) . ii. Fit a new tree, ˆ f b k ( x ) , to r i , by randomly perturbing the k th tree from the previous iteration, ˆ f b − 1 k ( x ) . Perturbations that improve the fit are favored. (b) Compute ˆ f b ( x ) = ) K k =1 ˆ f b k ( x ) . 4. Compute the mean after L burn-in samples, ˆ f ( x ) = 1 B − L B 0 b = L +1 ˆ f b ( x ) . We typically throw away the first few of these prediction models, since models obtained in the earlier iterations — known as the burn-in period burn-in — tend not to provide very good results. We can let L denote the nuber of burn-in iterations; for instance, we might take L = 200 . Then, to obtain a single prediction, we simply take the average after the burn-in iterations, ˆ f ( x ) = 1 B − L ) B b = L +1 ˆ f b ( x ) . However, it is also possible to copute quantities other than the average: for instance, the percentiles of ˆ f L +1 ( x ) , , ˆ f B ( x ) provide a measure of uncertainty in the final predition. The overall BART procedure is summarized in Algorithm 8.3 . A key element of the BART approach is that in Step 3(a)ii., we do not fit a fresh tree to the current partial residual: instead, we try to improve the fit to the current partial residual by slightly modifying the tree obtained in the previous iteration (see Figure 8.12 )",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_22"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Roughly speaking, this guards against overfitting since it limits how “hard” we fit the data in each iteration. Furthermore, the individual trees are typically quite small. We limit the tree size in order to avoid overfitting the data, which would be more likely to occur if we grew very large trees. Figure 8.13 shows the result of applying BART to the Heart data, using K = 200 trees, as the number of iterations is increased to 10 , 000 . During the initial iterations, the test and training errors jump around a bit. After this initial burn-in period, the error rates settle down. We note that there is only a small difference between the training error and the test error, indicating that the tree perturbation process largely avoids overfitting. 5 10 50 100 500 5000 0.0 0.1 0.2 0.3 0.4 0.5 Number of Iterations Error BART Training Error BART Test Error Boosting Training Error Boosting Test Error FIGURE 8.13. BART and boosting results for the Heart data. Both training and test errors are displayed. After a burn-in period of 100 iterations (shown in gray), the error rates for BART settle down. Boosting begins to overfit after a few hundred iterations. The training and test errors for boosting are also displayed in Figure 8.13 . We see that the test error for boosting approaches that of BART, but then begins to increase as the number of iterations increases. Furthermore, the training error for boosting decreases as the number of iterations increases, indicating that boosting has overfit the data. Though the details are outside of the scope of this book, it turns out that the BART method can be viewed as a Bayesian approach to fitting an ensemble of trees: each time we randomly perturb a tree in order to fit the residuals, we are in fact drawing a new tree from a posterior distribution. (Of course, this Bayesian connection is the motivation for BART’s name.) Furthermore, Algorithm 8.3 can be viewed as a Markov chain Monte Carlo Markov chain Monte Carlo algorithm for fitting the BART model",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_23"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". When we apply BART, we must select the number of trees K , the number of iterations B , and the number of burn-in iterations L . We typically choose large values for B and K , and a moderate value for L : for instance, K = 200 , B = 1 , 000 , and L = 100 is a reasonable choice. BART has been shown to have very impressive out-of-box performance — that is, it performs well with minimal tuning. 8.2.5 Summary of Tree Ensemble Methods Trees are an attractive choice of weak learner for an ensemble method for a number of reasons, including their flexibility and ability to handle predictors of mixed types (i.e. qualitative as well as quantitative). We have now seen four approaches for fitting an ensemble of trees: bagging, random forests, boosting, and BART. • In bagging , the trees are grown independently on random samples of the observations. Consequently, the trees tend to be quite similar to each other. Thus, bagging can get caught in local optima and can fail to thoroughly explore the model space. • In random forests , the trees are once again grown independently on random samples of the observations. However, each split on each tree is performed using a random subset of the features, thereby decorrlating the trees, and leading to a more thorough exploration of model space relative to bagging. • In boosting , we only use the original data, and do not draw any radom samples. The trees are grown successively, using a “slow” learing approach: each new tree is fit to the signal that is left over from the earlier trees, and shrunken down before it is used. • In BART , we once again only make use of the original data, and we grow the trees successively. However, each tree is perturbed in order to avoid local minima and achieve a more thorough exploration of the model space. 8.3 Lab: Tree-Based Methods We import some of our usual libraries at this top level",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_24"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 8.3 Lab: Tree-Based Methods We import some of our usual libraries at this top level. In [1]: import numpy as np import pandas as pd from matplotlib.pyplot import subplots from statsmodels.datasets import get_rdataset import sklearn.model_selection as skm from ISLP import load_data, confusion_table from ISLP.models import ModelSpec as MS We also collect the new imports needed for this lab. In [2]: from sklearn.tree import (DecisionTreeClassifier as DTC, DecisionTreeRegressor as DTR, plot_tree, export_text) from sklearn.metrics import (accuracy_score , log_loss) from sklearn.ensemble import \\ (RandomForestRegressor as RF, GradientBoostingRegressor as GBR) from ISLP.bart import BART 8.3.1 Fitting Classification Trees We first use classification trees to analyze the Carseats data set. In these data, Sales is a continuous variable, and so we begin by recoding it as a binary variable. We use the where() function to create a variable, called where() High , which takes on a value of Yes if the Sales variable exceeds 8, and takes on a value of No otherwise. In [3]: Carseats = load_data( 'Carseats' ) High = np.where(Carseats.Sales > 8, \"Yes\" , \"No\" ) We now use DecisionTreeClassifier() to fit a classification tree in order DecisionTree Classifier() to predict High using all variables but Sales . To do so, we must form a model matrix as we did when fitting regression models. In [4]: model = MS(Carseats.columns.drop( 'Sales' ), intercept=False) D = model.fit_transform(Carseats) feature_names = list(D.columns) X = np.asarray(D) We have converted D from a data frame to an array X , which is needed in some of the analysis below. We also need the feature_names for annotating our plots later. There are several options needed to specify the classifier, such as max_depth (how deep to grow the tree), min_samples_split (minimum number of oservations in a node to be eligible for splitting) and criterion (whether to use Gini or cross-entropy as the split criterion)",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_25"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We also set random_state for reproducibility; ties in the split criterion are broken at random. In [5]: clf = DTC(criterion= 'entropy' , max_depth=3, random_state=0) clf.fit(X, High) Out[5]: DecisionTreeClassifier(criterion= 'entropy' , max_depth=3) In our discussion of qualitative features in Section 3.3 , we noted that for a linear regression model such a feature could be represented by including a matrix of dummy variables (one-hot-encoding) in the model matrix, using the formula notation of statsmodels . As mentioned in Section 8.1 , there is a more natural way to handle qualitative features when building a decision tree, that does not require such dummy variables; each split amounts to partitioning the levels into two groups. However, the sklearn implementtion of decision trees does not take advantage of this approach; instead it simply treats the one-hot-encoded levels as separate variables. In [6]: accuracy_score(High, clf.predict(X)) Out[6]: 0.7275 With only the default arguments, the training error rate is 21%. For clasification trees, we can access the value of the deviance using log_loss() , log_loss() − 2 0 m 0 k n mk log ˆ p mk , where n mk is the number of observations in the m th terminal node that belong to the k th class. In [7]: resid_dev = np.sum(log_loss(High, clf.predict_proba(X))) resid_dev Out[7]: 0.4711 This is closely related to the entropy , defined in ( 8.7 ). A small deviance indicates a tree that provides a good fit to the (training) data. One of the most attractive properties of trees is that they can be graphcally displayed. Here we use the plot() function to display the tree structure (not shown here). In [8]: ax = subplots(figsize=(12,12))[1] plot_tree(clf, feature_names=feature_names , ax=ax); The most important indicator of Sales appears to be ShelveLoc . We can see a text representation of the tree using export_text() , which export_text() displays the split criterion (e.g. Price <= 92.5 ) for each branch. For leaf nodes it shows the overall prediction ( Yes or No )",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_26"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Price <= 92.5 ) for each branch. For leaf nodes it shows the overall prediction ( Yes or No ). We can also see the number of observations in that leaf that take on values of Yes and No by specifying show_weights=True . In [9]: print(export_text(clf, feature_names=feature_names , show_weights=True)) Out[9]: |--- ShelveLoc[Good] <= 0.50 | |--- Price <= 92.50 | | |--- Income <= 57.00 | | | |--- weights: [7.00, 3.00] class: No | | |--- Income > 57.00 | | | |--- weights: [7.00, 29.00] class: Yes | |--- Price > 92.50 | | |--- Advertising <= 13.50 | | | |--- weights: [183.00, 41.00] class: No | | |--- Advertising > 13.50 | | | |--- weights: [20.00, 25.00] class: Yes |--- ShelveLoc[Good] > 0.50 | |--- Price <= 135.00 | | |--- US[Yes] <= 0.50 | | | |--- weights: [6.00, 11.00] class: Yes | | |--- US[Yes] > 0.50 | | | |--- weights: [2.00, 49.00] class: Yes | |--- Price > 135.00 | | |--- Income <= 46.00 | | | |--- weights: [6.00, 0.00] class: No | | |--- Income > 46.00 | | | |--- weights: [5.00, 6.00] class: Yes In order to properly evaluate the performance of a classification tree on these data, we must estimate the test error rather than simply computing the training error. We split the observations into a training set and a test set, build the tree using the training set, and evaluate its performance on the test data. This pattern is similar to that in Chapter 6 , with the linear models replaced here by decision trees — the code for validation is almost identical. This approach leads to correct predictions for 68.5% of the locations in the test data set. In [10]: validation = skm.ShuffleSplit(n_splits=1, test_size=200, random_state=0) results = skm.cross_validate(clf, D, High, cv=validation) results[ 'test_score' ] Out[10]: array([0.685]) Next, we consider whether pruning the tree might lead to improved clasification performance. We first split the data into a training and test set. We will use cross-validation to prune the tree on the training set, and then evaluate the performance of the pruned tree on the test set",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_27"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We first split the data into a training and test set. We will use cross-validation to prune the tree on the training set, and then evaluate the performance of the pruned tree on the test set. In [11]: (X_train, X_test, High_train, High_test) = skm.train_test_split(X, High, test_size=0.5, random_state=0) We first refit the full tree on the training set; here we do not set a max_depth parameter, since we will learn that through cross-validation. In [12]: clf = DTC(criterion= 'entropy' , random_state=0) clf.fit(X_train, High_train) accuracy_score(High_test, clf.predict(X_test)) Out[12]: 0.735 Next we use the cost_complexity_pruning_path() method of clf to extract cost_ complexity_ pruning_ path() cost-complexity values. In [13]: ccp_path = clf.cost_complexity_pruning_path(X_train, High_train) kfold = skm.KFold(10, random_state=1, shuffle=T rue) This yields a set of impurities and α values from which we can extract an optimal one by cross-validation. In [14]: grid = skm.GridSearchCV(clf, { 'ccp_alpha' : ccp_path.ccp_alphas}, refit=True, cv=kfold, scoring= 'accuracy' ) grid.fit(X_train, High_train) grid.best_score_ Out[14]: 0.685 Let’s take a look at the pruned true. In [15]: ax = subplots(figsize=(12, 12))[1] best_ = grid.best_estimator_ plot_tree(best_, feature_names=feature_names , ax=ax); This is quite a bushy tree. We could count the leaves, or query best_ instead. In [16]: best_.tree_.n_leaves Out[16]: 30 The tree with 30 terminal nodes results in the lowest cross-validation error rate, with an accuracy of 68.5%. How well does this pruned tree perform on the test data set? Once again, we apply the predict() function. In [17]: print(accuracy_score(High_test, best_.predict(X_test))) confusion = confusion_table(best_.predict(X_test), High_test) confusion Out[17]: 0.72 Truth No Yes Predicted No 108 61 Yes 10 21 Now 72.0% of the test observations are correctly classified, which is slightly worse than the error for the full tree (with 35 leaves)",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_28"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". So crosvalidation has not helped us much here; it only pruned off 5 leaves, at a cost of a slightly worse error. These results would change if we were to change the random number seeds above; even though cross-validation gives an unbiased approach to model selection, it does have variance. 8.3.2 Fitting Regression Trees Here we fit a regression tree to the Boston data set. The steps are similar to those for classification trees. In [18]: Boston = load_data( \"Boston\" ) model = MS(Boston.columns.drop( 'medv' ), intercept=False) D = model.fit_transform(Boston) feature_names = list(D.columns) X = np.asarray(D) First, we split the data into training and test sets, and fit the tree to the training data. Here we use 30% of the data for the test set. In [19]: (X_train, X_test, y_train, y_test) = skm.train_test_split(X, Boston[ 'medv' ], test_size=0.3, random_state=0) Having formed our training and test data sets, we fit the regression tree. In [20]: reg = DTR(max_depth=3) reg.fit(X_train, y_train) ax = subplots(figsize=(12,12))[1] plot_tree(reg, feature_names=feature_names , ax=ax); The variable lstat measures the percentage of individuals with lower socioeconomic status. The tree indicates that lower values of lstat corrspond to more expensive houses. The tree predicts a median house price of $12,042 for small-sized homes ( rm < 6.8 ), in suburbs in which residents have low socioeconomic status ( lstat > 14.4 ) and the crime-rate is moerate ( crim > 5.8 ). Now we use the cross-validation function to see whether pruning the tree will improve performance. In [21]: ccp_path = reg.cost_complexity_pruning_path(X_train, y_train) kfold = skm.KFold(5, shuffle=True, random_state=10) grid = skm.GridSearchCV(reg, { 'ccp_alpha' : ccp_path.ccp_alphas}, refit=True, cv=kfold, scoring= 'neg_mean_squared_error' ) G = grid.fit(X_train, y_train) In keeping with the cross-validation results, we use the pruned tree to make predictions on the test set",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_29"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [22]: best_ = grid.best_estimator_ np.mean((y_test - best_.predict(X_test))**2) Out[22]: 28.07 In other words, the test set MSE associated with the regression tree is 28.07. The square root of the MSE is therefore around 5.30, indicating that this model leads to test predictions that are within around $5300 of the true median home value for the suburb. Let’s plot the best tree to see how interpretable it is. In [23]: ax = subplots(figsize=(12,12))[1] plot_tree(G.best_estimator_ , feature_names=feature_names , ax=ax); 8.3.3 Bagging and Random Forests Here we apply bagging and random forests to the Boston data, using the RandomForestRegressor() from the sklearn.ensemble package. Recall that RandomForest Regressor() sklearn. ensemble bagging is simply a special case of a random forest with m = p . Therefore, the RandomForestRegressor() function can be used to perform both bagging and random forests. We start with bagging. In [24]: bag_boston = RF(max_features=X_train.shape[1], random_state=0) bag_boston.fit(X_train, y_train) Out[24]: RandomForestRegressor(max_features=12, random_state=0) The argument max_features indicates that all 12 predictors should be considered for each split of the tree — in other words, that bagging should be done. How well does this bagged model perform on the test set? In [25]: ax = subplots(figsize=(8,8))[1] y_hat_bag = bag_boston.predict(X_test) ax.scatter(y_hat_bag, y_test) np.mean((y_test - y_hat_bag)**2) Out[25]: 14.63 The test set MSE associated with the bagged regression tree is 14.63, about half that obtained using an optimally-pruned single tree. We could change the number of trees grown from the default of 100 by using the n_estimators argument: In [26]: bag_boston = RF(max_features=X_train.shape[1], n_estimators=500, random_state=0).fit(X_train, y_train) y_hat_bag = bag_boston.predict(X_test) np.mean((y_test - y_hat_bag)**2) Out[26]: 14.61 There is not much change",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_30"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Bagging and random forests cannot overfit by increasing the number of trees, but can underfit if the number is too small. Growing a random forest proceeds in exactly the same way, except that we use a smaller value of the max_features argument. By default, RandomForestRegressor() uses p variables when building a random forest of regres sio n trees (i.e. it defaults to bagging), and RandomForestClassifier() uses √ p variables when building a random forest of classification trees. Here we use max_features=6 . In [27]: RF_boston = RF(max_features=6, random_state=0).fit(X_train, y_train) y_hat_RF = RF_boston.predict(X_test) np.mean((y_test - y_hat_RF)**2) Out[27]: 20.04 The test set MSE is 20.04; this indicates that random forests did somwhat worse than bagging in this case. Extracting the feature_importances_ values from the fitted model, we can view the importance of each variable. In [28]: feature_imp = pd.DataFrame( { 'importance' :RF_boston.feature_importances_}, index=feature_names) feature_imp.sort_values(by= 'importance' , ascending=False) Out[28]: importance lstat 0.368683 rm 0.333842 ptratio 0.057306 indus 0.053303 crim 0.052426 dis 0.042493 nox 0.034410 age 0.024327 tax 0.022368 rad 0.005048 zn 0.003238 chas 0.002557 This is a relative measure of the total decrease in node impurity that results from splits over that variable, averaged over all trees (this was plotted in Figure 8.9 for a model fit to the Heart data). The results indicate that across all of the trees considered in the random forest, the wealth level of the community ( lstat ) and the house size ( rm ) are by far the two most important variables. 8.3.4 Boosting Here we use GradientBoostingRegressor() from sklearn.ensemble to fit Gradient Boosting Regressor() boosted regression trees to the Boston data set. For classification we would use GradientBoostingClassifier() . The argument n_estimators=5000 indGradient Boosting Classifier() cates that we want 5000 trees, and the option max_depth=3 limits the depth of each tree",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_31"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The argument n_estimators=5000 indGradient Boosting Classifier() cates that we want 5000 trees, and the option max_depth=3 limits the depth of each tree. The argument learning_rate is the λ mentioned earlier in the description of boosting. In [29]: boost_boston = GBR(n_estimators=5000, learning_rate=0.001, max_depth=3, random_state=0) boost_boston.fit(X_train, y_train) We can see how the training error decreases with the train_score_ atribute. To get an idea of how the test error decreases we can use the staged_predict() method to get the predicted values along the path. In [30]: test_error = np.zeros_like(boost_boston.train_score_) for idx, y_ in enumerate(boost_boston.staged_predict(X_test)): test_error[idx] = np.mean((y_test - y_)**2) plot_idx = np.arange(boost_boston.train_score_.shape[0]) ax = subplots(figsize=(8,8))[1] ax.plot(plot_idx, boost_boston.train_score_ , 'b' , label= 'Training' ) ax.plot(plot_idx, test_error, 'r' , label= 'Test' ) ax.legend(); We now use the boosted model to predict medv on the test set: In [31]: y_hat_boost = boost_boston.predict(X_test); np.mean((y_test - y_hat_boost)**2) Out[31]: 14.48 The test MSE obtained is 14.48, similar to the test MSE for bagging. If we want to, we can perform boosting with a different value of the shrinkage parameter λ in ( 8.10 ). The default value is 0.001, but this is easily modified. Here we take λ = 0 . 2 . In [32]: boost_boston = GBR(n_estimators=5000, learning_rate=0.2, max_depth=3, random_state=0) boost_boston.fit(X_train, y_train) y_hat_boost = boost_boston.predict(X_test); np.mean((y_test - y_hat_boo s t )* * 2 ) Out[32]: 14.50 In this case, using λ = 0 . 2 leads to a almost the same test MSE as when using λ = 0 . 001 . 8.3.5 Bayesian Additive Regression Trees In this section we demonstrate a Python implementation of BART found in the ISLP.bart package. We fit a model to the Boston housing data set",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_32"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 001 . 8.3.5 Bayesian Additive Regression Trees In this section we demonstrate a Python implementation of BART found in the ISLP.bart package. We fit a model to the Boston housing data set. This BART() estimator is designed for quantitative outcome variables, though BART() other implementations are available for fitting logistic and probit models to categorical outcomes. In [33]: bart_boston = BART(random_state=0, burnin=5, ndraw=15) bart_boston.fit(X_train, y_train) Out[33]: BART(burnin=5, ndraw=15, random_state=0) On this data set, with this split into test and training, we see that the test error of BART is similar to that of random forest. In [34]: yhat_test = bart_boston.predict(X_test.astype(np.float32)) np.mean((y_test - yhat_test)**2) Out[34]: 20.92 We can check how many times each variable appeared in the collection of trees. This gives a summary similar to the variable importance plot for boosting and random forests. In [35]: var_inclusion = pd.Series(bart_boston.variable_inclusion_.mean(0), index=D.columns) var_inclusion Out[35]: crim 25.333333 zn 27.000000 indus 21.266667 chas 20.466667 nox 25.400000 rm 32.400000 age 26.133333 dis 25.666667 rad 24.666667 tax 23.933333 ptratio 25.000000 lstat 31.866667 dtype: float64 8.4 Exercises Conceptual 1. Draw an example (of your own invention) of a partition of twdimensional feature space that could result from recursive binary splitting. Your example should contain at least six regions. Draw a decision tree corresponding to this partition. Be sure to label all apects of your figures, including the regions R 1 , R 2 , , the cutpoints t 1 , t 2 , , and so forth. Hint: Your result should look something like Figures 8.1 and 8.2 . 2. It is mentioned in Section 8.2.3 that boosting using depth-one trees (or stumps ) leads to an additive model: that is, a model of the form f ( X ) = p 0 j =1 f j ( X j ) . Explain why this is the case. You can begin with ( 8.12 ) in Algorithm 8.2 . 3",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_33"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Explain why this is the case. You can begin with ( 8.12 ) in Algorithm 8.2 . 3. Consider the Gini index, classification error, and entropy in a simple classification setting with two classes. Create a single plot that diplays each of these quantities as a function of ˆ p m 1 . The x -axis should display ˆ p m 1 , ranging from 0 to 1 , and the y -axis should display the value of the Gini index, classification error, and entropy. Hint: In a setting with two classes, ˆ p m 1 = 1 − ˆ p m 2 . You could make this plot by hand, but it will be much easier to make in R . 4. This question relates to the plots in Figure 8.14 . | X2 < 1 X1 < 1 X1 < 0 X2 < 2 -1.80 -1.06 0.21 0.63 2.49 5 15 10 0 3 0 1 X 2 X 1 0 1 FIGURE 8.14. Left : A partition of the predictor space corresponding to Execise 4a . Right : A tree corresponding to Exercise 4b . (a) Sketch the tree corresponding to the partition of the predictor space illustrated in the left-hand panel of Figure 8.14 . The nubers inside the boxes indicate the mean of Y within each region. (b) Create a diagram similar to the left-hand panel of Figure 8.14 , using the tree illustrated in the right-hand panel of the same figure. You should divide up the predictor space into the correct regions, and indicate the mean for each region. 5. Suppose we produce ten bootstrapped samples from a data set containing red and green classes. We then apply a classification tree to each bootstrapped sample and, for a specific value of X , produce 10 estimates of P ( Class is Red | X ) : 0 . 1 , 0 . 15 , 0 . 2 , 0 . 2 , 0 . 55 , 0 . 6 , 0 . 6 , 0 . 65 , 0 . 7 , and 0 . 75 . There are two common ways to combine these results together into a single class prediction. One is the majority vote approach discussed in this chapter. The second approach is to classify based on the average probability. In this example, what is the final classification under each of these two approaches? 6. Provide a detailed explanation of the algorithm that is used to fit a regression tree. Applied 7",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_34"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In this example, what is the final classification under each of these two approaches? 6. Provide a detailed explanation of the algorithm that is used to fit a regression tree. Applied 7. In Section 8.3.3 , we applied random forests to the Boston data using max_features = 6 and using n_estimators = 100 and n_estimators = 500 . Create a plot displaying the test error resulting from random forests on this data set for a more comprehensive range of values for max_features and n_estimators . You can model your plot after Figure 8.10 . Describe the results obtained. 8. In the lab, a classification tree was applied to the Carseats data set ater converting Sales into a qualitative response variable. Now we will seek to predict Sales using regression trees and related approaches, treating the response as a quantitative variable. (a) Split the data set into a training set and a test set. (b) Fit a regression tree to the training set. Plot the tree, and intepret the results. What test MSE do you obtain? (c) Use cross-validation in order to determine the optimal level of tree complexity. Does pruning the tree improve the test MSE? (d) Use the bagging approach in order to analyze this data. What test MSE do you obtain? Use the feature_importance_ values to determine which variables are most important. (e) Use random forests to analyze this data. What test MSE do you obtain? Use the feature_importance_ values to determine which variables are most important. Describe the effect of m , the number of variables considered at each split, on the error rate obtained. (f) Now analyze the data using BART, and report your results. 9. This problem involves the OJ data set which is part of the ISLP package. (a) Create a training set containing a random sample of 800 obsevations, and a test set containing the remaining observations. (b) Fit a tree to the training data, with Purchase as the response and the other variables as predictors. What is the training error rate? (c) Create a plot of the tree, and interpret the results",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_35"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (b) Fit a tree to the training data, with Purchase as the response and the other variables as predictors. What is the training error rate? (c) Create a plot of the tree, and interpret the results. How many terminal nodes does the tree have? (d) Use the export_tree() function to produce a text summary of the fitted tree. Pick one of the terminal nodes, and interpret the information displayed. (e) Predict the response on the test data, and produce a confusion matrix comparing the test labels to the predicted test labels. What is the test error rate? (f) Use cross-validation on the training set in order to determine the optimal tree size. (g) Produce a plot with tree size on the x -axis and cross-validated classification error rate on the y -axis. (h) Which tree size corresponds to the lowest cross-validated classfication error rate? (i) Produce a pruned tree corresponding to the optimal tree size obtained using cross-validation. If cross-validation does not lead to selection of a pruned tree, then create a pruned tree with five terminal nodes. (j) Compare the training error rates between the pruned and upruned trees. Which is higher? (k) Compare the test error rates between the pruned and unpruned trees. Which is higher? 10. We now use boosting to predict Salary in the Hitters data set. (a) Remove the observations for whom the salary information is unknown, and then log-transform the salaries. (b) Create a training set consisting of the first 200 observations, and a test set consisting of the remaining observations. (c) Perform boosting on the training set with 1,000 trees for a range of values of the shrinkage parameter λ . Produce a plot with different shrinkage values on the x -axis and the corresponding training set MSE on the y -axis. (d) Produce a plot with different shrinkage values on the x -axis and the corresponding test set MSE on the y -axis. (e) Compare the test MSE of boosting to the test MSE that results from applying two of the regression approaches seen in Chapters 3 and 6",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_36"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (e) Compare the test MSE of boosting to the test MSE that results from applying two of the regression approaches seen in Chapters 3 and 6 . (f) Which variables appear to be the most important predictors in the boosted model? (g) Now apply bagging to the training set. What is the test set MSE for this approach? 11. This question uses the Caravan data set. (a) Create a training set consisting of the first 1,000 observations, and a test set consisting of the remaining observations. (b) Fit a boosting model to the training set with Purchase as the response and the other variables as predictors. Use 1,000 trees, and a shrinkage value of 0 . 01 . Which predictors appear to be the most important? (c) Use the boosting model to predict the response on the test data. Predict that a person will make a purchase if the estimated proability of purchase is greater than 20 % . Form a confusion mtrix. What fraction of the people predicted to make a purchase do in fact make one? How does this compare with the results obtained from applying KNN or logistic regression to this data set? 12. Apply boosting, bagging, random forests, and BART to a data set of your choice. Be sure to fit the models on a training set and to evaluate their performance on a test set. How accurate are the results compared to simple methods like linear or logistic regression? Which of these approaches yields the best performance? 9 Support Vector Machines In this chapter, we discuss the support vector machine (SVM), an approach for classification that was developed in the computer science community in the 1990s and that has grown in popularity since then. SVMs have been shown to perform well in a variety of settings, and are often considered one of the best “out of the box” classifiers. The support vector machine is a generalization of a simple and intitive classifier called the maximal margin classifier , which we introduce in Section 9.1",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_37"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The support vector machine is a generalization of a simple and intitive classifier called the maximal margin classifier , which we introduce in Section 9.1 . Though it is elegant and simple, we will see that this classifier unfortunately cannot be applied to most data sets, since it requires that the classes be separable by a linear boundary. In Section 9.2 , we introduce the support vector classifier , an extension of the maximal margin classifier that can be applied in a broader range of cases. Section 9.3 introduces the support vector machine , which is a further extension of the support vetor classifier in order to accommodate non-linear class boundaries. Support vector machines are intended for the binary classification setting in which there are two classes; in Section 9.4 we discuss extensions of support vector machines to the case of more than two classes. In Section 9.5 we discuss the close connections between support vector machines and other statistical methods such as logistic regression. People often loosely refer to the maximal margin classifier, the support vector classifier, and the support vector machine as “support vector machines”. To avoid confusion, we will carefully distinguish between these three notions in this chapter. 9.1 Maximal Margin Classifier In this section, we define a hyperplane and introduce the concept of an optimal separating hyperplane. 367",
    "chunk_id": "an_introduction_to_statistical_learning_page-331-363.json_chunk_38"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "−1 0 1 2 3 −1 0 1 2 3 X 1 X 2 FIGURE 9.3. There are two classes of observations, shown in blue and in purple. The maximal margin hyperplane is shown as a solid line. The margin is the distance from the solid line to either of the dashed lines. The two blue points and the purple point that lie on the dashed lines are the support vectors, and the distance from those points to the hyperplane is indicated by arrows. The purple and blue grid indicates the decision rule made by a classifier based on this separating hyperplane. as the maximal margin classifier . We hope that a classifier that has a large maximal margin classifier margin on the training data will also have a large margin on the test data, and hence will classify the test observations correctly. Although the maxmal margin classifier is often successful, it can also lead to overfitting when p is large. If β 0 , β 1 , , β p are the coefficients of the maximal margin hyperplane, then the maximal margin classifier classifies the test observation x ∗ based on the sign of f ( x ∗ ) = β 0 + β 1 x ∗ 1 + β 2 x ∗ 2 + · · · + β p x ∗ p . Figure 9.3 shows the maximal margin hyperplane on the data set of Figure 9.2 . Comparing the right-hand panel of Figure 9.2 to Figure 9.3 , we see that the maximal margin hyperplane shown in Figure 9.3 does ideed result in a greater minimal distance between the observations and the separating hyperplane—that is, a larger margin. In a sense, the maximal margin hyperplane represents the mid-line of the widest “slab” that we can insert between the two classes. Examining Figure 9.3 , we see that three training observations are equiditant from the maximal margin hyperplane and lie along the dashed lines indicating the width of the margin. These three observations are known as support vectors , since they are vectors in p -dimensional space (in Figure 9.3 , support vector p = 2 ) and they “support” the maximal margin hyperplane in the sense that if these points were moved slightly then the maximal margin hypeplane would move as well",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Interestingly, the maximal margin hyperplane depends directly on the support vectors, but not on the other observations: a movement to any of the other observations would not affect the separating hyperplane, provided that the observation’s movement does not cause it to cross the boundary set by the margin. The fact that the maximal margin hyperplane depends directly on only a small subset of the observations is an important property that will arise later in this chapter when we discuss the support vector classifier and support vector machines. 9.1.4 Construction of the Maximal Margin Classifier We now consider the task of constructing the maximal margin hyperplane based on a set of n training observations x 1 , , x n ∈ R p and associated class labels y 1 , , y n ∈{− 1 , 1 } . Briefly, the maximal margin hyperplane is the solution to the optimization problem maximize β 0 ,β 1 ,,β p ,M M (9.9) subject to p 0 j =1 β 2 j = 1 , (9.10) y i ( β 0 + β 1 x i 1 + β 2 x i 2 + · · · + β p x ip ) ≥ M ∀ i = 1 , , n. (9.11) This optimization problem ( 9.9 )–( 9.11 ) is actually simpler than it looks. First of all, the constraint in ( 9.11 ) that y i ( β 0 + β 1 x i 1 + β 2 x i 2 + · · · + β p x ip ) ≥ M ∀ i = 1 , , n guarantees that each observation will be on the correct side of the hypeplane, provided that M is positive. (Actually, for each observation to be on the correct side of the hyperplane we would simply need y i ( β 0 + β 1 x i 1 + β 2 x i 2 + · · · + β p x ip ) > 0 , so the constraint in ( 9.11 ) in fact requires that each observation be on the correct side of the hyperplane, with some cushion, provided that M is positive.) Second, note that ( 9.10 ) is not really a constraint on the hyperplane, since if β 0 + β 1 x i 1 + β 2 x i 2 + · · · + β p x ip = 0 defines a hyperplane, then so does k ( β 0 + β 1 x i 1 + β 2 x i 2 + · · · + β p x ip ) = 0 for any k ̸ = 0",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, ( 9.10 ) adds meaning to ( 9.11 ); one can show that with this constraint the perpendicular distance from the i th observation to the hyperplane is given by y i ( β 0 + β 1 x i 1 + β 2 x i 2 + · · · + β p x ip ) . Therefore, the constraints ( 9.10 ) and ( 9.11 ) ensure that each observation is on the correct side of the hyperplane and at least a distance M from the hyperplane. Hence, M represents the margin of our hyperplane, and the optimization problem chooses β 0 , β 1 , , β p to maximize M . This is exactly the definition of the maximal margin hyperplane! The problem ( 9.9 )–( 9.11 ) can be solved efficiently, but details of this optimization are outside of the scope of this book. 9.1.5 The Non-separable Case The maximal margin classifier is a very natural way to perform classifcation, if a separating hyperplane exists . However, as we have hinted, in many cases no separating hyperplane exists, and so there is no maximal 0 1 2 3 −1.0 −0.5 0.0 0.5 1.0 1.5 2.0 X 1 X 2 FIGURE 9.4. There are two classes of observations, shown in blue and in purple. In this case, the two classes are not separable by a hyperplane, and so the maximal margin classifier cannot be used. margin classifier. In this case, the optimization problem ( 9.9 )–( 9.11 ) has no solution with M > 0 . An example is shown in Figure 9.4 . In this case, we cannot exactly separate the two classes. However, as we will see in the next section, we can extend the concept of a separating hyperplane in order to develop a hyperplane that almost separates the classes, using a so-called soft margin . The generalization of the maximal margin classifier to the non-separable case is known as the support vector classifier . 9.2 Support Vector Classifiers 9.2.1 Overview of the Support Vector Classifier In Figure 9.4 , we see that observations that belong to two classes are not necessarily separable by a hyperplane",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 9.2 Support Vector Classifiers 9.2.1 Overview of the Support Vector Classifier In Figure 9.4 , we see that observations that belong to two classes are not necessarily separable by a hyperplane. In fact, even if a separating hypeplane does exist, then there are instances in which a classifier based on a separating hyperplane might not be desirable. A classifier based on a separating hyperplane will necessarily perfectly classify all of the training observations; this can lead to sensitivity to individual observations. An eample is shown in Figure 9.5 . The addition of a single observation in the right-hand panel of Figure 9.5 leads to a dramatic change in the maxmal margin hyperplane. The resulting maximal margin hyperplane is not satisfactory—for one thing, it has only a tiny margin. This is problematic because as discussed previously, the distance of an observation from the hyperplane can be seen as a measure of our confidence that the obsevation was correctly classified. Moreover, the fact that the maximal magin hyperplane is extremely sensitive to a change in a single observation suggests that it may have overfit the training data. In this case, we might be willing to consider a classifier based on a hperplane that does not perfectly separate the two classes, in the interest of −1 0 1 2 3 −1 0 1 2 3 −1 0 1 2 3 −1 0 1 2 3 X 1 X 1 X 2 X 2 FIGURE 9.5. Left: Two classes of observations are shown in blue and in purple, along with the maximal margin hyperplane. Right: An additional blue observation has been added, leading to a dramatic shift in the maximal margin hyperplane shown as a solid line. The dashed line indicates the maximal margin hyperplane that was obtained in the absence of this additional point. • Greater robustness to individual observations, and • Better classification of most of the training observations. That is, it could be worthwhile to misclassify a few training observations in order to do a better job in classifying the remaining observations",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". That is, it could be worthwhile to misclassify a few training observations in order to do a better job in classifying the remaining observations. The support vector classifier , sometimes called a soft margin classifier , support vector classifier soft margin classifier does exactly this. Rather than seeking the largest possible margin so that every observation is not only on the correct side of the hyperplane but also on the correct side of the margin, we instead allow some observations to be on the incorrect side of the margin, or even the incorrect side of the hyperplane. (The margin is soft because it can be violated by some of the training observations.) An example is shown in the left-hand panel of Figure 9.6 . Most of the observations are on the correct side of the margin. However, a small subset of the observations are on the wrong side of the margin. An observation can be not only on the wrong side of the margin, but also on the wrong side of the hyperplane. In fact, when there is no separating hyperplane, such a situation is inevitable. Observations on the wrong side of the hyperplane correspond to training observations that are misclassified by the support vector classifier. The right-hand panel of Figure 9.6 illustrates such a scenario. 9.2.2 Details of the Support Vector Classifier The support vector classifier classifies a test observation depending on which side of a hyperplane it lies. The hyperplane is chosen to correctly separate most of the training observations into the two classes, but may −0.5 0.0 0.5 1.0 1.5 2.0 2.5 −1 0 1 2 3 4 1 2 3 4 5 6 7 8 9 10 −0.5 0.0 0.5 1.0 1.5 2.0 2.5 −1 0 1 2 3 4 1 2 3 4 5 6 7 8 9 10 11 12 X 1 X 1 X 2 X 2 FIGURE 9.6. Left: A support vector classifier was fit to a small data set. The hyperplane is shown as a solid line and the margins are shown as dashed lines. Purple observations: Observations 3 , 4 , 5 , and 6 are on the correct side of the margin, observation 2 is on the margin, and observation 1 is on the wrong side of the margin",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Purple observations: Observations 3 , 4 , 5 , and 6 are on the correct side of the margin, observation 2 is on the margin, and observation 1 is on the wrong side of the margin. Blue observations: Observations 7 and 10 are on the correct side of the margin, observation 9 is on the margin, and observation 8 is on the wrong side of the margin. No observations are on the wrong side of the hyperplane. Right: Same as left panel with two additional points, 11 and 12 . These two observations are on the wrong side of the hyperplane and the wrong side of the margin. misclassify a few observations. It is the solution to the optimization problem maximize β 0 ,β 1 ,,β p ,ε 1 ,,ε n , M M (9.12) subject to p 0 j =1 β 2 j = 1 , (9.13) y i ( β 0 + β 1 x i 1 + β 2 x i 2 + · · · + β p x ip ) ≥ M (1 − ε i ) , (9.14) ε i ≥ 0 , n 0 i =1 ε i ≤ C, (9.15) where C is a nonnegative tuning parameter. As in ( 9.11 ), M is the width of the margin; we seek to make this quantity as large as possible. In ( 9.14 ), ε 1 , , ε n are slack variables that allow individual observations to be on slack variable the wrong side of the margin or the hyperplane; we will explain them in greater detail momentarily. Once we have solved ( 9.12 )–( 9.15 ), we classify a test observation x ∗ as before, by simply determining on which side of the hyperplane it lies. That is, we classify the test observation based on the sign of f ( x ∗ ) = β 0 + β 1 x ∗ 1 + · · · + β p x ∗ p . The problem ( 9.12 )–( 9.15 ) seems complex, but insight into its behavior can be made through a series of simple observations presented below. First of all, the slack variable ε i tells us where the i th observation is located, relative to the hyperplane and relative to the margin. If ε i = 0 then the i th observation is on the correct side of the margin, as we saw in Section 9.1.4 . If ε i > 0 then the i th observation is on the wrong side of the margin, and we say that the i th observation has violated the margin. If ε i > 1 then it is on the wrong side of the hyperplane",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". If ε i > 0 then the i th observation is on the wrong side of the margin, and we say that the i th observation has violated the margin. If ε i > 1 then it is on the wrong side of the hyperplane. We now consider the role of the tuning parameter C . In ( 9.15 ), C bounds the sum of the ε i ’s, and so it determines the number and severity of the vilations to the margin (and to the hyperplane) that we will tolerate. We can think of C as a budget for the amount that the margin can be violated by the n observations. If C = 0 then there is no budget for violations to the margin, and it must be the case that ε 1 = · · · = ε n = 0 , in which case ( 9.12 )–( 9.15 ) simply amounts to the maximal margin hyperplane optimiztion problem ( 9.9 )–( 9.11 ). (Of course, a maximal margin hyperplane exists only if the two classes are separable.) For C > 0 no more than C observtions can be on the wrong side of the hyperplane, because if an observation is on the wrong side of the hyperplane then ε i > 1 , and ( 9.15 ) requires that ) n i =1 ε i ≤ C . As the budget C increases, we become more tolerant of violations to the margin, and so the margin will widen. Conversely, as C decreases, we become less tolerant of violations to the margin and so the margin narrows. An example is shown in Figure 9.7 . In practice, C is treated as a tuning parameter that is generally chosen via cross-validation. As with the tuning parameters that we have seen througout this book, C controls the bias-variance trade-off of the statistical learing technique. When C is small, we seek narrow margins that are rarely violated; this amounts to a classifier that is highly fit to the data, which may have low bias but high variance. On the other hand, when C is larger, the margin is wider and we allow more violations to it; this amounts to fitting the data less hard and obtaining a classifier that is potentially more biased but may have lower variance",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The optimization problem ( 9.12 )–( 9.15 ) has a very interesting property: it turns out that only observations that either lie on the margin or that violate the margin will affect the hyperplane, and hence the classifier otained. In other words, an observation that lies strictly on the correct side of the margin does not affect the support vector classifier! Changing the position of that observation would not change the classifier at all, provided that its position remains on the correct side of the margin. Observations that lie directly on the margin, or on the wrong side of the margin for their class, are known as support vectors . These observations do affect the support vector classifier. The fact that only support vectors affect the classifier is in line with our previous assertion that C controls the bias-variance trade-off of the support vector classifier. When the tuning parameter C is large, then the margin is wide, many observations violate the margin, and so there are many support vectors. In this case, many observations are involved in determining the hyperplane. The top left panel in Figure 9.7 illustrates this setting: this classifier has low variance (since many observations are support vectors) but potentially high bias. In contrast, if C is small, then there will be fewer support vectors and hence the resulting classifier will have low bias but high variance. The bottom right panel in Figure 9.7 illustrates this setting, with only eight support vectors. The fact that the support vector classifier’s decision rule is based only on a potentially small subset of the training observations (the support vetors) means that it is quite robust to the behavior of observations that are far away from the hyperplane. This property is distinct from some of −1 0 1 2 −3 −2 −1 0 1 2 3 −1 0 1 2 −3 −2 −1 0 1 2 3 −1 0 1 2 −3 −2 −1 0 1 2 3 −1 0 1 2 −3 −2 −1 0 1 2 3 X 1 X 1 X 1 X 1 X 2 X 2 X 2 X 2 FIGURE 9.7",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This property is distinct from some of −1 0 1 2 −3 −2 −1 0 1 2 3 −1 0 1 2 −3 −2 −1 0 1 2 3 −1 0 1 2 −3 −2 −1 0 1 2 3 −1 0 1 2 −3 −2 −1 0 1 2 3 X 1 X 1 X 1 X 1 X 2 X 2 X 2 X 2 FIGURE 9.7. A support vector classifier was fit using four different values of the tuning parameter C in ( 9.12 )–( 9.15 ). The largest value of C was used in the top left panel, and smaller values were used in the top right, bottom left, and bottom right panels. When C is large, then there is a high tolerance for observations being on the wrong side of the margin, and so the margin will be large. As C decreases, the tolerance for observations being on the wrong side of the margin decreases, and the margin narrows. the other classification methods that we have seen in preceding chapters, such as linear discriminant analysis. Recall that the LDA classification rule depends on the mean of all of the observations within each class, as well as the within-class covariance matrix computed using all of the observations. In contrast, logistic regression, unlike LDA, has very low sensitivity to oservations far from the decision boundary. In fact we will see in Section 9.5 that the support vector classifier and logistic regression are closely related. 9.3 Support Vector Machines We first discuss a general mechanism for converting a linear classifier into one that produces non-linear decision boundaries. We then introduce the support vector machine, which does this in an automatic way. −4 −2 0 2 4 −4 −2 0 2 4 −4 −2 0 2 4 −4 −2 0 2 4 X 1 X 1 X 2 X 2 FIGURE 9.8. Left: The observations fall into two classes, with a non-liear boundary between them. Right: The support vector classifier seeks a linear boundary, and consequently performs very poorly. 9.3.1 Classification with Non-Linear Decision Boundaries The support vector classifier is a natural approach for classification in the two-class setting, if the boundary between the two classes is linear. Hoever, in practice we are sometimes faced with non-linear class boundaries",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Hoever, in practice we are sometimes faced with non-linear class boundaries. For instance, consider the data in the left-hand panel of Figure 9.8 . It is clear that a support vector classifier or any linear classifier will perform poorly here. Indeed, the support vector classifier shown in the right-hand panel of Figure 9.8 is useless here. In Chapter 7 , we are faced with an analogous situation. We see there that the performance of linear regression can suffer when there is a nolinear relationship between the predictors and the outcome. In that case, we consider enlarging the feature space using functions of the predictors, such as quadratic and cubic terms, in order to address this non-linearity. In the case of the support vector classifier, we could address the prolem of possibly non-linear boundaries between classes in a similar way, by enlarging the feature space using quadratic, cubic, and even higher-order polynomial functions of the predictors. For instance, rather than fitting a support vector classifier using p features X 1 , X 2 , , X p , we could instead fit a support vector classifier using 2 p features X 1 , X 2 1 , X 2 , X 2 2 , , X p , X 2 p . Then ( 9.12 )–( 9.15 ) would become maximize β 0 ,β 11 ,β 12 ,,β p 1 ,β p 2 ,ε 1 ,,ε n , M M (9.16) subject to y i   β 0 + p 0 j =1 β j 1 x ij + p 0 j =1 β j 2 x 2 ij   ≥ M (1 − ε i ) , n 0 i =1 ε i ≤ C, ε i ≥ 0 , p 0 j =1 2 0 k =1 β 2 jk = 1 . Why does this lead to a non-linear decision boundary? In the enlarged feature space, the decision boundary that results from ( 9.16 ) is in fact liear. But in the original feature space, the decision boundary is of the form q ( x ) = 0 , where q is a quadratic polynomial, and its solutions are geneally non-linear. One might additionally want to enlarge the feature space with higher-order polynomial terms, or with interaction terms of the form X j X j ′ for j ̸ = j ′ . Alternatively, other functions of the predictors could be considered rather than polynomials",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Alternatively, other functions of the predictors could be considered rather than polynomials. It is not hard to see that there are many possible ways to enlarge the feature space, and that unless we are careful, we could end up with a huge number of features. Then comptations would become unmanageable. The support vector machine, which we present next, allows us to enlarge the feature space used by the support vector classifier in a way that leads to efficient computations. 9.3.2 The Support Vector Machine The support vector machine (SVM) is an extension of the support vector support vector machine classifier that results from enlarging the feature space in a specific way, using kernels . We will now discuss this extension, the details of which are kernel somewhat complex and beyond the scope of this book. However, the main idea is described in Section 9.3.1 : we may want to enlarge our feature space in order to accommodate a non-linear boundary between the classes. The kernel approach that we describe here is simply an efficient computational approach for enacting this idea. We have not discussed exactly how the support vector classifier is coputed because the details become somewhat technical. However, it turns out that the solution to the support vector classifier problem ( 9.12 )–( 9.15 ) involves only the inner products of the observations (as opposed to the observations themselves). The inner product of two r -vectors a and b is defined as ⟨ a, b ⟩ = ) r i =1 a i b i . Thus the inner product of two observations x i , x i ′ is given by ⟨ x i , x i ′ ⟩ = p 0 j =1 x ij x i ′ j . (9.17) It can be shown that • The linear support vector classifier can be represented as f ( x ) = β 0 + n 0 i =1 α i ⟨ x, x i ⟩ , (9.18) where there are n parameters α i , i = 1 , , n , one per training observation. • To estimate the parameters α 1 , , α n and β 0 , all we need are the ' n 2 ( inner products ⟨ x i , x i ′ ⟩ between all pairs of training observations",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". • To estimate the parameters α 1 , , α n and β 0 , all we need are the ' n 2 ( inner products ⟨ x i , x i ′ ⟩ between all pairs of training observations. (The notation ' n 2 ( means n ( n − 1) / 2 , and gives the number of pairs among a set of n items.) Notice that in ( 9.18 ), in order to evaluate the function f ( x ) , we need to compute the inner product between the new point x and each of the training points x i . However, it turns out that α i is nonzero only for the support vectors in the solution—that is, if a training observation is not a support vector, then its α i equals zero. So if S is the collection of indices of these support points, we can rewrite any solution function of the form ( 9.18 ) as f ( x ) = β 0 + 0 i ∈S α i ⟨ x, x i ⟩ , (9.19) which typically involves far fewer terms than in ( 9.18 ). 2 To summarize, in representing the linear classifier f ( x ) , and in computing its coefficients, all we need are inner products. Now suppose that every time the inner product ( 9.17 ) appears in the representation ( 9.18 ), or in a calculation of the solution for the support vector classifier, we replace it with a generalization of the inner product of the form K ( x i , x i ′ ) , (9.20) where K is some function that we will refer to as a kernel . A kernel is a kernel function that quantifies the similarity of two observations. For instance, we could simply take K ( x i , x i ′ ) = p 0 j =1 x ij x i ′ j , (9.21) which would just give us back the support vector classifier. Equation 9.21 is known as a linear kernel because the support vector classifier is linear in the features; the linear kernel essentially quantifies the similarity of a pair of observations using Pearson (standard) correlation. But one could instead choose another form for ( 9.20 ). For instance, one could replace every instance of ) p j =1 x ij x i ′ j with the quantity K ( x i , x i ′ ) = (1 + p 0 j =1 x ij x i ′ j ) d . (9.22) This is known as a polynomial kernel of degree d , where d is a positive polynomial kernel integer",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (9.22) This is known as a polynomial kernel of degree d , where d is a positive polynomial kernel integer. Using such a kernel with d > 1 , instead of the standard linear kernel ( 9.21 ), in the support vector classifier algorithm leads to a much more flexible decision boundary. It essentially amounts to fitting a support vector 2 By expanding each of the inner products in ( 9.19 ), it is easy to see that f ( x ) is a linear function of the coordinates of x . Doing so also establishes the correspondence between the α i and the original parameters β j . −4 −2 0 2 4 −4 −2 0 2 4 −4 −2 0 2 4 −4 −2 0 2 4 X 1 X 1 X 2 X 2 FIGURE 9.9. Left: An SVM with a polynomial kernel of degree 3 is applied to the non-linear data from Figure 9.8 , resulting in a far more appropriate decision rule. Right: An SVM with a radial kernel is applied. In this example, either kernel is capable of capturing the decision boundary. classifier in a higher-dimensional space involving polynomials of degree d , rather than in the original feature space. When the support vector classifier is combined with a non-linear kernel such as ( 9.22 ), the resulting classifier is known as a support vector machine. Note that in this case the (non-linear) function has the form f ( x ) = β 0 + 0 i ∈S α i K ( x, x i ) . (9.23) The left-hand panel of Figure 9.9 shows an example of an SVM with a polynomial kernel applied to the non-linear data from Figure 9.8 . The fit is a substantial improvement over the linear support vector classifier. When d = 1 , then the SVM reduces to the support vector classifier seen earlier in this chapter. The polynomial kernel shown in ( 9.22 ) is one example of a possible non-linear kernel, but alternatives abound. Another popular choice is the radial kernel , which takes the form radial kernel K ( x i , x i ′ ) = exp( − γ p 0 j =1 ( x ij − x i ′ j ) 2 ) . (9.24) In ( 9.24 ), γ is a positive constant",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Another popular choice is the radial kernel , which takes the form radial kernel K ( x i , x i ′ ) = exp( − γ p 0 j =1 ( x ij − x i ′ j ) 2 ) . (9.24) In ( 9.24 ), γ is a positive constant. The right-hand panel of Figure 9.9 shows an example of an SVM with a radial kernel on this non-linear data; it also does a good job in separating the two classes. How does the radial kernel ( 9.24 ) actually work? If a given test obsevation x ∗ = ( x ∗ 1 , , x ∗ p ) T is far from a training observation x i in terms of Euclidean distance, then ) p j =1 ( x ∗ j − x ij ) 2 will be large, and so K ( x ∗ , x i ) = exp( − γ ) p j =1 ( x ∗ j − x ij ) 2 ) will be tiny. This means that in ( 9.23 ), x i will play virtually no role in f ( x ∗ ) . Recall that the predicted class label for the test observation x ∗ is based on the sign of f ( x ∗ ) . In other words, training observations that are far from x ∗ will play essentially no role in the prdicted class label for x ∗ . This means that the radial kernel has very local False positive rate True positive rate 0.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0 Support Vector Classifier LDA False positive rate True positive rate 0.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0 Support Vector Classifier SVM: γ =10 − 3 SVM: γ =10 − 2 SVM: γ =10 − 1 FIGURE 9.10. ROC curves for the Heart data training set. Left: The support vector classifier and LDA are compared. Right: The support vector classifier is compared to an SVM using a radial basis kernel with γ = 10 − 3 , 10 − 2 , and 10 − 1 . behavior, in the sense that only nearby training observations have an effect on the class label of a test observation. What is the advantage of using a kernel rather than simply enlarging the feature space using functions of the original features, as in ( 9.16 )? One advantage is computational, and it amounts to the fact that using kernels, one need only compute K ( x i , x ′ i ) for all ' n 2 ( distinct pairs i, i ′ . This can be done without explicitly working in the enlarged feature space",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This can be done without explicitly working in the enlarged feature space. This is iportant because in many applications of SVMs, the enlarged feature space is so large that computations are intractable. For some kernels, such as the radial kernel ( 9.24 ), the feature space is implicit and infinite-dimensional, so we could never do the computations there anyway! 9.3.3 An Application to the Heart Disease Data In Chapter 8 we apply decision trees and related methods to the Heart data. The aim is to use 13 predictors such as Age , Sex , and Chol in order to predict whether an individual has heart disease. We now investigate how an SVM compares to LDA on this data. After removing 6 missing observations, the data consist of 297 subjects, which we randomly split into 207 training and 90 test observations. We first fit LDA and the support vector classifier to the training data. Note that the support vector classifier is equivalent to an SVM using a polnomial kernel of degree d = 1 . The left-hand panel of Figure 9.10 displays ROC curves (described in Section 4.4.2 ) for the training set predictions for both LDA and the support vector classifier. Both classifiers compute scores of the form ˆ f ( X ) = ˆ β 0 + ˆ β 1 X 1 + ˆ β 2 X 2 + · · · + ˆ β p X p for each observation. For any given cutoff t , we classify observations into the heart disease or no heart disease categories depending on whether ˆ f ( X ) < t or ˆ f ( X ) ≥ t . The ROC curve is obtained by forming these predictions and computing the false positive and true positive rates for a range of values of t . An optmal classifier will hug the top left corner of the ROC plot. In this instance False positive rate True positive rate 0.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0 Support Vector Classifier LDA False positive rate True positive rate 0.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0 Support Vector Classifier SVM: γ =10 − 3 SVM: γ =10 − 2 SVM: γ =10 − 1 FIGURE 9.11. ROC curves for the test set of the Heart data",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". ROC curves for the test set of the Heart data. Left: The support vector classifier and LDA are compared. Right: The support vector classifier is compared to an SVM using a radial basis kernel with γ = 10 − 3 , 10 − 2 , and 10 − 1 . LDA and the support vector classifier both perform well, though there is a suggestion that the support vector classifier may be slightly superior. The right-hand panel of Figure 9.10 displays ROC curves for SVMs using a radial kernel, with various values of γ . As γ increases and the fit becomes more non-linear, the ROC curves improve. Using γ = 10 − 1 appears to give an almost perfect ROC curve. However, these curves represent training error rates, which can be misleading in terms of performance on new test data. Figure 9.11 displays ROC curves computed on the 90 test observtions. We observe some differences from the training ROC curves. In the left-hand panel of Figure 9.11 , the support vector classifier appears to have a small advantage over LDA (although these differences are not statistcally significant). In the right-hand panel, the SVM using γ = 10 − 1 , which showed the best results on the training data, produces the worst estimates on the test data. This is once again evidence that while a more flexible method will often produce lower training error rates, this does not necesarily lead to improved performance on test data. The SVMs with γ = 10 − 2 and γ = 10 − 3 perform comparably to the support vector classifier, and all three outperform the SVM with γ = 10 − 1 . 9.4 SVMs with More than Two Classes So far, our discussion has been limited to the case of binary classification: that is, classification in the two-class setting. How can we extend SVMs to the more general case where we have some arbitrary number of classes? It turns out that the concept of separating hyperplanes upon which SVMs are based does not lend itself naturally to more than two classes",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Though a number of proposals for extending SVMs to the K -class case have been made, the two most popular are the one-versus-one and one-versus-all approaches. We briefly discuss those two approaches here. 9.4.1 One-Versus-One Classification Suppose that we would like to perform classification using SVMs, and there are K > 2 classes. A one-versus-one or all-pairs approach constructs ' K 2 ( one-versuone SVMs, each of which compares a pair of classes. For example, one such SVM might compare the k th class, coded as +1 , to the k ′ th class, coded as − 1 . We classify a test observation using each of the ' K 2 ( classifiers, and we tally the number of times that the test observation is assigned to each of the K classes. The final classification is performed by assigning the test observation to the class to which it was most frequently assigned in these ' K 2 ( pairwise classifications. 9.4.2 One-Versus-All Classification The one-versus-all approach (also referred to as one-versus-rest ) is an aone-versuall one-versurest ternative procedure for applying SVMs in the case of K > 2 classes. We fit K SVMs, each time comparing one of the K classes to the remaining K − 1 classes. Let β 0 k , β 1 k , , β pk denote the parameters that result from fitting an SVM comparing the k th class (coded as +1 ) to the others (coded as − 1 ). Let x ∗ denote a test observation. We assign the observation to the class for which β 0 k + β 1 k x ∗ 1 + β 2 k x ∗ 2 + · · · + β pk x ∗ p is largest, as this amounts to a high level of confidence that the test observation belongs to the k th class rather than to any of the other classes. 9.5 Relationship to Logistic Regression When SVMs were first introduced in the mid-1990s, they made quite a splash in the statistical and machine learning communities. This was due in part to their good performance, good marketing, and also to the fact that the underlying approach seemed both novel and mysterious",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This was due in part to their good performance, good marketing, and also to the fact that the underlying approach seemed both novel and mysterious. The idea of finding a hyperplane that separates the data as well as possible, while alowing some violations to this separation, seemed distinctly different from classical approaches for classification, such as logistic regression and liear discriminant analysis. Moreover, the idea of using a kernel to expand the feature space in order to accommodate non-linear class boundaries apeared to be a unique and valuable characteristic. However, since that time, deep connections between SVMs and other more classical statistical methods have emerged. It turns out that one can rewrite the criterion ( 9.12 )–( 9.15 ) for fitting the support vector classifier f ( X ) = β 0 + β 1 X 1 + · · · + β p X p as minimize β 0 ,β 1 ,,β p    n 0 i =1 max [0 , 1 − y i f ( x i )] + λ p 0 j =1 β 2 j    , (9.25) where λ is a nonnegative tuning parameter. When λ is large then β 1 , , β p are small, more violations to the margin are tolerated, and a low-variance but high-bias classifier will result. When λ is small then few violations to the margin will occur; this amounts to a high-variance but low-bias classifier. Thus, a small value of λ in ( 9.25 ) amounts to a small value of C in ( 9.15 ). Note that the λ ) p j =1 β 2 j term in ( 9.25 ) is the ridge penalty term from Section 6.2.1 , and plays a similar role in controlling the bias-variance trade-off for the support vector classifier. Now ( 9.25 ) takes the “Loss + Penalty” form that we have seen repeatedly throughout this book: minimize β 0 ,β 1 ,,β p { L ( X , y , β ) + λP ( β ) } . (9.26) In ( 9.26 ), L ( X , y , β ) is some loss function quantifying the extent to which the model, parametrized by β , fits the data ( X , y ) , and P ( β ) is a penalty function on the parameter vector β whose effect is controlled by a nonneative tuning parameter λ",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For instance, ridge regression and the lasso both take this form with L ( X , y , β ) = n 0 i =1   y i − β 0 − p 0 j =1 x ij β j   2 and with P ( β ) = ) p j =1 β 2 j for ridge regression and P ( β ) = ) p j =1 | β j | for the lasso. In the case of ( 9.25 ) the loss function instead takes the form L ( X , y , β ) = n 0 i =1 max [0 , 1 − y i ( β 0 + β 1 x i 1 + · · · + β p x ip )] . This is known as hinge loss , and is depicted in Figure 9.12 . However, it hinge loss turns out that the hinge loss function is closely related to the loss function used in logistic regression, also shown in Figure 9.12 . An interesting characteristic of the support vector classifier is that only support vectors play a role in the classifier obtained; observations on the correct side of the margin do not affect it. This is due to the fact that the loss function shown in Figure 9.12 is exactly zero for observations for which y i ( β 0 + β 1 x i 1 + · · · + β p x ip ) ≥ 1 ; these correspond to observations that are on the correct side of the margin. 3 In contrast, the loss function for logistic regression shown in Figure 9.12 is not exactly zero anywhere. But it is very small for observations that are far from the decision boundary. Due to the similarities between their loss functions, logistic regression and the support vector classifier often give very similar results. When the classes are well separated, SVMs tend to behave better than logistic regression; in more overlapping regimes, logistic regression is often preferred. When the support vector classifier and SVM were first introduced, it was thought that the tuning parameter C in ( 9.15 ) was an unimportant “nusance” parameter that could be set to some default value, like 1. However, the “Loss + Penalty” formulation ( 9.25 ) for the support vector classifier indicates that this is not the case. The choice of tuning parameter is very important and determines the extent to which the model underfits or ovefits the data, as illustrated, for example, in Figure 9.7",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_19"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The choice of tuning parameter is very important and determines the extent to which the model underfits or ovefits the data, as illustrated, for example, in Figure 9.7 . 3 With this hinge-loss + penalty representation, the margin corresponds to the value one, and the width of the margin is determined by ! β 2 j . −6 −4 −2 0 2 0 2 4 6 8 Loss SVM Loss Logistic Regression Loss y i ( β 0 + β 1 x i 1 + + β p x ip ) FIGURE 9.12. The SVM and logistic regression loss functions are compared, as a function of y i ( β 0 + β 1 x i 1 + · · · + β p x ip ) . When y i ( β 0 + β 1 x i 1 + · · · + β p x ip ) is greater than 1, then the SVM loss is zero, since this corresponds to an observation that is on the correct side of the margin. Overall, the two loss functions have quite similar behavior. We have established that the support vector classifier is closely related to logistic regression and other preexisting statistical methods. Is the SVM unique in its use of kernels to enlarge the feature space to accommodate non-linear class boundaries? The answer to this question is “no”. We could just as well perform logistic regression or many of the other classification methods seen in this book using non-linear kernels; this is closely related to some of the non-linear approaches seen in Chapter 7 . However, for hitorical reasons, the use of non-linear kernels is much more widespread in the context of SVMs than in the context of logistic regression or other methods. Though we have not addressed it here, there is in fact an extension of the SVM for regression (i.e. for a quantitative rather than a qualittive response), called support vector regression . In Chapter 3 , we saw that support vector regression least squares regression seeks coefficients β 0 , β 1 , , β p such that the sum of squared residuals is as small as possible",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_20"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In Chapter 3 , we saw that support vector regression least squares regression seeks coefficients β 0 , β 1 , , β p such that the sum of squared residuals is as small as possible. (Recall from Chapter 3 that residuals are defined as y i − β 0 − β 1 x i 1 −· · · − β p x ip .) Support vector regression instead seeks coefficients that minimize a different type of loss, where only residuals larger in absolute value than some positive constant contribute to the loss function. This is an extension of the margin used in support vector classifiers to the regression setting. 9.6 Lab: Support Vector Machines In this lab, we use the sklearn.svm library to demonstrate the support vector classifier and the support vector machine. We import some of our usual libraries. In [1]: import numpy as np from matplotlib.pyplot import subplots, cm import sklearn.model_selection as skm from ISLP import load_data, confusion_table We also collect the new imports needed for this lab. In [2]: from sklearn.svm import SVC from ISLP.svm import plot as plot_svm from sklearn.metrics import RocCurveDisplay We will use the function RocCurveDisplay.from_estimator() to produce RocCurve Display.from_ estimator() several ROC plots, using a shorthand roc_curve . In [3]: roc_curve = RocCurveDisplay.from_estimator # shorthand 9.6.1 Support Vector Classifier We now use the SupportVectorClassifier() function (abbreviated SVC() ) SupportVector Classifier() from sklearn to fit the support vector classifier for a given value of the parameter C . The C argument allows us to specify the cost of a violation to the margin. When the cost argument is small, then the margins will be wide and many support vectors will be on the margin or will violate the margin. When the C argument is large, then the margins will be narrow and there will be few support vectors on the margin or violating the margin. Here we demonstrate the use of SVC() on a two-dimensional example, so that we can plot the resulting decision boundary",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_21"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Here we demonstrate the use of SVC() on a two-dimensional example, so that we can plot the resulting decision boundary. We begin by generating the observations, which belong to two classes, and checking whether the classes are linearly separable. In [4]: rng = np.random.default_rng(1) X = rng.standard_normal((50, 2)) y = np.array([-1]*25+[1]*25) X[y==1] += 1 fig, ax = subplots(figsize=(8,8)) ax.scatter(X[:,0], X[:,1], c=y, cmap=cm.coolwarm); They are not. We now fit the classifier. In [5]: svm_linear = SVC(C=10, kernel= 'linear' ) svm_linear.fit(X, y) Out[5]: SVC(C=10, kernel= 'linear' ) The support vector classifier with two features can be visualized by ploting values of its decision function . We have included a function for this in decision function the ISLP package (inspired by a similar example in the sklearn docs). In [6]: fig, ax = subplots(figsize=(8,8)) plot_svm(X, y, svm_linear, ax=ax) The decision boundary between the two classes is linear (because we used the argument kernel='linear' ). The support vectors are marked with + and the remaining observations are plotted as circles. What if we instead used a smaller value of the cost parameter? In [7]: svm_linear_small = SVC(C=0.1, kernel= 'linear' ) svm_linear_small.fit(X, y) fig, ax = subplots(figsize=(8,8)) plot_svm(X, y, svm_linear_small , ax=ax) With a smaller value of the cost parameter, we obtain a larger number of support vectors, because the margin is now wider. For linear kernels, we can extract the coefficients of the linear decision boundary as follows: In [8]: svm_linear.coef_ Out[8]: array([[1.173 , 0.7734]]) Since the support vector machine is an estimator in sklearn , we can use the usual machinery to tune it. In [9]: kfold = skm.KFold(5, random_state=0, shuffle=True) grid = skm.GridSearchCV(svm_linear, { 'C' :[0.001,0.01,0.1,1,5,10,100]}, refit=True, cv=kfold, scoring= 'accuracy' ) grid.fit(X, y) grid.best_params_ Out[9]: { 'C' : 1} We can easily access the cross-validation errors for each of these models in grid.cv_results_",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_22"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This prints out a lot of detail, so we extract the accuracy results only. In [10]: grid.cv_results_[( 'mean_test_score' )] Out[10]: array([0.46, 0.46, 0.72, 0.74, 0.74, 0.74, 0.74]) We see that C=1 results in the highest cross-validation accuracy of 0.74, though the accuracy is the same for several values of C . The classifier grid.best_estimator_ can be used to predict the class label on a set of test observations. Let’s generate a test data set. In [11]: X_test = rng.standard_normal((20, 2)) y_test = np.array([-1]*10+[1]*10) X_test[y_test==1] += 1 Now we predict the class labels of these test observations. Here we use the best model selected by cross-validation in order to make the predictions. In [12]: best_ = grid.best_estimator_ y_test_hat = best_.predict(X_test) confusion_table(y_test_hat , y_test) Out[12]: Truth -1 1 Predicted -1 8 4 1 2 6 Thus, with this value of C , 70% of the test observations are correctly clasified. What if we had instead used C=0.001 ? In [13]: svm_ = SVC(C=0.001, kernel= 'linear' ).fit(X, y) y_test_hat = svm_.predict(X_test) confusion_table(y_test_hat , y_test) Out[13]: Truth -1 1 Predicted -1 2 0 1 8 10 In this case 60% of test observations are correctly classified. We now consider a situation in which the two classes are linearly seprable. Then we can find an optimal separating hyperplane using the SVC() estimator. We first further separate the two classes in our simulated data so that they are linearly separable: In [14]: X[y==1] += 1.9; fig, ax = subplots(figsize=(8,8)) ax.scatter(X[:,0], X[:,1], c=y, cmap=cm.coolwarm); Now the observations are just barely linearly separable. In [15]: svm_ = SVC(C=1e5, kernel= 'linear' ).fit(X, y) y_hat = svm_.predict(X) confusion_table(y_hat, y) Out[15]: Truth -1 1 Predicted -1 25 0 1 0 25 We fit the support vector classifier and plot the resulting hyperplane, using a very large value of C so that no observations are misclassified",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_23"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [16]: fig, ax = subplots(figsize=(8,8)) plot_svm(X, y, svm_, ax=ax) Indeed no training errors were made and only three support vectors were used. In fact, the large value of C also means that these three support points are on the margin , and define it. One may wonder how good the classifier could be on test data that depends on only three data points! We now try a smaller value of C . In [17]: svm_ = SVC(C=0.1, kernel= 'linear' ).fit(X, y) y_hat = svm_.predict(X) confusion_table(y_hat, y) Out[17]: Truth -1 1 Predicted -1 25 0 1 0 25 Using C=0.1 , we again do not misclassify any training observations, but we also obtain a much wider margin and make use of twelve support vectors. These jointly define the orientation of the decision boundary, and since there are more of them, it is more stable. It seems possible that this model will perform better on test data than the model with C=1e5 (and indeed, a simple experiment with a large test set would bear this out). In [18]: fig, ax = subplots(figsize=(8,8)) plot_svm(X, y, svm_, ax=ax) 9.6.2 Support Vector Machine In order to fit an SVM using a non-linear kernel, we once again use the SVC() estimator. However, now we use a different value of the parameter kernel . To fit an SVM with a polynomial kernel we use kernel=\"poly\" , and to fit an SVM with a radial kernel we use kernel=\"rbf\" . In the former case we also use the degree argument to specify a degree for the polynomial kernel (this is d in ( 9.22 )), and in the latter case we use gamma to specify a value of γ for the radial basis kernel ( 9.24 ). We first generate some data with a non-linear class boundary, as follows: In [19]: X = rng.standard_normal((200, 2)) X[:100] += 2 X[100:150] -= 2 y = np.array([1]*150+[2]*50) Plotting the data makes it clear that the class boundary is indeed nolinear. In [20]: fig, ax = subplots(figsize=(8,8)) ax.scatter(X[:,0], X[:,1], c=y, cmap=cm.coolwarm) Out[20]: <matplotlib.collections.PathCollection at 0x7faa9ba52eb0 > The data is randomly split into training and testing groups",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_24"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We then fit the training data using the SVC() estimator with a radial kernel and γ = 1 : In [21]: (X_train, X_test, y_train, y_test) = skm.train_test_split(X, y, test_size=0.5, random_state=0) svm_rbf = SVC(kernel= \"rbf\" , gamma=1, C=1) svm_rbf.fit(X_train, y_tra in) The plot shows that the resulting SVM has a decidedly non-linear bounary. In [22]: fig, ax = subplots(figsize=(8,8)) plot_svm(X_train, y_train, svm_rbf, ax=ax) We can see from the figure that there are a fair number of training errors in this SVM fit. If we increase the value of C , we can reduce the number of training errors. However, this comes at the price of a more irregular decision boundary that seems to be at risk of overfitting the data. In [23]: svm_rbf = SVC(kernel= \"rbf\" , gamma=1, C=1e5) svm_rbf.fit(X_train, y_train) fig, ax = subplots(figsize=(8,8)) plot_svm(X_train, y_train, svm_rbf, ax=ax) We can perform cross-validation using skm.GridSearchCV() to select the best choice of γ and C for an SVM with a radial kernel: In [24]: kfold = skm.KFold(5, random_state=0, shuffle=True) grid = skm.GridSearchCV(svm_rbf, { 'C' :[0.1,1,10,100,1000], 'gamma' :[0.5,1,2,3,4]}, refit=True, cv=kfold, scoring= 'accuracy' ); grid.fit(X_train, y_train) grid.best_params_ Out[24]: { 'C' : 100, 'gamma' : 1} The best choice of parameters under five-fold CV is achieved at C=1 and gamma=0.5 , though several other values also achieve the same value. In [25]: best_svm = grid.best_estimator_ fig, ax = subplots(figsize=(8,8)) plot_svm(X_train, y_train, best_svm, ax=ax) y_hat_test = best_svm.predict(X_test) confusion_table(y_hat_test , y_test) Out[25]: Truth 1 2 Predicted 1 69 6 2 6 19 With these parameters, 12% of test observations are misclassified by this SVM. 9.6.3 ROC Curves SVMs and support vector classifiers output class labels for each observation. However, it is also possible to obtain fitted values for each observation, which are the numerical scores used to obtain the class labels",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_25"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, it is also possible to obtain fitted values for each observation, which are the numerical scores used to obtain the class labels. For instance, in the case of a support vector classifier, the fitted value for an observation X = ( X 1 , X 2 , , X p ) T takes the form ˆ β 0 + ˆ β 1 X 1 + ˆ β 2 X 2 + + ˆ β p X p . For an SVM with a non-linear kernel, the equation that yields the fitted value is given in ( 9.23 ). The sign of the fitted value determines on which side of the decision boundary the observation lies. Therefore, the relationship between the fitted value and the class prediction for a given observation is simple: if the fitted value exceeds zero then the observation is assigned to one class, and if it is less than zero then it is assigned to the other. By changing this threshold from zero to some positive value, we skew the classifications in favor of one class versus the other. By considering a range of these thresholds, positive and negative, we produce the ingredients for a ROC plot. We can access these values by calling the decision_function() .function_ decision() method of a fitted SVM estimator. The function ROCCurveDisplay.from_estimator() (which we have abbrviated to roc_curve() ) will produce a plot of a ROC curve. It takes a fitted roc_curve() estimator as its first argument, followed by a model matrix X and labels y . The argument name is used in the legend, while color is used for the color of the line. Results are plotted on our axis object ax . In [26]: fig, ax = subplots(figsize=(8,8)) roc_curve(best_svm, X_train, y_train, name= 'Training' , color= 'r' , ax=ax); In this example, the SVM appears to provide accurate predictions. By increasing γ we can produce a more flexible fit and generate further iprovements in accuracy",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_26"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". By increasing γ we can produce a more flexible fit and generate further iprovements in accuracy. In [27]: svm_flex = SVC(kernel= \"rbf\" , gamma=50, C=1) svm_flex.fit(X_train, y_train) fig, ax = subplots(figsize=(8,8)) roc_curve(svm_flex, X_train, y_train, name= 'Training $\\gamma=50$' , color= 'r' , ax=ax); However, these ROC curves are all on the training data. We are really more interested in the level of prediction accuracy on the test data. When we compute the ROC curves on the test data, the model with γ = 0 . 5 appears to provide the most accurate results. In [28]: roc_curve(svm_flex, X_test, y_test, name= 'Test $\\gamma=50$' , color= 'b' , ax=ax) fig; Let’s look at our tuned SVM. In [29]: fig, ax = subplots(figsize=(8,8)) for (X_, y_, c, name) in zip( (X_train, X_test), (y_train, y_test), ( 'r' , 'b' ), ( 'CV tuned on training' , 'CV tuned on test' )): roc_curve(best_svm, X_, y_, name=name, ax=ax, color=c) 9.6.4 SVM with Multiple Classes If the response is a factor containing more than two levels, then the SVC() function will perform multi-class classification using either the one-versuone approach (when decision_function_shape=='ovo' ) or one-versus-rest 4 (when decision_function_shape=='ovr' ). We explore that setting briefly here by generating a third class of observations. In [30]: rng = np.random.default_rng(123) X = np.vstack([X, rng.standard_normal((50, 2))]) y = np.hstack([y, [0]*50]) X[y==0,1] += 2 fig, ax = subplots(figsize=(8,8)) ax.scatter(X[:,0], X[:,1], c =y , c m a p=cm.coolwarm); 4 One-versus-rest is also known as one-versus-all. We now fit an SVM to the data: In [31]: svm_rbf_3 = SVC(kernel= \"rbf\" , C=10, gamma=1, decision_function_shape= 'ovo' ); svm_rbf_3.fit(X, y) fig, ax = subplots(figsize=(8,8)) plot_svm(X, y, svm_rbf_3, scatter_cmap=cm.tab10, ax=ax) The sklearn.svm library can also be used to perform support vector rgression with a numerical response using the estimator SupportVectoRegression()",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_27"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". SupportVector Regression() 9.6.5 Application to Gene Expression Data We now examine the Khan data set, which consists of a number of tissue samples corresponding to four distinct types of small round blue cell tmors. For each tissue sample, gene expression measurements are available. The data set consists of training data, xtrain and ytrain , and testing data, xtest and ytest . We examine the dimension of the data: In [32]: Khan = load_data( 'Khan' ) Khan[ 'xtrain' ].shape, Khan[ 'xtest' ].shape Out[32]: ((63, 2308), (20, 2308)) This data set consists of expression measurements for 2,308 genes. The training and test sets consist of 63 and 20 observations, respectively. We will use a support vector approach to predict cancer subtype using gene expression measurements. In this data set, there is a very large number of features relative to the number of observations. This suggests that we should use a linear kernel, because the additional flexibility that will result from using a polynomial or radial kernel is unnecessary. In [33]: khan_linear = SVC(kernel= 'linear' , C=10) khan_linear.fit(Khan[ 'xtrain' ], Khan[ 'ytrain' ]) confusion_table(khan_linear.predict(Khan[ 'xtrain' ]), Khan[ 'ytrain' ]) Out[33]: Truth 1 2 3 4 Predicted 1 8 0 0 0 2 0 23 0 0 3 0 0 12 0 4 0 0 0 20 We see that there are no training errors. In fact, this is not surprising, because the large number of variables relative to the number of observations implies that it is easy to find hyperplanes that fully separate the classes. We are more interested in the support vector classifier’s performance on the test observations. In [34]: confusion_table(khan_linear.predict(Khan[ 'xtest' ]), Khan[ 'ytest' ]) Out[34]: Truth 1 2 3 4 Predicted 1 3 0 0 0 2 0 6 2 0 3 0 0 4 0 4 0 0 0 5 We see that using C=10 yields two test set errors on these data. 9.7 Exercises Conceptual 1. This problem involves hyperplanes in two dimensions. (a) Sketch the hyperplane 1 + 3 X 1 − X 2 = 0",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_28"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 9.7 Exercises Conceptual 1. This problem involves hyperplanes in two dimensions. (a) Sketch the hyperplane 1 + 3 X 1 − X 2 = 0 . Indicate the set of points for which 1 + 3 X 1 − X 2 > 0 , as well as the set of points for which 1 + 3 X 1 − X 2 < 0 . (b) On the same plot, sketch the hyperplane − 2 + X 1 + 2 X 2 = 0 . Indicate the set of points for which − 2 + X 1 + 2 X 2 > 0 , as well as the set of points for which − 2 + X 1 + 2 X 2 < 0 . 2. We have seen that in p = 2 dimensions, a linear decision boundary takes the form β 0 + β 1 X 1 + β 2 X 2 = 0 . We now investigate a non-linear decision boundary. (a) Sketch the curve (1 + X 1 ) 2 + (2 − X 2 ) 2 = 4 . (b) On your sketch, indicate the set of points for which (1 + X 1 ) 2 + (2 − X 2 ) 2 > 4 , as well as the set of points for which (1 + X 1 ) 2 + (2 − X 2 ) 2 ≤ 4 . (c) Suppose that a classifier assigns an observation to the blue class if (1 + X 1 ) 2 + (2 − X 2 ) 2 > 4 , and to the red class otherwise. To what class is the observation (0 , 0) classified? ( − 1 , 1) ? (2 , 2) ? (3 , 8) ? (d) Argue that while the decision boundary in (c) is not linear in terms of X 1 and X 2 , it is linear in terms of X 1 , X 2 1 , X 2 , and X 2 2 . 3. Here we explore the maximal margin classifier on a toy data set. (a) We are given n = 7 observations in p = 2 dimensions. For each observation, there is an associated class label. Obs. X 1 X 2 Y 1 3 4 Red 2 2 2 Red 3 4 4 Red 4 1 4 Red 5 2 1 Blue 6 4 3 Blue 7 4 1 Blue Sketch the observations. (b) Sketch the optimal separating hyperplane, and provide the eqution for this hyperplane (of the form ( 9.1 )). (c) Describe the classification rule for the maximal margin classifier. It should be something along the lines of “Classify to Red if β 0 + β 1 X 1 + β 2 X 2 > 0 , and classify to Blue otherwise.” Provide the values for β 0 , β 1 , and β 2 . (d) On your sketch, indicate the margin for the maximal margin hyperplane. (e) Indicate the support vectors for the maximal margin classifier",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_29"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (d) On your sketch, indicate the margin for the maximal margin hyperplane. (e) Indicate the support vectors for the maximal margin classifier. (f) Argue that a slight movement of the seventh observation would not affect the maximal margin hyperplane. (g) Sketch a hyperplane that is not the optimal separating hypeplane, and provide the equation for this hyperplane. (h) Draw an additional observation on the plot so that the two classes are no longer separable by a hyperplane. Applied 4. Generate a simulated two-class data set with 100 observations and two features in which there is a visible but non-linear separation btween the two classes. Show that in this setting, a support vector machine with a polynomial kernel (with degree greater than 1) or a radial kernel will outperform a support vector classifier on the traiing data. Which technique performs best on the test data? Make plots and report training and test error rates in order to back up your assertions. 5. We have seen that we can fit an SVM with a non-linear kernel in order to perform classification using a non-linear decision boundary. We will now see that we can also obtain a non-linear decision boundary by performing logistic regression using non-linear transformations of the features. (a) Generate a data set with n = 500 and p = 2 , such that the obsevations belong to two classes with a quadratic decision boundary between them. For instance, you can do this as follows: rng = np.random.default_rng(5) x1 = rng.uniform(size=500) - 0.5 x2 = rng.uniform(size=500) - 0.5 y = x1**2 - x2**2 > 0 (b) Plot the observations, colored according to their class labels. Your plot should display X 1 on the x -axis, and X 2 on the y - axis. (c) Fit a logistic regression model to the data, using X 1 and X 2 as predictors. (d) Apply this model to the training data in order to obtain a prdicted class label for each training observation. Plot the oservations, colored according to the predicted class labels. The decision boundary should be linear",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_30"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Plot the oservations, colored according to the predicted class labels. The decision boundary should be linear. (e) Now fit a logistic regression model to the data using non-linear functions of X 1 and X 2 as predictors (e.g. X 2 1 , X 1 × X 2 , log( X 2 ) , and so forth). (f) Apply this model to the training data in order to obtain a prdicted class label for each training observation. Plot the oservations, colored according to the predicted class labels. The decision boundary should be obviously non-linear. If it is not, then repeat (a)–(e) until you come up with an example in which the predicted class labels are obviously non-linear. (g) Fit a support vector classifier to the data with X 1 and X 2 as predictors. Obtain a class prediction for each training observtion. Plot the observations, colored according to the predicted class labels . (h) Fit a SVM using a non-linear kernel to the data. Obtain a class prediction for each training observation. Plot the observations, colored according to the predicted class labels . (i) Comment on your results. 6. At the end of Section 9.6.1 , it is claimed that in the case of data that is just barely linearly separable, a support vector classifier with a small value of C that misclassifies a couple of training observations may perform better on test data than one with a huge value of C that does not misclassify any training observations. You will now investigate this claim. (a) Generate two-class data with p = 2 in such a way that the classes are just barely linearly separable. (b) Compute the cross-validation error rates for support vector classifiers with a range of C values. How many training obsevations are misclassified for each value of C considered, and how does this relate to the cross-validation errors obtained? (c) Generate an appropriate test data set, and compute the test errors corresponding to each of the values of C considered",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_31"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Which value of C leads to the fewest test errors, and how does this compare to the values of C that yield the fewest training errors and the fewest cross-validation errors? (d) Discuss your results. 7. In this problem, you will use support vector approaches in order to predict whether a given car gets high or low gas mileage based on the Auto data set. (a) Create a binary variable that takes on a 1 for cars with gas mileage above the median, and a 0 for cars with gas mileage below the median. (b) Fit a support vector classifier to the data with various values of C , in order to predict whether a car gets high or low gas mileage. Report the cross-validation errors associated with different vaues of this parameter. Comment on your results. Note you will need to fit the classifier without the gas mileage variable to prduce sensible results. (c) Now repeat (b), this time using SVMs with radial and polynmial basis kernels, with different values of gamma and degree and C . Comment on your results. (d) Make some plots to back up your assertions in (b) and (c). Hint: In the lab, we used the plot_svm() function for fitted SVMs. When p > 2 , you can use the keyword argument features to create plots displaying pairs of variables at a time. 8. This problem involves the OJ data set which is part of the ISLP package. (a) Create a training set containing a random sample of 800 observations, and a test set containing the remaining observations. (b) Fit a support vector classifier to the training data using C = 0.01 , with Purchase as the response and the other variables as predictors. How many support points are there? (c) What are the training and test error rates? (d) Use cross-validation to select an optimal C . Consider values in the range 0 . 01 to 10 . (e) Compute the training and test error rates using this new value for C . (f) Repeat parts (b) through (e) using a support vector machine with a radial kernel. Use the default value for gamma",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_32"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (e) Compute the training and test error rates using this new value for C . (f) Repeat parts (b) through (e) using a support vector machine with a radial kernel. Use the default value for gamma . (g) Repeat parts (b) through (e) using a support vector machine with a polynomial kernel. Set degree = 2 . (h) Overall, which approach seems to give the best results on this data? 10 Deep Learning This chapter covers the important topic of deep learning . At the time of deep learning writing (2020), deep learning is a very active area of research in the machine learning and artificial intelligence communities. The cornerstone of deep learning is the neural network . neural network Neural networks rose to fame in the late 1980s. There was a lot of excitment and a certain amount of hype associated with this approach, and they were the impetus for the popular Neural Information Processing Systems meetings (NeurIPS, formerly NIPS) held every year, typically in exotic places like ski resorts. This was followed by a synthesis stage, where the properties of neural networks were analyzed by machine learners, matematicians and statisticians; algorithms were improved, and the methoology stabilized. Then along came SVMs, boosting, and random forests, and neural networks fell somewhat from favor. Part of the reason was that neural networks required a lot of tinkering, while the new methods were more automatic. Also, on many problems the new methods outperformed poorly-trained neural networks. This was the status quo for the first decade in the new millennium. All the while, though, a core group of neural-network enthusiasts were pushing their technology harder on ever-larger computing architectures and data sets. Neural networks resurfaced after 2010 with the new name deep learning , with new architectures, additional bells and whistles, and a string of success stories on some niche problems such as image and video classifcation, speech and text modeling",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_33"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Many in the field believe that the major reason for these successes is the availability of ever-larger training datasets, made possible by the wide-scale use of digitization in science and industry. In this chapter we discuss the basics of neural networks and deep learing, and then go into some of the specializations for specific problems, such as convolutional neural networks (CNNs) for image classification, and rcurrent neural networks (RNNs) for time series and other sequences. We 399 X 1 X 2 X 3 X 4 A 1 A 2 A 3 A 4 A 5 f ( X ) Y Hidden Layer Input Layer Output Layer FIGURE 10.1. Neural network with a single hidden layer. The hidden layer computes activations A k = h k ( X ) that are nonlinear transformations of linear combinations of the inputs X 1 , X 2 , , X p . Hence these A k are not directly oserved. The functions h k ( · ) are not fixed in advance, but are learned during the training of the network. The output layer is a linear model that uses these actvations A k as inputs, resulting in a function f ( X ) . will also demonstrate these models using the Python torch package, along with a number of helper packages. The material in this chapter is slightly more challenging than elsewhere in this book. 10.1 Single Layer Neural Networks A neural network takes an input vector of p variables X = ( X 1 , X 2 , , X p ) and builds a nonlinear function f ( X ) to predict the response Y . We have built nonlinear prediction models in earlier chapters, using trees, boosting and generalized additive models. What distinguishes neural networks from these methods is the particular structure of the model. Figure 10.1 shows a simple feed-forward neural network for modeling a quantitative response feed-forward neural network using p = 4 predictors. In the terminology of neural networks, the four fetures X 1 , , X 4 make up the units in the input layer . The arrows indicate input layer that each of the inputs from the input layer feeds into each of the K hidden units (we get to pick K ; here we chose 5 )",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_34"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The arrows indicate input layer that each of the inputs from the input layer feeds into each of the K hidden units (we get to pick K ; here we chose 5 ). The neural network model has hidden units the form f ( X ) = β 0 + ) K k =1 β k h k ( X ) = β 0 + ) K k =1 β k g ( w k 0 + ) p j =1 w kj X j ) . (10.1) It is built up here in two steps. First the K activations A k , k = 1 , , K, in activations the hidden layer are computed as functions of the input features X 1 , , X p , A k = h k ( X ) = g ( w k 0 + ) p j =1 w kj X j ) , (10.2) −4 −2 0 2 4 0.0 0.2 0.4 0.6 0.8 1.0 z g(z) sigmoid ReLU FIGURE 10.2. Activation functions. The piecewise-linear ReLU function is poular for its efficiency and computability. We have scaled it down by a factor of five for ease of comparison. where g ( z ) is a nonlinear activation function that is specified in advance. activation function We can think of each A k as a different transformation h k ( X ) of the original features, much like the basis functions of Chapter 7. These K activations from the hidden layer then feed into the output layer, resulting in f ( X ) = β 0 + K 0 k =1 β k A k , (10.3) a linear regression model in the K = 5 activations. All the parameters β 0 , , β K and w 10 , , w Kp need to be estimated from data. In the early instances of neural networks, the sigmoid activation function was favored, sigmoid g ( z ) = e z 1 + e z = 1 1 + e − z , (10.4) which is the same function used in logistic regression to convert a linear function into probabilities between zero and one (see Figure 10.2 ). The preferred choice in modern neural networks is the ReLU ( rectified linear ReLU unit ) activation function, which takes the form rectified linear unit g ( z ) = ( z ) + = K 0 if z < 0 z otherwise . (10.5) A ReLU activation can be computed and stored more efficiently than a sigmoid activation. Although it thresholds at zero, because we apply it to a linear function ( 10.2 ) the constant term w k 0 will shift this inflection point",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_35"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Although it thresholds at zero, because we apply it to a linear function ( 10.2 ) the constant term w k 0 will shift this inflection point. So in words, the model depicted in Figure 10.1 derives five new features by computing five different linear combinations of X , and then squashes each through an activation function g ( · ) to transform it. The final model is linear in these derived variables. The name neural network originally derived from thinking of these hidden units as analogous to neurons in the brain — values of the activations A k = h k ( X ) close to one are firing , while those close to zero are silent (using the sigmoid activation function). The nonlinearity in the activation function g ( · ) is essential, since without it the model f ( X ) in ( 10.1 ) would collapse into a simple linear model in X 1 , , X p . Moreover, having a nonlinear activation function allows the model to capture complex nonlinearities and interaction effects. Consider a very simple example with p = 2 input variables X = ( X 1 , X 2 ) , and K = 2 hidden units h 1 ( X ) and h 2 ( X ) with g ( z ) = z 2 . We specify the other parameters as β 0 = 0 , β 1 = 1 4 , β 2 = − 1 4 , w 10 = 0 , w 11 = 1 , w 12 = 1 , w 20 = 0 , w 21 = 1 , w 22 = − 1 . (10.6) From ( 10.2 ), this means that h 1 ( X ) = (0 + X 1 + X 2 ) 2 , h 2 ( X ) = (0 + X 1 − X 2 ) 2 . (10.7) Then plugging ( 10.7 ) into ( 10.1 ), we get f ( X ) = 0 + 1 4 · (0 + X 1 + X 2 ) 2 − 1 4 · (0 + X 1 − X 2 ) 2 = 1 4 N ( X 1 + X 2 ) 2 − ( X 1 − X 2 ) 2 O = X 1 X 2 . (10.8) So the sum of two nonlinear transformations of linear functions can give us an interaction! In practice we would not use a quadratic function for g ( z ) , since we would always get a second-degree polynomial in the original coordinates X 1 , , X p . The sigmoid or ReLU activations do not have such a limitation. Fitting a neural network requires estimating the unknown parameters in ( 10.1 )",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_36"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The sigmoid or ReLU activations do not have such a limitation. Fitting a neural network requires estimating the unknown parameters in ( 10.1 ). For a quantitative response, typically squared-error loss is used, so that the parameters are chosen to minimize n 0 i =1 ( y i − f ( x i )) 2 . (10.9) Details about how to perform this minimization are provided in Section 10.7 . 10.2 Multilayer Neural Networks Modern neural networks typically have more than one hidden layer, and often many units per layer. In theory a single hidden layer with a large number of units has the ability to approximate most functions. However, the learning task of discovering a good solution is made much easier with multiple layers each of modest size. We will illustrate a large dense network on the famous and publicly available MNIST handwritten digit dataset. 1 Figure 10.3 shows examples of these digits. The idea is to build a model to classify the images into their correct digit class 0–9. Every image has p = 28 × 28 = 784 pixels, each of which is an eight-bit grayscale value between 0 and 255 representing 1 See LeCun, Cortes, and Burges (2010) “The MNIST database of handwritten digits”, available at http://yann.lecun.com/exdb/mnist .",
    "chunk_id": "an_introduction_to_statistical_learning_page-367-398.json_chunk_37"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "FIGURE 10.3. Examples of handwritten digits from the MNIST corpus. Each grayscale image has 28 × 28 pixels, each of which is an eight-bit number (0–255) which represents how dark that pixel is. The first 3, 5, and 8 are enlarged to show their 784 individual pixel values. the relative amount of the written digit in that tiny square. 2 These pixels are stored in the input vector X (in, say, column order). The output is the class label, represented by a vector Y = ( Y 0 , Y 1 , , Y 9 ) of 10 dummy variables, with a one in the position corresponding to the label, and zeros elsewhere. In the machine learning community, this is known as one-hot encoding . There are 60,000 training images, and 10,000 test images. one-hot encoding On a historical note, digit recognition problems were the catalyst that accelerated the development of neural network technology in the late 1980s at AT&T Bell Laboratories and elsewhere. Pattern recognition tasks of this kind are relatively simple for humans. Our visual system occupies a large fraction of our brains, and good recognition is an evolutionary force for survival. These tasks are not so simple for machines, and it has taken more than 30 years to refine the neural-network architectures to match human performance. Figure 10.4 shows a multilayer network architecture that works well for solving the digit-classification task. It differs from Figure 10.1 in several ways: • It has two hidden layers L 1 (256 units) and L 2 (128 units) rather than one. Later we will see a network with seven hidden layers. • It has ten output variables, rather than one. In this case the ten varables really represent a single qualitative variable and so are quite dependent. (We have indexed them by the digit class 0–9 rather than 1–10, for clarity.) More generally, in multi-task learning one can prmulti-task learning dict different responses simultaneously with a single network; they all have a say in the formation of the hidden layers",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". • The loss function used for training the network is tailored for the multiclass classification task. 2 In the analog-to-digital conversion process, only part of the written numeral may fall in the square representing a particular pixel. X 1 X 2 X 3 X 4 X 5 X 6 X p A (1) 1 A (1) 2 A (1) 3 A (1) 4 A (1) K 1 A (2) 1 A (2) 2 A (2) 3 A (2) K 2 f 0 ( X ) Y 0 f 1 ( X ) Y 1 f 9 ( X ) Y 9 Hidden layer L 2 Hidden layer L 1 Input layer Output layer W 1 W 2 B FIGURE 10.4. Neural network diagram with two hidden layers and multiple outputs, suitable for the MNIST handwritten-digit problem. The input layer has p = 784 units, the two hidden layers K 1 = 256 and K 2 = 128 units respectively, and the output layer 10 units. Along with intercepts (referred to as biases in the deep-learning community) this network has 235,146 parameters (referred to as weights). The first hidden layer is as in ( 10.2 ), with A (1) k = h (1) k ( X ) = g ( w (1) k 0 + ) p j =1 w (1) kj X j ) (10.10) for k = 1 , , K 1 . The second hidden layer treats the activations A (1) k of the first hidden layer as inputs and computes new activations A (2) l = h (2) l ( X ) = g ( w (2) l 0 + ) K 1 k =1 w (2) lk A (1) k ) (10.11) for l = 1 , , K 2 . Notice that each of the activations in the second layer A (2) l = h (2) l ( X ) is a function of the input vector X . This is the case because while they are explicitly a function of the activations A (1) k from layer L 1 , these in turn are functions of X . This would also be the case with more hidden layers. Thus, through a chain of transformations, the network is able to build up fairly complex transformations of X that ultimately feed into the output layer as features. We have introduced additional superscript notation such as h (2) l ( X ) and w (2) lj in ( 10.10 ) and ( 10.11 ) to indicate to which layer the activations and weights (coefficients) belong, in this case layer 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The notation W 1 in Fiweights ure 10.4 represents the entire matrix of weights that feed from the input layer to the first hidden layer L 1 . This matrix will have 785 × 256 = 200 , 960 elements; there are 785 rather than 784 because we must account for the intercept or bias term. 3 bias Each element A (1) k feeds to the second hidden layer L 2 via the matrix of weights W 2 of dimension 257 × 128 = 32 , 896 . We now get to the output layer, where we now have ten responses rather than one. The first step is to compute ten different linear models similar to our single model ( 10.1 ), Z m = β m 0 + ) K 2 l =1 β ml h (2) l ( X ) = β m 0 + ) K 2 l =1 β ml A (2) l , (10.12) for m = 0 , 1 , , 9 . The matrix B stores all 129 × 10 = 1 , 290 of these weights. If these were all separate quantitative responses, we would simply set each f m ( X ) = Z m and be done. However, we would like our estimates to represent class probabilities f m ( X ) = Pr( Y = m | X ) , just like in multnomial logistic regression in Section 4.3.5 . So we use the special softmax softmax activation function (see ( 4.13 ) on page 145 ), f m ( X ) = Pr( Y = m | X ) = e Z m ) 9 l =0 e Z l , (10.13) for m = 0 , 1 , , 9 . This ensures that the 10 numbers behave like probbilities (non-negative and sum to one). Even though the goal is to build a classifier, our model actually estimates a probability for each of the 10 classes. The classifier then assigns the image to the class with the highest probability. To train this network, since the response is qualitative, we look for coeficient estimates that minimize the negative multinomial log-likelihood − n 0 i =1 9 0 m =0 y im log( f m ( x i )) , (10.14) also known as the cross-entropy . This is a generalization of the critcrosentropy rion ( 4.5 ) for two-class logistic regression. Details on how to minimize this objective are given in Section 10.7 . If the response were quantitative, we would instead minimize squared-error loss as in ( 10.9 )",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Details on how to minimize this objective are given in Section 10.7 . If the response were quantitative, we would instead minimize squared-error loss as in ( 10.9 ). Table 10.1 compares the test performance of the neural network with two simple models presented in Chapter 4 that make use of linear decision boundaries: multinomial logistic regression and linear discriminant analysis. The improvement of neural networks over both of these linear methods is dramatic: the network with dropout regularization achieves a test error rate below 2% on the 10 , 000 test images. (We describe dropout regularization in Section 10.7.3 .) In Section 10.9.2 of the lab, we present the code for fitting this model, which runs in just over two minutes on a laptop computer. 3 The use of “weights” for coefficients and “bias” for the intercepts w k 0 in ( 10.2 ) is popular in the machine learning community; this use of bias is not to be confused with the “bias-variance” usage elsewhere in this book. Method Test Error Neural Network + Ridge Regularization 2 . 3% Neural Network + Dropout Regularization 1 . 8% Multinomial Logistic Regression 7 . 2% Linear Discriminant Analysi s 12 . 7% TABLE 10.1. Test error rate on the MNIST data, for neural networks with two forms of regularization, as well as multinomial logistic regression and linear dicriminant analysis. In this example, the extra complexity of the neural network leads to a marked improvement in test error. FIGURE 10.5. A sample of images from the CIFAR100 database: a collection of natural images from everyday life, with 100 different classes represented. Adding the number of coefficients in W 1 , W 2 and B , we get 235 , 146 in all, more than 33 times the number 785 × 9 = 7 , 065 needed for multinomial logistic regression. Recall that there are 60 , 000 images in the training set",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Recall that there are 60 , 000 images in the training set. While this might seem like a large training set, there are almost four times as many coefficients in the neural network model as there are observations in the training set! To avoid overfitting, some regularization is needed. In this example, we used two forms of regularization: ridge regularization, which is similar to ridge regression from Chapter 6 , and dropout regularization. dropout We discuss both forms of regularization in Section 10.7 . 10.3 Convolutional Neural Networks Neural networks rebounded around 2010 with big successes in image classfication. Around that time, massive databases of labeled images were being accumulated, with ever-increasing numbers of classes. Figure 10.5 shows 75 images drawn from the CIFAR100 database. 4 This database consists of 60,000 images labeled according to 20 superclasses (e.g. aquatic mammals), with five classes per superclass (beaver, dolphin, otter, seal, whale). Each image has a resolution of 32 × 32 pixels, with three eight-bit numbers per pixel representing red, green and blue. The numbers for each image are organized in a three-dimensional array called a feature map . The first two feature map 4 See Chapter 3 of Krizhevsky (2009) “Learning multiple layers of fetures from tiny images”, available at https://www.cs.toronto.edu/~kriz/ learning-features-2009-TR.pdf . FIGURE 10.6. Schematic showing how a convolutional neural network classifies an image of a tiger. The network takes in the image and identifies local features. It then combines the local features in order to create compound features, which in this example include eyes and ears. These compound features are used to output the label “tiger”. axes are spatial (both are 32 -dimensional), and the third is the channel channel axis, 5 representing the three colors. There is a designated training set of 50,000 images, and a test set of 10,000",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". axes are spatial (both are 32 -dimensional), and the third is the channel channel axis, 5 representing the three colors. There is a designated training set of 50,000 images, and a test set of 10,000. A special family of convolutional neural networks (CNNs) has evolved for convolutional neural networks classifying images such as these, and has shown spectacular success on a wide range of problems. CNNs mimic to some degree how humans classify images, by recognizing specific features or patterns anywhere in the image that distinguish each particular object class. In this section we give a brief overview of how they work. Figure 10.6 illustrates the idea behind a convolutional neural network on a cartoon image of a tiger. 6 The network first identifies low-level features in the input image, such as small edges, patches of color, and the like. These low-level features are then combined to form higher-level features, such as parts of ears, eyes, and so on. Eventually, the presence or absence of these higher-level features contributes to the probability of any given output class. How does a convolutional neural network build up this hierarchy? It cobines two specialized types of hidden layers, called convolution layers and pooling layers. Convolution layers search for instances of small patterns in the image, whereas pooling layers downsample these to select a prominent subset. In order to achieve state-of-the-art results, contemporary neuranetwork architectures make use of many convolution and pooling layers. We describe convolution and pooling layers next. 10.3.1 Convolution Layers A convolution layer is made up of a large number of convolution filters , each convolution layer convolution filter 5 The term channel is taken from the signal-processing literature. Each channel is a distinct source of information. 6 Thanks to Elena Tuzhilina for producing the diagram and https://www. cartooning4kids.com/ for permission to use the cartoon tiger",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Each channel is a distinct source of information. 6 Thanks to Elena Tuzhilina for producing the diagram and https://www. cartooning4kids.com/ for permission to use the cartoon tiger. of which is a template that determines whether a particular local feature is present in an image. A convolution filter relies on a very simple operation, called a convolution , which basically amounts to repeatedly multiplying matrix elements and then adding the results. To understand how a convolution filter works, consider a very simple example of a 4 × 3 image: Original Image =   a b c d e f g h i j k l   . Now consider a 2 × 2 filter of the form Convolution Filter = 3 α β γ δ 4 . When we convolve the image with the filter, we get the result 7 Convolved Image =   aα + bβ + dγ + eδ bα + cβ + eγ + fδ dα + eβ + gγ + hδ eα + fβ + hγ + iδ gα + hβ + jγ + kδ hα + iβ + kγ + lδ   . For instance, the top-left element comes from multiplying each element in the 2 × 2 filter by the corresponding element in the top left 2 × 2 portion of the image, and adding the results. The other elements are obtained in a similar way: the convolution filter is applied to every 2 × 2 submatrix of the original image in order to obtain the convolved image. If a 2 × 2 submatrix of the original image resembles the convolution filter, then it will have a large value in the convolved image; otherwise, it will have a small value. Thus, the convolved image highlights regions of the original image that resemble the convolution filter. We have used 2 × 2 as an example; in general convolution filters are small l 1 × l 2 arrays, with l 1 and l 2 small positive integers that are not necessarily equal. Figure 10.7 illustrates the application of two convolution filters to a 192 × 179 image of a tiger, shown on the left-hand side. 8 Each convolution filter is a 15 × 15 image containing mostly zeros (black), with a narrow strip of ones (white) oriented either vertically or horizontally within the image",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 8 Each convolution filter is a 15 × 15 image containing mostly zeros (black), with a narrow strip of ones (white) oriented either vertically or horizontally within the image. When each filter is convolved with the image of the tiger, areas of the tiger that resemble the filter (i.e. that have either horizontal or vertical stripes or edges) are given large values, and areas of the tiger that do not resemble the feature are given small values. The convolved images are displayed on the right-hand side. We see that the horizontal stripe filter picks out horizontal stripes and edges in the original image, whereas the vertical stripe filter picks out vertical stripes and edges in the original image. 7 The convolved image is smaller than the original image because its dimension is given by the number of 2 × 2 submatrices in the original image. Note that 2 × 2 is the dimension of the convolution filter. If we want the convolved image to have the same dimension as the original image, then padding can be applied. 8 The tiger image used in Figures 10.7 – 10.9 was obtained from the public domain image resource https://www.needpix.com/ . FIGURE 10.7. Convolution filters find local features in an image, such as edges and small shapes. We begin with the image of the tiger shown on the left, and apply the two small convolution filters in the middle. The convolved images higlight areas in the original image where details similar to the filters are found. Specifically, the top convolved image highlights the tiger’s vertical stripes, whereas the bottom convolved image highlights the tiger’s horizontal stripes. We can think of the original image as the input layer in a convolutional neural network, and the convolved images as the units in the first hidden layer. We have used a large image and two large filters in Figure 10.7 for illutration. For the CIFAR100 database there are 32 × 32 color pixels per image, and we use 3 × 3 convolution filters",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We have used a large image and two large filters in Figure 10.7 for illutration. For the CIFAR100 database there are 32 × 32 color pixels per image, and we use 3 × 3 convolution filters. In a convolution layer, we use a whole bank of filters to pick out a variety of differently-oriented edges and shapes in the image. Using predefined filters in this way is standard practice in image processing. By contrast, with CNNs the filters are learned for the specific classification task. We can think of the filter weights as the parameters going from an input layer to a hidden layer, with one hidden unit for each pixel in the convolved image. This is in fact the case, though the parameters are highly structured and constrained (see Exercise 4 for more details). They operate on localized patches in the input image (so there are many structural zeros), and the same weights in a given filter are reused for all possible patches in the image (so the weights are constrained). 9 We now give some additional details. • Since the input image is in color, it has three channels represented by a three-dimensional feature map (array). Each channel is a twdimensional ( 32 × 32 ) feature map — one for red, one for green, and one for blue. A single convolution filter will also have three channels, one per color, each of dimension 3 × 3 , with potentially different filter weights. The results of the three convolutions are summed to form a two-dimensional output feature map. Note that at this point the color information has been used, and is not passed on to subsequent layers except through its role in the convolution. 9 This used to be called weight sharing in the early years of neural networks. • If we use K different convolution filters at this first hidden layer, we get K two-dimensional output feature maps, which together are treated as a single three-dimensional feature map",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". • If we use K different convolution filters at this first hidden layer, we get K two-dimensional output feature maps, which together are treated as a single three-dimensional feature map. We view each of the K output feature maps as a separate channel of information, so now we have K channels in contrast to the three color channels of the original input feature map. The three-dimensional feature map is just like the activations in a hidden layer of a simple neural network, except organized and produced in a spatially structured way. • We typically apply the ReLU activation function ( 10.5 ) to the covolved image. This step is sometimes viewed as a separate layer in the convolutional neural network, in which case it is referred to as a detector layer . detector layer 10.3.2 Pooling Layers A pooling layer provides a way to condense a large image into a smaller pooling summary image. While there are a number of possible ways to perform pooling, the max pooling operation summarizes each non-overlapping 2 × 2 block of pixels in an image using the maximum value in the block. This reduces the size of the image by a factor of two in each direction, and it also provides some location invariance : i.e. as long as there is a large value in one of the four pixels in the block, the whole block registers as a large value in the reduced image. Here is a simple example of max pooling: Max pool   1 2 5 3 3 0 1 2 2 1 3 4 1 1 2 0   → 3 3 5 2 4 4 . 10.3.3 Architecture of a Convolutional Neural Network So far we have defined a single convolution layer — each filter produces a new two-dimensional feature map. The number of convolution filters in a convolution layer is akin to the number of units at a particular hidden layer in a fully-connected neural network of the type we saw in Section 10.2 . This number also defines the number of channels in the resulting thredimensional feature map. We have also described a pooling layer, which reduces the first two dimensions of each three-dimensional feature map",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We have also described a pooling layer, which reduces the first two dimensions of each three-dimensional feature map. Deep CNNs have many such layers. Figure 10.8 shows a typical architecture for a CNN for the CIFAR100 image classification task. At the input layer, we see the three-dimensional feature map of a color image, where the channel axis represents each color by a 32 × 32 twdimensional feature map of pixels. Each convolution filter produces a new channel at the first hidden layer, each of which is a 32 × 32 feature map (after some padding at the edges). After this first round of convolutions, we now have a new “image”; a feature map with considerably more channels than the three color input channels (six in the figure, since we used six convolution filters). 32 16 32 8 16 4 32 2 500 100 convolve convolve convolve pool pool pool flatten 8 FIGURE 10.8. Architecture of a deep CNN for the CIFAR100 classification task. Convolution layers are interspersed with 2 × 2 max-pool layers, which reduce the size by a factor of 2 in both dimensions. This is followed by a max-pool layer, which reduces the size of the feature map in each channel by a factor of four: two in each dimension. This convolve-then-pool sequence is now repeated for the next two layers. Some details are as follows: • Each subsequent convolve layer is similar to the first. It takes as input the three-dimensional feature map from the previous layer and treats it like a single multi-channel image. Each convolution filter learned has as many channels as this feature map. • Since the channel feature maps are reduced in size after each pool layer, we usually increase the number of filters in the next convolve layer to compensate. • Sometimes we repeat several convolve layers before a pool layer. This effectively increases the dimension of the filter. These operations are repeated until the pooling has reduced each channel feature map down to just a few pixels in each dimension",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This effectively increases the dimension of the filter. These operations are repeated until the pooling has reduced each channel feature map down to just a few pixels in each dimension. At this point the three-dimensional feature maps are flattened — the pixels are treated as separate units — and fed into one or more fully-connected layers before reaching the output layer, which is a softmax activation for the 100 classes (as in ( 10.13 )). There are many tuning parameters to be selected in constructing such a network, apart from the number, nature, and sizes of each layer. Dropout learning can be used at each layer, as well as lasso or ridge regularization (see Section 10.7 ). The details of constructing a convolutional neural nework can seem daunting. Fortunately, terrific software is available, with extensive examples and vignettes that provide guidance on sensible choices for the parameters. For the CIFAR100 official test set, the best accuracy as of this writing is just above 75%, but undoubtedly this performance will continue to improve. 10.3.4 Data Augmentation An additional important trick used with image modeling is data augmendata aumentation ation . Essentially, each training image is replicated many times, with each replicate randomly distorted in a natural way such that human recognition is unaffected. Figure 10.9 shows some examples. Typical distortions are FIGURE 10.9. Data augmentation. The original image (leftmost) is distorted in natural ways to produce different images with the same class label. These distortions do not fool humans, and act as a form of regularization when fitting the CNN. zoom, horizontal and vertical shift, shear, small rotations, and in this case horizontal flips. At face value this is a way of increasing the training set considerably with somewhat different examples, and thus protects against overfitting. In fact we can see this as a form of regularization: we build a cloud of images around each original image, all with the same label",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In fact we can see this as a form of regularization: we build a cloud of images around each original image, all with the same label. This kind of fattening of the data is similar in spirit to ridge regularization. We will see in Section 10.7.2 that the stochastic gradient descent agorithms for fitting deep learning models repeatedly process randomlselected batches of, say, 128 training images at a time. This works hand-iglove with augmentation, because we can distort each image in the batch on the fly, and hence do not have to store all the new images. 10.3.5 Results Using a Pretrained Classifier Here we use an industry-level pretrained classifier to predict the class of some new images. The resnet50 classifier is a convolutional neural network that was trained using the imagenet data set, which consists of millions of images that belong to an ever-growing number of categories. 10 Figure 10.10 demonstrates the performance of resnet50 on six photographs (private colection of one of the authors). 11 The CNN does a reasonable job classifying the hawk in the second image. If we zoom out as in the third image, it gets confused and chooses the fountain rather than the hawk. In the final image a “jacamar” is a tropical bird from South and Central America with similar coloring to the South African Cape Weaver. We give more details on this example in Section 10.9.4 . Much of the work in fitting a CNN is in learning the convolution filters at the hidden layers; these are the coefficients of a CNN. For models fit to massive corpora such as imagenet with many classes, the output of these filters can serve as features for general natural-image classification prolems. One can use these pretrained hidden layers for new problems with much smaller training sets (a process referred to as weight freezing ), and weight freezing just train the last few layers of the network, which requires much less data",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 10 For more information about resnet50 , see He, Zhang, Ren, and Sun (2015) “Deep residual learning for image recognition”, https://arxiv.org/abs/1512.03385 . For dtails about imagenet , see Russakovsky, Deng, et al. (2015) “ImageNet Large Scale Visual Recognition Challenge”, in International Journal of Computer Vision . 11 These resnet results can change with time, since the publicly-trained model gets updated periodically. f l amingo Cooper’s hawk Cooper’s hawk flamingo 0.83 kite 0.60 fountain 0.35 spoonbill 0.17 great grey owl 0.09 nail 0.12 white stork 0.00 robin 0.06 hook 0.07 Lhasa Apso cat Cape weaver Tibetan terrier 0.56 Old English sheepdog 0.82 jacamar 0.28 Lhasa 0.32 Shih-Tzu 0.04 macaw 0.12 cocker spaniel 0.03 Persian cat 0.04 robin 0.12 FIGURE 10.10. Classification of six photographs using the resnet50 CNN trained on the imagenet corpus. The table below the images displays the true (intended) label at the top of each panel, and the top three choices of the classifier (out of 100). The numbers are the estimated probabilities for each choice. (A kite is a raptor, but not a hawk.) The vignettes and book 12 that accompany the keras package give more details on such applications. 10.4 Document Classification In this section we introduce a new type of example that has important applications in industry and science: predicting attributes of documents. Examples of documents include articles in medical journals, Reuters news feeds, emails, tweets, and so on. Our example will be IMDb (Internet Movie Database) ratings — short documents where viewers have written critiques of movies. 13 The response in this case is the sentiment of the review, which will be positive or negative . 12 Deep Learning with R by F. Chollet and J.J. Allaire, 2018, Manning Publications. 13 For details, see Maas et al. (2011) “Learning word vectors for sentiment analysis”, in Proceedings of the 49th Annual Meeting of the Association for Computational Liguistics: Human Language Technologies , pages 142–150",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (2011) “Learning word vectors for sentiment analysis”, in Proceedings of the 49th Annual Meeting of the Association for Computational Liguistics: Human Language Technologies , pages 142–150. Here is the beginning of a rather amusing negative review: This has to be one of the worst films of the 1990s. When my friends & I were watching this film (being the target audience it was aimed at) we just sat & watched the first half an hour with our jaws touching the floor at how bad it really was. The rest of the time, everyone else in the theater just started talking to each other, leaving or generally crying into their popcorn Each review can be a different length, include slang or non-words, have spelling errors, etc. We need to find a way to featurize such a document. featurize This is modern parlance for defining a set of predictors. The simplest and most common featurization is the bag-of-words model. bag-of-words We score each document for the presence or absence of each of the words in a language dictionary — in this case an English dictionary. If the dictionary contains M words, that means for each document we create a binary feature vector of length M , and score a 1 for every word present, and 0 otherwise. That can be a very wide feature vector, so we limit the dictionary — in this case to the 10,000 most frequently occurring words in the training corpus of 25,000 reviews. Fortunately there are nice tools for doing this automatically. Here is the beginning of a positive review that has been redacted in this way: ⟨ START ⟩ this film was just brilliant casting location scenery story direction everyone’s really suited the part they played and you could just imagine being there robert ⟨ UNK ⟩ is an amazing actor and now the same being director ⟨ UNK ⟩ father came from the same scottish island as myself so i loved Here we can see many words have been omitted, and some unknown words (UNK) have been marked as such",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". With this reduction the binary feature vector has length 10,000, and consists mostly of 0’s and a smattering of 1’s in the positions corresponding to words that are present in the document. We have a training set and test set, each with 25,000 examples, and each balanced with regard to sentiment . The resulting training feature matrix X has dimension 25 , 000 × 10 , 000 , but only 1.3% of the binary entries are nozero. We call such a matrix sparse, because most of the values are the same (zero in this case); it can be stored efficiently in sparse matrix format . 14 sparse matrix format There are a variety of ways to account for the document length; here we only score a word as in or out of the document, but for example one could instead record the relative frequency of words. We split off a validation set of size 2,000 from the 25,000 training observations (for model tuning), and fit two model sequences: • A lasso logistic regression using the glmnet package; • A two-class neural network with two hidden layers, each with 16 ReLU units. 14 Rather than store the whole matrix, we can store instead the location and values for the nonzero entries. In this case, since the nonzero entries are all 1, just the locations are stored. FIGURE 10.11. Accuracy of the lasso and a two-hidden-layer neural network on the IMDb data. For the lasso, the x -axis displays − log( λ ) , while for the neural network it displays epochs (number of times the fitting algorithm passes through the training set). Both show a tendency to overfit, and achieve approximately the same test accuracy. Both methods produce a sequence of solutions. The lasso sequence is idexed by the regularization parameter λ . The neural-net sequence is idexed by the number of gradient-descent iterations used in the fitting, as measured by training epochs or passes through the training set (Setion 10.7 ). Notice that the training accuracy in Figure 10.11 (black points) increases monotonically in both cases",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Notice that the training accuracy in Figure 10.11 (black points) increases monotonically in both cases. We can use the validation error to pick a good solution from each sequence (blue points in the plots), which would then be used to make predictions on the test data set. Note that a two-class neural network amounts to a nonlinear logistic regression model. From ( 10.12 ) and ( 10.13 ) we can see that log * Pr( Y = 1 | X ) Pr( Y = 0 | X ) + = Z 1 − Z 0 (10.15) = ( β 10 − β 00 ) + K 2 0 l =1 ( β 1 l − β 0 l ) A (2) l . (This shows the redundancy in the softmax function; for K classes we really only need to estimate K − 1 sets of coefficients. See Section 4.3.5 .) In Figure 10.11 we show accuracy (fraction correct) rather than classification accuracy error (fraction incorrect), the former being more popular in the machine learning community. Both models achieve a test-set accuracy of about 88% . The bag-of-words model summarizes a document by the words present, and ignores their context. There are at least two popular ways to take the context into account: • The bag-on -grams model. For example, a bag of 2-grams records bag-on - grams ●●●●●● ●●● ● ●● ● ● ● ● ● ● ● ● ● ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● 4 6 8 10 12 0.6 0.7 0.8 0.9 1.0 Lasso − log( λ ) Accuracy ●●●●●● ●●● ● ● ● ● ● ● ● ● ● ●● ● ● ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● ●●●●●● ●●● ● ●● ● ● ● ● ● ● ● ● ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●● ● ● ● train validation test ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● 5 10 15 20 0.6 0.7 0.8 0.9 1.0 Neural Net Epochs Accuracy ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● the consecutive co-occurrence of every distinct pair of words. “Blisfully long” can be seen as a positive phrase in a movie review, while “blissfully short” a negative",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". “Blisfully long” can be seen as a positive phrase in a movie review, while “blissfully short” a negative. • Treat the document as a sequence, taking account of all the words in the context of those that preceded and those that follow. In the next section we explore models for sequences of data, which have applications in weather forecasting, speech recognition, language transltion, and time-series prediction, to name a few. We continue with this IMDb example there. 10.5 Recurrent Neural Networks Many data sources are sequential in nature, and call for special treatment when building predictive models. Examples include: • Documents such as book and movie reviews, newspaper articles, and tweets. The sequence and relative positions of words in a document capture the narrative, theme and tone, and can be exploited in tasks such as topic classification, sentiment analysis, and language transltion. • Time series of temperature, rainfall, wind speed, air quality, and so on. We may want to forecast the weather several days ahead, or clmate several decades ahead. • Financial time series, where we track market indices, trading volumes, stock and bond prices, and exchange rates. Here prediction is often difficult, but as we will see, certain indices can be predicted with reasonable accuracy. • Recorded speech, musical recordings, and other sound recordings. We may want to give a text transcription of a speech, or perhaps a laguage translation. We may want to assess the quality of a piece of music, or assign certain attributes. • Handwriting, such as doctor’s notes, and handwritten digits such as zip codes. Here we want to turn the handwriting into digital text, or read the digits (optical character recognition). In a recurrent neural network (RNN), the input object X is a sequence . recurrent neural network Consider a corpus of documents, such as the collection of IMDb movie rviews. Each document can be represented as a sequence of L words, so X = { X 1 , X 2 , , X L } , where each X l represents a word",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Each document can be represented as a sequence of L words, so X = { X 1 , X 2 , , X L } , where each X l represents a word. The order of the words, and closeness of certain words in a sentence, convey semantic meaning. RNNs are designed to accommodate and take advantage of the sequential nature of such input objects, much like convolutional neural neworks accommodate the spatial structure of image inputs. The output Y can also be a sequence (such as in language translation), but often is a scalar, like the binary sentiment label of a movie review document. A 1 A 2 A 3 A L-1 A L = A l O l Y X l O 1 X 1 O 2 X 2 O 3 X 3 O L-1 X L-1 O L Y X L W U B W B W B W B W B W B U U U U FIGURE 10.12. Schematic of a simple recurrent neural network. The input is a sequence of vectors { X l } L 1 , and here the target is a single response. The network processes the input sequence X sequentially; each X l feeds into the hidden layer, which also has as input the activation vector A l − 1 from the previous element in the sequence, and produces the current activation vector A l . The same collections of weights W , U and B are used as each element of the sequence is processed. The output layer produces a sequence of predictions O l from the current activation A l , but typically only the last of these, O L , is of relevance. To the left of the equal sign is a concise representation of the network, which is unrolled into a more explicit version on the right. Figure 10.12 illustrates the structure of a very basic RNN with a sequence X = { X 1 , X 2 , , X L } as input, a simple output Y , and a hidden-layer sequence { A l } L 1 = { A 1 , A 2 , , A L } . Each X l is a vector; in the document example X l could represent a one-hot encoding for the l th word based on the language dictionary for the corpus (see the top panel in Figure 10.13 for a simple example)",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_19"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As the sequence is processed one vector X l at a time, the network updates the activations A l in the hidden layer, taking as input the vector X l and the activation vector A l − 1 from the previous step in the sequence. Each A l feeds into the output layer and produces a prediction O l for Y . O L , the last of these, is the most relevant. In detail, suppose each vector X l of the input sequence has p components X T l = ( X l 1 , X l 2 , , X lp ) , and the hidden layer consists of K units A T l = ( A l 1 , A l 2 , , A lK ) . As in Figure 10.4 , we represent the collection of K × ( p +1) shared weights w kj for the input layer by a matrix W , and similarly U is a K × K matrix of the weights u ks for the hidden-to-hidden layers, and B is a K + 1 vector of weights β k for the output layer. Then A lk = g 1 w k 0 + p 0 j =1 w kj X lj + K 0 s =1 u ks A l − 1 ,s 2 , (10.16) and the output O l is computed as O l = β 0 + K 0 k =1 β k A lk (10.17) for a quantitative response, or with an additional sigmoid activation funtion for a binary response, for example. Here g ( · ) is an activation function such as ReLU. Notice that the same weights W , U and B are used as we process each element in the sequence, i.e. they are not functions of l . This is a form of weight sharing used by RNNs, and similar to the use of filters weight sharing in convolutional neural networks (Section 10.3.1 .) As we proceed from bginning to end, the activations A l accumulate a history of what has been seen before, so that the learned context can be used for prediction. For regression problems the loss function for an observation ( X, Y ) is ( Y − O L ) 2 , (10.18) which only references the final output O L = β 0 + ) K k =1 β k A Lk . Thus O 1 , O 2 , , O L − 1 are not used. When we fit the model, each element X l of the input sequence X contributes to O L via the chain ( 10.16 ), and hence contributes indirectly to learning the shared parameters W , U and B via the loss ( 10.18 )",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_20"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". With n input sequence/response pairs ( x i , y i ) , the parameters are found by minimizing the sum of squares n 0 i =1 ( y i − o iL ) 2 = n 0 i =1 1 y i − ' β 0 + K 0 k =1 β k g ' w k 0 + p 0 j =1 w kj x iLj + K 0 s =1 u ks a i,L − 1 ,s (( 2 2 . (10.19) Here we use lowercase letters for the observed y i and vector sequences x i = { x i 1 , x i 2 , , x iL } , 15 as well as the derived activations. Since the intermediate outputs O l are not used, one may well ask why they are there at all. First of all, they come for free, since they use the same output weights B needed to produce O L , and provide an evolving prediction for the output. Furthermore, for some learning tasks the response is also a sequence, and so the output sequence { O 1 , O 2 , , O L } is explicitly needed. When used at full strength, recurrent neural networks can be quite coplex. We illustrate their use in two simple applications. In the first, we continue with the IMDb sentiment analysis of the previous section, where we process the words in the reviews sequentially. In the second application, we illustrate their use in a financial time series forecasting problem. 10.5.1 Sequential Models for Document Classification Here we return to our classification task with the IMDb reviews. Our aproach in Section 10.4 was to use the bag-of-words model. Here the plan is to use instead the sequence of words occurring in a document to make predictions about the label for the entire document. We have, however, a dimensionality problem: each word in our document is represented by a one-hot-encoded vector (dummy variable) with 10,000 elements (one per word in the dictionary)! An approach that has become popular is to represent each word in a much lower-dimensional embedding embedding space. This means that rather than representing each word by a binary vector with 9,999 zeros and a single one in some position, we will represent it instead by a set of m real numbers, none of which are typically zero",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_21"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Here m is the embedding dimension, and can be in the low 100s, or even less. This means (in our case) that we need a matrix E of dimension m × 10 , 000 , 15 This is a sequence of vectors; each element x il is a p -vector. this is one of the best films actually the best I have ever seen the film starts one fall day One−hot Embed FIGURE 10.13. Depiction of a sequence of 20 words representing a single doument: one-hot encoded using a dictionary of 16 words (top panel) and embedded in an m -dimensional space with m = 5 (bottom panel). where each column is indexed by one of the 10,000 words in our dictionary, and the values in that column give the m coordinates for that word in the embedding space. Figure 10.13 illustrates the idea (with a dictionary of 16 rather than 10,000, and m = 5 ). Where does E come from? If we have a large corpus of labeled documents, we can have the neural network learn E as part of the optimization. In this case E is referred to as an embedding layer, embedding layer and a specialized E is learned for the task at hand. Otherwise we can insert a precomputed matrix E in the embedding layer, a process known as weight freezing . Two pretrained embeddings, word2vec and GloVe , are weight freezing word2vec GloVe widely used. 16 These are built from a very large corpus of documents by a variant of principal components analysis (Section 12.2 ). The idea is that the positions of words in the embedding space preserve semantic meaning; e.g. synonyms should appear near each other. So far, so good. Each document is now represented as a sequence of m - vectors that represents the sequence of words. The next step is to limit each document to the last L words. Documents that are shorter than L get padded with zeros upfront. So now each document is represented by a series consisting of L vectors X = { X 1 , X 2 , , X L } , and each X l in the sequence has m components. We now use the RNN structure in Figure 10.12",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_22"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". So now each document is represented by a series consisting of L vectors X = { X 1 , X 2 , , X L } , and each X l in the sequence has m components. We now use the RNN structure in Figure 10.12 . The training corpus consists of n separate series (documents) of length L , each of which gets processed sequentially from left to right. In the process, a parallel series of hidden activation vectors A l , l = 1 , , L is created as in ( 10.16 ) for each document. A l feeds into the output layer to produce the evolving prediction O l . We use the final value O L to predict the response: the sentiment of the review. 16 word2vec is described in Mikolov, Chen, Corrado, and Dean (2013), available at https://code.google.com/archive/p/word2vec . GloVe is described in Pennington, Socher, and Manning (2014), available at https://nlp.stanford.edu/projects/glove . This is a simple RNN, and has relatively few parameters. If there are K hidden units, the common weight matrix W has K × ( m + 1) parameters, the matrix U has K × K parameters, and B has 2( K + 1) for the two-class logistic regression as in ( 10.15 ). These are used repeatedly as we process the sequence X = { X l } L 1 from left to right, much like we use a single convolution filter to process each patch in an image (Section 10.3.1 ). If the embedding layer E is learned, that adds an additional m × D parameters ( D = 10 , 000 here), and is by far the biggest cost. We fit the RNN as described in Figure 10.12 and the accompaying text to the IMDb data. The model had an embedding matrix E with m = 32 (which was learned in training as opposed to precomputed), followed by a single recurrent layer with K = 32 hidden units. The model was trained with dropout regularization on the 25,000 reviews in the designated training set, and achieved a disappointing 76% accuracy on the IMDb test data. A network using the GloVe pretrained embedding matrix E performed slightly worse. For ease of exposition we have presented a very simple RNN",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_23"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A network using the GloVe pretrained embedding matrix E performed slightly worse. For ease of exposition we have presented a very simple RNN. More elaorate versions use long term and short term memory (LSTM). Two tracks of hidden-layer activations are maintained, so that when the activation A l is computed, it gets input from hidden units both further back in time, and closer in time — a so-called LSTM RNN . With long sequences, this LSTM RNN overcomes the problem of early signals being washed out by the time they get propagated through the chain to the final activation vector A L . When we refit our model using the LSTM architecture for the hidden layer, the performance improved to 87% on the IMDb test data. This is coparable with the 88% achieved by the bag-of-words model in Section 10.4 . We give details on fitting these models in Section 10.9.6 . Despite this added LSTM complexity, our RNN is still somewhat “entry level”. We could probably achieve slightly better results by changing the size of the model, changing the regularization, and including additional hidden layers. However, LSTM models take a long time to train, which makes exploring many architectures and parameter optimization tedious. RNNs provide a rich framework for modeling data sequences, and they continue to evolve. There have been many advances in the development of RNNs — in architecture, data augmentation, and in the learning algrithms. At the time of this writing (early 2020) the leading RNN configurtions report accuracy above 95% on the IMDb data. The details are beyond the scope of this book. 17 10.5.2 Time Series Forecasting Figure 10.14 shows historical trading statistics from the New York Stock Exchange. Shown are three daily time series covering the period December 3, 1962 to December 31, 1986: 18 17 An IMDb leaderboard can be found at https://paperswithcode.com/sota/ sentiment-analysis-on-imdb . 18 These data were assembled by LeBaron and Weigend (1998) IEEE Transactions on Neural Networks , 9(1): 213–220",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_24"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 18 These data were assembled by LeBaron and Weigend (1998) IEEE Transactions on Neural Networks , 9(1): 213–220. Log(Trading Volume) −1.0 0.0 0.5 1.0 Dow Jones Return −0.04 0.00 0.04 1965 1970 1975 1980 1985 −13 −11 −9 −8 Log(Volatility) FIGURE 10.14. Historical trading statistics from the New York Stock Exchange. Daily values of the normalized log trading volume, DJIA return, and log volatility are shown for a 24-year period from 1962–1986. We wish to predict trading volume on any day, given the history on all earlier days. To the left of the red bar (January 2, 1980) is training data, and to the right test data. • Log trading volume . This is the fraction of all outstanding shares that are traded on that day, relative to a 100-day moving average of past turnover, on the log scale. • Dow Jones return . This is the difference between the log of the Dow Jones Industrial Index on consecutive trading days. • Log volatility . This is based on the absolute values of daily price movements. Predicting stock prices is a notoriously hard problem, but it turns out that predicting trading volume based on recent past history is more manageable (and is useful for planning trading strategies). An observation here consists of the measurements ( v t , r t , z t ) on day t , in this case the values for log_volume , DJ_return and log_volatility . There are a total of T = 6 , 051 such triples, each of which is plotted as a time series in Figure 10.14 . One feature that strikes us immediately is that the dato-day observations are not independent of each other. The series exhibit auto-correlation — in this case values nearby in time tend to be similar autcorrelation to each other. This distinguishes time series from other data sets we have encountered, in which observations can be assumed to be independent of 0 5 10 15 20 25 30 35 0.0 0.4 0.8 Lag Autocorrelation Function FIGURE 10.15. The autocorrelation function for log_volume . We see that nearby values are fairly strongly correlated, with correlations above 0",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_25"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The autocorrelation function for log_volume . We see that nearby values are fairly strongly correlated, with correlations above 0 . 2 as far as 20 days apart. each other. To be clear, consider pairs of observations ( v t , v t − l ) , a lag of l lag days apart. If we take all such pairs in the v t series and compute their corrlation coefficient, this gives the autocorrelation at lag l . Figure 10.15 shows the autocorrelation function for all lags up to 37, and we see considerable correlation. Another interesting characteristic of this forecasting problem is that the response variable v t — log_volume — is also a predictor! In particular, we will use the past values of log_volume to predict values in the future. RNN forecaster We wish to predict a value v t from past values v t − 1 , v t − 2 , , and also to make use of past values of the other series r t − 1 , r t − 2 , and z t − 1 , z t − 2 , Although our combined data is quite a long series with 6,051 trading days, the structure of the problem is different from the previous documenclassification example. • We only have one series of data, not 25,000. • We have an entire series of targets v t , and the inputs include past values of this series. How do we represent this problem in terms of the structure displayed in Figure 10.12 ? The idea is to extract many short mini-series of input squences X = { X 1 , X 2 , , X L } with a predefined length L (called the lag lag in this context), and a corresponding target Y . They have the form X 1 =   v t − L r t − L z t − L   , X 2 =   v t − L +1 r t − L +1 z t − L +1   , · · · , X L =   v t − 1 r t − 1 z t − 1   , and Y = v t . (10.20) So here the target Y is the value of log_volume v t at a single timepoint t , and the input sequence X is the series of 3-vectors { X l } L 1 each consisting of the three measurements log_volume , DJ_return and log_volatility from day t − L , t − L + 1 , up to t − 1 . Each value of t makes a separate ( X, Y ) pair, for t running from L + 1 to T",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_26"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Each value of t makes a separate ( X, Y ) pair, for t running from L + 1 to T . For the NYSE data we will use the past 1980 1982 1984 1986 −1.0 0.0 0.5 1.0 log(Trading Volume) FIGURE 10.16. RNN forecast of log_volume on the NYSE test data. The black lines are the true volumes, and the superimposed orange the forecasts. The forcasted series accounts for 42% of the variance of log_volume . five trading days to predict the next day’s trading volume. Hence, we use L = 5 . Since T = 6 , 051 , we can create 6,046 such ( X, Y ) pairs. Clearly L is a parameter that should be chosen with care, perhaps using validation data. We fit this model with K = 12 hidden units using the 4,281 training sequences derived from the data before January 2, 1980 (see Figure 10.14 ), and then used it to forecast the 1,770 values of log_volume after this date. We achieve an R 2 = 0 . 42 on the test data. Details are given in Setion 10.9.6 . As a straw man , 19 using yesterday’s value for log_volume as the prediction for today has R 2 = 0 . 18 . Figure 10.16 shows the forecast results. We have plotted the observed values of the daily log_volume for the test period 1980–1986 in black, and superimposed the predicted series in orange. The correspondence seems rather good. In forecasting the value of log_volume in the test period, we have to use the test data itself in forming the input sequences X . This may feel like cheating, but in fact it is not; we are always using past data to predict the future. Autoregression The RNN we just fit has much in common with a traditional autoregression autregression (AR) linear model, which we present now for comparison. We first consider the response sequence v t alone, and construct a response vector y and a matrix M of predictors for least squares regression as follows: y =   v L +1 v L +2 v L +3 v T   M =   1 v L v L − 1 · · · v 1 1 v L +1 v L · · · v 2 1 v L +2 v L +1 · · · v 3 1 v T − 1 v T − 2 · · · v T − L   . (10.21) M and y each have T − L rows, one per observation",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_27"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (10.21) M and y each have T − L rows, one per observation. We see that the predictors for any given response v t on day t are the previous L values 19 A straw man here refers to a simple and sensible prediction that can be used as a baseline for comparison. of the same series. Fitting a regression of y on M amounts to fitting the model ˆ v t = ˆ β 0 + ˆ β 1 v t − 1 + ˆ β 2 v t − 2 + · · · + ˆ β L v t − L , (10.22) and is called an ordeL autoregressive model, or simply AR( L ). For the NYSE data we can include lagged versions of DJ_return and log_volatility , r t and z t , in the predictor matrix M , resulting in 3 L + 1 columns. An AR model with L = 5 achieves a test R 2 of 0 . 41 , slightly inferior to the 0 . 42 achieved by the RNN. Of course the RNN and AR models are very similar. They both use the same response Y and input sequences X of length L = 5 and dimesion p = 3 in this case. The RNN processes this sequence from left to right with the same weights W (for the input layer), while the AR model simply treats all L elements of the sequence equally as a vector of L × p predictors — a process called flattening in the neural network literature. flattening Of course the RNN also includes the hidden layer activations A l which transfer information along the sequence, and introduces additional nonliearity. From ( 10.19 ) with K = 12 hidden units, we see that the RNN has 13 + 12 × (1 + 3 + 12) = 205 parameters, compared to the 16 for the AR( 5 ) model. An obvious extension of the AR model is to use the set of lagged preditors as the input vector to an ordinary feedforward neural network ( 10.1 ), and hence add more flexibility. This achieved a test R 2 = 0 . 42 , slightly better than the linear AR, and the same as the RNN. All the models can be improved by including the variable day_of_week corresponding to the day t of the target v t (which can be learned from the calendar dates supplied with the data); trading volume is often higher on Mondays and Fridays",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_28"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Since there are five trading days, this one-hot ecodes to five binary variables. The performance of the AR model improved to R 2 = 0 . 46 as did the RNN, and the nonlinear AR model improved to R 2 = 0 . 47 . We used the most simple version of the RNN in our examples here. Additional experiments with the LSTM extension of the RNN yielded small improvements, typically of up to 1% in R 2 in these examples. We give details of how we fit all three models in Section 10.9.6 . 10.5.3 Summary of RNNs We have illustrated RNNs through two simple use cases, and have only scratched the surface. There are many variations and enhancements of the simple RNN we used for sequence modeling. One approach we did not discuss uses a ondimensional convolutional neural network, treating the sequence of vectors (say words, as represented in the embedding space) as an image. The covolution filter slides along the sequence in a one-dimensional fashion, with the potential to learn particular phrases or short subsequences relevant to the learning task. One can also have additional hidden layers in an RNN. For example, with two hidden layers, the sequence A l is treated as an input sequence to the next hidden layer in an obvious fashion. The RNN we used scanned the document from beginning to end; altenative bidirectional RNNs scan the sequences in both directions. bidirectional In language translation the target is also a sequence of words, in a language different from that of the input sequence. Both the input squence and the target sequence are represented by a structure similar to Figure 10.12 , and they share the hidden units. In this so-called Seq2Seq Seq2Seq learning, the hidden units are thought to capture the semantic meaning of the sentences. Some of the big breakthroughs in language modeling and translation resulted from the relatively recent improvements in such RNNs. Algorithms used to fit RNNs can be complex and computationally costly",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_29"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Algorithms used to fit RNNs can be complex and computationally costly. Fortunately, good software protects users somewhat from these complexties, and makes specifying and fitting these models relatively painless. Many of the models that we enjoy in daily life (like Google Translate ) use statof-the-art architectures developed by teams of highly skilled engineers, and have been trained using massive computational and data resources. 10.6 When to Use Deep Learning The performance of deep learning in this chapter has been rather impresive. It nailed the digit classification problem, and deep CNNs have really revolutionized image classification. We see daily reports of new success stries for deep learning. Many of these are related to image classification tasks, such as machine diagnosis of mammograms or digital X-ray images, ophthalmology eye scans, annotations of MRI scans, and so on. Likewise there are numerous successes of RNNs in speech and language translation, forecasting, and document modeling. The question that then begs an aswer is: should we discard all our older tools, and use deep learning on every problem with data? To address this question, we revisit our Hitters dataset from Chapter 6 . This is a regression problem, where the goal is to predict the Salary of a baseball player in 1987 using his performance statistics from 1986. After removing players with missing responses, we are left with 263 players and 19 variables. We randomly split the data into a training set of 176 players (two thirds), and a test set of 87 players (one third). We used three methods for fitting a regression model to these data. • A linear model was used to fit the training data, and make predictions on the test data. The model has 20 parameters. • The same linear model was fit with lasso regularization. The tuning parameter was selected by 10-fold cross-validation on the training data. It selected a model with 12 variables having nonzero coefficients",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_30"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The tuning parameter was selected by 10-fold cross-validation on the training data. It selected a model with 12 variables having nonzero coefficients. • A neural network with one hidden layer consisting of 64 ReLU units was fit to the data. This model has 1,345 parameters. 20 20 The model was fit by stochastic gradient descent with a batch size of 32 for 1,000 epochs, and 10% dropout regularization. The test error performance flattened out and started to slowly increase after 1,000 epochs. These fitting details are discussed in Setion 10.7 . Model # Parameters Mean Abs. Error Test Set R 2 Linear Regression 20 254.7 0.56 Lasso 12 252.3 0.51 Neural Network 1345 257.4 0.54 TABLE 10.2. Prediction results on the Hitters test data for linear models fit by ordinary least squares and lasso, compared to a neural network fit by stochastic gradient descent with dropout regularization. Coef fi cient Std. error t -statistic p -value Intercept -226.67 86.26 -2.63 0.0103 Hits 3.06 1.02 3.00 0.0036 Walks 0.181 2.04 0.09 0.9294 CRuns 0.859 0.12 7.09 < 0 . 0001 PutOuts 0.465 0.13 3.60 0.0005 TABLE 10.3. Least squares coefficient estimates associated with the regresion of Salary on four variables chosen by lasso on the Hitters data set. This model achieved the best performance on the test data, with a mean absolute error of 224.8. The results reported here were obtained from a regression on the test data, which was not used in fitting the lasso model. Table 10.2 compares the results. We see similar performance for all three models. We report the mean absolute error on the test data, as well as the test R 2 for each method, which are all respectable (see Exercise 5 ). We spent a fair bit of time fiddling with the configuration parameters of the neural network to achieve these results. It is possible that if we were to spend more time, and got the form and amount of regularization just right, that we might be able to match or even outperform linear regression and the lasso",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_31"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". It is possible that if we were to spend more time, and got the form and amount of regularization just right, that we might be able to match or even outperform linear regression and the lasso. But with great ease we obtained linear models that work well. Linear models are much easier to present and understand than the neural network, which is essentially a black box. The lasso selected 12 of the 19 variables in making its prediction. So in cases like this we are much better off following the Occam’s razor principle: when faced with several methods Occam’s razor that give roughly equivalent performance, pick the simplest. After a bit more exploration with the lasso model, we identified an even simpler model with four variables. We then refit the linear model with these four variables to the training data (the so-called relaxed lasso ), and achieved a test mean absolute error of 224.8, the overall winner! It is tempting to present the summary table from this fit, so we can see coefficients and values; however, since the model was selected on the training data, there would be selection bias . Instead, we refit the model on the test data, which was not used in the selection. Table 10.3 shows the results. We have a number of very powerful tools at our disposal, including neural networks, random forests and boosting, support vector machines and geeralized additive models, to name a few. And then we have linear models, and simple variants of these. When faced with new data modeling and prdiction problems, it’s tempting to always go for the trendy new methods. Often they give extremely impressive results, especially when the datasets are very large and can support the fitting of high-dimensional nonlinear models. However, if we can produce models with the simpler tools that perform as well, they are likely to be easier to fit and understand, and ptentially less fragile than the more complex approaches",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_32"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". However, if we can produce models with the simpler tools that perform as well, they are likely to be easier to fit and understand, and ptentially less fragile than the more complex approaches. Wherever possible, it makes sense to try the simpler models as well, and then make a choice based on the performance/complexity tradeoff. Typically we expect deep learning to be an attractive choice when the sample size of the training set is extremely large, and when interpretability of the model is not a high priority. 10.7 Fitting a Neural Network Fitting neural networks is somewhat complex, and we give a brief overview here. The ideas generalize to much more complex networks. Readers who find this material challenging can safely skip it. Fortunately, as we see in the lab at the end of this chapter, good software is available to fit neural network models in a relatively automated way, without worrying about the technical details of the model-fitting procedure. We start with the simple network depicted in Figure 10.1 in Section 10.1 . In model ( 10.1 ) the parameters are β = ( β 0 , β 1 , , β K ) , as well as each of the w k = ( w k 0 , w k 1 , , w kp ) , k = 1 , , K. Given observations ( x i , y i ) , i = 1 , , n, we could fit the model by solving a nonlinear least squares problem minimize { w k } K 1 , β 1 2 n 0 i =1 ( y i − f ( x i )) 2 , (10.23) where f ( x i ) = β 0 + K 0 k =1 β k g 1 w k 0 + p 0 j =1 w kj x ij 2 . (10.24) The objective in ( 10.23 ) looks simple enough, but because of the nested arrangement of the parameters and the symmetry of the hidden units, it is not straightforward to minimize. The problem is nonconvex in the paraeters, and hence there are multiple solutions. As an example, Figure 10.17 shows a simple nonconvex function of a single variable θ ; there are two solutions: one is a local minimum and the other is a global minimum",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_33"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As an example, Figure 10.17 shows a simple nonconvex function of a single variable θ ; there are two solutions: one is a local minimum and the other is a global minimum . Fulocal minimum global minimum thermore, ( 10.1 ) is the very simplest of neural networks; in this chapter we have presented much more complex ones where these problems are copounded. To overcome some of these issues and to protect from overfitting, two general strategies are employed when fitting neural networks. • Slow Learning: the model is fit in a somewhat slow iterative fasion, using gradient descent . The fitting process is then stopped when gradient descent overfitting is detected. • Regularization: penalties are imposed on the parameters, usually lasso or ridge as discussed in Section 6.2 . Suppose we represent all the parameters in one long vector θ . Then we can rewrite the objective in ( 10.23 ) as R ( θ ) = 1 2 n 0 i =1 ( y i − f θ ( x i )) 2 , (10.25) FIGURE 10.17. Illustration of gradient descent for one-dimensional θ . The objective function R ( θ ) is not convex, and has two minima, one at θ = − 0 . 46 (local), the other at θ = 1 . 02 (global). Starting at some value θ 0 (typically radomly chosen), each step in θ moves downhill — against the gradient — until it cannot go down any further. Here gradient descent reached the global minimum in 7 steps. where we make explicit the dependence of f on the parameters. The idea of gradient descent is very simple. 1. Start with a guess θ 0 for all the parameters in θ , and set t = 0 . 2. Iterate until the objective ( 10.25 ) fails to decrease: (a) Find a vector δ that reflects a small change in θ , such that θ t +1 = θ t + δ reduces the objective; i.e. such that R ( θ t +1 ) < R ( θ t ) . (b) Set t ← t + 1 . One can visualize (Figure 10.17 ) standing in a mountainous terrain, and the goal is to get to the bottom through a series of steps. As long as each step goes downhill, we must eventually get to the bottom",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_34"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As long as each step goes downhill, we must eventually get to the bottom. In this case we were lucky, because with our starting guess θ 0 we end up at the global minimum. In general we can hope to end up at a (good) local minimum. 10.7.1 Backpropagation How do we find the directions to move θ so as to decrease the objective R ( θ ) in ( 10.25 )? The gradient of R ( θ ) , evaluated at some current value θ = θ m , gradient is the vector of partial derivatives at that point: ∇ R ( θ m ) = ∂R ( θ ) ∂θ VVV θ = θ m . (10.26) The subscript θ = θ m means that after computing the vector of derivatives, we evaluate it at the current guess, θ m . This gives the direction in θ -space in which R ( θ ) increases most rapidly. The idea of gradient descent is to move θ a little in the opposite direction (since we wish to go downhill): θ m +1 ← θ m − ρ ∇ R ( θ m ) . (10.27) −1.0 −0.5 0.0 0.5 1.0 0 1 2 3 4 5 6 θ R( θ ) θ 0 θ 1 θ 2 θ 7 ● ● ● ● R( θ 0 )R( θ 1 ) R( θ 2 ) R( θ 7 ) For a small enough value of the learning rate ρ , this step will decrease the learning rate objective R ( θ ) ; i.e. R ( θ m +1 ) ≤ R ( θ m ) . If the gradient vector is zero, then we may have arrived at a minimum of the objective. How complicated is the calculation ( 10.26 )? It turns out that it is quite simple here, and remains simple even for much more complex networks, because of the chain rule of differentiation. chain rule Since R ( θ ) = ) n i =1 R i ( θ ) = 1 2 ) n i =1 ( y i − f θ ( x i )) 2 is a sum, its gradient is also a sum over the n observations, so we will just examine one of these terms, R i ( θ ) = 1 2 1 y i − β 0 − K 0 k =1 β k g ' w k 0 + p 0 j =1 w kj x ij ( 2 2 . (10.28) To simplify the expressions to follow, we write z ik = w k 0 + ) p j =1 w kj x ij . First we take the derivative with respect to β k : ∂R i ( θ ) ∂β k = ∂R i ( θ ) ∂f θ ( x i ) · ∂f θ ( x i ) ∂β k = − ( y i − f θ ( x i )) · g ( z ik )",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_35"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". First we take the derivative with respect to β k : ∂R i ( θ ) ∂β k = ∂R i ( θ ) ∂f θ ( x i ) · ∂f θ ( x i ) ∂β k = − ( y i − f θ ( x i )) · g ( z ik ) . (10.29) And now we take the derivative with respect to w kj : ∂R i ( θ ) ∂w kj = ∂R i ( θ ) ∂f θ ( x i ) · ∂f θ ( x i ) ∂g ( z ik ) · ∂g ( z ik ) ∂z ik · ∂z ik ∂w kj = − ( y i − f θ ( x i )) · β k · g ′ ( z ik ) · x ij . (10.30) Notice that both these expressions contain the residual y i − f θ ( x i ) . In ( 10.29 ) we see that a fraction of that residual gets attributed to each of the hidden units according to the value of g ( z ik ) . Then in ( 10.30 ) we see a similar attribution to input j via hidden unit k . So the act of differetiation assigns a fraction of the residual to each of the parameters via the chain rule — a process known as backpropagation in the neural network backproagation literature. Although these calculations are straightforward, it takes careful bookkeeping to keep track of all the pieces. 10.7.2 Regularization and Stochastic Gradient Descent Gradient descent usually takes many steps to reach a local minimum. In practice, there are a number of approaches for accelerating the process. Also, when n is large, instead of summing ( 10.29 )–( 10.30 ) over all n oservations, we can sample a small fraction or minibatch of them each time minibatch we compute a gradient step. This process is known as stochastic gradient descent (SGD) and is the state of the art for learning deep neural networks. stochastic gradient descent Fortunately, there is very good software for setting up deep learning moels, and for fitting them to data, so most of the technicalities are hidden from the user. We now turn to the multilayer network (Figure 10.4 ) used in the digit recognition problem. The network has over 235,000 weights, which is around four times the number of training examples",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_36"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We now turn to the multilayer network (Figure 10.4 ) used in the digit recognition problem. The network has over 235,000 weights, which is around four times the number of training examples. Regularization is essential here 0 5 10 15 20 25 30 0.1 0.2 0.3 0.4 Epochs Value of Objective Function Training Set Validation Set 0 5 10 15 20 25 30 0.00 0.02 0.04 0.06 0.08 0.10 0.12 Epochs Classification Error FIGURE 10.18. Evolution of training and validation errors for the MNIST neural network depicted in Figure 10.4 , as a function of training epochs. The objective refers to the log-likelihood ( 10.14 ). to avoid overfitting. The first row in Table 10.1 uses ridge regularization on the weights. This is achieved by augmenting the objective function ( 10.14 ) with a penalty term: R ( θ ; λ ) = − n 0 i =1 9 0 m =0 y im log( f m ( x i )) + λ 0 j θ 2 j . (10.31) The parameter λ is often preset at a small value, or else it is found using the validation-set approach of Section 5.3.1 . We can also use different values of λ for the groups of weights from different layers; in this case W 1 and W 2 were penalized, while the relatively few weights B of the output layer were not penalized at all. Lasso regularization is also popular as an additional form of regularization, or as an alternative to ridge. Figure 10.18 shows some metrics that evolve during the training of the network on the MNIST data. It turns out that SGD naturally enforces its own form of approximately quadratic regularization. 21 Here the minibatch size was 128 observations per gradient update. The term epochs labeling the epochs horizontal axis in Figure 10.18 counts the number of times an equivalent of the full training set has been processed. For this network, 20% of the 60,000 training observations were used as a validation set in order to determine when training should stop. So in fact 48,000 observations were used for training, and hence there are 48 , 000 / 128 ≈ 375 minibatch gradient updates per epoch",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_37"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". So in fact 48,000 observations were used for training, and hence there are 48 , 000 / 128 ≈ 375 minibatch gradient updates per epoch. We see that the value of the validation objective actually starts to increase by 30 epochs, so early stopping can also be used as an additional early stopping form of regularization. 21 This and other properties of SGD for deep learning are the subject of much research in the machine learning literature at the time of writing. FIGURE 10.19. Dropout Learning. Left: a fully connected network. Right: nework with dropout in the input and hidden layer. The nodes in grey are selected at random, and ignored in an instance of training. 10.7.3 Dropout Learning The second row in Table 10.1 is labeled dropout . This is a relatively new dropout and efficient form of regularization, similar in some respects to ridge reularization. Inspired by random forests (Section 8.2 ), the idea is to radomly remove a fraction φ of the units in a layer when fitting the model. Figure 10.19 illustrates this. This is done separately each time a training observation is processed. The surviving units stand in for those missing, and their weights are scaled up by a factor of 1 / (1 − φ ) to compensate. This prevents nodes from becoming over-specialized, and can be seen as a form of regularization. In practice dropout is achieved by randomly seting the activations for the “dropped out” units to zero, while keeping the architecture intact. 10.7.4 Network Tuning The network in Figure 10.4 is considered to be relatively straightforward; it nevertheless requires a number of choices that all have an effect on the performance: • The number of hidden layers, and the number of units per layer. Modern thinking is that the number of units per hidden layer can be large, and overfitting can be controlled via the various forms of regularization. • Regularization tuning parameters. These include the dropout rate φ and the strength λ of lasso and ridge regularization, and are typically set separately at each layer",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_38"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". • Regularization tuning parameters. These include the dropout rate φ and the strength λ of lasso and ridge regularization, and are typically set separately at each layer. • Details of stochastic gradient descent. These include the batch size, the number of epochs, and if used, details of data augmentation (Setion 10.3.4 .) Choices such as these can make a difference. In preparing this MNIST exaple, we achieved a respectable 1 . 8% misclassification error after some trial and error. Finer tuning and training of a similar network can get under 1% error on these data, but the tinkering process can be tedious, and can result in overfitting if done carelessly. 2 5 10 20 50 0.0 0.5 1.0 1.5 2.0 Degrees of Freedom Error Training Error Test Error FIGURE 10.20. Double descent phenomenon, illustrated using error plots for a one-dimensional natural spline example. The horizontal axis refers to the number of spline basis functions on the log scale. The training error hits zero when the degrees of freedom coincides with the sample size n = 20 , the “interpolation threshold”, and remains zero thereafter. The test error increases dramatically at this threshold, but then descends again to a reasonable value before finally increasing again. 10.8 Interpolation and Double Descent Throughout this book, we have repeatedly discussed the bias-variance tradoff, first presented in Section 2.2.2 . This trade-off indicates that statistical learning methods tend to perform the best, in terms of test-set error, for an intermediate level of model complexity. In particular, if we plot “flexibiity” on the x -axis and error on the y -axis, then we generally expect to see that test error has a U-shape, whereas training error decreases monotoncally. Two “typical” examples of this behavior can be seen in the right-hand panel of Figure 2.9 on page 29 , and in Figure 2.17 on page 39",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_39"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Two “typical” examples of this behavior can be seen in the right-hand panel of Figure 2.9 on page 29 , and in Figure 2.17 on page 39 . One impliction of the bias-variance trade-off is that it is generally not a good idea to interpolate the training data — that is, to get zero training error — since interpolate that will often result in very high test error. However, it turns out that in certain specific settings it can be possible for a statistical learning method that interpolates the training data to perform well — or at least, better than a slightly less complex model that does not quite interpolate the data. This phenomenon is known as double descent , and is displayed in Figure 10.20 . “Double descent” gets its name from the fact that the test error has a U-shape before the interpolation threshold is reached, and then it descends again (for a while, at least) as an increasingly flexible model is fit. We now describe the set-up that resulted in Figure 10.20 . We simulated n = 20 observations from the model Y = sin( X ) + ε, where X ∼ U [ − 5 , 5] (uniform distribution), and ε ∼ N (0 , σ 2 ) with σ = 0 . 3 . We then fit a natural spline to the data, as described in Section 7.4 , with d −4 −2 0 2 4 −3 −2 −1 0 1 2 3 8 Degrees of Freedom −4 −2 0 2 4 −3 −2 −1 0 1 2 3 20 Degrees of Freedom −4 −2 0 2 4 −3 −2 −1 0 1 2 3 42 Degrees of Freedom −4 −2 0 2 4 −3 −2 −1 0 1 2 3 80 Degrees of Freedom FIGURE 10.21. Fitted functions ˆ f d ( X ) (orange), true function f ( X ) (black) and the observed 20 training data points. A different value of d (degrees of freedom) is used in each panel. For d ≥ 20 the orange curves all interpolate the training points, and hence the training error is zero. degrees of freedom. 22 Recall from Section 7.4 that fitting a natural spline with d degrees of freedom amounts to fitting a least-squares regression of the response onto a set of d basis functions",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_40"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". degrees of freedom. 22 Recall from Section 7.4 that fitting a natural spline with d degrees of freedom amounts to fitting a least-squares regression of the response onto a set of d basis functions. The upper-left panel of Figure 10.21 shows the data, the true function f ( X ) , and ˆ f 8 ( X ) , the fitted natural spline with d = 8 degrees of freedom. Next, we fit a natural spline with d = 20 degrees of freedom. Since n = 20 , this means that n = d , and we have zero training error; in other words, we have interpolated the training data! We can see from the top-right panel of Figure 10.21 that ˆ f 20 ( X ) makes wild excursions, and hence the test error will be large. We now continue to fit natural splines to the data, with increasing values of d . For d > 20 , the least squares regression of Y onto d basis functions is not unique: there are an infinite number of least squares coefficient etimates that achieve zero error. To select among them, we choose the one with the smallest sum of squared coefficients, ) d j =1 ˆ β 2 j . This is known as the minimum-norm solution. The two lower panels of Figure 10.21 show the minimum-norm natural spline fits with d = 42 and d = 80 degrees of freedom. Incredibly, ˆ f 42 ( X ) is quite a bit less less wild than ˆ f 20 ( X ) , even though it makes use of more degrees of freedom . And ˆ f 80 ( X ) is not much different. How can this be? Essentially, ˆ f 20 ( X ) is very wild because there is just a single way to interplate n = 20 observations using d = 20 basis functions, and that single way results in a somewhat extreme fitted function. By contrast, there are an 22 This implies the choice of d knots, here chosen at d equi-probability quantiles of the training data. When d > n , the quantiles are found by interpolation",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_41"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". By contrast, there are an 22 This implies the choice of d knots, here chosen at d equi-probability quantiles of the training data. When d > n , the quantiles are found by interpolation. infinite number of ways to interpolate n = 20 observations using d = 42 or d = 80 basis functions, and the smoothest of them — that is, the minimum norm solution — is much less wild than ˆ f 20 ( X ) ! In Figure 10.20 , we display the training error and test error associated with ˆ f d ( X ) , for a range of values of the degrees of freedom d . We see that the training error drops to zero once d = 20 and beyond; i.e. once the interpolation threshold is reached. By contrast, the test error shows a U - shape for d ≤ 20 , grows extremely large around d = 20 , and then shows a second region of descent for d > 20 . For this example the signal-to-noise ratio — Var( f ( X )) /σ 2 — is 5 . 9 , which is quite high (the data points are close to the true curve). So an estimate that interpolates the data and does not wander too far inbetween the observed data points will likely do well. In Figures 10.20 and 10.21 , we have illustrated the double descent phnomenon in a simple one-dimensional setting using natural splines. Hoever, it turns out that the same phenomenon can arise for deep learning. Basically, when we fit neural networks with a huge number of parameters, we are sometimes able to get good results with zero training error. This is particularly true in problems with high signal-to-noise ratio, such as natural image recognition and language translation, for example. This is because the techniques used to fit neural networks, including stochastic gradient descent, naturally lend themselves to selecting a “smooth” interpolating model that has good test-set performance on these kinds of problems. Some points are worth emphasizing: • The double-descent phenomenon does not contradict the bias-variance trade-off, as presented in Section 2.2.2",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_42"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Some points are worth emphasizing: • The double-descent phenomenon does not contradict the bias-variance trade-off, as presented in Section 2.2.2 . Rather, the double-descent curve seen in the right-hand side of Figure 10.20 is a consequence of the fact that the x -axis displays the number of spline basis functions used, which does not properly capture the true “flexibility” of models that interpolate the training data. Stated another way, in this exaple, the minimum-norm natural spline with d = 42 has lower variance than the natural spline with d = 20 . • Most of the statistical learning methods seen in this book do not exhibit double descent. For instance, regularization approaches typically do not interpolate the training data, and thus double descent does not occur. This is not a drawback of regularized methods: they can give great results without interpolating the data ! In particular, in the examples here, if we had fit the natural splines using ridge regression with an appropriately-chosen penalty rather than least squares, then we would not have seen double descent, and in fact would have obtained better test error results. • In Chapter 9, we saw that maximal margin classifiers and SVMs that have zero training error nonetheless often achieve very good test error. This is in part because those methods seek smooth minimum norm solutions. This is similar to the fact that the minimum-norm natural spline can give good results with zero training error. • The double-descent phenomenon has been used by the machine learing community to explain the successful practice of using an ove parametrized neural network (many layers, and many hidden units), and then fitting all the way to zero training error. However, fitting to zero error is not always optimal, and whether it is advisable dpends on the signal-to-noise ratio. For instance, we may use ridge regularization to avoid overfitting a neural network, as in ( 10.31 )",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_43"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". For instance, we may use ridge regularization to avoid overfitting a neural network, as in ( 10.31 ). In this case, provided that we use an appropriate choice for the tuning parameter λ , we will never interpolate the training data, and thus will not see the double descent phenomenon. Nonetheless we can get very good test-set performance, likely much better than we would have achieved had we interpolated the training data. Early stopping during stochastic gradient descent can also serve as a form of regulaization that prevents us from interpolating the training data, while still getting very good results on test data. To summarize: though double descent can sometimes occur in neural neworks, we typically do not want to rely on this behavior. Moreover, it is important to remember that the bias-variance trade-off always holds (though it is possible that test error as a function of flexibility may not exhibit a U-shape, depending on how we have parametrized the notion of “flexibility” on the x -axis). 10.9 Lab: Deep Learning In this section we demonstrate how to fit the examples discussed in the text. We use the Python torch package, along with the pytorch_lightning torch pytorch_ lightning package which provides utilities to simplify fitting and evaluating moels. This code can be impressively fast with certain special processors, such as Apple’s new M1 chip. The package is well-structured, flexible, and will feel comfortable to Python users. A good companion is the site ptorch.org/tutorials . Much of our code is adapted from there, as well as the pytorch_lightning documentation. 23 We start with several standard imports that we have seen before",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_44"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Much of our code is adapted from there, as well as the pytorch_lightning documentation. 23 We start with several standard imports that we have seen before. In [1]: import numpy as np, pandas as pd from matplotlib.pyplot import subplots from sklearn.linear_model import \\ (LinearRegression , LogisticRegression , Lasso) from sklearn.preprocessing import StandardScaler from sklearn.model_selection import KFold from sklearn.pipeline import Pipeline from ISLP import load_data from ISLP.models import ModelSpec as MS from sklearn.model_selection import \\ (train_test_split , GridSearchCV) 23 The precise URLs at the time of writing are https://pytorch.org/tutorials/ beginner/basics/intro.html and https://pytorch-lightning.readthedocs.io/en/ latest/ . Torch-Specific Imports There are a number of imports for torch . (These are not included with ISLP , so must be installed separately.) First we import the main library and essential tools used to specify sequentially-structured networks. In [2]: import torch from torch import nn from torch.optim import RMSprop from torch.utils.data import TensorDataset There are several other helper packages for torch . For instance, the torchmetrics package has utilities to compute various metrics to evaltorchmetrics ate performance when fitting a model. The torchinfo package provides a torchinfo useful summary of the layers of a model. We use the read_image() function read_image() when loading test images in Section 10.9.4 . In [3]: from torchmetrics import (MeanAbsoluteError , R2Score) from torchinfo import summary from torchvision.io import read_image The package pytorch_lightning is a somewhat higher-level interface to torch that simplifies the specification and fitting of models by reducing the amount of boilerplate code needed (compared to using torch alone). In [4]: from pytorch_lightning import Trainer from pytorch_lightning.loggers import CSVLogger In order to reproduce results we use seed_everything()",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_45"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [4]: from pytorch_lightning import Trainer from pytorch_lightning.loggers import CSVLogger In order to reproduce results we use seed_everything() . We will also seed_ everything() instruct torch to use deterministic algorithms where possible. In [5]: from pytorch_lightning.utilities.seed import seed_everything seed_everything(0, workers=True) torch.use_deterministic_algorithms(True, warn_only=Tr u e ) We will use several datasets shipped with torchvision for our examples: torchvision a pretrained network for image classification, as well as some transforms used for preprocessing. In [6]: from torchvision.datasets import MNIST, CIFAR100 from torchvision.models import (resnet50, ResNet50_Weights) from torchvision.transforms import (Resize, Normalize, CenterCrop , ToTensor) We have provided a few utilities in ISLP specifically for this lab. The SimpleDataModule and SimpleModule are simple versions of objects used in pytorch_lightning , the high-level module for fitting torch models. Athough more advanced uses such as computing on graphical processing units (GPUs) and parallel data processing are possible in this module, we will not be focusing much on these in this lab. The ErrorTracker handles collections of targets and predictions over each mini-batch in the validation or test stage, allowing computation of the metric over the entire validation or test data set. In [7]: from ISLP.torch import (SimpleDataModule , SimpleModule , ErrorTracker , rec_num_workers) In addition we have included some helper functions to load the IMDb database, as well as a lookup that maps integers to particular keys in the database. We’ve included a slightly modified copy of the preprocessed IMDb data from keras , a separate package for fitting deep learning models. This keras saves us significant preprocessing and allows us to focus on specifying and fitting the models themselves",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_46"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This keras saves us significant preprocessing and allows us to focus on specifying and fitting the models themselves. In [8]: from ISLP.torch.imdb import (load_lookup , load_tensor , load_sparse , load_sequential) Finally, we introduce some utility imports not directly related to torch . The glob() function from the glob module is used to find all files matching glob() wildcard characters, which we will use in our example applying the ResNet50 model to some of our own images. The json module will be used to load a json JSON file for looking up classes to identify the labels of the pictures in the ResNet50 example. In [9]: from glob import glob import json 10.9.1 Single Layer Network on Hitters Data We start by fitting the models in Section 10.6 on the Hitters data. In [10]: Hitters = load_data( 'Hitters' ).dropna() n = Hitters.shape[0] We will fit two linear models (least squares and lasso) and compare their performance to that of a neural network. For this comparison we will use mean absolute error on a validation dataset. MAE ( y, ˆ y ) = 1 n n 0 i =1 | y i − ˆ y i | . We set up the model matrix and the response. In [11]: model = MS(Hitters.columns.drop( 'Salary' ), intercept=False) X = model.fit_transform(Hitters).to_numpy() Y = Hitters[ 'Salary' ].to_nu m p y() The to_numpy() method above converts pandas data frames or series to to_numpy() numpy arrays. We do this because we will need to use sklearn to fit the lasso model, and it requires this conversion. We also use a linear regresion method from sklearn , rather than the method in Chapter 3 from statsmodels , to facilitate the comparisons. We now split the data into test and training, fixing the random state used by sklearn to do the split. In [12]: (X_train, X_test, Y_train, Y_test) = train_test_split(X, Y, test_size=1/3, random_state=1) Linear Models We fit the linear model and evaluate the test error directly",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_47"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [12]: (X_train, X_test, Y_train, Y_test) = train_test_split(X, Y, test_size=1/3, random_state=1) Linear Models We fit the linear model and evaluate the test error directly. In [13]: hit_lm = LinearRegression().fit(X_train, Y_train) Yhat_test = hit_lm.predict(X_test) np.abs(Yhat_test - Y_test).mean() Out[13]: 259.7153 Next we fit the lasso using sklearn . We are using mean absolute error to select and evaluate a model, rather than mean squared error. The spcialized solver we used in Section 6.5.2 uses only mean squared error. So here, with a bit more work, we create a cross-validation grid and perform the cross-validation directly. We encode a pipeline with two steps: we first normalize the features using a StandardScaler() transform, and then fit the lasso without further normalization. In [14]: scaler = StandardScaler(with_mean=True, with_std=True) lasso = Lasso(warm_start=True, max_iter=30000) standard_lasso = Pipeline(steps=[( 'scaler' , scaler), ( 'lasso' , lasso)]) We need to create a grid of values for λ . As is common practice, we choose a grid of 100 values of λ , uniform on the log scale from lam_max down to 0.01*lam_max . Here lam_max is the smallest value of λ with an alzero solution. This value equals the largest absolute inner-product between any predictor and the (centered) response. 24 In [15]: X_s = scaler.fit_transform(X_train) n = X_s.shape[0] lam_max = np.fabs(X_s.T.dot(Y_train - Y_train.mean())).max() / n param_grid = { 'alpha' : np.exp(np.linspace(0, np.log(0.01), 100)) * lam_max} Note that we had to transform the data first, since the scale of the varables impacts the choice of λ . We now perform cross-validation using this sequence of λ values. In [16]: cv = KFold(10, shuffle=True, random_state=1) grid = GridSearchCV(lasso, 24 The derivation of this result is beyond the scope of this book",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_48"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [16]: cv = KFold(10, shuffle=True, random_state=1) grid = GridSearchCV(lasso, 24 The derivation of this result is beyond the scope of this book. param_grid , cv=cv, scoring= 'neg_mean_absolute_error' ) grid.fit(X_train, Y_train); We extract the lasso model with best cross-validated mean absolute error, and evaluate its performance on X_test and Y_test , which were not used in cross-validation. In [17]: trained_lasso = grid.best_estimator_ Yhat_test = trained_lasso.predict(X_test) np.fabs(Yhat_test - Y_test).mean() Out[17]: 257.2382 This is similar to the results we got for the linear model fit by least squares. However, these results can vary a lot for different train/test splits; we ecourage the reader to try a different seed in code block 12 and rerun the subsequent code up to this point. Specifying a Network: Classes and Inheritance To fit the neural network, we first set up a model structure that describes the network. Doing so requires us to define new classes specific to the model we wish to fit. Typically this is done in pytorch by sub-classing a generic representation of a network, which is the approach we take here. Although this example is simple, we will go through the steps in some detail, since it will serve us well for the more complex examples to follow. In [18]: class HittersModel(nn.Module): def __init__(self, input_size): super(HittersModel , self).__init__() self.flatten = nn.Flatten() self.sequential = nn.Sequential( nn.Linear(input_size, 50), nn.ReLU(), nn.Dropout(0.4), nn.Linear(50, 1)) def forward(self, x): x = self.flatten(x) return torch.flatten(self.sequential(x)) The class statement identifies the code chunk as a declaration for a class HittersModel that inherits from the base class nn.Module . This base class is ubiquitous in torch and represents the mappings in the neural networks. Indented beneath the class statement are the methods of this class: in this case __init__ and forward . The __init__ method is called when an instance of the class is created as in the cell below",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_49"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Indented beneath the class statement are the methods of this class: in this case __init__ and forward . The __init__ method is called when an instance of the class is created as in the cell below. In the methods, self always refers to an instance of the class. In the __init__ method, we have attached two objects to self as attributes: flatten and sequential . These are used in the forward method to describe the map that this module implements. There is one additional line in the __init__ method, which is a call to super() . This function allows subclasses (i.e. HittersModel ) to access metsuper() ods of the class they inherit from. For example, the class nn.Module has its own __init__ method, which is different from the HittersModel.__init__() method we’ve written above. Using super() allows us to call the method of the base class. For torch models, we will always be making this super() call as it is necessary for the model to be properly interpreted by torch . The object nn.Module has more methods than simply __init__ and forward . These methods are directly accessible to HittersModel instances because of this inheritance. One such method we will see shortly is the eval() method, used to disable dropout for when we want to evaluate the model on test data. In [19]: hit_model = HittersModel(X.shape[1]) The object self.sequential is a composition of four maps. The first maps the 19 features of Hitters to 50 dimensions, introducing 50 × 19 + 50 parameters for the weights and intercept of the map (often called the bias ). This layer is then mapped to a ReLU layer followed by a 40% dropout layer, and finally a linear map down to 1 dimension, again with a bias. The total number of trainable parameters is therefore 50 × 19 + 50 + 50 + 1 = 1051 . The package torchinfo provides a summary() function that neatly sumarizes this information. We specify the size of the input and see the size of each tensor as it passes through layers of the network",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_50"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We specify the size of the input and see the size of each tensor as it passes through layers of the network. In [20]: summary(hit_model, input_size=X_train.shape, col_names=[ 'input_size' , 'output_size' , 'num_params' ]) Out[20]: ===================================================================== Layer (type:depth-idx) Input Shape Output Shape Param # ===================================================================== HittersModel [175, 19] [175] -- Flatten: 1-1 [175, 19] [175, 19] -- Sequential: 1-2 [175, 19] [175, 1] -- Linear: 2-1 [175, 19] [175, 50] 1,000 ReLU: 2-2 [175, 50] [175, 50] -- Dropout: 2-3 [175, 50] [175, 50] -- Linear: 2-4 [175, 50] [175, 1] 51 ===================================================================== Total params: 1,051 Trainable params: 1,051 We have truncated the end of the output slightly, here and in subsequent uses. We now need to transform our training data into a form accessible to torch . The basic datatype in torch is a tensor , which is very similar to an ndarray from early chapters. We also note here that torch typically works with 32-bit ( single precision ) rather than 64-bit ( double precision ) floating point numbers. We therefore convert our data to np.float32 before forming the tensor. The X and Y tensors are then arranged into a Dataset Dataset recognized by torch using TensorDataset() . Tensor Dataset() In [21]: X_train_t = torch.tensor(X_train.astype(np.float32)) Y_train_t = torch.tensor(Y_train.astype(np.float32)) hit_train = TensorDataset(X_train_t, Y_train_t) We do the same for the test data. In [22]: X_test_t = torch.tensor(X_test.astype(np.float32)) Y_test_t = torch.tensor(Y_test.astype(np.float32)) hit_test = TensorDataset(X_test_t, Y_test_t) Finally, this dataset is passed to a DataLoader() which ultimately passes data into our network. While this may seem like a lot of overhead, this structure is helpful for more complex tasks where data may live on different machines, or where data must be passed to a GPU",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_51"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". While this may seem like a lot of overhead, this structure is helpful for more complex tasks where data may live on different machines, or where data must be passed to a GPU. We provide a helper function SimpleDataModule() in ISLP to make this task easier for standard SimpleData Module() usage. One of its arguments is num_workers , which indicates how many processes we will use for loading the data. For small data like Hitters this will have little effect, but it does provide an advantage for the MNIST and CIFAR100 examples below. The torch package will inspect the process running and determine a maximum number of workers. 25 We’ve included a function rec_num_workers() to compute this so we know how many workers might be reasonable (here the max was 16). In [23]: max_num_workers = rec_num_workers() The general training setup in pytorch_lightning involves training, valdation and test data. These are each represented by different data loaders. During each epoch, we run a training step to learn the model and a valdation step to track the error. The test data is typically used at the end of training to evaluate the model. In this case, as we had split only into test and training, we’ll use the test data as validation data with the argument validation=hit_test . The validation argument can be a float between 0 and 1, an integer, or a Dataset . If a float (respectively, integer), it is interpreted as a percentage (respectively number) of the training observations to be used for validation. If it is a Dataset , it is passed directly to a data loader. In [24]: hit_dm = SimpleDataModule(hit_train, hit_test, batch_size=32, num_workers=min(4, max_num_workers), validation=hit_test) Next we must provide a pytorch_lightning module that controls the steps performed during the training process. We provide methods for our SimpleModule() that simply record the value of the loss function and any additional metrics at the end of each epoch",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_52"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We provide methods for our SimpleModule() that simply record the value of the loss function and any additional metrics at the end of each epoch. These operations are controlled by the methods SimpleModule.[training/test/validation]_step() , though we will not be modifying these in our examples. 25 This depends on the computing hardware and the number of cores available. In [25]: hit_module = SimpleModule.regression(hit_model, metrics={ 'mae' :MeanAbsolut eEr ror ( ) } ) By using the SimpleModule.regression() method, we indicate that we SimpleModule. regression() will use squared-error loss as in ( 10.23 ). We have also asked for mean asolute error to be tracked as well in the metrics that are logged. We log our results via CSVLogger() , which in this case stores the results in a CSV file within a directory logs/hitters . After the fitting is complete, this allows us to load the results as a pd.DataFrame() and visualize them below. There are several ways to log the results within pytorch_lightning , though we will not cover those here in detail. In [26]: hit_logger = CSVLogger( 'logs' , name= 'hitters' ) Finally we are ready to train our model and log the results. We use the Trainer() object from pytorch_lightning to do this work. The argment datamodule=hit_dm tells the trainer how training/validation/test logs are produced, while the first argument hit_module specifies the network architecture as well as the training/validation/test steps. The callbacks argument allows for several tasks to be carried out at various points while training a model. Here our ErrorTracker() callback will enable us to copute validation error while training and, finally, the test error. We now fit the model for 50 epochs. In [27]: hit_trainer = Trainer(deterministic=True, max_epochs=50, log_every_n_steps=5, logger=hit_logger, callbacks=[ErrorTracker()]) hit_trainer.fit(hit_module, datamodule=hit_dm) At each step of SGD, the algorithm randomly selects 32 training observtions for the computation of the gradient",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_53"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Recall from Section 10.7 that an epoch amounts to the number of SGD steps required to process n observtions. Since the training set has n = 175 , and we specified a batch_size of 32 in the construction of hit_dm , an epoch is 175 / 32 = 5 . 5 SGD steps. After having fit the model, we can evaluate performance on our test data using the test() method of our trainer. In [28]: hit_trainer.test(hit_module, datamodule=hit_dm) Out[28]: [{ 'test_loss' : 104098.5469, 'test_mae' : 229.5012}] The results of the fit have been logged into a CSV file. We can find the results specific to this run in the experiment.metrics_file_path attribute of our logger. Note that each time the model is fit, the logger will output results into a new subdirectory of our directory logs/hitters . We now create a plot of the MAE (mean absolute error) as a function of the number of epochs. First we retrieve the logged summaries. hit_results = pd.read_csv(hit_logger.experiment.metrics_file_path) Since we will produce similar plots in later examples, we write a simple generic function to produce this plot. In [29]: def summary_plot(results, ax, col= 'loss' , valid_legend= 'Validation' , training_legend= 'Training' , ylabel= 'Loss' , fontsize=20): for (column, color, label) in zip([f 'train_{col}_epoch' , f 'valid_{col}' ], [ 'black' , 'red' ], [training_legend , valid_legend]): results.plot(x= 'epoch' , y=column, label=label, marker= 'o' , color=color, ax=ax) ax.set_xlabel( 'Epoch' ) ax.set_ylabel(ylabel) return ax We now set up our axes, and use our function to produce the MAE plot. In [30]: fig, ax = subplots(1, 1, figsize=(6, 6)) ax = summary_plot(hit_results , ax, col= 'mae' , ylabel= 'MAE' , valid_legend= 'Validation (=Test)' ) ax.set_ylim([0, 400]) ax.set_xticks(np.linspace(0, 50, 11).astype(int)); We can predict directly from the final model, and evaluate its peformance on the test data. Before fitting, we call the eval() method of hit_model",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_54"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Before fitting, we call the eval() method of hit_model . This tells torch to effectively consider this model to be fitted, so that we can use it to predict on new data. For our model here, the biggest change is that the dropout layers will be turned off, i.e. no weights will be randomly dropped in predicting on new data. In [31]: hit_model.eval() preds = hit_module(X_test_t) torch.abs(Y_test_t - preds).mean() Out[31]: tensor(229.5012, grad_fn=<MeanBackward0 >) Cleanup In setting up our data module, we had initiated several worker processes that will remain running. We delete all references to the torch objects to ensure these processes will be killed. In [32]: del(Hitters, hit_model, hit_dm, hit_logger, hit_test, hit_train, X, Y, X_test, X_train, Y_test, Y_train, X_test_t, Y_test_t, hit_trainer , hit_module) 10.9.2 Multilayer Network on the MNIST Digit Data The torchvision package comes with a number of example datasets, incluing the MNIST digit data. Our first step is to retrieve the training and test data sets; the MNIST() function within torchvision.datasets is provided for MNIST() this purpose. The data will be downloaded the first time this function is executed, and stored in the directory data/MNIST . In [33]: (mnist_train , mnist_test) = [MNIST(root= 'data' , train=train, download=True, transform=ToTensor()) for train in [True, False]] mnist_train Out[33]: Dataset MNIST Number of datapoints: 60000 Root location: data Split: Train StandardTransform Transform: ToTensor() There are 60,000 images in the training data and 10,000 in the test data. The images are 28 × 28 , and stored as a matrix of pixels. We need to transform each one into a vector. Neural networks are somewhat sensitive to the scale of the inputs, much as ridge and lasso regularization are affected by scaling. Here the inputs are eight-bit grayscale values between 0 and 255, so we rescale to the unit interval",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_55"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Here the inputs are eight-bit grayscale values between 0 and 255, so we rescale to the unit interval. 26 This transformation, along with some reordering of the axes, is performed by the ToTensor() transform from the torchvision.transforms package. As in our Hitters example, we form a data module from the training and test datasets, setting aside 20% of the training images for validation. In [34]: mnist_dm = SimpleDataModule(mnist_train , mnist_test , validation=0.2, num_workers=max_num_workers , b a t c h _ s ize=256) 26 Note: eight bits means 2 8 , which equals 256. Since the convention is to start at 0 , the possible values range from 0 to 255 . Let’s take a look at the data that will get fed into our network. We loop through the first few chunks of the test dataset, breaking after 2 batches: In [35]: for idx, (X_ ,Y_) in enumerate(mnist_dm.train_dataloader()): print( 'X: ' , X_.shape) print( 'Y: ' , Y_.shape) if idx >= 1: break X: torch.Size([256, 1, 28, 28]) Y: torch.Size([256]) X: torch.Size([256, 1, 28, 28]) Y: torch.Size([256]) We see that the X for each batch consists of 256 images of size 1x28x28 . Here the 1 indicates a single channel (greyscale). For RGB images such as CIFAR100 below, we will see that the 1 in the size will be replaced by 3 for the three RGB channels. Now we are ready to specify our neural network. In [36]: class MNISTModel(nn.Module): def __init__(self): super(MNISTModel, self).__init__() self.layer1 = nn.Sequential( nn.Flatten(), nn.Linear(28*28, 256), nn.ReLU(), nn.Dropout(0.4)) self.layer2 = nn.Sequential( nn.Linear(256, 128), nn.ReLU(), nn.Dropout(0.3)) self._forward = nn.Sequential( self.layer1, self.layer2, nn.Linear(128, 10)) def forward(self, x): return self._forward(x) We see that in the first layer, each 1x28x28 image is flattened, then mapped to 256 dimensions where we apply a ReLU activation with 40% dropout. A second layer maps the first layer’s output down to 128 dmensions, applying a ReLU activation with 30% dropout",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_56"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A second layer maps the first layer’s output down to 128 dmensions, applying a ReLU activation with 30% dropout. Finally, the 128 dimensions are mapped down to 10, the number of classes in the MNIST data. In [37]: mnist_model = MNISTModel() We can check that the model produces output of expected size based on our existing batch X_ above. In [38]: mnist_model(X_).size() Out[38]: torch.Size([256, 10]) Let’s take a look at the summary of the model. Instead of an input_size we can pass a tensor of correct shape. In this case, we pass through the final batched X_ from above. In [39]: summary(mnist_model , input_data=X_, col_names=[ 'input_size' , 'output_size' , 'num_params' ]) Out[39]: ===================================================================== Layer (type:depth-idx) Input Shape Output Shape Param # ===================================================================== MNISTModel [256, 1, 28, 28] [256, 10] -- Sequential: 1-1 [256, 1, 28, 28] [256, 10] -- Sequential: 2-1 [256, 1, 28, 28] [256, 256] -- Flatten: 3-1 [256, 1, 28, 28] [256, 784] -- Linear: 3-2 [256, 784] [256, 256] 200,960 ReLU: 3-3 [256, 256] [256, 256] -- Dropout: 3-4 [256, 256] [256, 256] -- Sequential: 2-2 [256, 256] [256, 128] -- Linear: 3-5 [256, 256] [256, 128] 32,896 ReLU: 3-6 [256, 128] [256, 128] -- Dropout: 3-7 [256, 128] [256, 128] -- Linear: 2-3 [256, 128] [256, 10] 1,290 ===================================================================== Total params: 235,146 Trainable params: 235,146 Having set up both the model and the data module, fitting this model is now almost identical to the Hitters example. In contrast to our regression model, here we will use the SimpleModule.classification() method which SimpleModule. classifcation() uses the cross-entropy loss function instead of mean squared error. In [40]: mnist_module = SimpleModule.classification(mnist_model) mnist_logger = CSVLogger( 'logs' , name= 'MNIST' ) Now we are ready to go. The final step is to supply training data, and fit the model",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_57"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The final step is to supply training data, and fit the model. In [41]: mnist_trainer = Trainer(deterministic=True, max_epochs=30, logger=mnist_logger , callbacks=[ErrorTracker()]) mnist_trainer.fit(mnist_module , datamodule=mnist_dm) We have suppressed the output here, which is a progress report on the fitting of the model, grouped by epoch. This is very useful, since on large datasets fitting can take time. Fitting this model took 245 seconds on a MacBook Pro with an Apple M1 Pro chip with 10 cores and 16 GB of RAM. Here we specified a validation split of 20%, so training is actually performed on 80% of the 60,000 observations in the training set. This is an alternative to actually supplying validation data, like we did for the Hitters data. SGD uses batches of 256 observations in computing the gradient, and doing the arithmetic, we see that an epoch corresponds to 188 gradient steps. SimpleModule.classification() includes an accuracy metric by default. Other classification metrics can be added from torchmetrics . We will use our summary_plot() function to display accuracy across epochs. In [42]: mnist_results = pd.read_csv(mnist_logger.experiment. metrics_file_path) fig, ax = subplots(1, 1, figsize=(6, 6)) summary_plot(mnist_results , ax, col= 'accuracy' , ylabel= 'Accuracy' ) ax.set_ylim([0.5, 1]) ax.set_ylabel( 'Accuracy' ) ax.set_xticks(np.linspace(0, 30, 7).astype(int)); Once again we evaluate the accuracy using the test() method of our trainer. This model achieves 97% accuracy on the test data. In [43]: mnist_trainer.test(mnist_module , datamodule=mnist_dm) Out[43]: [{ 'test_loss' : 0.1471, 'test_accuracy' : 0.9681}] Table 10.1 also reports the error rates resulting from LDA (Chapter 4 ) and multiclass logistic regression. For LDA we refer the reader to Section 4.7.3 . Although we could use the sklearn function LogisticRegression() to fit multiclass logistic regression, we are set up here to fit such a model with torch",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_58"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Although we could use the sklearn function LogisticRegression() to fit multiclass logistic regression, we are set up here to fit such a model with torch . We just have an input layer and an output layer, and omit the hidden layers! In [44]: class MNIST_MLR(nn.Module): def __init__(self): super(MNIST_MLR, self).__init__() self.linear = nn.Sequential(nn.Flatten(), nn.Linear(784, 10)) def forward(self, x): return self.linear(x) mlr_model = MNIST_MLR() mlr_module = SimpleModule.classification(mlr_model) mlr_logger = CSVLogger( 'logs' , name= 'MNIST_MLR' ) In [45]: mlr_trainer = Trainer(deterministic=True, max_epochs=30, callbacks=[ErrorTracker()]) mlr_trainer.fit(mlr_module, datamodule=mnist_dm) We fit the model just as before and compute the test results. In [46]: mlr_trainer.test(mlr_module, datamodule=m n i s t _ dm) Out[46]: [{ 'test_loss' : 0.3187, 'test_accuracy' : 0.9241}] The accuracy is above 90% even for this pretty simple model. As in the Hitters example, we delete some of the objects we created above. In [47]: del(mnist_test, mnist_train , mnist_model , mnist_dm, mnist_trainer , mnist_module , mnist_results , mlr_model, mlr_module, mlr_trainer) 10.9.3 Convolutional Neural Networks In this section we fit a CNN to the CIFAR100 data, which is available in the torchvision package. It is arranged in a similar fashion as the MNIST data. In [48]: (cifar_train , cifar_test) = [CIFAR100(root= \"data\" , train=train, download=True) for train in [True, False]] In [49]: transform = ToTensor() cifar_train_X = torch.stack([transform(x) for x in cifar_train.data]) cifar_test_X = torch.stack([transform(x) for x in cifar_test.data]) cifar_train = TensorDataset(cifar_train_X , torch.tensor(cifar_train.targets)) cifar_test = TensorDataset(cifar_test_X , torch.tensor(cifar_test.targets)) The CIFAR100 dataset consists of 50,000 training images, each represented by a three-dimensional tensor: each three-color image is represented as a set of three channels, each of which consists of 32 × 32 eight-bit pixels",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_59"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We standardize as we did for the digits, but keep the array structure. This is accomplished with the ToTensor() transform. Creating the data module is similar to the MNIST example. In [50]: cifar_dm = SimpleDataModule(cifar_train , cifar_test , validation=0.2, num_workers=max_num_workers , batch_size=128) We again look at the shape of typical batches in our data loaders. In [51]: for idx, (X_ ,Y_) in enumerate(cifar_dm.train_dataloader()): print( 'X: ' , X_.shape) print( 'Y: ' , Y_.shape) if idx >= 1: break X: torch.Size([128, 3, 32, 32]) Y: torch.Size([128]) X: torch.Size([128, 3, 32, 32]) Y: torch.Size([128]) Before we start, we look at some of the training images; similar code produced Figure 10.5 on page 406 . The example below also illustrates that TensorDataset objects can be indexed with integers — we are choosing radom images from the training data by indexing cifar_train . In order to diplay correctly, we must reorder the dimensions by a call to np.transpose() . In [52]: fig, axes = subplots(5, 5, figsize=(10,10)) rng = np.random.default_rng(4) indices = rng.choice(np.arange(len(cifar_train)), 25, replace=False).reshape((5,5)) for i in range(5): for j in range(5): idx = indices[i,j] axes[i,j].imshow(np.transpose(cifar_train[idx][0], [1,2,0]), interpolation=None) axes[i,j].set_xticks([]) axes[i,j].set_yticks([]) Here the imshow() method recognizes from the shape of its argument that .imshow() it is a 3-dimensional array, with the last dimension indexing the three RGB color channels. We specify a moderately-sized CNN for demonstration purposes, simlar in structure to Figure 10.8 . We use several layers, each consisting of convolution, ReLU, and max-pooling steps. We first define a module that defines one of these layers. As in our previous examples, we overwrite the __init__() and forward() methods of nn.Module . This user-defined module can now be used in ways just like nn.Linear() or nn.Dropout()",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_60"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". As in our previous examples, we overwrite the __init__() and forward() methods of nn.Module . This user-defined module can now be used in ways just like nn.Linear() or nn.Dropout() . In [53]: class BuildingBlock(nn.Module): def __init__(self, in_channels , out_channels): super(BuildingBlock , self).__init__() self.conv = nn.Conv2d(in_channels=in_channels , out_channels=out_channels , kernel_size=(3,3), padding= 'same' ) self.activation = nn.ReLU() self.pool = nn.MaxPool2d(kernel_size=(2,2)) def forward(self, x): return self.pool(self.activation(self.conv(x))) Notice that we used the padding = \"same\" argument to nn.Conv2d() , which ensures that the output channels have the same dimension as the input channels. There are 32 channels in the first hidden layer, in contrast to the three channels in the input layer. We use a 3 × 3 convolution fiter for each channel in all the layers. Each convolution is followed by a max-pooling layer over 2 × 2 blocks. In forming our deep learning model for the CIFAR100 data, we use several of our BuildingBlock() modules sequentially. This simple example illutrates some of the power of torch . Users can define modules of their own, which can be combined in other modules. Ultimately, everything is fit by a generic trainer. In [54]: class CIFARModel(nn.Module): def __init__(self): super(CIFARModel, self).__init__() sizes = [(3,32), (32,64), (64,128), (128,256)] self.conv = nn.Sequential(*[BuildingBlock(in_, out_) for in_, out_ in sizes]) self.output = nn.Sequential(nn.Dropout(0.5), nn.Linear(2*2*256, 512), nn.ReLU(), nn.Linear(512, 100)) def forward(self, x): val = self.conv(x) val = torch.flatten(val, start_dim=1) return self.output(val) We build the model and look at the summary",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_61"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (We had created examples of X_ earlier.) In [55]: cifar_model = CIFARModel() summary(cifar_model , input_data=X_, col_names=[ 'input_size' , 'output_size' , 'num_params' ]) Out[55]: ====================================================================== Layer (type:depth-idx) Input Shape Output Shape Param # ====================================================================== CIFARModel [128, 3, 32, 32] [128, 100] -- Sequential: 1-1 [128, 3, 32, 32] [128, 256, 2, 2] -- BuildingBlock: 2-1 [128, 3, 32, 32] [128, 32, 16, 16] -- Conv2d: 3-1 [128, 3, 32, 32] [128, 32, 32, 32] 896 ReLU: 3-2 [128, 32, 32, 32] [128, 32, 32, 32] -- MaxPool2d: 3-3 [128, 32, 32, 32] [128, 32, 16, 16] -- BuildingBlock: 2-2 [128, 32, 16, 16] [128, 64, 8, 8] -- Conv2d: 3-4 [128, 32, 16, 16] [128, 64, 16, 16] 18,496 ReLU: 3-5 [128, 64, 16, 16] [128, 64, 16, 16] -- MaxPool2d: 3-6 [128, 64, 16, 16] [128, 64, 8, 8] -- BuildingBlock: 2-3 [128, 64, 8, 8] [128, 128, 4, 4] -- Conv2d: 3-7 [128, 64, 8, 8] [128, 128, 8, 8] 73,856 ReLU: 3-8 [128, 128, 8, 8] [128, 128, 8, 8] -- MaxPool2d: 3-9 [128, 128, 8, 8] [128, 128, 4, 4] -- BuildingBlock: 2-4 [128, 128, 4, 4] [128, 256, 2, 2] -- Conv2d: 3-10 [128, 128, 4, 4] [128, 256, 4, 4] 295,168 ReLU: 3-11 [128, 256, 4, 4] [128, 256, 4, 4] -- MaxPool2d: 3-12 [128, 256, 4, 4] [128, 256, 2, 2] -- Sequential: 1-2 [128, 1024] [128, 100] -- Dropout: 2-5 [128, 1024] [128, 1024] -- Linear: 2-6 [128, 1024] [128, 512] 524,800 ReLU: 2-7 [128, 512] [128, 512] -- Linear: 2-8 [128, 512] [128, 100] 51,300 ====================================================================== Total params: 964,516 Trainable params: 964,516 The total number of trainable parameters is 964,516. By studying the size of the parameters, we can see that the channels halve in both dimensions after each of these max-pooling operations. After the last of these we have a layer with 256 channels of dimension 2 × 2",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_62"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". After the last of these we have a layer with 256 channels of dimension 2 × 2 . These are then flattened to a dense layer of size 1,024; in other words, each of the 2 × 2 matrices is turned into a 4 -vector, and put side-by-side in one layer. This is followed by a dropout regularization layer, then another dense layer of size 512, and finally, the output layer. Up to now, we have been using a default optimizer in SimpleModule() . For these data, experiments show that a smaller learning rate performs better than the default 0.01. We use a custom optimizer here with a learning rate of 0.001. Besides this, the logging and training follow a similar pattern to our previous examples. The optimizer takes an argument params that informs the optimizer which parameters are involved in SGD (stochastic gradient descent). We saw earlier that entries of a module’s parameters are tensors. In passing the parameters to the optimizer we are doing more than simply passing arrays; part of the structure of the graph is encoded in the tensors themselves. In [56]: cifar_optimizer = RMSprop(cifar_model.parameters(), lr=0.001) cifar_module = SimpleModule.classification(cifar_model , optimizer=cifar_optimizer) cifar_logger = CSVLogger( 'logs' , name= 'CIFAR100' ) In [57]: cifar_trainer = Trainer(deterministic=True, max_epochs=30, logger=cifar_logger , callbacks=[ErrorTracker()]) cifar_trainer.fit(cifar_module , datamodule=cifar_dm) This model takes 10 minutes or more to run and achieves about 42% accuracy on the test data. Although this is not terrible for 100-class data (a random classifier gets 1% accuracy), searching the web we see results around 75%. Typically it takes a lot of architecture carpentry, fiddling with regularization, and time, to achieve such results. Let’s take a look at the validation and training accuracy across epochs",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_63"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Typically it takes a lot of architecture carpentry, fiddling with regularization, and time, to achieve such results. Let’s take a look at the validation and training accuracy across epochs. In [58]: log_path = cifar_logger.experiment.metrics_file_path cifar_results = pd.read_csv(log_path) fig, ax = subplots(1, 1, figsize=(6, 6)) summary_plot(cifar_results , ax, col= 'accuracy' , ylabel= 'Accuracy' ) ax.set_xticks(np.linspace(0, 10, 6).astype(int)) ax.set_ylabel( 'Accuracy' ) ax.set_ylim([0, 1]); Finally, we evaluate our model on our test data. In [59]: cifar_trainer.test(cifar_module , datamodule=cifar_dm) Out[59]: [{ 'test_loss' : 2.4238 'test_accuracy' : 0.4206}] Hardware Acceleration As deep learning has become ubiquitous in machine learning, hardware manufacturers have produced special libraries that can often speed up the gradient-descent steps. For instance, Mac OS devices with the M1 chip may have the Metal prgramming framework enabled, which can speed up the torch computations. We present an example of how to use this acceleration. The main changes are to the Trainer() call as well as to the metrics that will be evaluated on the data. These metrics must be told where the data will be located at evaluation time. This is accomplished with a call to the to() method of the metrics. In [60]: try: for name, metric in cifar_module.metrics.items(): cifar_module.metrics[name] = metric.to( 'mps' ) cifar_trainer_mps = Trainer(accelerator= 'mps' , deterministic=True, max_epochs=30) cifar_trainer_mps.fit(cifar_module , datamodule=cifar_dm) cifar_trainer_mps.test(cifar_module , datamodule=cifar_dm) except: pass This yields approximately twor three-fold acceleration for each epoch. We have protected this code block using try: and except: clauses; if it works, we get the speedup, if it fails, nothing happens. 10.9.4 Using Pretrained CNN Models We now show how to use a CNN pretrained on the imagenet database to classify natural images, and demonstrate how we produced Figure 10.10",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_64"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 10.9.4 Using Pretrained CNN Models We now show how to use a CNN pretrained on the imagenet database to classify natural images, and demonstrate how we produced Figure 10.10 . We copied six JPEG images from a digital photo album into the diretory book_images . These images are available from the data section of www. statlearning.com , the ISLP book website. Download book_images.zip ; when clicked it creates the book_images directory. The pretrained network we use is called resnet50 ; specification details can be found on the web. We will read in the images, and convert them into the array format expected by the torch software to match the specifications in resnet50 . The conversion involves a resize, a crop and then a predefined standardization for each of the three channels. We now read in the images and preprocess them. In [61]: resize = Resize((232,232)) crop = CenterCrop(224) normalize = Normalize([0.485,0.456,0.406], [0.229,0.224,0.225]) imgfiles = sorted([f for f in glob( 'book_images/*' )]) imgs = torch.stack([torch.div(crop(resize(read_image(f))), 255) for f in imgfiles]) imgs = normalize(imgs) imgs.size() Out[61]: torch.Size([6, 3, 224, 224]) We now set up the trained network with the weights we read in code block 6. The model has 50 layers, with a fair bit of complexity. In [62]: resnet_model = resnet50(weights=ResNet50_Weights.DEFAULT) summary(resnet_model , input_data=imgs, col_names=[ 'input_size' , 'output_size' , 'num_params' ]) We set the mode to eval() to ensure that the model is ready to predict on new data. In [63]: resnet_model.eval() Inspecting the output above, we see that when setting up the resnet_model , the authors defined a Bottleneck , much like our BuildingBlock module. We now feed our six images through the fitted network. In [64]: img_preds = resnet_model(imgs) Let’s look at the predicted probabilities for each of the top 3 choices. First we compute the probabilities by applying the softmax to the logits in img_preds",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_65"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". First we compute the probabilities by applying the softmax to the logits in img_preds . Note that we have had to call the detach() method on the tensor img_preds in order to convert it to our a more familiar ndarray . In [65]: img_probs = np.exp(np.asarray(img_preds.detach())) img_probs /= img_probs.sum( 1) [ : ,N o ne] In order to see the class labels, we must download the index file associated with imagenet . 27 In [66]: labs = json.load(open( 'imagenet_class_index.json' )) class_labels = pd.DataFrame([(int(k), v[1]) for k, v in labs.items()], columns=[ 'idx' , 'label' ]) class_labels = class_labels.set_index( 'idx' ) class_labels = class_labels.sort_index() We’ll now construct a data frame for each image file with the labels with the three highest probabilities as estimated by the model above. 27 This is avalable from the book website and s3.amazonaws.com/deep-learninmodels/image-models/imagenet_class_index.json . In [67]: for i, imgfile in enumerate(imgfiles): img_df = class_labels.copy() img_df[ 'prob' ] = img_probs[i] img_df = img_df.sort_values(by= 'prob' , ascending=False)[:3] print(f 'Image: {imgfile}' ) print(img_df.reset_index().drop(columns=[ 'idx' ])) Image: book_images/Cape_Weaver.jpg label prob 0 jacamar 0.287283 1 bee_eater 0.046768 2 bulbul 0.037507 Image: book_images/Flamingo.jpg label prob 0 flamingo 0.591761 1 spoonbill 0.012386 2 American_egret 0.002105 Image: book_images/Hawk_Fountain.jpg label prob 0 great_grey_owl 0.287959 1 kite 0.039478 2 fountain 0.029384 Image: book_images/Hawk_cropped.jpg label prob 0 kite 0.301830 1 jay 0.121674 2 magpie 0.015513 Image: book_images/Lhasa_Apso.jpg label prob 0 Lhasa 0.151143 1 Shih-Tzu 0.129850 2 Tibetan_terrier 0.102358 Image: book_images/Sleeping_Cat.jpg label prob 0 tabby 0.173627 1 tiger_cat 0.110414 2 doormat 0.093447 We see that the model is quite confident about Flamingo.jpg , but a little less so for the other images. We end this section with our usual cleanup",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_66"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We end this section with our usual cleanup. In [68]: del(cifar_test, cifar_train , cifar_dm, cifar_module , cifar_logger , cifar_optimizer , cifar_trainer) 10.9.5 IMDB Document Classification We now implement models for sentiment classification (Section 10.4 ) on the IMDB dataset. As mentioned above code block 8, we are using a preprcessed version of the IMDB dataset found in the keras package. As keras uses tensorflow , a different tensor and deep learning library, we have converted the data to be suitable for torch . The code used to convert from keras is available in the module ISLP.torch._make_imdb . It requires some of the keras packages to run. These data use a dictionary of size 10,000. We have stored three different representations of the review data for this lab: • load_tensor() , a sparse tensor version usable by torch ; • load_sparse() , a sparse matrix version usable by sklearn , since we will compare with a lasso fit; • load_sequential() , a padded version of the original sequence reprsentation, limited to the last 500 words of each review. In [69]: (imdb_seq_train , imdb_seq_test) = load_sequential(root= 'data/IMDB' ) padded_sample = np.asarray(imdb_seq_train.tensors[0][0]) sample_review = padded_sample[padded_sample > 0][:12] sample_review[:12] Out[69]: array([ 1, 14, 22, 16, 43, 530, 973, 1622, 1385, 65, 458, 4468], dtype=int32) The datasets imdb_seq_train and imdb_seq_test are both instances of the class TensorDataset . The tensors used to construct them can be found in the tensors attribute, with the first tensor the features X and the second the outcome Y . We have taken the first row of features and stored it as padded_sample . In the preprocessing used to form these data, sequences were padded with 0s in the beginning if they were not long enough, hence we remove this padding by restricting to entries where padded_sample > 0 . We then provide the first 12 words of the sample review. We can find these words in the lookup dictionary from the ISLP.torch.imdb module",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_67"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We then provide the first 12 words of the sample review. We can find these words in the lookup dictionary from the ISLP.torch.imdb module. In [70]: lookup = load_lookup(root= 'data/IMDB' ) ' ' .join(lookup[i] for i in sample_review) Out[70]: \"<START> this film was just brilliant casting location scenery story direction everyone's\" For our first model, we have created a binary feature for each of the 10,000 possible words in the dataset, with an entry of one in the i, j entry if word j appears in review i . As most reviews are quite short, such a feature matrix has over 98% zeros. These data are accessed using load_tensor() from the ISLP library. In [71]: max_num_workers=10 (imdb_train , imdb_test) = load_tensor(root= 'data/IMDB' ) imdb_dm = SimpleDataModule(imdb_train, imdb_test, validation=2000, num_workers=min(6, max_num_workers), batch_size=512) We’ll use a two-layer model for our first model. In [72]: class IMDBModel(nn.Module): def __init__(self, input_size): super(IMDBModel, self).__init__() self.dense1 = nn.Linear(input_size, 16) self.activation = nn.ReLU() self.dense2 = nn.Linear(16, 16) self.output = nn.Linear(16, 1) def forward(self, x): val = x for _map in [self.dense1, self.activation, self.dense2, self.activation, self.output]: val = _map(val) return torch.flatten(val) We now instantiate our model and look at a summary (not shown). In [73]: imdb_model = IMDBModel(imdb_test.tensors[0].size()[1]) summary(imdb_model, input_size=imdb_test.tensors[0].size(), col_names=[ 'input_size' , 'output_size' , 'num_params' ]) We’ll again use a smaller learning rate for these data, hence we pass an optimizer to the SimpleModule . Since the reviews are classified into positive or negative sentiment, we use SimpleModule.binary_classification()",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_68"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Since the reviews are classified into positive or negative sentiment, we use SimpleModule.binary_classification() . 28 In [74]: imdb_optimizer = RMSprop(imdb_model.parameters(), lr=0.001) imdb_module = SimpleModule.binary_classification( imdb_model , op t i m i z e r= imdb_optimizer) Having loaded the datasets into a data module and created a SimpleModule , the remaining steps are familiar. In [75]: imdb_logger = CSVLogger( 'logs' , name= 'IMDB' ) imdb_trainer = Trainer(deterministic=True, max_epochs=30, logger=imdb_logger , callbacks=[ErrorTracker()]) imdb_trainer.fit(imdb_module , datamodule=i mdb _d m ) Evaluating the test error yields roughly 86% accuracy. In [76]: test_results = imdb_trainer.test(imdb_module , datamodule=imdb_dm) test_results 28 Our use of binary_classification() instead of classification() is due to some subtlety in how torchmetrics.Accuracy() works, as well as the data type of the targets. Out[76]: [{ 'test_loss' : 1.0863, 'test_accuracy' : 0.8550}] Comparison to Lasso We now fit a lasso logistic regression model using LogisticRegression() from sklearn . Since sklearn does not recognize the sparse tensors of torch , we use a sparse matrix that is recognized by sklearn. In [77]: ((X_train, Y_train), (X_valid, Y_valid), (X_test, Y_test)) = load_sparse(validation=2000, random_state=0, root= 'data/IMDB' ) Similar to what we did in Section 10.9.1 , we construct a series of 50 values for the lasso reguralization parameter λ . In [78]: lam_max = np.abs(X_train.T * (Y_train - Y_train.mean())).max() lam_val = lam_max * np.exp(np.linspace(np.log(1), np.log(1e-4), 50)) With LogisticRegression() the regularization parameter C is specified as the inverse of λ . There are several solvers for logistic regression; here we use liblinear which works well with the sparse input format. In [79]: logit = LogisticRegression(penalty= 'l1' , C=1/lam_max, solver= 'liblinear' , warm_start=True, fit_intercept=True) The path of 50 values takes approximately 40 seconds to run",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_69"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [79]: logit = LogisticRegression(penalty= 'l1' , C=1/lam_max, solver= 'liblinear' , warm_start=True, fit_intercept=True) The path of 50 values takes approximately 40 seconds to run. In [80]: coefs = [] intercepts = [] for l in lam_val: logit.C = 1/l logit.fit(X_train, Y_train) coefs.append(logit.coef_.copy()) intercepts.append(logit.intercept_) The coefficient and intercepts have an extraneous dimension which can be removed by the np.squeeze() function. In [81]: coefs = np.squeeze(coefs) intercepts = np.squeeze(intercepts) We’ll now make a plot to compare our neural network results with the lasso. In [82]: %%capture fig, axes = subplots(1, 2, figsize=(16, 8), sharey=True) for ((X_, Y_), data_, color) in zip([(X_train, Y_train), (X_valid, Y_valid), (X_test, Y_test)], [ 'Training' , 'Validation' , 'Test' ], [ 'black' , 'red' , 'blue' ]): linpred_ = X_ * coefs.T + intercepts[None,:] label_ = np.array(linpred_ > 0) accuracy_ = np.array([np.mean(Y_ == l) for l in label_.T]) axes[0].plot(-np.log(lam_val / X_train.shape[0]), accuracy_, '.--' , color=color, markersize=13, linewidth=2, label=data_) axes[0].legend() axes[0].set_xlabel( r'$-\\log(\\lambda)$' , fontsize=20) axes[0].set_ylabel( 'Accuracy' , fontsize=20) Notice the use of %%capture , which suppresses the displaying of the partially %%capture completed figure. This is useful when making a complex figure, since the steps can be spread across two or more cells. We now add a plot of the lasso accuracy, and display the composed figure by simply entering its name at the end of the cell",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_70"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We now add a plot of the lasso accuracy, and display the composed figure by simply entering its name at the end of the cell. In [83]: imdb_results = pd.read_csv(imdb_logger.experiment.metrics_file_path) summary_plot(imdb_results , axes[1], col= 'accuracy' , ylabel= 'Accuracy' ) axes[1].set_xticks(np.linspace(0, 30, 7).astype(int)) axes[1].set_ylabel( 'Accuracy' , fontsize=20) axes[1].set_xlabel( 'Epoch' , fontsize=20) axes[1].set_ylim([0.5, 1]); axes[1].axhline(test_results[0][ 'test_accuracy' ], color= 'blue' , linestyle= '--' , linewidth=3) fig From the graphs we see that the accuracy of the lasso logistic regression peaks at about 0 . 88 , as it does for the neural network. Once again, we end with a cleanup. In [84]: del(imdb_model, imdb_trainer , imdb_logger , imdb_dm, imdb_train, imdb_test) 10.9.6 Recurrent Neural Networks In this lab we fit the models illustrated in Section 10.5 . Sequential Models for Document Classification Here we fit a simple LSTM RNN for sentiment prediction to the IMDb movie-review data, as discussed in Section 10.5.1 . For an RNN we use the sequence of words in a document, taking their order into account. We loaded the preprocessed data at the beginning of Section 10.9.5 . A script that details the preprocessing can be found in the ISLP library. Notably, since more than 90% of the documents had fewer than 500 words, we set the document length to 500. For longer documents, we used the last 500 words, and for shorter documents, we padded the front with blanks. In [85]: imdb_seq_dm = SimpleDataModule(imdb_seq_train , imdb_seq_test , validation=2000, batch_size=300, num_workers=min(6, max_num_workers) ) The first layer of the RNN is an embedding layer of size 32, which will be learned during training. This layer one-hot encodes each document as a matrix of dimension 500 × 10 , 003 , and then maps these 10 , 003 dimensions down to 32",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_71"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This layer one-hot encodes each document as a matrix of dimension 500 × 10 , 003 , and then maps these 10 , 003 dimensions down to 32 . 29 Since each word is represented by an integer, this is effectively achieved by the creation of an embedding matrix of size 10 , 003 × 32 ; each of the 500 integers in the document are then mapped to the appropriate 32 real numbers by indexing the appropriate rows of this matrix. The second layer is an LSTM with 32 units, and the output layer is a single logit for the binary classification task. In the last line of the forward() method below, we take the last 32-dimensional output of the LSTM and map it to our response. In [86]: class LSTMModel(nn.Module): def __init__(self, input_size): super(LSTMModel, self).__init__() self.embedding = nn.Embedding(input_size, 32) self.lstm = nn.LSTM(input_size=32, hidden_size=32, batch_first=True) self.dense = nn.Linear(32, 1) def forward(self, x): val, (h_n, c_n) = self.lstm(self.embedding(x)) return torch.flatten(self.dense(val[:,-1])) We instantiate and take a look at the summary of the model, using the first 10 documents in the corpus. In [87]: lstm_model = LSTMModel(X_test.shape[-1]) summary(lstm_model, input_data=imdb_seq_train.tensors[0][:10], col_names=[ 'input_size' , 'output_size' , 'num_pa r am s ' ] ) Out[87]: ==================================================================== Layer (type:depth-idx) Input Shape Output Shape Param # ==================================================================== LSTMModel [10, 500] [10] -- 29 The extra 3 dimensions correspond to commonly occurring non-word entries in the reviews. Embedding: 1-1 [10, 500] [10, 500, 32] 320,096 LSTM: 1-2 [10, 500, 32] [10, 500, 32] 8,448 Linear: 1-3 [10, 32] [10, 1] 33 ==================================================================== Total params: 328,577 Trainable params: 328,577 The 10,003 is suppressed in the summary, but we see it in the parameter count, since 10 , 003 × 32 = 320 , 096",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_72"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [88]: lstm_module = SimpleModule.binary_classification(lstm_model) lstm_logger = CSVLogger( 'logs' , name= 'IMDB_LSTM' ) In [89]: lstm_trainer = Trainer(deterministic=True, max_epochs=20, logger=lstm_logger , callbacks=[ErrorTracker()]) lstm_trainer.fit(lstm_module , datamodule=imdb_seq_dm) The rest is now similar to other networks we have fit. We track the test performance as the network is fit, and see that it attains 85% accuracy. In [90]: lstm_trainer.test(lstm_module , datamodule=imdb_seq_dm) Out[90]: [{ 'test_loss' : 0.8178, 'test_accuracy' : 0.8476}] We once again show the learning progress, followed by cleanup. In [91]: lstm_results = pd.read_csv(lstm_logger.experiment.metrics_file_path) fig, ax = subplots(1, 1, figsize=(6, 6)) summary_plot(lstm_results , ax, col= 'accuracy' , ylabel= 'Accuracy' ) ax.set_xticks(np.linspace(0, 20, 5).astype(int)) ax.set_ylabel( 'Accuracy' ) ax.set_ylim([0.5, 1]) In [92]: del(lstm_model, lstm_trainer , lstm_logger , imdb_seq_dm , imdb_seq_train , imdb_seq_test) Time Series Prediction We now show how to fit the models in Section 10.5.2 for time series prdiction. We first load and standardize the data. In [93]: NYSE = load_data( 'NYSE' ) cols = [ 'DJ_return' , 'log_volume' , 'log_volatility' ] X = pd.DataFrame(StandardScaler( with_mean=True, with_std=True).fit_transform(NYSE[cols]), columns=NYSE[cols].columns, index=NYSE.index) Next we set up the lagged versions of the data, dropping any rows with missing values using the dropna() method. In [94]: for lag in range(1, 6): for col in cols: newcol = np.zeros(X.shape[0]) * np.nan newcol[lag:] = X[col].values[:-lag] X.insert(len(X.columns), \"{0}_{1}\" .format(col, lag), newcol) X.insert(len(X.columns), 'train' , NYSE[ 'train' ]) X = X.dropna() Finally, we extract the response, training indicator, and drop the current day’s DJ_return and log_volatility to predict only from previous day’s data",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_73"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In [95]: Y, train = X[ 'log_volume' ], X[ 'train' ] X = X.drop(columns=[ 'train' ] + cols) X.columns Out[95]: Index([ 'DJ_return_1' , 'log_volume_1' , 'log_volatility_1' , 'DJ_return_2' , 'log_volume_2' , 'log_volatility_2' , 'DJ_return_3' , 'log_volume_3' , 'log_volatility_3' , 'DJ_return_4' , 'log_volume_4' , 'log_volatility_4' , 'DJ_return_5' , 'log_volume_5' , 'log_volatility_5' ], dtype= 'object' ) We first fit a simple linear model and compute the R 2 on the test data using the score() method. In [96]: M = LinearRegression() M.fit(X[train], Y[train]) M.score(X[ ∼ train], Y[ ∼ train]) Out[96]: 0.4129 We refit this model, including the factor variable day_of_week . For a catgorical series in pandas , we can form the indicators using the get_dummies() method. In [97]: X_day = pd.merge(X, pd.get_dummies(NYSE[ 'day_of_week' ]), on= 'date' ) Note that we do not have to reinstantiate the linear regression model as its fit() method accepts a design matrix and a response directly. In [98]: M.fit(X_day[train], Y[train]) M.score(X_day[ ∼ train], Y[ ∼ train]) Out[98]: 0.4595 This model achieves an R 2 of about 46%. To fit the RNN, we must reshape the data, as it will expect 5 lagged versions of each feature as indicated by the input_shape argument to the layer nn.RNN() below. We first ensure the columns of our data frame are such that a reshaped matrix will have the variables correctly lagged. We use the reindex() method to do this. For an input shape (5,3) , each row represents a lagged version of the three variables. The nn.RNN() layer also expects the first row of each obsevation to be earliest in time, so we must reverse the current order. Hence we loop over range(5,0,-1) below, which is an example of using a slice() to index iterable objects. The general notation is start:end:step",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_74"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Hence we loop over range(5,0,-1) below, which is an example of using a slice() to index iterable objects. The general notation is start:end:step . In [99]: ordered_cols = [] for lag in range(5,0,-1): for col in cols: ordered_cols.append( '{0}_{1}' .format(col, lag)) X = X.reindex(columns=ordered_cols) X.columns Out[99]: Index([ 'DJ_return_5' , 'log_volume_5' , 'log_volatility_5' , 'DJ_return_4' , 'log_volume_4' , 'log_volatility_4' , 'DJ_return_3' , 'log_volume_3' , 'log_volatility_3' , 'DJ_return_2' , 'log_volume_2' , 'log_volatility_2' , 'DJ_return_1' , 'log_volume_1' , 'log_volatility_1' ], dtype= 'object' ) We now reshape the data. In [100]: X_rnn = X.to_numpy().reshape((-1,5,3)) X_rnn.shape Out[100]: (6046, 5, 3) By specifying the first size as -1, numpy.reshape() deduces its size based on the remaining arguments. Now we are ready to proceed with the RNN, which uses 12 hidden units, and 10% dropout. After passing through the RNN, we extract the final time point as val[:,-1] in forward() below. This gets passed through a 10% dropout and then flattened through a linear layer. In [101]: class NYSEModel(nn.Module): def __init__(self): super(NYSEModel, self).__init__() self.rnn = nn.RNN(3, 12, batch_first=True) self.dense = nn.Linear(12, 1) self.dropout = nn.Dropout(0.1) def forward(self, x): val, h_n = self.rnn(x) val = self.dense(self.dropout(val[:,-1])) return torch.flatten(val) nyse_model = NYSEModel() We fit the model in a similar fashion to previous networks. We supply the fit function with test data as validation data, so that when we monitor its progress and plot the history function we can see the progress on the test data. Of course we should not use this as a basis for early stopping, since then the test performance would be biased. We form the training dataset similar to our Hitters example",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_75"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Of course we should not use this as a basis for early stopping, since then the test performance would be biased. We form the training dataset similar to our Hitters example. In [102]: datasets = [] for mask in [train, ∼ train]: X_rnn_t = torch.tensor(X_rnn[mask].astype(np.float32)) Y_t = torch.tensor(Y[mask].astype(np.float32)) datasets.append(TensorDataset(X_rnn_t, Y_t)) nyse_train, nyse_test = datasets Following our usual pattern, we inspect the summary. In [103]: summary(nyse_model, input_data=X_rnn_t, col_names=[ 'input_size' , 'output_size' , 'num_params' ]) Out[103]: ==================================================================== Layer (type:depth-idx) Input Shape Output Shape Param # ==================================================================== NYSEModel [1770, 5, 3] [1770] -- RNN: 1-1 [1770, 5, 3] [1770, 5, 12] 204 Dropout: 1-2 [1770, 12] [1770, 12] -- Linear: 1-3 [1770, 12] [1770, 1] 13 ==================================================================== Total params: 217 Trainable params: 217 We again put the two datasets into a data module, with a batch size of 64. In [104]: nyse_dm = SimpleDataModule(nyse_train, nyse_test, num_workers=min(4, max_num_workers), validation=nyse_test, batch_size=64) We run some data through our model to be sure the sizes match up corectly. In [105]: for idx, (x, y) in enumerate(nyse_dm.train_dataloader()): out = nyse_model(x) print(y.size(), out.size()) if idx >= 2: break torch.Size([64]) torch.Size([64]) torch.Size([64]) torch.Size([64]) torch.Size([64]) torch.Size([64]) We follow our previous example for setting up a trainer for a regression problem, requesting the R 2 metric to be be computed at each epoch. In [106]: nyse_optimizer = RMSprop(nyse_model.parameters(), lr=0.001) nyse_module = SimpleModule.regression(nyse_model, optimizer=nyse_optimizer , metrics={ 'r2' :R2Score()}) Fitting the model should by now be familiar. The results on the test data are very similar to the linear AR model",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_76"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The results on the test data are very similar to the linear AR model. In [107]: nyse_trainer = Trainer(deterministic=True, max_epochs=200, callbacks=[ErrorTracker()]) nyse_trainer.fit(nyse_module , datamodule=nyse_dm) nyse_trainer.test(nyse_module , datamodule=nyse_dm) Out[107]: [{ 'test_loss' : 0.6141, 'test_r2' : 0.4172}] We could also fit a model without the nn.RNN() layer by just using a nn.Flatten() layer instead. This would be a nonlinear AR model. If in addition we excluded the hidden layer, this would be equivalent to our earlier linear AR model. Instead we will fit a nonlinear AR model using the feature set X_day that includes the day_of_week indicators. To do so, we must first create our test and training datasets and a corresponding data module. This may seem a little burdensome, but is part of the general pipeline for torch . In [108]: datasets = [] for mask in [train, ∼ train]: X_day_t = torch.tensor( np.asarray(X_day[mask]).astype(np.float32)) Y_t = torch.tensor(np.asarray(Y[mask]).astype(np.float32)) datasets.append(TensorDataset(X_day_t, Y_t)) day_train, day_test = datasets Creating a data module follows a familiar pattern. In [109]: day_dm = SimpleDataModule(day_train, day_test, num_workers=min(4, max_num_workers), validation=day_test, batch_size=64) We build a NonLinearARModel() that takes as input the 20 features and a hidden layer with 32 units. The remaining steps are familiar. In [110]: class NonLinearARModel(nn.Module): def __init__(self): super(NonLinearARModel , self).__init__() self._forward = nn.Sequential(nn.Flatten(), nn.Linear(20, 32), nn.ReLU(), nn.Dropout(0.5), nn.Linear(32, 1)) def forward(self, x): return torch.flatten(self._forward(x)) In [111]: nl_model = NonLinearARModel() nl_optimizer = RMSprop(nl_model.parameters(), lr=0.001) nl_module = SimpleModule.regression(nl_model, optimizer=nl_optimizer , metrics={ 'r2' :R2Score()}) We continue with the usual training steps, fit the model, and evaluate the test error",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_77"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We see the test R 2 is a slight improvement over the linear AR model that also includes day_of_week . In [112]: nl_trainer = Trainer(deterministic=True, max_epochs=20, callbacks=[ErrorTracker()]) nl_trainer.fit(nl_module, datamodule=day_dm) nl_trainer.test(nl_module, datamodule=day_dm) Out[112]: [{ 'test_loss' : 0.5625, 'test_r2' : 0.4662}] 10.10 Exercises Conceptual 1. Consider a neural network with two hidden layers: p = 4 input units, 2 units in the first hidden layer, 3 units in the second hidden layer, and a single output. (a) Draw a picture of the network, similar to Figures 10.1 or 10.4 . (b) Write out an expression for f ( X ) , assuming ReLU activation functions. Be as explicit as you can! (c) Now plug in some values for the coefficients and write out the value of f ( X ) . (d) How many parameters are there? 2. Consider the softmax function in ( 10.13 ) (see also ( 4.13 ) on page 145 ) for modeling multinomial probabilities. (a) In ( 10.13 ), show that if we add a constant c to each of the z l , then the probability is unchanged. (b) In ( 4.13 ), show that if we add constants c j , j = 0 , 1 , , p , to each of the corresponding coefficients for each of the classes, then the predictions at any new point x are unchanged. This shows that the softmax function is over-parametrized . However, oveparametrized regularization and SGD typically constrain the solutions so that this is not a problem. 3. Show that the negative multinomial log-likelihood ( 10.14 ) is equivlent to the negative log of the likelihood expression ( 4.5 ) when there are M = 2 classes. 4. Consider a CNN that takes in 32 × 32 grayscale images and has a single convolution layer with three 5 × 5 convolution filters (without boundary padding). (a) Draw a sketch of the input and first hidden layer similar to Figure 10.8 . (b) How many parameters are in this model? (c) Explain how this model can be thought of as an ordinary feeforward neural network with the individual pixels as inputs, and with constraints on the weights in the hidden units",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_78"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". What are the constraints? (d) If there were no constraints, then how many weights would there be in the ordinary feed-forward neural network in (c)? 5. In Table 10.2 on page 426 , we see that the ordering of the three methods with respect to mean absolute error is different from the ordering with respect to test set R 2 . How can this be? Applied 6. Consider the simple function R ( β ) = sin( β ) + β/ 10 . (a) Draw a graph of this function over the range β ∈ [ − 6 , 6] . (b) What is the derivative of this function? (c) Given β 0 = 2 . 3 , run gradient descent to find a local minimum of R ( β ) using a learning rate of ρ = 0 . 1 . Show each of β 0 , β 1 , in your plot, as well as the final answer. (d) Repeat with β 0 = 1 . 4 . 7. Fit a neural network to the Default data. Use a single hidden layer with 10 units, and dropout regularization. Have a look at Labs 10.9.1 – 10.9.2 for guidance. Compare the classification performance of your model with that of linear logistic regression. 8. From your collection of personal photographs, pick 10 images of aimals (such as dogs, cats, birds, farm animals, etc.). If the subject does not occupy a reasonable part of the image, then crop the image. Now use a pretrained image classification CNN as in Lab 10.9.4 to predict the class of each of your images, and report the probabilities for the top five predicted classes for each image. 9. Fit a lag-5 autoregressive model to the NYSE data, as described in the text and Lab 10.9.6 . Refit the model with a 12-level factor reprsenting the month. Does this factor improve the performance of the model? 10. In Section 10.9.6 , we showed how to fit a linear AR model to the NYSE data using the LinearRegression() function. However, we also mentioned that we can “flatten” the short sequences produced for the RNN model in order to fit a linear AR model. Use this latter approach to fit a linear AR model to the NYSE data. Compare the test R 2 of this linear AR model to that of the linear AR model that we fit in the lab",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_79"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Use this latter approach to fit a linear AR model to the NYSE data. Compare the test R 2 of this linear AR model to that of the linear AR model that we fit in the lab. What are the advantages/disadvantages of each approach? 11. Repeat the previous exercise, but now fit a nonlinear AR model by “flattening” the short sequences produced for the RNN model. 12. Consider the RNN fit to the NYSE data in Section 10.9.6 . Modify the code to allow inclusion of the variable day_of_week , and fit the RNN. Compute the test R 2 . 13. Repeat the analysis of Lab 10.9.5 on the IMDb data using a similarly structured neural network. We used 16 hidden units at each of two hidden layers. Explore the effect of increasing this to 32 and 64 units per layer, with and without 30% dropout regularization. 11 Survival Analysis and Censored Data In this chapter, we will consider the topics of survival analysis and censored survival analysis data . These arise in the analysis of a unique kind of outcome variable: the censored data time until an event occurs . For example, suppose that we have conducted a five-year medical study, in which patients have been treated for cancer. We would like to fit a model to predict patient survival time, using features such as baseline health mesurements or type of treatment. At first pass, this may sound like a regresion problem of the kind discussed in Chapter 3 . But there is an important complication: hopefully some or many of the patients have survived until the end of the study. Such a patient’s survival time is said to be censored : we know that it is at least five years, but we do not know its true value. We do not want to discard this subset of surviving patients, as the fact that they survived at least five years amounts to valuable information. However, it is not clear how to make use of this information using the techniques covered thus far in this textbook. Though the phrase “survival analysis” evokes a medical study, the aplications of survival analysis extend far beyond medicine",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_80"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Though the phrase “survival analysis” evokes a medical study, the aplications of survival analysis extend far beyond medicine. For example, consider a company that wishes to model churn , the process by which cutomers cancel subscription to a service. The company might collect data on customers over some time period, in order to model each customer’s time to cancellation as a function of demographics or other predictors. However, presumably not all customers will have canceled their subscription by the end of this time period; for such customers, the time to cancellation is censored. In fact, survival analysis is relevant even in application areas that are unrelated to time. For instance, suppose we wish to model a person’s weight as a function of some covariates, using a dataset with measurements for a large number of people. Unfortunately, the scale used to weigh those people is unable to report weights above a certain number. Then, any weights that 469 exceed that number are censored. The survival analysis methods presented in this chapter could be used to analyze this dataset. Survival analysis is a very well-studied topic within statistics, due to its critical importance in a variety of applications, both in and out of medicine. However, it has received relatively little attention in the machine learning community. 11.1 Survival and Censoring Times For each individual, we suppose that there is a true survival time , T , as well survival time as a true censoring time , C . (The survival time is also known as the failure censoring time time or the event time .) The survival time represents the time at which the failure time event time event of interest occurs: for instance, the time at which the patient dies, or the customer cancels his or her subscription. By contrast, the censoring time is the time at which censoring occurs: for example, the time at which the patient drops out of the study or the study ends. We observe either the survival time T or else the censoring time C",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_81"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We observe either the survival time T or else the censoring time C . Specifically, we observe the random variable Y = min ( T, C ) . (11.1) In other words, if the event occurs before censoring (i.e. T < C ) then we observe the true survival time T ; however, if censoring occurs before the event ( T > C ) then we observe the censoring time. We also observe a status indicator, δ = = 1 if T ≤ C 0 if T > C. Thus, δ = 1 if we observe the true survival time, and δ = 0 if we instead observe the censoring time. Now, suppose we observe n ( Y, δ ) pairs, which we denote as ( y 1 , δ 1 ) , , ( y n , δ n ) . Figure 11.1 displays an example from a (fictitious) medical study in which we observe n = 4 patients for a 365-day follow-up period. For patients 1 and 3, we observe the time to event (such as death or disease relapse) T = t i . Patient 2 was alive when the study ended, and patient 4 dropped out of the study, or was “lost to follow-up”; for these patients we observe C = c i . Therefore, y 1 = t 1 , y 3 = t 3 , y 2 = c 2 , y 4 = c 4 , δ 1 = δ 3 = 1 , and δ 2 = δ 4 = 0 . 11.2 A Closer Look at Censoring In order to analyze survival data, we need to make some assumptions about why censoring has occurred. For instance, suppose that a number of patients drop out of a cancer study early because they are very sick. An analysis that does not take into consideration the reason why the patients dropped out will likely overestimate the true average survival time. Similarly, suppose that males who are very sick are more likely to drop out of the study than 0 100 200 300 1 2 3 4 Time in Days Patient FIGURE 11.1. Illustration of censored survival data. For patients 1 and 3, the event was observed. Patient 2 was alive when the study ended. Patient 4 dropped out of the study. females who are very sick. Then a comparison of male and female survival times may wrongly suggest that males survive longer than females",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_82"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Patient 4 dropped out of the study. females who are very sick. Then a comparison of male and female survival times may wrongly suggest that males survive longer than females. In general, we need to assume that the censoring mechanism is indepedent : conditional on the features, the event time T is independent of the censoring time C . The two examples above violate the assumption of indpendent censoring. Typically, it is not possible to determine from the data itself whether the censoring mechanism is independent. Instead, one has to carefully consider the data collection process in order to determine whether independent censoring is a reasonable assumption. In the remainder of this chapter, we will assume that the censoring mechanism is independent. 1 In this chapter, we focus on right censoring , which occurs when T ≥ Y , i.e. the true event time T is at least as large as the observed time Y . (Notice that T ≥ Y is a consequence of ( 11.1 ). Right censoring derives its name from the fact that time is typically displayed from left to right, as in Figure 11.1 .) However, other types of censoring are possible. For instance, in left censoring , the true event time T is less than or equal to the observed time Y . For example, in a study of pregnancy duration, suppose that we survey patients 250 days after conception, when some have already had their babies. Then we know that for those patients, pregnancy duration is less than 250 days. More generally, interval censoring refers to the setting in which we do not know the exact event time, but we know that it falls in some interval. For instance, this setting arises if we survey patients once per week in order to determine whether the event has occurred. While left censoring and interval censoring can be accommodated using variants of the ideas presented in this chapter, in what follows we focus specifically on right censoring",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_83"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". While left censoring and interval censoring can be accommodated using variants of the ideas presented in this chapter, in what follows we focus specifically on right censoring. 1 The assumption of independent censoring can be relaxed somewhat using the notion of non-informative censoring ; however, the definition of non-informative censoring is too technical for this book. 11.3 The Kaplan–Meier Survival Curve The survival curve , or survival function , is defined as survival curve survival function S ( t ) = Pr( T > t ) . (11.2) This decreasing function quantifies the probability of surviving past time t . For example, suppose that a company is interested in modeling customer churn. Let T represent the time that a customer cancels a subscription to the company’s service. Then S ( t ) represents the probability that a customer cancels later than time t . The larger the value of S ( t ) , the less likely that the customer will cancel before time t . In this section, we will consider the task of estimating the survival curve. Our investigation is motivated by the BrainCancer dataset, which contains the survival times for patients with primary brain tumors udergoing treatment with stereotactic radiation methods. 2 The predictors are gtv (gross tumor volume, in cubic centimeters); sex (male or female); diagnosis (meningioma, LG glioma, HG glioma, or other); loc (the tumor location: either infratentorial or supratentorial); ki (Karnofsky index); and stereo (stereotactic method: either stereotactic radiosurgery or fractioated stereotactic radiotherapy, abbreviated as SRS and SRT, respectively). Only 53 of the 88 patients were still alive at the end of the study. Now, we consider the task of estimating the survival curve ( 11.2 ) for these data. To estimate S (20) = Pr( T > 20) , the probability that a patient survives for at least t = 20 months, it is tempting to simply compute the proportion of patients who are known to have survived past 20 months, i.e. the proportion of patients for whom Y > 20",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_84"
  },
  {
    "document_type": "book",
    "title": "An introduction to statistical learning - with applications in python",
    "author": "Gareth James, Daniela Witten, Trevor Hastie, Robert Tibshirani & Jonathan Taylor",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\An_introduction_to_statistical_learning.pdf",
    "date_published": "2023-08-14",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". the proportion of patients for whom Y > 20 . This turns out to be 48 / 88 , or approximately 55% . However, this does not seem quite right, since Y and T represent different quantities. In particular, 17 of the 40 patients who did not survive to 20 months were actually censored, and this analysis implicitly assumes that T < 20 for all of those censored patients; of course, we do not know whether that is true. Alternatively, to estimate S (20) , we could consider computing the prportion of patients for whom Y > 20 , out of the 71 patients who were not censored by time t = 20 ; this comes out to 48 / 71 , or approximately 68% . However, this is not quite right either, since it amounts to completely inoring the patients who were censored before time t = 20 , even though the time at which they are censored is potentially informative. For instance, a patient who was censored at time t = 19 . 9 likely would have survived past t = 20 had he or she not been censored. We have seen that estimating S ( t ) is complicated by the presence of censoring. We now present an approach to overcome these challenges. We let d 1 < d 2 < · · · < d K denote the K unique death times among the nocensored patients, and we let q k denote the number of patients who died at time d k . For k = 1 , , K , we let r k denote the number of patients alive 2 This dataset is described in the following paper: Selingerová et al. (2016) Survival of patients with primary brain tumors: Comparison of two statistical approaches. PLoS One, 11(2):e0148733.",
    "chunk_id": "an_introduction_to_statistical_learning_page-399-467.json_chunk_85"
  },
  {
    "document_type": "research_paper",
    "title": "Statistical Modeling: The Two Cultures",
    "author": "Leo Breiman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Breiman-2001-Statistical-modeling-the-two-cultur.pdf",
    "date_published": "2001-12-19",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "y x nature y x linear regression logistic regression Cox model y x unknown decision trees neural nets • Led to irrelevant theory and questionable sc • Kept statisticians from using more suitable • Prevented statisticians from working on exci • The conclusions are about the model’s mech• If the model is a poor emulation of nature, the y = b 0 + b m x m + ε where the coefficients b m are to be estimated, ε is N 0 σ 2 and σ 2 is to be estimated. Given that R 2 which was often closer to zero than one and parameters. Besides computing R 2 , nothing else put y ′ . The closeness of y and y ′ is a measure of y = 2 1 + 3 8 x 3 − 0 6 x 8 + 83 2 x 12 − 2 1 x 17 + 3 2 x 27 y = − 8 9 + 4 6 x 5 + 0 01 x 6 + 12 0 x 15 + 17 5 x 21 + 0 2 x 22 y = − 76 7 + 9 3 x 2 + 22 0 x 7 − 13 2 x 8 + 3 4 x 11 + 7 2 x 28 Shuttle × 10 3 • Accuracy generally requires more complex pr• Instead of reducing dimensionality, increase it probability estimates p 0 p 9 that it represents optimal hyperplane support vector x m 1 x m 2 . A hyperplane in the original variables plus y x nature y x neural nets forests support vectors • The goal is not interpretability, but accurate – . 5 .5 1.5 2.5 3.5 standardized coefficients 0 1 2 3 4 5 6 7 8 9 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 2 0 variables – 1 0 0 1 0 2 0 3 0 4 0 5 0 percent increse in error 0 1 2 3 4 5 6 7 8 9 1 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 2 0 variables – 4 – 3 – 2 – 1 0 1 variable 12 0 .2 .4 .6 .8 1 class 1 probability VARIABLE 12 vs PROBABILITY #1 – 3 – 2 – 1 0 1 variable 17 0 .2 .4 .6 .8 1 class 1 probability VARIABLE 17 vs PROBABILITY #1 • Higher predictive accuracy is associated with • Algorithmic models can give better predictive y −ˆ y 2 . Given a set of data (training set) consising of y n x n n = 1 2 N , use it to construct the predictor φ 1 x . Take another bootstrap sapredictor φ 2 x . Continue this way for K steps",
    "chunk_id": "breiman-2001-statistical-modeling-the-two-cultur.json_chunk_1"
  },
  {
    "document_type": "research_paper",
    "title": "Statistical Modeling: The Two Cultures",
    "author": "Leo Breiman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Breiman-2001-Statistical-modeling-the-two-cultur.pdf",
    "date_published": "2001-12-19",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Given a set of data (training set) consising of y n x n n = 1 2 N , use it to construct the predictor φ 1 x . Take another bootstrap sapredictor φ 2 x . Continue this way for K steps. In regression, average all of the φ k x to get the which has the plurality vote of the φ k x is the • The “prediction culture,” at least around Sta• Estimation and testing are a form of prediction: • Prediction by itself is only occasionally suff gence is 2 E S y = 1 − E S y = 0 2 / V S y = rithm that yields a black box, for which x 1 is imposet of input variables, excluding x 1 and an algorithm this black box, x 1 is unimportant. inverse F − 1 u of a distribution function F x , sity f , F Q u = u , q u = Q ′ u = 1 /f Q u . function, Q ̃ for a raw estimator from a sample, and Q ˆ for a smooth estimator of the true Q . sity d u F G = D ′ u F G For F G continous, define D u F G = G F − 1 u d u F G = g F − 1 u /f F − 1 u assuming f x = 0 implies probability mass functions p F and p G define (assuing G ≪ F ) d u F G = p G F − 1 u /p F F − 1 u . density d t u = d u F Y F Y X = Q X t When X Y = f X Y Q X t Q Y u /f X Q X t f Y Q Y u The statistical independence hypothesis F X Y = F X F Y is equivalent to d t u = 1, all t u . A fundQ Y X = x u = Q Y D − 1 u F Y F Y X = x = Q Y s u = D s F Y F Y X = x is defined (note F Y is the pooled distribution fund 1 u = d u F Y F Y X = 1 = P X = 1 Y = Q Y u /P X = 1 Y 1 Y m",
    "chunk_id": "breiman-2001-statistical-modeling-the-two-cultur.json_chunk_2"
  },
  {
    "document_type": "research_paper",
    "title": "Statistical Modeling: The Two Cultures",
    "author": "Leo Breiman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Breiman-2001-Statistical-modeling-the-two-cultur.pdf",
    "date_published": "2001-12-19",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A fundQ Y X = x u = Q Y D − 1 u F Y F Y X = x = Q Y s u = D s F Y F Y X = x is defined (note F Y is the pooled distribution fund 1 u = d u F Y F Y X = 1 = P X = 1 Y = Q Y u /P X = 1 Y 1 Y m . dimensional comparison densities d u 1 u m to when we have two samples, d 1 u 1 u m to test 1 0 du 1 1 0 du m d u 1 u m d 1 u 1 u m = 1 A decile quantile bin B k 1 k m is defined to be the set of observations Y 1 Y m satisfing, for j = 1 m Q Y j k j − 1 / 10 < Y j ≤ Q Y j k j / 10 Instead of deciles k/ 10 we could use To test the hypothesis that Y 1 Y m are statitically independent we form for all k j = 1 10, d k 1 k m = P Bin k 1 k m / P Bin k 1 k m independence d 1 k 1 k m = P Bin k 1 k m population I / P Bin k 1 k m pooled sample for all k 1 k m such that the denominator is d 1 k 1 k m = P X = I observation from Bin k 1 k m /P X = I the values d k 1 k m and d 1 k 1 k m . “ R 2 = 0 34, reasonably large by the standards usual",
    "chunk_id": "breiman-2001-statistical-modeling-the-two-cultur.json_chunk_3"
  },
  {
    "document_type": "AU_course_page",
    "title": "Data Science Prediction And Forecasting",
    "author": "Aarhus University",
    "source": "https://kursuskatalog.au.dk/en/course/122493/Data-Science-Prediction-and-Forecasting",
    "flag": "",
    "date_published": "Unknown",
    "chunk_text": "Data Science, Prediction, and Forecasting Spring semester 2024 Course Catalogue Save course ECTS 10 Form of instruction Lecture Form of examination Take-home assignment (Assign) Language of instruction English Level Master Location Aarhus Use arrow keys on your keyboard to explore Course content Read more see description of qualifications Description of qualifications Read more Purpose: The purpose of the course is to introduce students to advanced statistical and computational methods required for the analysis of large, complex, and naturalistic data sets. In particular, students are introduced to state-of-the-art methods for the analysis of time series. In this area, a particular focus is placed on prediction and forecasting. Examples of relevant data sets are publicly available unit sales time series from large multinational companies, financial market time series, behavioural time series from cognitive-scientific and neuroscientific experimental studies, social media network data, data from wearable technology, and data from interactive sensors. Students will also be able to recognise important ethical, social, and policy implications arising from the application of advanced statistical analysis to human data, and to reflect on the ethical choices that must be made when developing data processing and statistical analysis software. The course covers advanced tools in data science, time series analysis, prediction, and forecasting. The course relates these tools to experimental and lab methodology, and to theories of cognitive functions. The course also includes integrated discussion of the ethical, social, and policy implications of the use of data science. The course equips students with the computational tools to model and investigate human cognition and behaviour both at the individual and at the collective level. The course prepares students for a wide range of data processing and analysis career paths",
    "chunk_id": "data_science_prediction_and_forecasting.json_chunk_1"
  },
  {
    "document_type": "AU_course_page",
    "title": "Data Science Prediction And Forecasting",
    "author": "Aarhus University",
    "source": "https://kursuskatalog.au.dk/en/course/122493/Data-Science-Prediction-and-Forecasting",
    "flag": "",
    "date_published": "Unknown",
    "chunk_text": ". The course prepares students for a wide range of data processing and analysis career paths. Academic objectives: In the evaluation of the student’s performance, emphasis is placed on the extent to which the student is able to: Knowledge: - describe and contrast different computational and statistical methods for analysing large and complex data sets, in particular time series. Skills: - identify relevant data sources for specific research and applied questions, and integrate data sources as needed - prepare and pre-process complex data for analysis - create visualisation of time series and other complex data. Competences: - clearly and effectively present the results of complex analyses, in a way that is understood by non-specialists - critically evaluate the appropriateness of a given method for a given data set - recognise and analyse ethical, social, and policy issues arising from the use of data science methods and technology. See all ECTS 10 Level Master Semester MA, 2nd semester Language of instruction English Hours - week - period Time and place will be announced no later than at the start of the semester here: https://timetable.au.dk/schedule Type of course Ordinary Primary programme Master's Degree Programme in Cognitive Science Department School of Communication and Culture Faculty Arts Location Aarhus STADS UVA code 147222U007 Copy UVA code Teaching Form of instruction Lecture Instructor See all Roberta Rocca Institut for Kultur og Samfund - Interacting Minds (IMC) Comments on the form of instruction Read more Lectures and classroom instruction. Language of instruction: The rules governing language of exam and teaching are stated in section 2.1 of the academic regulations. Literature Read more Will be announced on Brightspace at the start of the semester",
    "chunk_id": "data_science_prediction_and_forecasting.json_chunk_2"
  },
  {
    "document_type": "AU_course_page",
    "title": "Data Science Prediction And Forecasting",
    "author": "Aarhus University",
    "source": "https://kursuskatalog.au.dk/en/course/122493/Data-Science-Prediction-and-Forecasting",
    "flag": "",
    "date_published": "Unknown",
    "chunk_text": ". Literature Read more Will be announced on Brightspace at the start of the semester. Examination Form of examination Take-home assignment on topic of student's choice Form of co-examination Internal co-examination Assessment 7-point grading scale Permitted exam aids Not specified Comments Read more Ordinary exam and re-examination: The examination consists of a take-home assignment on a topic of the student’s choice and a related practical product. The assignment can be written individually or in groups of up to 4 students. Group assignments must be written in such a way that the contribution of each student, except for the introduction, thesis statement and conclusion, can form the basis of individual assessment. The assignment should clearly state which student is responsible for which section. Length for one student: 10-12 standard pages Length for two students: 17-22 standard pages Length for three students: 24-32 standard pages Length for four students: 31-42 standard pages The scope and nature of the product must be relevant in relation to the content of the course and is subject to the approval of the teacher. It must be possible to submit the product digitally in a documented form which can be accessed by the examiner and co-examiner. The product must be accompanied by a take-home assignment on a topic of the student’s choice, in which the student explains the relevance and methodological and theoretical basis of the product. The assignment and the product must be submitted for assessment in WISEflow before the deadline set in the examination plan. Assessment is based on an overall assessment of the take-home assignment and the practical product.",
    "chunk_id": "data_science_prediction_and_forecasting.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": "2 Assumptions for Causal Inference Now that we have encountered the basic components of SCMs, it is a good time to pause and consider some of the assumptions we have seen, as well as what these assumptions imply for the purpose of causal reasoning and learning. A crucial notion in our discussion will be a form of independence , and we can informally introduce it using an optical illusion known as the Beuchet chair. When we see an object such as the one on the left of Figure 2.1, our brain makes the assumption that the object and the mechanism by which the information contained in its light reaches our brain are independent. We can violate this assumption by looking at the object from a very specific viewpoint. If we do that, perception goes wrong: We perceive the three-dimensional structure of a chair, which in reality is not there. Most of the time, however, the independence assumption does hold. If we look at an object, our brain assumes that the object is independent from our vantage point and the illumination. So there should be no unlikely coincidences, no separate 3D structures lining up in two dimensions, or shadow boundaries coiciding with texture boundaries. This is called the generic viewpoint assumption in vision [Freeman, 1994]. The independence assumption is more general than this, though. We will see in Section 2.1 below that the causal generative process is composed of autonomous modules that do not inform or influence each other. As we shall describe below, this means that while one module’s output may influence another module’s input, the modules themselves are independent of each other. In the preceding example, while the overall percept is a function of object, lighing, and viewpoint, the object and the lighting are not affected by us moving about — in other words, some components of the overall causal generative model remain invariant , and we can infer three-dimensional information from this invariance",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_1"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Figure 2.1: The left panel shows a generic view of the (separate) parts comprising a Beuchet chair . The right panel shows the illusory percept of a chair if the parts are viewed from a single, very special vantage point. From this accidental viewpoint , we perceive a chair. (Image courtesy of Markus Elsholz.) This is the basic idea of structure from motion [Ullman, 1979], which plays a cetral role in both biological vision and computer vision. 2.1 The Principle of Independent Mechanisms We now describe a simple cause-effect problem and point out several observations. Subsequently, we shall try to provide a unified view of how these observation relate to each other, arguing that they derive from a common independence principle. Suppose we have estimated the joint density p ( a , t ) of the altitude A and the average annual temperature T of a sample of cities in some country (see Figure 4.6 on page 65). Consider the following ways of expressing p ( a , t ) : p ( a , t ) = p ( a | t ) p ( t ) = p ( t | a ) p ( a ) (2.1) The first decomposition describes T and the conditional A | T . It corresponds to a factorization of p ( a , t ) according to the graph T → A . 1 The second decomposition corresponds to a factorization according to A → T (cf. Definition 6.21). Can we 1 Note that the conditional density p ( a | t ) allows us to compute p ( a , t ) (and thus also p ( a ) ) from decide which of the two structures is the causal one (i.e., in which case would we be able to think of the arrow as causal)? A first idea (see Figure 2.2, left) is to consider the effect of interventions . Imaine we could change the altitude A of a city by some hypothetical mechanism that raises the grounds on which the city is built. Suppose that we find that the average temperature decreases. Let us next imagine that we devise another intervention eperiment. This time, we do not change the altitude, but instead we build a massive heating system around the city that raises the average temperature by a few dgrees",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_2"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This time, we do not change the altitude, but instead we build a massive heating system around the city that raises the average temperature by a few dgrees. Suppose we find that the altitude of the city is unaffected. Intervening on A has changed T , but intervening on T has not changed A . We would thus reasonably prefer A → T as a description of the causal structure. Why do we find this description of the effect of interventions plausible, even though the hypothetical intervention is hard or impossible to carry out in practice? If we change the altitude A , then we assume that the physical mechanism p ( t | a ) responsible for producing an average temperature (e.g., the chemical composition of the atmosphere, the physics of how pressure decreases with altitude, the metorological mechanisms of winds) is still in place and leads to a changed T . This would hold true independent of the distribution from which we have sampled the cities, and thus independent of p ( a ) . Austrians may have founded their cities in locations subtly different from those of the Swiss, but the mechanism p ( t | a ) would apply in both cases. 2 If, on the other hand, we change T , then we have a hard time thinking of p ( a | t ) as a mechanism that is still in place — we probably do not believe that such a mechanism exists in the first place. Given a set of different city distributions p ( a , t ) , while we could write them all as p ( a | t ) p ( t ) , we would find that it is impossible to explain them all using an invariant p ( a | t ) . Our intuition can be rephrased and postulated in two ways: If A → T is the correct causal structure, then (i) it is in principle possible to perform a localized intervention on A , in other words, to change p ( a ) without changing p ( t | a ) , and (ii) p ( a ) and p ( t | a ) are autonomous , modular , or invariant mechanisms or objects in the world. p ( t ) , which may serve to motivate the direction of the arrow in T → A for the time being. This will be made precise in Definition 6.21",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_3"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". p ( t ) , which may serve to motivate the direction of the arrow in T → A for the time being. This will be made precise in Definition 6.21. 2 This is an idealized setting — no doubt counterexamples to these general remarks can be costructed. Interestingly, while we started off with a hypothetical intervention experiment to arrive at the causal structure, our reasoning ends up suggesting that actual intervetions may not be the only way to arrive at causal structures. We may also be able to identify the causal structure by checking, for data sources p ( a , t ) , which of the two decompositions (2.1) leads to autonomous or invariant terms. Sticking with the preceding example, let us denote the joint distributions of altitude and tempeature in Austria and Switzerland by p ̈o ( a , t ) and p s ( a , t ) , respectively. These may be distinct since Austrians and Swiss founded their cities in different places (i.e., p ̈o ( a ) and p s ( a ) are distinct). The causal factorizations, however, may still use the same conditional, i.e. p ̈o ( a , t ) = p ( t | a ) p ̈o ( a ) and p s ( a , t ) = p ( t | a ) p s ( a ) . We next describe an idea (see Figure 2.2, middle), closely related to the previous example, but different in that it also applies for individual distributions. In the causal factorization p ( a , t ) = p ( t | a ) p ( a ) , we would expect that the conditional density p ( t | a ) (viewed as a function of t and a ) provides no information about the marginal density function p ( a ) . This holds true if p ( t | a ) is a model of a physical mechanism that does not care about what distribution p ( a ) we feed into it. In other words, the mechanism is not influenced by the ensemble of cities to which we apply it. If, on the other hand, we write p ( a , t ) = p ( a | t ) p ( t ) , then the preceding indepedence of cause and mechanism does not apply",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_4"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". If, on the other hand, we write p ( a , t ) = p ( a | t ) p ( t ) , then the preceding indepedence of cause and mechanism does not apply. Instead, we will notice that to connect the observed p ( t ) and p ( a , t ) , the mechanism p ( a | t ) would need to take a rather peculiar shape constrained by the equation p ( a , t ) = p ( a | t ) p ( t ) . This could be empirically checked, given an ensemble of cities and temperatures. 3 We have already seen several ideas connected to independence, autonomy, and invariance, all of which can inform causal inference. We now turn to a final one (see Figure 2.2, right), related to the independence of noise terms and thus best explained when rewriting (2.1) as a distribution entailed by an SCM with graph A → T , realizing the effect T as a noisy function of the cause A , A : = N A , T : = f T ( A , N T ) , where N T and N A are statistically independent noises N T ⊥⊥ N A . Making suitable restrictions on the functional form of f T (see Sections 4.1.3–4.1.6 and 7.1.2) alows us to identify which of two causal structures ( A → T or T → A ) has entailed the observed p ( a , t ) (without such restrictions though, we can always realize both 3 We shall formalize this idea in Section 4.1.7. (physical) independence of mechanisms Principle 2.1 intervenability, autonomy, modularity, invariance, transfer independence of information contained in mechanisms independence of noises, conditional independence of structures Figure 2.2: The principle of independent mechanisms and its implications for causal infeence (Principle 2.1). decompositions (2.1)). Furthermore, in the multivariate setting and under suitable conditions, the assumption of jointly independent noises allows the identification of causal structures by conditional independence testing (see Section 7.1.1). We like to view all these observations as closely connected instantiations of a general principle of (physically) independent mechanisms",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_5"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We like to view all these observations as closely connected instantiations of a general principle of (physically) independent mechanisms . Principle 2.1 (Independent mechanisms) The causal generative process of a system’s variables is composed of autonomous modules that do not inform or ifluence each other. In the probabilistic case, this means that the conditional distribution of each variable given its causes (i.e., its mechanism) does not inform or influence the other conditional distributions. In case we have only two variables, this reduces to an independence between the cause distribution and the mechanism producing the effect distribution. The principle is plausible if we conceive our system as being composed of moules comprising (sets of) variables such that the modules represent physically idependent mechanisms of the world. The special case of two variables has been referred to as independence of cause and mechanism (ICM) [Daniuˇsis et al., 2010, Shajarisales et al., 2015]. It is obtained by thinking of the input as the result of a preparation that is done by a mechanism that is independent of the mechanism that turns the input into the output. Before we discuss the principle in depth, we should state that not all systems will satisfy it. For instance, if the mechanisms that an overall system is composed of have been tuned to each other by design or evolution, this independence may be violated. We will presently argue that the principle is sufficiently broad to cover the main aspects of causal reasoning and causal learning (see Figure 2.2). Let us address three aspects, corresponding, from left to right, to the three branches of the tree in Figure 2.2. 1. One way to think of these modules is as physical machines that incorporate an input-output behavior. This assumption implies that we can change one mechanism without affecting the others — or, in causal terminology, we can intervene on one mechanism without affecting the others",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_6"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This assumption implies that we can change one mechanism without affecting the others — or, in causal terminology, we can intervene on one mechanism without affecting the others. Changing a mechanism will change its input-output behavior, and thus the inputs other mechanisms downstream might receive, but we are assuming that the phyical mechanisms themselves are unaffected by this change. An assumption such as this one is often implicit to justify the possibility of interventions in the first place, but one can also view it as a more general basis for causal resoning and causal learning. If a system allows such localized interventions, there is no physical pathway that would connect the mechanisms to each other in a directed way by “meta-mechanisms.” The latter makes it plausble that we can also expect a tendency for mechanisms to remain invariant with respect to changes within the system under consideration and possibly also to some changes stemming from outside the system (see Section 7.1.6). This kind of autonomy of mechanisms can be expected to help with tranfer of knowledge learned in one domain to a related one where some of the modules coincide with the source domain (see Sections 5.2 and 8.3). 2. While the discussion of the first aspect focused on the physical aspect of independence and its ramifications, there is also an information theoretic apect that is implied by the above. A time evolution involving several coupled objects and mechanisms can generate statistical dependence. This is related to our discussion from page 10, where we considered the dependence btween the class label and the image of a handwritten digit. Similarly, mecanisms that are physically coupled will tend to generate information that can be quantified in terms of statistical or algorithmic information measures (see Sections 4.1.9 and 6.10 below)",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_7"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Here, it is important to distinguish between two levels of information: oviously, an effect contains information about its cause, but — according to the independence principle — the mechanism that generates the effect from its cause contains no information about the mechanism generating the cause. For a causal structure with more than two nodes, the independence princ ple states that the mechanism generating every node from its direct causes contain no information about each other. 4 3. Finally, we should discuss how the assumption of independent noise terms, commonly made in structural equation modeling, is connected to the princple of independent mechanism. This connection is less obvious. To this end, consider a variable E : = f ( C , N ) where the noise N is discrete. For each value s taken by N , the assignment E : = f ( C , N ) reduces to a deterministic mechanism E : = f s ( C ) that turns an input C into an output E . Effectively, this means that the noise randomly chooses between a number of mechnisms f s (where the number equals the cardinality of the range of the noise variable N ). Now suppose the noise variables for two mechanisms at the vertices X j and X k were statistically dependent. 5 Such a dependence could ensure, for instance, that whenever one mechanism f s j is active at node j , we know which mechanism f t k is active at node k . This would violate our principle of independent mechanisms. The preceding paragraph uses the somewhat extreme view of noise varables as selectors between mechanisms (see also Section 3.4). In practice, the role of the noise might be less pronounced. For instance, if the noise is additive (i.e., E : = f ( C ) + N ), then its influence on the mechanism is rstricted. In this case, it can only shift the output of the mechanism up or down, so it selects between a set of mechanisms that are very similar to each other",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_8"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In this case, it can only shift the output of the mechanism up or down, so it selects between a set of mechanisms that are very similar to each other. This is consistent with a view of the noise variables as variables ouside the system that we are trying to describe, representing the fact that a system can never be totally isolated from its environment. In such a view, one would think that a weak dependence of noises may be possible without invalidating the principle of independent mechanisms. All of the above-mentioned aspects of Principle 2.1 may help for the problem of causal learning, in other words, they may provide information about causal strutures. It is conceivable, however, that this information may in cases be conflicting, depending on which assumptions hold true in any given situation. 4 There is an intuitive relation between this aspect of independence and the one described under 1.: whenever the mechanisms change independently, the change of one mechanism does not provide information on how the others have changed. Despite this overlap, the second independence contains an aspect that is not strictly contained in the first one because it is also applicable to a scenario in which none of the mechanisms has changed; for example, it refers also to homogeneous data sets. 5 Although we have so far focused on the two-variable case, we phrase this argument such that it also applies for causal structures with more than two variables. Figure 2.3: Early path diagram; dam and sire are the female and male parents of a guinea pig, respectively. The path coefficients capture the importance of a given path, defined as the ratio of the variability of the effect to be found when all causes are constant except the one in question, the variability of which is kept unchanged, to the total variability. (Reproduced from Wright [1920].) 2.2 Historical Notes The idea of autonomy and invariance is deeply engrained in the concept of strutural equation models (SEMs) or SCMs",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_9"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". (Reproduced from Wright [1920].) 2.2 Historical Notes The idea of autonomy and invariance is deeply engrained in the concept of strutural equation models (SEMs) or SCMs. We prefer the latter term, since the term SEM has been used in a number of contexts where the structural assignments are used as algebraic equations rather than assignments. The literature is wide ranging, with overviews provided by Aldrich [1989], Hoover [2008], and Pearl [2009]. An intellectual antecedent to SEMs is the concept of a path model pioneered by Wright [1918, 1920, 1921] (see Figure 2.3). Although Wright was a biolgist, SEMs are nowadays most strongly associated with econometrics. Following Hoover [2008], pioneering work on structural econometric models was done in the 1930s by Jan Tinbergen, and the conceptual foundations of probabilistic econmetrics were laid in Trgyve Haavelmo’s work [Haavelmo, 1944]. Early economists were trying to conceptualize the fact that unlike correlation, regression has a naural direction. The regression of Y on X leads to a solution that usually is not the inverse of the regression of X on Y . 6 But how would the data then tell us in which direction we should perform the regression? This is a problem of observational equivalence , and it is closely related to a problem econometricians call identifiction . A number of early works saw a connection between what made a set of equations or relations structural [Frisch and Waugh, 1933], and properties of invariance and autonomy — according to Aldrich [1989], indeed the central notion in the pioneeing work of Frisch et al. [1948]. Here, a structural relation was aiming for more than merely modeling an observed distribution of data — it was trying to capture an underlying structure connecting the variables of the model. At the time, the Cowles Commission was a major economic research institute, instrumental in creating the field of econometrics. Its work related causality to the invariance properties of the structural econometric model [Hoover, 2008]",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_10"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Its work related causality to the invariance properties of the structural econometric model [Hoover, 2008]. Pearl [2009] credits Marschak’s opening chapter of a 1950 Cowles monograph with the idea that structural equations remain invariant to certain changes in the system [Marschak, 1950]. A crucial distinction emphasized by the Cowles work was the one between endogenous and exogenous variables . Endogeneous variables are those that the modeler tries to understand, while exogenous ones are determined by factors outside the model, and are taken as given. Koopmans [1950] assayed two principles for determining what should be treated as exogeneous. The dpartmental principle considers variables outside of the scope of the discipline as exogeneous (e.g., weather is exogeneous to economics). The (preferred) causal principle calls those variables exogenous that influence the remaining (endogneous) variables, but are (almost) not influenced thereby. Haavelmo [1943] interpreted structural equations as statements about hypotheical controlled experiments. He considered cyclic stochastic equation models and discussed the role of invariance as well as policy interventions. Pearl [2015] gives an appraisal of Haavelmo’s role in the study of policy intervention questions and the development of the field of causal inference. In an account of causality in 6 As an aside, while most of the early works were using linear equations only, there have also been attempts to generalize to nonlinear SEMs [Hoover, 2008]. economics and econometrics, Hoover [2008] discusses a system of the form X i : = N i X Y i : = θ X i + N i Y , where the errors N i X , N i Y are i.i.d., and θ is a parameter. He attributes to Simon [1953] the view (which does not require any temporal order) that X i may be rferred to as causing Y i since one knows all about X i without knowing about Y i , but not vice versa. The equations also allow us to predict the effect of interventions",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_11"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The equations also allow us to predict the effect of interventions. Hoover goes on to argue that one can rewrite the system reversing the roles of X i and Y i while retaining the property that the error terms are uncorrelated. 7 He thus points out that we cannot infer the correct causal direction on the basis of a single set of data (“observational equivalence”). Experiments, either controlled or natral, could help us decide. If, for example, an experiment can change the conditional distribution of Y i given X i , without altering the marginal distribution of X i , then it must be that X i causes Y i . Hoover refers to this as Simon’s invariance criterion : the true causal order is the one that is invariant under the right sort of intervention. 8 Hurwicz [1962] argues that an equation system becomes structural by virtue of ivariance to a domain of modifications. Such a system then bears resemblance to a natural law. Hurwicz recognized that one can use such modifications to determine structure, and that while structure is necessary for causality, it is not for prediction. Aldrich [1989] provides an account of the role of autonomy in structural equation modeling. He argues that autonomous relations are likely to be more stable than others. He equates Haavelmo’s autonomous variables with what subsequently bcame known as exogeneous variables. Autonomous variables are parameters fixed by external forces, or treated as stochastically independent. 9 Following Aldrich [1989, page 30], “the use of the qualifier autonomous and the phrase forces extenal to the sector under consideration suggest that the parameters of that model would be invariant to changes in the sectoral parameters.” He also relates invarance to a notion termed super-exogeneity [Engle et al., 1983]. While the early proponents of structural equation modeling already had some profound insights in their causal underpinnings, the developments in computer sc7 We shall revisit this topic in more detail in Section 4.1.3",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_12"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". 8 We would argue that this may not hold true if interventions are coupled to each other, for exaple, to keep the anticausal conditional (which describes the cause, given its effect) invariant. This could be seen as a violation of Principle 2.1 on the level of interventions . We return to this point in Section 2.3.4. 9 This is akin to the independence of noise terms we use in SCMs. ence initially happened separately. Pearl [2009, p. 104] relates how he and his coworkers started connecting Bayesian networks and structural equation modeling: “It suddenly hit me that the century-old tension between economists and statistcians stems from simple semantic confusion: statisticians read structural equtions as statements about E [ Y | x ] while economists read them as E [ Y | do ( x )] . This would explain why statisticians claim that structural equations have no meaning and economists retort that statistics has no substance.” Pearl [2009, p. 22] formlates the independence principle as follows: “that each parent-child relationship in the network represents a stable and autonomous physical mechanism — in other words, that it is conceivable to change one such relationship without changing the others.” It is noteworthy, and indeed a motivation for writing the present book, that among the different implications of Principle 2.1, shown in Figure 2.2, most of the work using causal Bayesian networks only exploits the independence of noise terms. 10 It leads to a rich structure of conditional independences [Pearl, 2009, Spirtes et al., 2000, Dawid, 1979, Spohn, 1980], ultimately deriving from Reichenbach’s Priciple 1.1. The other aspects of independence received significantly less attention [Hausman and Woodward, 1999, Lemeire and Dirkx, 2006], but there is a recent thread of work aiming at formalizing and using them. A major motivation for this has been the cause-effect problem where conditional independence is useless since we have only two variables (see Sections 4.1.2 and 6.10)",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_13"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". A major motivation for this has been the cause-effect problem where conditional independence is useless since we have only two variables (see Sections 4.1.2 and 6.10). Janzing and Sch ̈olkopf [2010] formalize independence of mechanism in terms of algorithmic information theory (Section 4.1.9). They view the functions in an SCM as representing idependent causal mechanisms that persist after manipulating the distribution of inputs or other mechanisms. More specifically, in the context of causal Bayesian networks, they postulate that the conditional distributions of all nodes given their parents are algorithmically independent. In particular, for the causal Bayesian nework X → Y , P X and P Y | X contain no algorithmic information about each other — meaning that knowledge of one does not admit a shorter description of the other. The idea that unrelated mechanisms are algorithmically independent follows from the generalization of SCMs from random variables to individual objects where sttistical dependences are replaced with algorithmic dependences. Sch ̈olkopf et al. [2012, e.g., Section 2.1.1.] discuss the question of robustness with respect to changes in the distribution of the cause (in the two-variable se10 Certain Bayesian structure learning methods [Heckerman et al., 1999] can be viewed as implmenting the independence principle by assigning independent priors to the conditional probabilities of each variable given its causes. ting), and connect it to problems of machine learning ; see also Chapter 5. Within an SCM, they analyze invariance of either the function or of the noises, for diffeent learning scenarios (e.g., transfer learning, concept drift)",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_14"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Within an SCM, they analyze invariance of either the function or of the noises, for diffeent learning scenarios (e.g., transfer learning, concept drift). They employ a notion of independence of mechanism and input that subsumes both independence uder changes and information-theoretic independence (we called this the “overlap” between the first and second independence in Figure 2.2 in the discussion of the boxes): “ P E | C contains no information about P C and vice versa; in particular, if P E | C changes at some point in time, there is no reason to believe that P C changes at the same time.” Further links to transfer and related machine learning problems are discussed by Bareinboim and Pearl [2016], Rojas-Carulla et al. [2016], Zhang et al. [2013] and Zhang et al. [2015]. Peters et al. [2016] exploited invariance across envronments for learning parts of the graph structure underlying a multivariate SCM (Section 7.1.6). 2.3 Physical Structure Underlying Causal Models We conclude this chapter with some notes on connections to physics. Readers whose interests are limited to mathematical and statistical structures may prefer to skip this part. 2.3.1 The Role of Time An aspect that is conspicuously missing in Section 2.1 is the role of time. Indeed, physics incorporates causality into its basic laws by excluding causation from fture to past. 11 This does not do away with all problems of causal inference, though. Already Simon [1953] recognized that while time ordering can provide a useful asymmetry, it is asymmetry that is important, not the temporal sequence. Microscopically, the time evolution of both classical systems and quantum mchanical systems is widely believed to be invertible. This seems to contradict our intuition that the world evolves in a directed way — we believe we would be able to tell if time were to flow backward. The contradiction can be resolved in two ways",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_15"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This seems to contradict our intuition that the world evolves in a directed way — we believe we would be able to tell if time were to flow backward. The contradiction can be resolved in two ways. In one of them, suppose we have a complexity measure for states [Bennett, 1982, Zurek, 1989], and we start with a state whose complexity is very low. In that 11 More precisely, an event can only influence events lying in its light cone since no signal can travel faster than the speed of light in a vacuum, according to the theory of relativity. case, time evolution (assuming it is sufficiently ergodic) will tend to increase coplexity. In the other way, we assume that we are considering open systems. Even if the time evolution for a closed system is invertible (e.g., in quantum mechanics, a unitary time evolution), the time evolution of an open subsystem (which interacts with its environment) in the generic case need not be invertible. 2.3.2 Physical Laws An often discussed causal question can be addressed with the following example. The ideal gas law stipulates that pressure p , volume V , amount of substance n , and absolute temperature T satisfy the equation p · V = n · R · T , (2.2) where R is the ideal gas constant. If we, for instance, change the volume V allcated to a given amount of gas, then pressure p and/or temperature T will change, and the specifics will depend on the exact setup of the intervention. If, on the other hand, we change T , then V and/or p will change. If we keep p constant, then we can, at least approximately, construct a cycle involving T and V . So what causes what? It is sometimes argued that such laws show that it does not make sense to talk about causality unless the system is temporal. In the next paragraph, we ague that this is misleading. The gas law (2.2) refers to an equilibrium state of an underlying dynamical system, and writing it as a simple equation does not provide enough information about what interventions are in principle possible and what is their effect",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_16"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". SCMs and their corresponding directed acyclic graphs do provide us with this information, but in the general case of non-equilibrium systems, it is a hard problem whether and how a given dynamical systems leads to an SCM. 2.3.3 Cyclic Assignments We think of SCMs as abstractions of underlying processes that take place in time. For these underlying processes, there is no problem with feedback loops, since at a sufficiently fast time scale, those loops will be unfolded in time, assuming there are no instantaneous interactions, which are arguably excluded by the finiteness of the speed of light. Even though the time-dependent processes do not have cycles, it is possible that an SCM derived from such processes (for instance, by methods mentioned below in Remarks 6.5 and 6.7), involving only quantities that no longer depend on time, does have cycles. It becomes a little harder to define general interventions in such systems, but certain types of interventions should still be doable. For instance, a hard intervention where we set the value of one variable to a fixed value may be possible (and realizable physically by a forcing term in an underlying set of differential equations; see Remark 6.7). This cuts the cycle, and we can then derive the entailed intervention distribution. However, it may be impossible to derive an entailed observational distribution from a cyclic set of structural assignments. Let us consider the two assignments X : = f X ( Y , N X ) Y : = f Y ( X , N Y ) and noise variables N X ⊥⊥ N Y . Just like in the case of acyclic models, we consider the noises and functions as given and seek to compute the entailed joint distribution of X and Y . To this end, let us start with the first assignment X : = f X ( Y , N X ) , and substitute some initial Y into it. This yields an X , which we can then substitute into the other assignment. Suppose we iterate the two assignments and converge to some fixed point",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_17"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This yields an X , which we can then substitute into the other assignment. Suppose we iterate the two assignments and converge to some fixed point. This point would then correspond to a joint distribution of X , Y simultaneously satisfying both structural assignments as equalities of random variables. 12 Note that we have here assumed that the same N X , N Y are used at every step, rather than independent copies thereof. However, such an equilibrium for X , Y need not always exist, and even if it does, it need not be the case that it can be found using the iteration. In the linear case, this has been analyzed by Lacerda et al. [2008] and Hyttinen et al. [2012]; see also Lauritzen and Richardson [2002]. For further details see Remark 6.5. This observation that one may not always be able to get an entailed distribution satisfying two cyclic structural assignments is consistent with the view of SCMs as abstractions of underlying physical processes — abstractions whose domain of vlidity as causal models is limited. If we want to understand general cyclic systems, it may be unavoidable to study systems of differential equations rather than SCMs. For certain restricted settings, on the other hand, it can still make sense to stay on the phenomenologically more superficial level of SCMs; see, for example, Mooij et al. [2013]. One may speculate that this difficulty inherent to SCMs (or SEMs) is part of the reason why the econometrics community started off viewing SEMs as 12 The fact that the assignments are satisfied as equalities of random variables means that we are considering an ensemble of systems that differ in the realizations of the noise variables. Each realiztion leads to a (possibly different) realization for X , Y , and thus the distribution of the noises implies a distribution over X , Y . causal models, but later on parts of the community decided to forgo this interprtation in favor of a view of structural equations as purely algebraic equations",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_18"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". causal models, but later on parts of the community decided to forgo this interprtation in favor of a view of structural equations as purely algebraic equations. 2.3.4 Feasibility of Interventions We have used the principle of independent mechanisms to motivate interventions that only affect one mechanism (or structural assignment) at a time. While real systems may admit such kind of interventions, there will also be interventions that replace several assignments at the same time. The former type of interventions may be considered more elementary in an intuitive physical sense. If multiple elementary interventions are combined, then this may in principle happen in a way such that they tuned to each other, and we would view this as violating a form of our independence Principle 2.1; see footnote 8 on page 24. One may hope that combined interventions that are “natural” will not violate independence. However, to tell whether an intervention is “natural” in this sense requires knowledge of the causal structure, which we do not have when trying to use such principles to perform causal learning in the first place. Ultimately, one can try to resort to physics to assay what is elementary or natural. The questions of which operations on a physical system are elementary plays a crucial role in modern quantum information theory. There, the question is closely related to analyzing the structure of physical interactions. 13 Likewise, we believe that understanding physical mechanisms underlying causal relations may somtimes explain why some interventions are natural and others are complex, which essentially defines the “modules” given by the different structural equations. 2.3.5 Independence of Cause and Mechanism and the Thermodynamic Arrow of Time We provide a discussion as well as a toy model illustrating how the principle of independent mechanisms can be viewed as a principle of physics",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_19"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". To this end, we 13 For the interested reader: A system consisting of n two-level quantum systems is described by the 2 n -dimensional Hilbert space C 2 ⊗···⊗ C 2 . Unitary operators acting on this Hilbert space corespond to physical processes. For several such systems, researchers have shown how to implement “basic” unitaries that act on at most two of the n tensor components [Nielsen and Chuang, 2000] and act trivially on the remaining n − 2 ones. Then one can generate any other unitary [DiVincenzo, 1995] approximately by concatenation. Although this is by no means the only possible choice for the set of “basic” unitary operations, the choice seems natural given the structure of physical interactions. Figure 2.4: Simple example of the independence of initial state and dynamical law: beam of particles that are scattered at an object. The outgoing particles contain information about the object while the incoming do not. consider the special case of two variables and postulate the following as a speciaization of Principle 2.1: Principle 2.2 (Initial state and dynamical law) If s is the initial state of a phyical system and M a map describing the effect of applying the system dynamics for some fixed time, then s and M are independent. Here, we assume that the initial state, by definition, is a state that has not interacted with the dynamics before. Here, the “initial” state s and “final” state M ( s ) are considered as “cause” and “effect.” Accordingly, M is the mechanism relating cause and effect. The last setence of Principle 2.2 requires some explanation to avoid erroneous conclusions. We now discuss its meaning for an intuitive example. Figure 2.4 shows a scenario where the independence of initial state and dynamics is so natural that we take it for granted: a beam of n particles propagating in exactly the same direction are approaching some object, where they are scattered in various directions",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_20"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". The directions of the outgoing particles contain information about the object, while the beam of incoming particles does not contain information about it. The assumption that the particles initially propagate exactly in the same direction can certainly be weakened. Even if there is some disorder in the incoming beam, the outgoing beam can still contain information about the object. Indeed, vision and photography are only possible because photons contain information about the objects at which they were scattered. We can easily time-reverse the scenario by “hand-designing” an incoming beam for which all particles propagate in the same direction after the scattering process. We now argue how to make sense of Principle 2.2 in this case. Certainly, such a beam can only be prepared by a machine or a subject that is aware of the object’s shape and then directs the particles accordingly. As a matter of fact, particles that have never been in contact with the object cannot a priori contain information about it. Then, Principle 2.2 can be maintained if we consider the process of directing the particles as part of the mechanism and reject the idea of calling the state of the hand-designed beam an initial state. Instead, the initial state then refers to the time instant before the particles have been given the fine-tuned momenta. The fact that photographic images show what has happened in the past and not what will happen in the future is among the most evident asymmetries between past and future. The preceding discussion shows that this asymmetry can be seen as an implication of Principle 2.2. The principle thus links asymmetries between cause and effect with asymmetries between past and future that we take for granted. After having explained the relation between Principle 2.1 and the asymmetry between past and future in physics on an informal level, we briefly mention that this link has been made more formally by Janzing et al. [2016] using algorithmic information theory",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_21"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". [2016] using algorithmic information theory. In the same way as Principle 4.13 formalizes independence of P C and P E | C as algorithmic independence, Principle 2.2 can also be interpreted as algorithmic independence of s and M . Janzing et al. [2016, Theorem 1] show that for any bijective M , Principle 2.2 then implies that the physical entropy of M ( s ) cannot be smaller than the entropy of s (up to an additive constant) provided that one is willing to accept Kolmogorov complexity (see Section 4.1.9) as the right formalization of physical entropy, as proposed by Bennett [1982] and Zurek [1989]. Principle 2.2 thus implies non-decrease of entropy in the sense of the standard arrow of time in physics. 3 Cause-Effect Models The present chapter formalizes some basic concepts of causality for the case where the causal models contain only two variables. Assuming, these two variables are non-trivially related and their dependence is not solely due to a common cause, this constitutes a cause-effect model. We briefly introduce SCMs, interventions, and counterfactuals. All of these concepts are defined again in the context of mutivariate causal models (Chapter 6) and we hope that encountering them for two variables first makes the ideas more easily accessible. 3.1 Structural Causal Models SCMs constitute an important tool to relate causal and probabilistic statements. Definition 3.1 (Structural causal models) An SCM C with graph C → E consists of two assignments C : = N C , (3.1) E : = f E ( C , N E ) , (3.2) where N E ⊥⊥ N C , that is, N E is independent of N C . In this model, we call the random variables C the cause and E the effect . Futhermore, we call C a direct cause of E , and we refer to C → E as a causal graph . This notation hopefully clarifies and coincides with the reader’s intuition when we talk about interventions, for example, in Example 3.2",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_22"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This notation hopefully clarifies and coincides with the reader’s intuition when we talk about interventions, for example, in Example 3.2. If we are given both the function f E and the noise distributions P N C and P N E , we can sample data from such a model in the following way: We sample noise values N E , N C and then evaluate (3.1) followed by (3.2). The SCM thus entails a joint distribution P C , E over C and E (for a formal proof see Proposition 6.3). 3.2 Interventions As discussed in Section 1.4.2, we are often interested in the system’s behavior under an intervention. The intervened system induces another distribution, which usually differs from the observational distribution. If any type of intervention can lead to an arbitrary change of the system, these two distributions become unrelated and instead of studying the two systems jointly we may consider them as two searate systems. This motivates the idea that after an intervention only parts of the data-generating process change. For example, we may be interested in a situation in which variable E is set to the value 4 (irrespective of the value of C ) without chaning the mechanism (3.1) that generates C . That is, we replace the assignment (3.2) by E : = 4. This is called a (hard) intervention and is denoted by do ( E : = 4 ) . The modified SCM, where (3.2) is replaced, entails a distribution over C that we denote by P do ( E : = 4 ) C or P C ; do ( E : = 4 ) C , where the latter makes explicit that the SCM C was our starting point. The corresponding density is denoted by c 7→ p do ( E : = 4 ) ( c ) or, in slight abuse of notation, p do ( E : = 4 ) ( c ) . 1 However, manipulations can be much more general. For example, the intervention do E : = g E ( C )+ ̃ N E keeps a functional dependence on C but changes the noise distribution. This is an example of a soft intervention . We can replace either of the two equations",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_23"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". This is an example of a soft intervention . We can replace either of the two equations. The following example motivates the namings “cause” and “effect”: Example 3.2 (Cause-effect interventions) Suppose that the distribution P C , E is entailed by an SCM C C : = N C E : = 4 · C + N E , (3.3) with N C , N E iid ∼N ( 0 , 1 ) , and graph C → E . Then, P C E = N ( 0 , 17 ) ̸ = N ( 8 , 1 ) = P C ; do ( C : = 2 ) E = P C E | C = 2 ̸ = N ( 12 , 1 ) = P C ; do ( C : = 3 ) E = P C E | C = 3 . 1 In the literature, the notation p ( c | do ( E : = 4 )) is also commonly used. We prefer p do ( E : = 4 ) since interventions are conceptually different from conditioning, and p ( c | do ( E : = 4 )) resembles the usual notation for the latter, p ( c | E = 4 ) . Intervening on C changes the distribution of E . But on the other hand, P C ; do ( E : = 2 ) C = N ( 0 , 1 ) = P C C = P C ; do ( E : = 314159265 ) C ̸ = P C C | E = 2 . (3.4) No matter how strongly we intervene on E , the distribution of C remains what it was before. This model behavior corresponds well to our intuition of C “cauing” E : for example, no matter how much we whiten someone’s teeth, this will not have any effect on this person’s smoking habits. (Importantly, the conditional ditribution of C given E = 2 is different from the distribution of C after intervening and setting E to 2.) The asymmetry between cause and effect can also be formulated as an indepedence statement. When we replace the assignment (3.3) with E : = ̃ N E (think about randomizing E ), we break the dependence between C and E . In P C ; do ( E : = ̃ N E ) C , E we find C ⊥⊥ E . This independence does not hold when randomizing C . As long as var [ ̃ N C ] ̸ = 0, we find C ̸⊥⊥ E in P C ; do ( C : = ̃ N C ) C , E ; the correlation between C and E remains non-zero. Code Snippet 3.3 The code samples from the SCM described in Example 3.2",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_24"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Code Snippet 3.3 The code samples from the SCM described in Example 3.2. 1 set.seed(1) 2 # generates a sample from the distribution entailed by the SCM 3 C <- rnorm(300) 4 E <- 4*C + rnorm(300) 5 c(mean(E), var(E)) 6 # [1] 0.1236532 16.1386767 7 # 8 # generates a sample from the intervention distribution do(C:=2); 9 # this changes the distribution of E 10 C <- rep(2,300) 11 E <- 4*C + rnorm(300) 12 c(mean(E), var(E)) 13 # [1] 7.936917 1.187035 14 # 15 # generates a sample from the intervention distribution do(E:=N ~ ); 16 # this breaks the dependence between C and E 17 C <- rnorm(300) 18 E <- rnorm(300) 19 cor.test(C,E)$p.value 20 # [1] 0.2114492 3.3 Counterfactuals Another possible modification of an SCM changes all of its noise distributions. Such a change can be induced by observations and allows us to answer countefactual questions. To illustrate this, imagine the following hypothetical scenario: Example 3.4 (Eye disease) There exists a rather effective treatment for an eye disease. For 99% of all patients, the treatment works and the patient gets cured ( B = 0); if untreated, these patients turn blind within a day ( B = 1). For the remaining 1%, the treatment has the opposite effect and they turn blind ( B = 1) within a day. If untreated, they regain normal vision ( B = 0). Which category a patient belongs to is controlled by a rare condition ( N B = 1) that is unknown to the doctor, whose decision whether to administer the treatment ( T = 1) is thus independent of N B . We write it as a noise variable N T . Assume the underlying SCM C : T : = N T B : = T · N B +( 1 − T ) · ( 1 − N B ) (3.5) with Bernoulli distributed N B ∼ Ber ( 0 . 01 ) ; note that the corresponding causal graph is T → B . Now imagine a specific patient with poor eyesight comes to the hospital and goes blind ( B = 1) after the doctor administers the treatment ( T = 1). We can now ask the counterfactual question “What would have happened had the doctor admiistered treatment T = 0 ?” Surprisingly, this can be answered",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_25"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". We can now ask the counterfactual question “What would have happened had the doctor admiistered treatment T = 0 ?” Surprisingly, this can be answered. The observation B = T = 1 implies with (3.5) that for the given patient, we had N B = 1. This, in turn, lets us calculate the effect of do ( T : = 0 ) . To this end, we first condition on our observation to update the distribution over the noise variables. As we have seen, conditioned on B = T = 1, the distribution for N B and the one for N T collapses to a point mass on 1, that is, δ 1 . This leads to a modified SCM: C | B = 1 , T = 1 : T : = 1 B : = T · 1 +( 1 − T ) · ( 1 − 1 ) = T (3.6) Note that we only update the noise distributions; conditioning does not change the structure of the assignments themselves. The idea is that the physical mechanisms are unchanged (in our case, what leads to a cure and what leads to blindness), but we have gleaned knowledge about the previously unknown noise variables for the given patient . Next, we calculate the effect of do ( T = 0 ) for this patient: C | B = 1 , T = 1; do ( T : = 0 ) : T : = 0 B : = T (3.7) Clearly, the entailed distribution puts all mass on ( 0 , 0 ) , and hence P C | B = 1 , T = 1; do ( T : = 0 ) ( B = 0 ) = 1 . This means that the patient would thus have been cured ( B = 0) if the doctor had not given him treatment, in other words, do ( T : = 0 ) . Because of P C ; do ( T : = 1 ) ( B = 0 ) = 0 . 99 and P C ; do ( T : = 0 ) ( B = 0 ) = 0 . 01 , however, we can still argue that the doctor acted optimally (according to the avaiable knowledge). Interestingly, Example 3.4 shows that we can use counterfactual statements to falsify the underlying causal model (see Section 6.8). Imagine that the rare codition N B can be tested, but the test results take longer than a day. In this case, it is possible that we observe a counterfactual statement that contradicts the mesurement result for N B . The same argument is given by Pearl [2009, p.220, point (2)]",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_26"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". In this case, it is possible that we observe a counterfactual statement that contradicts the mesurement result for N B . The same argument is given by Pearl [2009, p.220, point (2)]. Since the scientific content of counterfactuals has been debated extensively, it should be emphasized that the counterfactual statement here is falsifiable because the noise variable is not unobservable in principle but only at the moment when the decision of the doctor has to be made. 3.4 Canonical Representation of Structural Causal Models We have discussed two types of causal statements both entailed by SCMs: first, the behavior of the system under potential interventions, and second, counterfatual statements. To further understand the difference between them, we introduce the following “canonical representation” of an SCM. 2 According to the structural assignment E = f E ( C , N E ) , 2 This representation has been used in the literature in various places, for example, [Pearl, 2009] although we have not found the term “canonical representation.” for each fixed value n E of the noise N E , E is a deterministic function of C : E = f E ( C , n E ) . (3.8) In order words, if C and E attain values in C and E , respectively, then the noise N E switches between different functions from C to E . Without loss of generality, we may therefore assume that N E attains values in the set of functions from C to E , denoted by E C . Using this convention, we can also rewrite (3.8) as E = n E ( C ) , (3.9) and call this the canonical representation of the structural equation relating C and E . Let us now explain why two SCMs with different canonical representations may induce the same interventional probabilities, although they differ in their countefactual statements. To this end, we restrict the attention to the case where C attains values in the finite set C = { 1 ,, k }",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_27"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". To this end, we restrict the attention to the case where C attains values in the finite set C = { 1 ,, k } . Then the set of functions from C to E is given by the k -fold Cartesian product E k : = E ×· · ·×E | {z } k times , where the j th component describes which value E attains for C = j . Accordingly, the distribution P N E is given by a joint distribution on E k whose marginal distrbution of the j th component determines the conditional P E | C = j . Since C is the cause and E the effect, we have P do ( C : = j ) E = P E | C = j ; in other words, here intervetional probabilities and observational conditional probabilities coincide. Thus, the interventional causal implications of the SCM are completely determined by the marginal distributions of each component of the vector-valued noise variable N E even though the SCM includes a precise specification of P N E , that is, the joint ditribution of all components. While the statistical dependences between the compnents of the noise variable N E referring to the effect are irrelevant for interventional causal statements, they do matter for counterfactual statements. To see this, let C and E be binary, that is, C = E = { 0 , 1 } . The set of functions from { 0 , 1 } to { 0 , 1 } reads E C = { 0 , 1 , ID , NOT } where 0 , 1 denote the constant functions attaining 0 and 1, respectively, and ID and NOT denote identity and negation, respectively. To construct two different distributions P 1 N E and P 2 N E inducing the same conditional P E | C = 0 , P E | C = 1 , first choose the uniform mixture of 0 and 1 and second the uniform mixture of ID and NOT. In both cases, C and E are statistically independent and the distribution of E is unaffected by interventions on C because E remains an ubiased coin toss regardless of C . In the Cartesian product representation, the four functions read E C = { ( 0 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( 1 , 0 ) } , the first and the second compnent denote the images of C = 0 and C = 1, respectively",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_28"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Obviously, the uniform mixture of ( 0 , 0 ) and ( 1 , 1 ) and the uniform mixture of ( 0 , 1 ) and ( 1 , 0 ) both iduce the same marginal distributions on the first and the second component of the Cartesian product — in agreement with our remark that they induce the same itervention distributions. The counterfactual statement “ E would have attained a different value if C had been set to a different one,” however, is true only for the mixture of ID and NOT, but not for the mixture of 0 and 1 . Hence, counterfactual statements depend not only on the marginal distributions of the components of the noise variable N E , but also on the statistical dependences between the Cartesian product components. Note that two formally different SCMs may induce not only the same intervetional distribution but even imply the same counterfactual statements: Given the assignment E : = f E ( C , N E ) , reparameterizations of N E are obviously irrelevant. More explicitly, we may set E : = ̃ f E ( C , ̃ N E ) = f E ( C , g − 1 ( ̃ N E )) , for some bijection g on the range of N E and redefine the noise variable by ̃ N E : = g ( N E ) . Using the canonical representation (3.9), we got rid of this additional degree of freedom that would have confused this discussion of counterfactuals. 3.5 Problems Problem 3.5 (Sampling from an SCM) Consider the SCM X : = Y 2 + N X (3.10) Y : = N Y (3.11) with N X , N Y iid ∼N ( 0 , 1 ) . Generate an i.i.d. sample of size 200 from the joint distrbution ( X , Y ) . Problem 3.6 (Conditional distributions) Show that P C C | E = 2 in Equation (3.4) is a Gaussian distribution: C | E = 2 ∼N 8 17 , σ 2 = 1 17 . 40 Chapter 3. Cause-Effect Models Problem 3.7 (Interventions) Assume that we know that a process either follows the SCM X : = Y + N X Y : = N Y , where N X ∼N ( μ X , σ 2 X ) and N Y ∼N ( μ Y , σ 2 Y ) with unknown μ X , μ Y and σ X , σ Y > 0 , or it follows the SCM X : = M X Y : = X + M Y , where M X ∼N ( ν X , τ 2 X ) and M Y ∼N ( ν Y , τ 2 Y ) with unknown ν X , ν Y and τ X , τ Y > 0",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_29"
  },
  {
    "document_type": "book",
    "title": "Elements of Causal Inference",
    "author": "Peters, Jonas, Dominik Janzing, and Bernhard Schölkopf",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\elements_of_causal_inference.pdf",
    "date_published": "2017-09-06",
    "keywords": "Unavailable",
    "flag": "",
    "chunk_text": ". Is there a single intervention distribution that lets you distinguish between the two SCMs? Problem 3.8 (Cyclic SCMs) We have mentioned that if the assignments inherit a cyclic structure, the SCM does not necessarily induce a unique distribution over the observed variables. Sometimes there is no solution and sometimes it is not unique. a) We first look at an example that induces a unique solution. Consider the SCM X : = 2 · Y + N X (3.12) Y : = 2 · X + N Y (3.13) with ( N X , N Y ) ∼ P for an arbitrary distribution P. Compute α , β , γ , δ such that X : = α N X + β N Y Y : = γ N X + δ N Y yields a solution ( X , Y , N X , N Y ) of the SCM; that is, the vector satisfies Equtions (3.12) and (3.13) . The solution can be seen as a special case of Eqution (6.2) . b) Consider the SCM X : = Y + N X Y : = X + N Y with ( N X , N Y ) ∼ P. Show that if P allows for a density with respect to Lebesgue measure and factorizes, that is, N X ⊥⊥ N Y , then there is no soltion ( X , Y , N X , N Y ) of the SCM. Furthermore, construct a distribution P, and a vector ( X , Y , N X , N Y ) that solves the SCM.",
    "chunk_id": "elements_of_causal_inference_page-15-41.json_chunk_30"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/decomposition.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Time series data can exhibit a variety of patterns, and it is often helpful to split a time series into several components, each representing an underlying pattern category. In Section2.3we discussed three types of time series patterns: trend, seasonality and cycles. When we decompose a time series into components, we usually combine the trend and cycle into a singletrend-cyclecomponent (often just called thetrendfor simplicity). Thus we can think of a time series as comprising three components: a trend-cycle component, a seasonal component, and a remainder component (containing anything else in the time series). For some time series (e.g., those that are observed at least daily), there can be more than one seasonal component, corresponding to the different seasonal periods. In this chapter, we consider the most common methods for extracting these components from a time series. Often this is done to help improve understanding of the time series, but it can also be used to improve forecast accuracy. When decomposing a time series, it is sometimes helpful to first transform or adjust the series in order to make the decomposition (and later analysis) as simple as possible. So we will begin by discussing transformations and adjustments.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed).json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-r.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "TheARIMA()function in thefablepackage uses a variation of the Hyndman-Khandakar algorithm(Hyndman & Khandakar, 2008), which combines unit root tests, minimisation of the AICc and MLE to obtain an ARIMA model. The arguments toARIMA()provide for many variations on the algorithm. What is described here is the default behaviour. Figure 9.11: An illustrative example of the Hyndman-Khandakar stepwise search process Figure9.11illustrates diagrammatically how the Hyndman-Khandakar algorithm traverses the space of the ARMA orders, through an example. The grid covers combinations of ARMA(\\(p,q\\)) orders starting from the top-left corner with an ARMA(\\(0,0\\)), with the AR order increasing down the vertical axis, and the MA order increasing across the horizontal axis. The orange cells show the initial set of models considered by the algorithm. In this example, the ARMA(2,2) model has the lowest AICc value amongst these models. This is called the âcurrent modelâ and is shown by the black circle. The algorithm then searches over neighbouring models as shown by the blue arrows. If a better model is found then this becomes the new âcurrent modelâ. In this example, the new âcurrent modelâ is the ARMA(3,3) model. The algorithm continues in this fashion until no better model can be found. In this example the model returned is an ARMA(4,2) model. The default procedure will switch to a new âcurrent modelâ as soon as a better model is identified, without going through all the neighbouring models. The full neighbourhood search is done whengreedy=FALSE. The default procedure also uses some approximations to speed up the search. These approximations can be avoided with the argumentapproximation=FALSE. It is possible that the minimum AICc model will not be found due to these approximations, or because of the use of the stepwise procedure. A much larger set of models will be searched if the argumentstepwise=FALSEis used. See the help file for a full description of the arguments",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_012ac94b.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-r.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". A much larger set of models will be searched if the argumentstepwise=FALSEis used. See the help file for a full description of the arguments. When fitting an ARIMA model to a set of (non-seasonal) time series data, the following procedure provides a useful general approach. The Hyndman-Khandakar algorithm only takes care of steps 3â5. So even if you use it, you will still need to take care of the other steps yourself. The process is summarised in Figure9.12. Figure 9.12: General process for forecasting using an ARIMA model. With ARIMA models, more accurate portmanteau tests are obtained if the degrees of freedom of the test statistic are adjusted to take account of the number of parameters in the model. Specifically, we use\\(\\ell - K\\)degrees of freedom in the test, where\\(\\ell\\)is the number of lags used in the test, and\\(K\\)is the number of AR and MA parameters in the model. So for the non-seasonal models that we have considered so far,\\(K=p+q\\). The value of\\(K\\)is passed to theljung_boxfunction via the argumentdof, as shown in the example below. We will apply this procedure to the exports of the Central African Republic shown in Figure9.13. Figure 9.13: Exports of the Central African Republic as a percentage of GDP. The time plot shows some non-stationarity, with an overall decline. The improvement in 1994 was due to a new government which overthrew the military junta and had some initial success, before unrest caused further economic decline. There is no evidence of changing variance, so we will not do a Box-Cox transformation. To address the non-stationarity, we will take a first difference of the data. The differenced data are shown in Figure9.14. Figure 9.14: Time plot and ACF and PACF plots for the differenced Central African Republic Exports. These now appear to be stationary. The PACF shown in Figure9.14is suggestive of an AR(2) model; so an initial candidate model is an ARIMA(2,1,0). The ACF suggests an MA(3) model; so an alternative candidate is an ARIMA(0,1,3)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_012ac94b.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-r.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The PACF shown in Figure9.14is suggestive of an AR(2) model; so an initial candidate model is an ARIMA(2,1,0). The ACF suggests an MA(3) model; so an alternative candidate is an ARIMA(0,1,3). We fit both an ARIMA(2,1,0) and an ARIMA(0,1,3) model along with two automated model selections, one using the default stepwise procedure, and one working harder to search a larger model space. The four models have almost identical AICc values. Of the models fitted, the full search has found that an ARIMA(3,1,0) gives the lowest AICc value, closely followed by the ARIMA(2,1,0) and ARIMA(0,1,3) â the latter two being the models that we guessed from the ACF and PACF plots. The automated stepwise selection has identified an ARIMA(2,1,2) model, which has the highest AICc value of the four models. The ACF plot of the residuals from the ARIMA(3,1,0) model shows that all autocorrelations are within the threshold limits, indicating that the residuals are behaving like white noise. Figure 9.15: Residual plots for the ARIMA(3,1,0) model. A portmanteau test (setting\\(K = 3\\)) returns a large p-value, also suggesting that the residuals are white noise. Forecasts from the chosen model are shown in Figure9.16. Figure 9.16: Forecasts for the Central African Republic Exports. Note that the mean forecasts look very similar to what we would get with a random walk (equivalent to an ARIMA(0,1,0)). The extra work to include AR and MA terms has made little difference to the point forecasts in this example, although the prediction intervals are much narrower than for a random walk model. A non-seasonal ARIMA model can be written as\\[\\begin{equation} \\tag{9.3} (1-\\phi_1B - \\cdots - \\phi_p B^p)(1-B)^d y_t = c + (1 + \\theta_1 B + \\cdots + \\theta_q B^q)\\varepsilon_t, \\end{equation}\\]or equivalently as\\[\\begin{equation} \\tag{9.4} (1-\\phi_1B - \\cdots - \\phi_p B^p)(1-B)^d (y_t - \\mu t^d/d!) = (1 + \\theta_1 B + \\cdots + \\theta_q B^q)\\varepsilon_t, \\end{equation}\\]where\\(c = \\mu(1-\\phi_1 - \\cdots - \\phi_p )\\)and\\(\\mu\\)is the mean of\\((1-B)^d y_t\\)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_012ac94b.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-r.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Thefablepackage uses the parameterisation of Equation(9.3)while most other R implementations use Equation(9.4). Thus, the inclusion of a constant in a non-stationary ARIMA model is equivalent to inducing a polynomial trend of order\\(d\\)in the forecasts. (If the constant is omitted, the forecasts include a polynomial trend of order\\(d-1\\).) When\\(d=0\\), we have the special case that\\(\\mu\\)is the mean of\\(y_t\\). By default, theARIMA()function will automatically determine if a constant should be included. For\\(d=0\\)or\\(d=1\\), a constant will be included if it improves the AICc value. If\\(d>1\\)the constant is always omitted as a quadratic or higher order trend is particularly dangerous when forecasting. The constant can be specified by including0or1in the model formula (like the intercept inlm()). For example, to automatically select an ARIMA model with a constant, you could useARIMA(y ~ 1 + ). Similarly, a constant can be excluded withARIMA(y ~ 0 + ). (This is a more advanced section and can be skipped if desired.) We can re-write Equation(9.3)as\\[\\phi(B) (1-B)^d y_t = c + \\theta(B) \\varepsilon_t\\]where\\(\\phi(B)= (1-\\phi_1B - \\cdots - \\phi_p B^p)\\)is a\\(p\\)th order polynomial in\\(B\\)and\\(\\theta(B) = (1 + \\theta_1 B + \\cdots + \\theta_q B^q)\\)is a\\(q\\)th order polynomial in\\(B\\). The stationarity conditions for the model are that the\\(p\\)complex roots of\\(\\phi(B)\\)lie outside the unit circle, and the invertibility conditions are that the\\(q\\)complex roots of\\(\\theta(B)\\)lie outside the unit circle. So we can see whether the model is close to invertibility or stationarity by a plot of the roots in relation to the complex unit circle. It is easier to plot the inverse roots instead, as they should all liewithinthe unit circle. This is easily done in R. For the ARIMA(3,1,0) model fitted to the Central African Republic Exports, we obtain Figure9.17. Figure 9.17: Inverse characteristic roots for the ARIMA(3,1,0) model fitted to the Central African Republic Exports",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_012ac94b.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-r.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Figure 9.17: Inverse characteristic roots for the ARIMA(3,1,0) model fitted to the Central African Republic Exports. The three orange dots in the plot correspond to the roots of the polynomials\\(\\phi(B)\\). They are all inside the unit circle, as we would expect becausefableensures the fitted model is both stationary and invertible. Any roots close to the unit circle may be numerically unstable, and the corresponding model will not be good for forecasting. TheARIMA()function will never return a model with inverse roots outside the unit circle. Models automatically selected by theARIMA()function will not contain roots close to the unit circle either. Consequently, it is sometimes possible to find a model with better AICc value thanARIMA()will return, but such models will be potentially problematic.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_012ac94b.json_chunk_5"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/causality.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "It is important not to confuse correlation with causation, or causation with forecasting. A variable\\(x\\)may be useful for forecasting a variable\\(y\\), but that does not mean\\(x\\)is causing\\(y\\). It is possible that\\(x\\)iscausing\\(y\\), but it may be that\\(y\\)is causing\\(x\\), or that the relationship between them is more complicated than simple causality. For example, it is possible to model the number of drownings at a beach resort each month with the number of ice-creams sold in the same period. The model can give reasonable forecasts, not because ice-creams cause drownings, but because people eat more ice-creams on hot days when they are also more likely to go swimming. So the two variables (ice-cream sales and drownings) are correlated, but one is not causing the other. They are both caused by a third variable (temperature). This is an example of âconfoundingâ â where an omitted variable causes changes in both the response variable and at least one predictor variable. We describe a variable that is not included in our forecasting model as aconfounderwhen it influences both the response variable and at least one predictor variable. Confounding makes it difficult to determine what variables arecausingchanges in other variables, but it does not necessarily make forecasting more difficult. Similarly, it is possible to forecast if it will rain in the afternoon by observing the number of cyclists on the road in the morning. When there are fewer cyclists than usual, it is more likely to rain later in the day. The model can give reasonable forecasts, not because cyclists prevent rain, but because people are more likely to cycle when the published weather forecast is for a dry day. In this case, there is a causal relationship, but in the opposite direction to our forecasting model. The number of cyclists falls because there is rain forecast. That is,\\(y\\)(rainfall) is affecting\\(x\\)(cyclists)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_16dbdd0e.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/causality.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The number of cyclists falls because there is rain forecast. That is,\\(y\\)(rainfall) is affecting\\(x\\)(cyclists). It is important to understand that correlations are useful for forecasting, even when there is no causal relationship between the two variables, or when the causality runs in the opposite direction to the model, or when there is confounding. However, often a better model is possible if a causal mechanism can be determined. A better model for drownings will probably include temperatures and visitor numbers and exclude ice-cream sales. A good forecasting model for rainfall will not include cyclists, but it will include atmospheric observations from the previous few days. When two or more predictors are highly correlated it is always challenging to accurately separate their individual effects. Suppose we are forecasting monthly sales of a company for 2012, using data from 2000â2011. In January 2008, a new competitor came into the market and started taking some market share. At the same time, the economy began to decline. In your forecasting model, you include both competitor activity (measured using advertising time on a local television station) and the health of the economy (measured using GDP). It will not be possible to separate the effects of these two predictors because they are highly correlated. Having correlated predictors is not really a problem for forecasting, as we can still compute forecasts without needing to separate out the effects of the predictors. However, it becomes a problem with scenario forecasting as the scenarios should take account of the relationships between predictors. It is also a problem if some historical analysis of the contributions of various predictors is required. A closely related issue ismulticollinearity, which occurs when similar information is provided by two or more of the predictor variables in a multiple regression. It can occur when two predictors are highly correlated with each other (that is, they have a correlation coefficient close to +1 or -1)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_16dbdd0e.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/causality.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". It can occur when two predictors are highly correlated with each other (that is, they have a correlation coefficient close to +1 or -1). In this case, knowing the value of one of the variables tells you a lot about the value of the other variable. Hence, they are providing similar information. For example, foot size can be used to predict height, but including the size of both left and right feet in the same model is not going to make the forecasts any better, although it wonât make them worse either. Multicollinearity can also occur when a linear combination of predictors is highly correlated with another linear combination of predictors. In this case, knowing the value of the first group of predictors tells you a lot about the value of the second group of predictors. Hence, they are providing similar information. An example of this problem is the dummy variable trap discussed in Section7.4. Suppose you have quarterly data and use four dummy variables,\\(d_1\\),\\(d_2\\),\\(d_3\\)and\\(d_4\\). Then\\(d_4=1-d_1-d_2-d_3\\), so there is perfect correlation between\\(d_4\\)and\\(d_1+d_2+d_3\\). In the case of perfect correlation (i.e., a correlation of +1 or -1, such as in the dummy variable trap), it is not possible to estimate the regression model. If there is high correlation (close to but not equal to +1 or -1), then the estimation of the regression coefficients is computationally difficult. In fact, some software (notably Microsoft Excel) may give highly inaccurate estimates of the coefficients. Most reputable statistical software will use algorithms to limit the effect of multicollinearity on the coefficient estimates, but you do need to be careful. The major software packages such as R, SPSS, SAS and Stata all use estimation algorithms to avoid the problem as much as possible. When multicollinearity is present, the uncertainty associated with individual regression coefficients will be large. This is because they are difficult to estimate",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_16dbdd0e.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/causality.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". When multicollinearity is present, the uncertainty associated with individual regression coefficients will be large. This is because they are difficult to estimate. Consequently, statistical tests (e.g., t-tests) on regression coefficients are unreliable. (In forecasting we are rarely interested in such tests.) Also, it will not be possible to make accurate statements about the contribution of each separate predictor to the forecast. Forecasts will be unreliable if the values of the future predictors are outside the range of the historical values of the predictors. For example, suppose you have fitted a regression model with predictors\\(x_1\\)and\\(x_2\\)which are highly correlated with each other, and suppose that the values of\\(x_1\\)in the training data ranged between 0 and 100. Then forecasts based on\\(x_1>100\\)or\\(x_1<0\\)will be unreliable. It is always a little dangerous when future values of the predictors lie much outside the historical range, but it is especially problematic when multicollinearity is present. Note that if you are using good statistical software, if you are not interested in the specific contributions of each predictor, and if the future values of your predictor variables are within their historical ranges, there is nothing to worry about â multicollinearity is not a problem except when there is perfect correlation.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_16dbdd0e.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/classical-decomposition.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "The classical decomposition method originated in the 1920s. It is a relatively simple procedure, and forms the starting point for most other methods of time series decomposition. There are two forms of classical decomposition: an additive decomposition and a multiplicative decomposition. These are described below for a time series with seasonal period\\(m\\)(e.g.,\\(m=4\\)for quarterly data,\\(m=12\\)for monthly data,\\(m=7\\)for daily data with a weekly pattern). In classical decomposition, we assume that the seasonal component is constant from year to year. For multiplicative seasonality, the\\(m\\)values that form the seasonal component are sometimes called the âseasonal indicesâ. Figure3.13shows a classical decomposition of the total retail employment series across the US. Figure 3.13: A classical additive decomposition of US retail employment. A classical multiplicative decomposition is similar, except that the subtractions are replaced by divisions. While classical decomposition is still widely used, it is not recommended, as there are now several much better methods. Some of the problems with classical decomposition are summarised below.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_2194c2ce.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/moving-averages.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "The classical method of time series decomposition originated in the 1920s and was widely used until the 1950s. It still forms the basis of many time series decomposition methods, so it is important to understand how it works. The first step in a classical decomposition is to use a moving average method to estimate the trend-cycle, so we begin by discussing moving averages. A moving average of order\\(m\\)can be written as\\[\\begin{equation} \\hat{T}_{t} = \\frac{1}{m} \\sum_{j=-k}^k y_{t+j}, \\tag{3.2} \\end{equation}\\]where\\(m=2k+1\\). That is, the estimate of the trend-cycle at time\\(t\\)is obtained by averaging values of the time series within\\(k\\)periods of\\(t\\). Observations that are nearby in time are also likely to be close in value. Therefore, the average eliminates some of the randomness in the data, leaving a smooth trend-cycle component. We call this an\\(m\\)-MA, meaning a moving average of order\\(m\\). For example, consider Figure3.9which shows exports of goods and services for Australia as a percentage of GDP from 1960 to 2017. The data are also shown in Table3.1. Figure 3.9: Australian exports of goods and services: 1960â2017. In the last column of this table, a moving average of order 5 is shown, providing an estimate of the trend-cycle. The first value in this column is the average of the first five observations, 1960â1964; the second value in the 5-MA column is the average of the values for 1961â1965; and so on. Each value in the 5-MA column is the average of the observations in the five year window centred on the corresponding year. In the notation of Equation(3.2), column 5-MA contains the values of\\(\\hat{T}_{t}\\)with\\(k=2\\)and\\(m=2k+1=5\\). There are no values for either the first two years or the last two years, because we do not have two observations on either side. Later we will use more sophisticated methods of trend-cycle estimation which do allow estimates near the endpoints. This is easily computed usingslide_dbl()from thesliderpackage which applies a function to âslidingâ time windows",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_2ed0899a.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/moving-averages.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". This is easily computed usingslide_dbl()from thesliderpackage which applies a function to âslidingâ time windows. In this case, we use themean()function with a window of size 5. To see what the trend-cycle estimate looks like, we plot it along with the original data in Figure3.10. Figure 3.10: Australian exports (black) along with the 5-MA estimate of the trend-cycle (orange). Notice that the trend-cycle (in orange) is smoother than the original data and captures the main movement of the time series without all of the minor fluctuations. The order of the moving average determines the smoothness of the trend-cycle estimate. In general, a larger order means a smoother curve. Figure3.11shows the effect of changing the order of the moving average for the Australian exports data. Figure 3.11: Different moving averages applied to the Australian exports data. Simple moving averages such as these are usually of an odd order (e.g., 3, 5, 7, etc.). This is so they are symmetric: in a moving average of order\\(m=2k+1\\), the middle observation, and\\(k\\)observations on either side, are averaged. But if\\(m\\)was even, it would no longer be symmetric. It is possible to apply a moving average to a moving average. One reason for doing this is to make an even-order moving average symmetric. For example, we might take a moving average of order 4, and then apply another moving average of order 2 to the results. In the following table, this has been done for the first few years of the Australian quarterly beer production data. The notation â\\(2\\times4\\)-MAâ in the last column means a 4-MA followed by a 2-MA. The values in the last column are obtained by taking a moving average of order 2 of the values in the previous column. For example, the first two values in the 4-MA column are 451.25=(443+410+420+532)/4 and 448.75=(410+420+532+433)/4. The first value in the 2x4-MA column is the average of these two: 450.00=(451.25+448.75)/2",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_2ed0899a.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/moving-averages.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The first value in the 2x4-MA column is the average of these two: 450.00=(451.25+448.75)/2. When a 2-MA follows a moving average of an even order (such as 4), it is called a âcentred moving average of order 4â. This is because the results are now symmetric. To see that this is the case, we can write the\\(2\\times4\\)-MA as follows:\\[\\begin{align*} \\hat{T}_{t} &= \\frac{1}{2}\\Big[ \\frac{1}{4} (y_{t-2}+y_{t-1}+y_{t}+y_{t+1}) + \\frac{1}{4} (y_{t-1}+y_{t}+y_{t+1}+y_{t+2})\\Big] \\\\ &= \\frac{1}{8}y_{t-2}+\\frac14y_{t-1} + \\frac14y_{t}+\\frac14y_{t+1}+\\frac18y_{t+2}. \\end{align*}\\]It is now a weighted average of observations that is symmetric. Other combinations of moving averages are also possible. For example, a\\(3\\times3\\)-MA is often used, and consists of a moving average of order 3 followed by another moving average of order 3. In general, an even order MA should be followed by an even order MA to make it symmetric. Similarly, an odd order MA should be followed by an odd order MA. The most common use of centred moving averages is for estimating the trend-cycle from seasonal data. Consider the\\(2\\times4\\)-MA:\\[ \\hat{T}_{t} = \\frac{1}{8}y_{t-2} + \\frac14y_{t-1} + \\frac14y_{t} + \\frac14y_{t+1} + \\frac18y_{t+2}. \\]When applied to quarterly data, each quarter of the year is given equal weight as the first and last terms apply to the same quarter in consecutive years. Consequently, the seasonal variation will be averaged out and the resulting values of\\(\\hat{T}_t\\)will have little or no seasonal variation remaining. A similar effect would be obtained using a\\(2\\times 8\\)-MA or a\\(2\\times 12\\)-MA to quarterly data. In general, a\\(2\\times m\\)-MA is equivalent to a weighted moving average of order\\(m+1\\)where all observations take the weight\\(1/m\\), except for the first and last terms which take weights\\(1/(2m)\\). So, if the seasonal period is even and of order\\(m\\), we use a\\(2\\times m\\)-MA to estimate the trend-cycle. If the seasonal period is odd and of order\\(m\\), we use a\\(m\\)-MA to estimate the trend-cycle",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_2ed0899a.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/moving-averages.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". If the seasonal period is odd and of order\\(m\\), we use a\\(m\\)-MA to estimate the trend-cycle. For example, a\\(2\\times 12\\)-MA can be used to estimate the trend-cycle of monthly data with annual seasonality and a 7-MA can be used to estimate the trend-cycle of daily data with a weekly seasonality. Other choices for the order of the MA will usually result in trend-cycle estimates being contaminated by the seasonality in the data. Figure 3.12: A 2x12-MA applied to the US retail employment series. Figure3.12shows a\\(2\\times12\\)-MA applied to the total number of persons employed in the US retail sector. Notice that the smooth line shows no seasonality; it is almost the same as the trend-cycle shown in Figure3.6, which was estimated using a much more sophisticated method than a moving average. Any other choice for the order of the moving average (except for 24, 36, etc.) would have resulted in a smooth line that showed some seasonal fluctuations. Combinations of moving averages result in weighted moving averages. For example, the\\(2\\times4\\)-MA discussed above is equivalent to a weighted 5-MA with weights given by\\(\\left[\\frac{1}{8},\\frac{1}{4},\\frac{1}{4},\\frac{1}{4},\\frac{1}{8}\\right]\\). In general, a weighted\\(m\\)-MA can be written as\\[ \\hat{T}_t = \\sum_{j=-k}^k a_j y_{t+j}, \\]where\\(k=(m-1)/2\\), and the weights are given by\\(\\left[a_{-k},\\dots,a_k\\right]\\). It is important that the weights all sum to one and that they are symmetric so that\\(a_j = a_{-j}\\). The simple\\(m\\)-MA is a special case where all of the weights are equal to\\(1/m\\). A major advantage of weighted moving averages is that they yield a smoother estimate of the trend-cycle. Instead of observations entering and leaving the calculation at full weight, their weights slowly increase and then slowly decrease, resulting in a smoother curve.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_2ed0899a.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/transformations.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Adjusting the historical data can often lead to a simpler time series. Here, we deal with four kinds of adjustments: calendar adjustments, population adjustments, inflation adjustments and mathematical transformations. The purpose of these adjustments and transformations is to simplify the patterns in the historical data by removing known sources of variation, or by making the pattern more consistent across the whole data set. Simpler patterns are usually easier to model and lead to more accurate forecasts. Some of the variation seen in seasonal data may be due to simple calendar effects. In such cases, it is usually much easier to remove the variation before doing any further analysis. For example, if you are studying the total monthly sales in a retail store, there will be variation between the months simply because of the different numbers of trading days in each month, in addition to the seasonal variation across the year. It is easy to remove this variation by computing average sales per trading day in each month, rather than total sales in the month. Then we effectively remove the calendar variation. Any data that are affected by population changes can be adjusted to give per-capita data. That is, consider the data per person (or per thousand people, or per million people) rather than the total. For example, if you are studying the number of hospital beds in a particular region over time, the results are much easier to interpret if you remove the effects of population changes by considering the number of beds per thousand people. Then you can see whether there have been real increases in the number of beds, or whether the increases are due entirely to population increases. It is possible for the total number of beds to increase, but the number of beds per thousand people to decrease. This occurs when the population is increasing faster than the number of hospital beds. For most data that are affected by population changes, it is best to use per-capita data rather than the totals",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_343e3cb0.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/transformations.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". This occurs when the population is increasing faster than the number of hospital beds. For most data that are affected by population changes, it is best to use per-capita data rather than the totals. This can be seen in theglobal_economydataset, where a common transformation of GDP is GDP per-capita. Figure 3.1: Australian GDP per-capita. Data which are affected by the value of money are best adjusted before modelling. For example, the average cost of a new house will have increased over the last few decades due to inflation. A $200,000 house this year is not the same as a $200,000 house twenty years ago. For this reason, financial time series are usually adjusted so that all values are stated in dollar values from a particular year. For example, the house price data may be stated in year 2000 dollars. To make these adjustments, a price index is used. If\\(z_{t}\\)denotes the price index and\\(y_{t}\\)denotes the original house price in year\\(t\\), then\\(x_{t} = y_{t}/z_{t} * z_{2000}\\)gives the adjusted house price at year 2000 dollar values. Price indexes are often constructed by government agencies. For consumer goods, a common price index is the Consumer Price Index (or CPI). This allows us to compare the growth or decline of industries relative to a common price value. For example, looking at aggregate annual ânewspaper and bookâ retail turnover fromaus_retail, and adjusting the data for inflation using CPI fromglobal_economyallows us to understand the changes over time. Figure 3.2: Turnover for the Australian print media industry in Australian dollars. The âAdjustedâ turnover has been adjusted for inflation using the CPI. By adjusting for inflation using the CPI, we can see that Australiaâs newspaper and book retailing industry has been in decline much longer than the original data suggests. The adjusted turnover is in 2010 Australian dollars, as CPI is 100 in 2010 in this data set. If the data shows variation that increases or decreases with the level of the series, then a transformation can be useful",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_343e3cb0.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/transformations.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". If the data shows variation that increases or decreases with the level of the series, then a transformation can be useful. For example, a logarithmic transformation is often useful. If we denote the original observations as\\(y_{1},\\dots,y_{T}\\)and the transformed observations as\\(w_{1}, \\dots, w_{T}\\), then\\(w_t = \\log(y_t)\\). Logarithms are useful because they are interpretable: changes in a log value are relative (or percentage) changes on the original scale. So if log base 10 is used, then an increase of 1 on the log scale corresponds to a multiplication of 10 on the original scale. If any value of the original series is zero or negative, then logarithms are not possible. Sometimes other transformations are also used (although they are not so interpretable). For example, square roots and cube roots can be used. These are calledpower transformationsbecause they can be written in the form\\(w_{t} = y_{t}^p\\). A useful family of transformations, that includes both logarithms and power transformations, is the family ofBox-Cox transformations(Box & Cox, 1964), which depend on the parameter\\(\\lambda\\)and are defined as follows:\\[\\begin{equation} w_t = \\begin{cases} \\log(y_t) & \\text{if $\\lambda=0$}; \\\\ (\\text{sign}(y_t)|y_t|^\\lambda-1)/\\lambda & \\text{otherwise}. \\end{cases} \\tag{3.1} \\end{equation}\\]This is actually a modified Box-Cox transformation, discussed inBickel & Doksum (1981), which allows for negative values of\\(y_t\\)provided\\(\\lambda > 0\\). The logarithm in a Box-Cox transformation is always a natural logarithm (i.e., to base\\(e\\)). So if\\(\\lambda=0\\), natural logarithms are used, but if\\(\\lambda\\ne0\\), a power transformation is used, followed by some simple scaling. If\\(\\lambda=1\\), then\\(w_t = y_t-1\\), so the transformed data is shifted downwards but there is no change in the shape of the time series. For all other values of\\(\\lambda\\), the time series will change shape",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_343e3cb0.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/transformations.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". For all other values of\\(\\lambda\\), the time series will change shape. Use the slider below to see the effect of varying\\(\\lambda\\)to transform Australian quarterly gas production: Figure 3.3: Box-Cox transformations applied to Australian quarterly gas production. A good value of\\(\\lambda\\)is one which makes the size of the seasonal variation about the same across the whole series, as that makes the forecasting model simpler. In this case,\\(\\lambda=0.10\\)works quite well, although any value of\\(\\lambda\\)between 0.0 and 0.2 would give similar results. Theguerrerofeature(Guerrero, 1993)can be used to choose a value of lambda for you. In this case it chooses\\(\\lambda=0.11\\). (See the next chapter for discussion of thefeatures()function.) Figure 3.4: Transformed Australian quarterly gas production with the\\(\\lambda\\)parameter chosen using the Guerrero method.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_343e3cb0.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-exercises.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Figure9.32shows the ACFs for 36 random numbers, 360 random numbers and 1,000 random numbers. Figure 9.32: Left: ACF for a white noise series of 36 numbers. Middle: ACF for a white noise series of 360 numbers. Right: ACF for a white noise series of 1,000 numbers. A classic example of a non-stationary series are stock prices. Plot the daily closing prices for Amazon stock (contained ingafa_stock), along with the ACF and PACF. Explain how each plot shows that the series is non-stationary and should be differenced. For the following series, find an appropriate Box-Cox transformation and order of differencing in order to obtain stationary data. For thesouvenirsdata, write down the differences you chose above using backshift operator notation. For your retail data (from Exercise 7 in Section2.10), find the appropriate order of differencing (after transformation if necessary) to obtain stationary data. Simulate and plot some data from simple ARIMA models. Use the following R code to generate data from an AR(1) model with\\(\\phi_{1} = 0.6\\)and\\(\\sigma^2=1\\). The process starts with\\(y_1=0\\). Produce a time plot for the series. How does the plot change as you change\\(\\phi_1\\)? Write your own code to generate data from an MA(1) model with\\(\\theta_{1} = 0.6\\)and\\(\\sigma^2=1\\). Produce a time plot for the series. How does the plot change as you change\\(\\theta_1\\)? Generate data from an ARMA(1,1) model with\\(\\phi_{1} = 0.6\\),\\(\\theta_{1} = 0.6\\)and\\(\\sigma^2=1\\). Generate data from an AR(2) model with\\(\\phi_{1} =-0.8\\),\\(\\phi_{2} = 0.3\\)and\\(\\sigma^2=1\\). (Note that these parameters will give a non-stationary series.) Graph the latter two series and compare them. Consideraus_airpassengers, the total number of passengers (in millions) from Australian air carriers for the period 1970-2011. For the United States GDP series (fromglobal_economy): Consideraus_arrivals, the quarterly number of international visitors to Australia from several countries for the period 1981 Q1 â 2012 Q3",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3a610b4e.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-exercises.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". For the United States GDP series (fromglobal_economy): Consideraus_arrivals, the quarterly number of international visitors to Australia from several countries for the period 1981 Q1 â 2012 Q3. Choose a series fromus_employment, the total employment in different industries in the United States. Choose one of the following seasonal time series: the Australian production of electricity, cement, or gas (fromaus_production). For the same time series you used in the previous exercise, try using a non-seasonal model applied to the seasonally adjusted data obtained from STL. Compare the forecasts with those obtained in the previous exercise. Which do you think is the best approach? For the Australian tourism data (fromtourism): For your retail time series (Exercise 5 above): Consider the number of Snowshoe Hare furs traded by the Hudson Bay Company between 1845 and 1935 (data setpelt). Produce a time plot of the time series. Assume you decide to fit the following model:\\[ y_t = c + \\phi_1 y_{t-1} + \\phi_2 y_{t-2} + \\phi_3 y_{t-3} + \\phi_4 y_{t-4} + \\varepsilon_t, \\]where\\(\\varepsilon_t\\)is a white noise series. What sort of ARIMA model is this (i.e., what are\\(p\\),\\(d\\), and\\(q\\))? By examining the ACF and PACF of the data, explain why this model is appropriate. The last five values of the series are given below: The estimated parameters are\\(c = 30993\\),\\(\\phi_1 = 0.82\\),\\(\\phi_2 = -0.29\\),\\(\\phi_3 = -0.01\\), and\\(\\phi_4 = -0.22\\). Without using theforecast()function, calculate forecasts for the next three years (1936â1939). Now fit the model in R and obtain the forecasts usingforecast(). How are they different from yours? Why? The population of Switzerland from 1960 to 2017 is in data setglobal_economy. Produce a time plot of the data. You decide to fit the following model to the series:\\[y_t = c + y_{t-1} + \\phi_1 (y_{t-1} - y_{t-2}) + \\phi_2 (y_{t-2} - y_{t-3}) + \\phi_3( y_{t-3} - y_{t-4}) + \\varepsilon_t\\]where\\(y_t\\)is the Population in year\\(t\\)and\\(\\varepsilon_t\\)is a white noise series",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3a610b4e.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-exercises.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". What sort of ARIMA model is this (i.e., what are\\(p\\),\\(d\\), and\\(q\\))? Explain why this model was chosen using the ACF and PACF of the differenced series. The last five values of the series are given below. The estimated parameters are\\(c = 0.0053\\),\\(\\phi_1 = 1.64\\),\\(\\phi_2 = -1.17\\), and\\(\\phi_3 = 0.45\\). Without using theforecast()function, calculate forecasts for the next three years (2018â2020). Now fit the model in R and obtain the forecasts from the same model. How are they different from yours? Why?",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3a610b4e.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/selecting-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "When there are many possible predictors, we need some strategy for selecting the best predictors to use in a regression model. A common approach that isnot recommendedis to plot the forecast variable against a particular predictor and if there is no noticeable relationship, drop that predictor from the model. This is invalid because it is not always possible to see the relationship from a scatterplot, especially when the effects of other predictors have not been accounted for. Another common approach which is also invalid is to do a multiple linear regression on all the predictors and disregard all variables whose\\(p\\)-values are greater than 0.05. To start with, statistical significance does not always indicate predictive value. Even if forecasting is not the goal, this is not a good strategy because the\\(p\\)-values can be misleading when two or more predictors are correlated with each other (see Section7.8). Instead, we will use a measure of predictive accuracy. Five such measures are introduced in this section. They can be shown using theglance()function, here applied to the model for US consumption: We compare these values against the corresponding values from other models. For the CV, AIC, AICc and BIC measures, we want to find the model with the lowest value; for Adjusted\\(R^2\\), we seek the model with the highest value. Computer output for a regression will always give the\\(R^2\\)value, discussed in Section7.2. However, it is not a good measure of the predictive ability of a model. It measures how well the model fits the historical data, but not how well the model will forecast future data. In addition,\\(R^2\\)does not allow for âdegrees of freedomâ. Addinganyvariable tends to increase the value of\\(R^2\\), even if that variable is irrelevant. For these reasons, forecasters should not use\\(R^2\\)to determine whether a model will give good predictions, as it will lead to overfitting",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3caedfd8.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/selecting-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". For these reasons, forecasters should not use\\(R^2\\)to determine whether a model will give good predictions, as it will lead to overfitting. An equivalent idea is to select the model which gives the minimum sum of squared errors (SSE), given by\\[ \\text{SSE} = \\sum_{t=1}^T e_{t}^2. \\] Minimising the SSE is equivalent to maximising\\(R^2\\)and will always choose the model with the most variables, and so is not a valid way of selecting predictors. An alternative which is designed to overcome these problems is the adjusted\\(R^2\\)(also called âR-bar-squaredâ):\\[ \\bar{R}^2 = 1-(1-R^2)\\frac{T-1}{T-k-1}, \\]where\\(T\\)is the number of observations and\\(k\\)is the number of predictors. This is an improvement on\\(R^2\\), as it will no longer increase with each added predictor. Using this measure, the best model will be the one with the largest value of\\(\\bar{R}^2\\). Maximising\\(\\bar{R}^2\\)is equivalent to minimising the standard error\\(\\hat{\\sigma}_e\\)given in Equation(7.3). Maximising\\(\\bar{R}^2\\)works quite well as a method of selecting predictors, although it does tend to err on the side of selecting too many predictors. Time series cross-validation was introduced in Section5.10as a general tool for determining the predictive ability of a model. For regression models, it is also possible to use classical leave-one-out cross-validation to select predictors(Bergmeir et al., 2018). This is faster and makes more efficient use of the data. The procedure uses the following steps: Although this looks like a time-consuming procedure, there are fast methods of calculating CV, so that it takes no longer than fitting one model to the full data set. The equation for computing CV efficiently is given in Section7.9. Under this criterion, the best model is the one with the smallest value of CV",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3caedfd8.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/selecting-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The equation for computing CV efficiently is given in Section7.9. Under this criterion, the best model is the one with the smallest value of CV. A closely-related method is Akaikeâs Information Criterion, which we define as\\[ \\text{AIC} = T\\log\\left(\\frac{\\text{SSE}}{T}\\right) + 2(k+2), \\]where\\(T\\)is the number of observations used for estimation and\\(k\\)is the number of predictors in the model. Different computer packages use slightly different definitions for the AIC, although they should all lead to the same model being selected. The\\(k+2\\)part of the equation occurs because there are\\(k+2\\)parameters in the model: the\\(k\\)coefficients for the predictors, the intercept and the variance of the residuals. The idea here is to penalise the fit of the model (SSE) with the number of parameters that need to be estimated. The model with the minimum value of the AIC is often the best model for forecasting. For large values of\\(T\\), minimising the AIC is equivalent to minimising the CV value. For small values of\\(T\\), the AIC tends to select too many predictors, and so a bias-corrected version of the AIC has been developed,\\[ \\text{AIC}_{\\text{c}} = \\text{AIC} + \\frac{2(k+2)(k+3)}{T-k-3}. \\]As with the AIC, the AICc should be minimised. A related measure is Schwarzâs Bayesian Information Criterion (usually abbreviated to BIC, SBIC or SC):\\[ \\text{BIC} = T\\log\\left(\\frac{\\text{SSE}}{T}\\right) + (k+2)\\log(T). \\]As with the AIC, minimising the BIC is intended to give the best model. The model chosen by the BIC is either the same as that chosen by the AIC, or one with fewer terms. This is because the BIC penalises the number of parameters more heavily than the AIC. For large values of\\(T\\), minimising BIC is similar to leave-\\(v\\)-out cross-validation when\\(v = T[1-1/(\\log(T)-1)]\\). While\\(\\bar{R}^2\\)is widely used, and has been around longer than the other measures, its tendency to select too many predictor variables makes it less suitable for forecasting",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3caedfd8.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/selecting-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". While\\(\\bar{R}^2\\)is widely used, and has been around longer than the other measures, its tendency to select too many predictor variables makes it less suitable for forecasting. Many statisticians like to use the BIC because it has the feature that if there is a true underlying model, the BIC will select that model given enough data. However, in reality, there is rarely, if ever, a true underlying model, and even if there was a true underlying model, selecting that model will not necessarily give the best forecasts (because the parameter estimates may not be accurate). Consequently, we recommend that one of the AICc, AIC, or CV statistics be used, each of which has forecasting as their objective. If the value of\\(T\\)is large enough, they will all lead to the same model. In most of the examples in this book, we use the AICc value to select the forecasting model. In the multiple regression example for forecasting US consumption we considered four predictors. With four predictors, there are\\(2^4=16\\)possible models. Now we can check if all four predictors are actually useful, or whether we can drop one or more of them. All 16 models were fitted and the results are summarised in Table7.1. A ââ¬¤â indicates that the predictor was included in the model. Hence the first row shows the measures of predictive accuracy for a model including all four predictors. The results have been sorted according to the AICc. Therefore the best models are given at the top of the table, and the worst at the bottom of the table. The best model contains all four predictors. However, a closer look at the results reveals some interesting features. There is clear separation between the models in the first four rows and the ones below. This indicates thatIncomeandSavingsare both more important variables thanProductionandUnemployment. Also, the first three rows have almost identical values of CV, AIC and AICc. So we could possibly drop either theProductionvariable, or theUnemploymentvariable, and get similar forecasts",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3caedfd8.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/selecting-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Also, the first three rows have almost identical values of CV, AIC and AICc. So we could possibly drop either theProductionvariable, or theUnemploymentvariable, and get similar forecasts. Note thatProductionandUnemploymentare highly (negatively) correlated, as shown in Figure7.5, so most of the predictive information inProductionis also contained in theUnemploymentvariable. Where possible, all potential regression models should be fitted (as was done in the example above) and the best model should be selected based on one of the measures discussed. This is known as âbest subsetsâ regression or âall possible subsetsâ regression. If there are a large number of predictors, it is not possible to fit all possible models. For example, 40 predictors leads to\\(2^{40} >\\)1 trillion possible models! Consequently, a strategy is required to limit the number of models to be explored. An approach that works quite well isbackwards stepwise regression: If the number of potential predictors is too large, then the backwards stepwise regression will not work andforward stepwise regressioncan be used instead. This procedure starts with a model that includes only the intercept. Predictors are added one at a time, and the one that most improves the measure of predictive accuracy is retained in the model. The procedure is repeated until no further improvement can be achieved. Alternatively for either the backward or forward direction, a starting model can be one that includes a subset of potential predictors. In this case, an extra step needs to be included. For the backwards procedure we should also consider adding a predictor with each step, and for the forward procedure we should also consider dropping a predictor with each step. These are referred to ashybridprocedures. It is important to realise that any stepwise approach is not guaranteed to lead to the best possible model, but it almost always leads to a good model. For further details seeJames et al. (2014)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3caedfd8.json_chunk_5"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/selecting-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". It is important to realise that any stepwise approach is not guaranteed to lead to the best possible model, but it almost always leads to a good model. For further details seeJames et al. (2014). We do not discuss statistical inference of the predictors in this book (e.g., looking at\\(p\\)-values associated with each predictor). If you do wish to look at the statistical significance of the predictors, beware thatanyprocedure involving selecting predictors first will invalidate the assumptions behind the\\(p\\)-values. The procedures we recommend for selecting predictors are helpful when the model is used for forecasting; they are not helpful if you wish to study the effect of any predictor on the forecast variable.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_3caedfd8.json_chunk_6"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-evaluation.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "The differences between the observed\\(y\\)values and the corresponding fitted\\(\\hat{y}\\)values are the training-set errors or âresidualsâ defined as,\\[\\begin{align*} e_t &= y_t - \\hat{y}_t \\\\ &= y_t - \\hat\\beta_{0} - \\hat\\beta_{1} x_{1,t} - \\hat\\beta_{2} x_{2,t} - \\cdots - \\hat\\beta_{k} x_{k,t} \\end{align*}\\]for\\(t=1,\\dots,T\\). Each residual is the unpredictable component of the associated observation. The residuals have some useful properties including the following two:\\[ \\sum_{t=1}^{T}{e_t}=0 \\quad\\text{and}\\quad \\sum_{t=1}^{T}{x_{k,t}e_t}=0\\qquad\\text{for all $k$}. \\]As a result of these properties, it is clear that the average of the residuals is zero, and that the correlation between the residuals and the observations for the predictor variable is also zero. (This is not necessarily true when the intercept is omitted from the model.) After selecting the regression variables and fitting a regression model, it is necessary to plot the residuals to check that the assumptions of the model have been satisfied. There are a series of plots that should be produced in order to check different aspects of the fitted model and the underlying assumptions. We will now discuss each of them in turn. With time series data, it is highly likely that the value of a variable observed in the current time period will be similar to its value in the previous period, or even the period before that, and so on. Therefore when fitting a regression model to time series data, it is common to find autocorrelation in the residuals. In this case, the estimated model violates the assumption of no autocorrelation in the errors, and our forecasts may be inefficient â there is some information left over which should be accounted for in the model in order to obtain better forecasts. The forecasts from a model with autocorrelated errors are still unbiased, and so they are not âwrongâ, but they will usually have larger prediction intervals than they need to. Therefore we should always look at an ACF plot of the residuals",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_4615b9c9.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-evaluation.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Therefore we should always look at an ACF plot of the residuals. It is always a good idea to check whether the residuals are normally distributed. As we explained earlier, this is not essential for forecasting, but it does make the calculation of prediction intervals much easier. Using thegg_tsresiduals()function introduced in Section5.3, we can obtain all the useful residual diagnostics mentioned above. Figure 7.8: Analysing the residuals from a regression model for US quarterly consumption. The time plot shows some changing variation over time, but is otherwise relatively unremarkable. This heteroscedasticity will potentially make the prediction interval coverage inaccurate. The histogram shows that the residuals seem to be slightly skewed, which may also affect the coverage probability of the prediction intervals. The autocorrelation plot shows a significant spike at lag 7, and a significant Ljung-Box test at the 5% level. However, the autocorrelation is not particularly large, and at lag 7 it is unlikely to have any noticeable impact on the forecasts or the prediction intervals. In Chapter10we discuss dynamic regression models used for better capturing information left in the residuals. We would expect the residuals to be randomly scattered without showing any systematic patterns. A simple and quick way to check this is to examine scatterplots of the residuals against each of the predictor variables. If these scatterplots show a pattern, then the relationship may be nonlinear and the model will need to be modified accordingly. See Section7.7for a discussion of nonlinear regression. It is also necessary to plot the residuals against any predictors that arenotin the model. If any of these show a pattern, then the corresponding predictor may need to be added to the model (possibly in a nonlinear form). The residuals from the multiple regression model for forecasting US consumption plotted against each predictor in Figure7.9seem to be randomly scattered. Therefore we are satisfied with these in this case",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_4615b9c9.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-evaluation.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Therefore we are satisfied with these in this case. Figure 7.9: Scatterplots of residuals versus each predictor. A plot of the residuals against the fitted values should also show no pattern. If a pattern is observed, there may be âheteroscedasticityâ in the errors which means that the variance of the residuals may not be constant. If this problem occurs, a transformation of the forecast variable such as a logarithm or square root may be required (see Section3.1). Continuing the previous example, Figure7.10shows the residuals plotted against the fitted values. The random scatter suggests the errors are homoscedastic. Figure 7.10: Scatterplots of residuals versus fitted values. Observations that take extreme values compared to the majority of the data are calledoutliers. Observations that have a large influence on the estimated coefficients of a regression model are calledinfluential observations. Usually, influential observations are also outliers that are extreme in the\\(x\\)direction. There are formal methods for detecting outliers and influential observations that are beyond the scope of this textbook. As we suggested at the beginning of Chapter2, becoming familiar with your data prior to performing any analysis is of vital importance. A scatter plot of\\(y\\)against each\\(x\\)is always a useful starting point in regression analysis, and often helps to identify unusual observations. One source of outliers is incorrect data entry. Simple descriptive statistics of your data can identify minima and maxima that are not sensible. If such an observation is identified, and it has been recorded incorrectly, it should be corrected or removed from the sample immediately. Outliers also occur when some observations are simply different. In this case it may not be wise for these observations to be removed. If an observation has been identified as a likely outlier, it is important to study it and analyse the possible reasons behind it",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_4615b9c9.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-evaluation.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". If an observation has been identified as a likely outlier, it is important to study it and analyse the possible reasons behind it. The decision to remove or retain an observation can be a challenging one (especially when outliers are influential observations). It is wise to report results both with and without the removal of such observations. Figure7.11highlights the effect of a single outlier when regressing US consumption on income (the example introduced in Section7.1). In the left panel the outlier is only extreme in the direction of\\(y\\), as the percentage change in consumption has been incorrectly recorded as -4%. The orange line is the regression line fitted to the data which includes the outlier, compared to the black line which is the line fitted to the data without the outlier. In the right panel the outlier now is also extreme in the direction of\\(x\\)with the 4% decrease in consumption corresponding to a 6% increase in income. In this case the outlier is extremely influential as the orange line now deviates substantially from the black line. Figure 7.11: The effect of outliers and influential observations on regression More often than not, time series data are ânon-stationaryâ; that is, the values of the time series do not fluctuate around a constant mean or with a constant variance. We will deal with time series stationarity in more detail in Chapter9, but here we need to address the effect that non-stationary data can have on regression models. For example, consider the two variables plotted in Figure7.12. These appear to be related simply because they both trend upwards in the same manner. However, air passenger traffic in Australia has nothing to do with rice production in Guinea. Figure 7.12: Trending time series data can appear to be related, as shown in this example where air passengers in Australia are regressed against rice production in Guinea. Regressing non-stationary time series can lead to spurious regressions",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_4615b9c9.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-evaluation.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Regressing non-stationary time series can lead to spurious regressions. The output of regressing Australian air passengers on rice production in Guinea is shown in Figure7.13. High\\(R^2\\)and high residual autocorrelation can be signs of spurious regression. Notice these features in the output below. We discuss the issues surrounding non-stationary data and spurious regressions in more detail in Chapter10. Cases of spurious regression might appear to give reasonable short-term forecasts, but they will generally not continue to work into the future. Figure 7.13: Residuals from a spurious regression.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_4615b9c9.json_chunk_5"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stationarity.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "A stationary time series is one whose statistical properties do not depend on the time at which the series is observed.18Thus, time series with trends, or with seasonality, are not stationary â the trend and seasonality will affect the value of the time series at different times. On the other hand, a white noise series is stationary â it does not matter when you observe it, it should look much the same at any point in time. Some cases can be confusing â a time series with cyclic behaviour (but with no trend or seasonality) is stationary. This is because the cycles are not of a fixed length, so before we observe the series we cannot be sure where the peaks and troughs of the cycles will be. In general, a stationary time series will have no predictable patterns in the long-term. Time plots will show the series to be roughly horizontal (although some cyclic behaviour is possible), with constant variance. Figure 9.1: Which of these series are stationary? (a) Google closing stock price in 2015; (b) Daily change in the Google stock price in 2015; (c) Annual number of strikes in the US; (d) Monthly sales of new one-family houses sold in the US; (e) Annual price of a dozen eggs in the US (constant dollars); (f) Monthly total of pigs slaughtered in Victoria, Australia; (g) Annual total of Canadian Lynx furs traded by the Hudson Bay Company; (h) Quarterly Australian beer production; (i) Monthly Australian gas production. Consider the nine series plotted in Figure9.1. Which of these do you think are stationary? Obvious seasonality rules out series (d), (h) and (i). Trends and changing levels rules out series (a), (c), (e), (f) and (i). Increasing variance also rules out (i). That leaves only (b) and (g) as stationary series. At first glance, the strong cycles in series (g) might appear to make it non-stationary",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_49804c33.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stationarity.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Increasing variance also rules out (i). That leaves only (b) and (g) as stationary series. At first glance, the strong cycles in series (g) might appear to make it non-stationary. But these cycles are aperiodic â they are caused when the lynx population becomes too large for the available feed, so that they stop breeding and the population falls to low numbers, then the regeneration of their food sources allows the population to grow again, and so on. In the long-term, the timing of these cycles is not predictable. Hence the series is stationary. In Figure9.1, note that the Google stock price was non-stationary in panel (a), but the daily changes were stationary in panel (b). This shows one way to make a non-stationary time series stationary â compute the differences between consecutive observations. This is known asdifferencing. Transformations such as logarithms can help to stabilise the variance of a time series. Differencing can help stabilise the mean of a time series by removing changes in the level of a time series, and therefore eliminating (or reducing) trend and seasonality. As well as the time plot of the data, the ACF plot is also useful for identifying non-stationary time series. For a stationary time series, the ACF will drop to zero relatively quickly, while the ACF of non-stationary data decreases slowly. Also, for non-stationary data, the value of\\(r_1\\)is often large and positive. Figure 9.2: The ACF of the Google closing stock price in 2015 (left) and of the daily changes in Google closing stock price in 2015 (right). The ACF of the differenced Google stock price looks just like that of a white noise series. Only one autocorrelation is outside of the 95% limits, and the Ljung-Box\\(Q^*\\)statistic has ap-value of 0.637 (for\\(h=10\\)). This suggests that thedaily changein the Google stock price is essentially a random amount which is uncorrelated with that of previous days",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_49804c33.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stationarity.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". This suggests that thedaily changein the Google stock price is essentially a random amount which is uncorrelated with that of previous days. The differenced series is thechangebetween consecutive observations in the original series, and can be written as\\[ y'_t = y_t - y_{t-1}. \\]The differenced series will have only\\(T-1\\)values, since it is not possible to calculate a difference\\(y_1'\\)for the first observation. When the differenced series is white noise, the model for the original series can be written as\\[ y_t - y_{t-1} = \\varepsilon_t, \\]where\\(\\varepsilon_t\\)denotes white noise. Rearranging this leads to the ârandom walkâ model\\[ y_t = y_{t-1} + \\varepsilon_t. \\]Random walk models are widely used for non-stationary data, particularly financial and economic data. Random walks typically have: The forecasts from a random walk model are equal to the last observation, as future movements are unpredictable, and are equally likely to be up or down. Thus, the random walk model underpins naÃ ̄ve forecasts, first introduced in Section5.2. A closely related model allows the differences to have a non-zero mean. Then\\[ y_t - y_{t-1} = c + \\varepsilon_t\\quad\\text{or}\\quad {y_t = c + y_{t-1} + \\varepsilon_t}\\: . \\]The value of\\(c\\)is the average of the changes between consecutive observations. If\\(c\\)is positive, then the average change is an increase in the value of\\(y_t\\). Thus,\\(y_t\\)will tend to drift upwards. However, if\\(c\\)is negative,\\(y_t\\)will tend to drift downwards. This is the model behind the drift method, also discussed in Section5.2. Occasionally the differenced data will not appear to be stationary and it may be necessary to difference the data a second time to obtain a stationary series:\\[\\begin{align*} y''_{t} &= y'_{t} - y'_{t - 1} \\\\ &= (y_t - y_{t-1}) - (y_{t-1}-y_{t-2})\\\\ &= y_t - 2y_{t-1} +y_{t-2}. \\end{align*}\\]In this case,\\(y_t''\\)will have\\(T-2\\)values. Then, we would model the âchange in the changesâ of the original data",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_49804c33.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stationarity.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". \\end{align*}\\]In this case,\\(y_t''\\)will have\\(T-2\\)values. Then, we would model the âchange in the changesâ of the original data. In practice, it is almost never necessary to go beyond second-order differences. A seasonal difference is the difference between an observation and the previous observation from the same season. So\\[ y'_t = y_t - y_{t-m}, \\]where\\(m=\\)the number of seasons. These are also called âlag-\\(m\\)differencesâ, as we subtract the observation after a lag of\\(m\\)periods. If seasonally differenced data appear to be white noise, then an appropriate model for the original data is\\[ y_t = y_{t-m}+\\varepsilon_t. \\]Forecasts from this model are equal to the last observation from the relevant season. That is, this model gives seasonal naÃ ̄ve forecasts, introduced in Section5.2. The bottom panel in Figure9.3shows the seasonal differences of the logarithm of the monthly scripts for A10 (antidiabetic) drugs sold in Australia. The transformation and differencing have made the series look relatively stationary. Figure 9.3: Logs and seasonal differences of the A10 (antidiabetic) sales data. The logarithms stabilise the variance, while the seasonal differences remove the seasonality and trend. To distinguish seasonal differences from ordinary differences, we sometimes refer to ordinary differences as âfirst differencesâ, meaning differences at lag 1. Sometimes it is necessary to take both a seasonal difference and a first difference to obtain stationary data. Figure9.4plots Australian corticosteroid drug sales ($AUD) (top panel). Here, the data are first transformed using logarithms (second panel), then seasonal differences are calculated (third panel). The data still seem somewhat non-stationary, and so a further lot of first differences are computed (bottom panel). Figure 9.4: Top panel: Corticosteroid drug sales ($AUD). Other panels show the same data after transforming and differencing. There is a degree of subjectivity in selecting which differences to apply",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_49804c33.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stationarity.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Other panels show the same data after transforming and differencing. There is a degree of subjectivity in selecting which differences to apply. The seasonally differenced data in Figure9.3do not show substantially different behaviour from the seasonally differenced data in Figure9.4. In the latter case, we could have decided to stop with the seasonally differenced data, and not done an extra round of differencing. In the former case, we could have decided that the data were not sufficiently stationary and taken an extra round of differencing. Some formal tests for differencing are discussed below, but there are always some choices to be made in the modelling process, and different analysts may make different choices. If\\(y'_t = y_t - y_{t-m}\\)denotes a seasonally differenced series, then the twice-differenced series is\\[\\begin{align*} y''_t &= y'_t - y'_{t-1} \\\\ &= (y_t - y_{t-m}) - (y_{t-1} - y_{t-m-1}) \\\\ &= y_t -y_{t-1} - y_{t-m} + y_{t-m-1}\\: \\end{align*}\\]When both seasonal and first differences are applied, it makes no difference which is done firstâthe result will be the same. However, if the data have a strong seasonal pattern, we recommend that seasonal differencing be done first, because the resulting series will sometimes be stationary and there will be no need for a further first difference. If first differencing is done first, there will still be seasonality present. Beware that applying more differences than required will induce false dynamics or autocorrelations that do not really exist in the time series. Therefore, do as few differences as necessary to obtain a stationary series. It is important that if differencing is used, the differences are interpretable. First differences are the change between one observation and the next. Seasonal differences are the change between one year to the next. Other lags are unlikely to make much interpretable sense and should be avoided. One way to determine more objectively whether differencing is required is to use aunit root test",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_49804c33.json_chunk_5"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stationarity.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Other lags are unlikely to make much interpretable sense and should be avoided. One way to determine more objectively whether differencing is required is to use aunit root test. These are statistical hypothesis tests of stationarity that are designed for determining whether differencing is required. A number of unit root tests are available, which are based on different assumptions and may lead to conflicting answers. In our analysis, we use theKwiatkowski-Phillips-Schmidt-Shin (KPSS) test(Kwiatkowski et al., 1992). In this test, the null hypothesis is that the data are stationary, and we look for evidence that the null hypothesis is false. Consequently, small p-values (e.g., less than 0.05) suggest that differencing is required. The test can be computed using theunitroot_kpss()function. For example, let us apply it to the Google stock price data. The KPSS test p-value is reported as a number between 0.01 and 0.1. If the actual p-value is less than 0.01, it is reported as 0.01; and if the actual p-value is greater than 0.1, it is reported as 0.1. In this case, the p-value is shown as 0.01 (and therefore it may be smaller than that), indicating that the null hypothesis is rejected. That is, the data are not stationary. We can difference the data, and apply the test again. This time, the p-value is reported as 0.1 (and so it could be larger than that). We can conclude that the differenced data appear stationary. This process of using a sequence of KPSS tests to determine the appropriate number of first differences is carried out using theunitroot_ndiffs()feature. As we saw from the KPSS tests above, one difference is required to make thegoogle_2015data stationary. A similar feature for determining whether seasonal differencing is required isunitroot_nsdiffs(), which uses the measure of seasonal strength introduced in Section4.3to determine the appropriate number of seasonal differences required. No seasonal differences are suggested if\\(F_S<0.64\\), otherwise one seasonal difference is suggested",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_49804c33.json_chunk_6"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stationarity.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". No seasonal differences are suggested if\\(F_S<0.64\\), otherwise one seasonal difference is suggested. We can applyunitroot_nsdiffs()to the monthly total Australian retail turnover. Becauseunitroot_nsdiffs()returns 1 (indicating one seasonal difference is required), we apply theunitroot_ndiffs()function to the seasonally differenced data. These functions suggest we should do both a seasonal difference and a first difference. More precisely, if\\(\\{y_t\\}\\)is astationarytime series, then for all\\(s\\), the distribution of\\((y_t,\\dots,y_{t+s})\\)does not depend on\\(t\\).â©ï ̧",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_49804c33.json_chunk_7"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/MA.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Rather than using past values of the forecast variable in a regression, a moving average model uses past forecast errors in a regression-like model,\\[ y_{t} = c + \\varepsilon_t + \\theta_{1}\\varepsilon_{t-1} + \\theta_{2}\\varepsilon_{t-2} + \\dots + \\theta_{q}\\varepsilon_{t-q}, \\]where\\(\\varepsilon_t\\)is white noise. We refer to this as anMA(\\(q\\)) model, a moving average model of order\\(q\\). Of course, we do notobservethe values of\\(\\varepsilon_t\\), so it is not really a regression in the usual sense. Notice that each value of\\(y_t\\)can be thought of as a weighted moving average of the past few forecast errors (although the coefficients will not normally sum to one). However, moving averagemodelsshould not be confused with the moving averagesmoothingwe discussed in Chapter3. A moving average model is used for forecasting future values, while moving average smoothing is used for estimating the trend-cycle of past values. Figure 9.6: Two examples of data from moving average models with different parameters. Left: MA(1) with\\(y_t = 20 + \\varepsilon_t + 0.8\\varepsilon_{t-1}\\). Right: MA(2) with\\(y_t = \\varepsilon_\\varepsilon_{t-1}+0.8\\varepsilon_{t-2}\\). In both cases,\\(\\varepsilon_t\\)is normally distributed white noise with mean zero and variance one. Figure9.6shows some data from an MA(1) model and an MA(2) model. Changing the parameters\\(\\theta_1,\\dots,\\theta_q\\)results in different time series patterns. As with autoregressive models, the variance of the error term\\(\\varepsilon_t\\)will only change the scale of the series, not the patterns. It is possible to write any stationary AR(\\(p\\)) model as an MA(\\(\\infty\\)) model",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_4de3a7a4.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/MA.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". It is possible to write any stationary AR(\\(p\\)) model as an MA(\\(\\infty\\)) model. For example, using repeated substitution, we can demonstrate this for an AR(1) model:\\[\\begin{align*} y_t &= \\phi_1y_{t-1} + \\varepsilon_t\\\\ &= \\phi_1(\\phi_1y_{t-2} + \\varepsilon_{t-1}) + \\varepsilon_t\\\\ &= \\phi_1^2y_{t-2} + \\phi_1 \\varepsilon_{t-1} + \\varepsilon_t\\\\ &= \\phi_1^3y_{t-3} + \\phi_1^2\\varepsilon_{t-2} + \\phi_1 \\varepsilon_{t-1} + \\varepsilon_t\\\\ &\\text{etc.} \\end{align*}\\]Provided\\(-1 < \\phi_1 < 1\\), the value of\\(\\phi_1^k\\)will get smaller as\\(k\\)gets larger. So eventually we obtain\\[ y_t = \\varepsilon_t + \\phi_1 \\varepsilon_{t-1} + \\phi_1^2 \\varepsilon_{t-2} + \\phi_1^3 \\varepsilon_{t-3} + \\cdots, \\]an MA(\\(\\infty\\)) process. The reverse result holds if we impose some constraints on the MA parameters. Then the MA model is calledinvertible. That is, we can write any invertible MA(\\(q\\)) process as an AR(\\(\\infty\\)) process. Invertible models are not simply introduced to enable us to convert from MA models to AR models. They also have some desirable mathematical properties. For example, consider the MA(1) process,\\(y_{t} = \\varepsilon_t + \\theta_{1}\\varepsilon_{t-1}\\). In its AR(\\(\\infty\\)) representation, the most recent error can be written as a linear function of current and past observations:\\[\\varepsilon_t = \\sum_{j=0}^\\infty (-\\theta_1)^j y_{t-j}.\\]When\\(|\\theta_1| > 1\\), the weights increase as lags increase, so the more distant the observations the greater their influence on the current error. When\\(|\\theta_1|=1\\), the weights are constant in size, and the distant observations have the same influence as the recent observations. As neither of these situations make much sense, we require\\(|\\theta_1|<1\\), so the most recent observations have higher weight than observations from the more distant past. Thus, the process is invertible when\\(|\\theta_1|<1\\). The invertibility constraints for other models are similar to the stationarity constraints. More complicated conditions hold for\\(q\\ge3\\)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_4de3a7a4.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/MA.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Thus, the process is invertible when\\(|\\theta_1|<1\\). The invertibility constraints for other models are similar to the stationarity constraints. More complicated conditions hold for\\(q\\ge3\\). Again, thefablepackage will take care of these constraints when estimating the models.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_4de3a7a4.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-intro.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "In the simplest case, the regression model allows for a linear relationship between the forecast variable\\(y\\)and a single predictor variable\\(x\\):\\[ y_t = \\beta_0 + \\beta_1 x_t + \\varepsilon_t. \\]An artificial example of data from such a model is shown in Figure7.1. The coefficients\\(\\beta_0\\)and\\(\\beta_1\\)denote the intercept and the slope of the line respectively. The intercept\\(\\beta_0\\)represents the predicted value of\\(y\\)when\\(x=0\\). The slope\\(\\beta_1\\)represents the average predicted change in\\(y\\)resulting from a one unit increase in\\(x\\). Figure 7.1: An example of data from a simple linear regression model. Notice that the observations do not lie on the straight line but are scattered around it. We can think of each observation\\(y_t\\)as consisting of the systematic or explained part of the model,\\(\\beta_0+\\beta_1x_t\\), and the random âerrorâ,\\(\\varepsilon_t\\). The âerrorâ term does not imply a mistake, but a deviation from the underlying straight line model. It captures anything that may affect\\(y_t\\)other than\\(x_t\\). Figure7.2shows time series of quarterly percentage changes (growth rates) of real personal consumption expenditure,\\(y\\), and real personal disposable income,\\(x\\), for the US from 1970 Q1 to 2019 Q2. Figure 7.2: Percentage changes in personal consumption expenditure and personal income for the US. A scatter plot of consumption changes against income changes is shown in Figure7.3along with the estimated regression line \\[ \\hat{y}_t=0.54 + 0.27x_t. \\](We put a âhatâ above\\(y\\)to indicate that this is the value of\\(y\\)predicted by the model.) Figure 7.3: Scatterplot of quarterly changes in consumption expenditure versus quarterly changes in personal income and the fitted regression line. The equation is estimated using theTSLM()function: We will discuss howTSLM()computes the coefficients in Section7.2. The fitted line has a positive slope, reflecting the positive relationship between income and consumption",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_509b2863.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-intro.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The fitted line has a positive slope, reflecting the positive relationship between income and consumption. The slope coefficient shows that a one unit increase in\\(x\\)(a 1 percentage point increase in personal disposable income) results on average in 0.27 units increase in\\(y\\)(an average increase of 0.27 percentage points in personal consumption expenditure). Alternatively the estimated equation shows that a value of 1 for\\(x\\)(the percentage increase in personal disposable income) will result in a forecast value of\\(0.54 + 0.27 \\times 1 = 0.82\\)for\\(y\\)(the percentage increase in personal consumption expenditure). The interpretation of the intercept requires that a value of\\(x=0\\)makes sense. In this case when\\(x=0\\)(i.e., when there is no change in personal disposable income since the last quarter) the predicted value of\\(y\\)is 0.54 (i.e., an average increase in personal consumption expenditure of 0.54%). Even when\\(x=0\\)does not make sense, the intercept is an important part of the model. Without it, the slope coefficient can be distorted unnecessarily. The intercept should always be included unless the requirement is to force the regression line âthrough the originâ. In what follows we assume that an intercept is always included in the model. When there are two or more predictor variables, the model is called amultiple regression model. The general form of a multiple regression model is\\[\\begin{equation} y_t = \\beta_{0} + \\beta_{1} x_{1,t} + \\beta_{2} x_{2,t} + \\cdots + \\beta_{k} x_{k,t} + \\varepsilon_t, \\tag{7.1} \\end{equation}\\]where\\(y\\)is the variable to be forecast and\\(x_{1},\\dots,x_{k}\\)are the\\(k\\)predictor variables. Each of the predictor variables must be numerical. The coefficients\\(\\beta_{1},\\dots,\\beta_{k}\\)measure the effect of each predictor after taking into account the effects of all the other predictors in the model. Thus, the coefficients measure themarginal effectsof the predictor variables",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_509b2863.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-intro.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Thus, the coefficients measure themarginal effectsof the predictor variables. Figure7.4shows additional predictors that may be useful for forecasting US consumption expenditure. These are quarterly percentage changes in industrial production and personal savings, and quarterly changes in the unemployment rate (as this is already a percentage). Building a multiple linear regression model can potentially generate more accurate forecasts as we expect consumption expenditure to not only depend on personal income but on other predictors as well. Figure 7.4: Quarterly percentage changes in industrial production and personal savings and quarterly changes in the unemployment rate for the US over the period 1970Q1-2019Q2. Figure7.5is a scatterplot matrix of five variables. The first column shows the relationships between the forecast variable (consumption) and each of the predictors. The scatterplots show positive relationships with income and industrial production, and negative relationships with savings and unemployment. The strength of these relationships are shown by the correlation coefficients across the first row. The remaining scatterplots and correlation coefficients show the relationships between the predictors. Figure 7.5: A scatterplot matrix of US consumption expenditure and the four predictors. When we use a linear regression model, we are implicitly making some assumptions about the variables in Equation(7.1). First, we assume that the model is a reasonable approximation to reality; that is, the relationship between the forecast variable and the predictor variables satisfies this linear equation. Second, we make the following assumptions about the errors\\((\\varepsilon_{1},\\dots,\\varepsilon_{T})\\): It is also useful to have the errors being normally distributed with a constant variance\\(\\sigma^2\\)in order to easily produce prediction intervals. Another important assumption in the linear regression model is that each predictor\\(x\\)is not a random variable",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_509b2863.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-intro.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Another important assumption in the linear regression model is that each predictor\\(x\\)is not a random variable. If we were performing a controlled experiment in a laboratory, we could control the values of each\\(x\\)(so they would not be random) and observe the resulting values of\\(y\\). With observational data (including most data in business and economics), it is not possible to control the value of\\(x\\), we simply observe it. Hence we make this an assumption.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_509b2863.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-estimation.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Once the model order has been identified (i.e., the values of\\(p\\),\\(d\\)and\\(q\\)), we need to estimate the parameters\\(c\\),\\(\\phi_1,\\dots,\\phi_p\\),\\(\\theta_1,\\dots,\\theta_q\\). Whenfableestimates the ARIMA model, it usesmaximum likelihood estimation(MLE). This technique finds the values of the parameters which maximise the probability of obtaining the data that we have observed. For ARIMA models, MLE is similar to theleast squaresestimates that would be obtained by minimising\\[ \\sum_{t=1}^T\\varepsilon_t^2. \\](For the regression models considered in Chapter7, MLE gives exactly the same parameter estimates as least squares estimation.) Note that ARIMA models are much more complicated to estimate than regression models, and different software will give slightly different answers as they use different methods of estimation, and different optimisation algorithms. In practice, thefablepackage will report the value of thelog likelihoodof the data; that is, the logarithm of the probability of the observed data coming from the estimated model. For given values of\\(p\\),\\(d\\)and\\(q\\),ARIMA()will try to maximise the log likelihood when finding parameter estimates. Akaikeâs Information Criterion (AIC), which was useful in selecting predictors for regression (see Section7.5), is also useful for determining the order of an ARIMA model. It can be written as\\[ \\text{AIC} = -2 \\log(L) + 2(p+q+k+1), \\]where\\(L\\)is the likelihood of the data,\\(k=1\\)if\\(c\\ne0\\)and\\(k=0\\)if\\(c=0\\). Note that the last term in parentheses is the number of parameters in the model (including\\(\\sigma^2\\), the variance of the residuals). For ARIMA models, the corrected AIC can be written as\\[ \\text{AICc} = \\text{AIC} + \\frac{2(p+q+k+1)(p+q+k+2)}{T-p-q-k-2}, \\]and the Bayesian Information Criterion can be written as\\[ \\text{BIC} = \\text{AIC} + [\\log(T)-2](p+q+k+1). \\]Good models are obtained by minimising the AIC, AICc or BIC. Our preference is to use the AICc",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_56fadff1.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-estimation.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". \\]Good models are obtained by minimising the AIC, AICc or BIC. Our preference is to use the AICc. It is important to note that these information criteria tend not to be good guides to selecting the appropriate order of differencing (\\(d\\)) of a model, but only for selecting the values of\\(p\\)and\\(q\\). This is because the differencing changes the data on which the likelihood is computed, making the AIC values between models with different orders of differencing not comparable. So we need to use some other approach to choose\\(d\\), and then we can use the AICc to select\\(p\\)and\\(q\\).",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_56fadff1.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-matrices.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Warning: this is a more advanced, optional section and assumes knowledge of matrix algebra. Recall that multiple regression model can be written as\\[ y_{t} = \\beta_{0} + \\beta_{1} x_{1,t} + \\beta_{2} x_{2,t} + \\cdots + \\beta_{k} x_{k,t} + \\varepsilon_{t} \\]where\\(\\varepsilon_{t}\\)has mean zero and variance\\(\\sigma^2\\). This expresses the relationship between a single value of the forecast variable and the predictors. It can be convenient to write this in matrix form where all the values of the forecast variable are given in a single equation. Let\\(\\bm{y} = (y_{1},\\dots,y_{T})'\\),\\(\\bm{\\varepsilon} = (\\varepsilon_{1},\\dots,\\varepsilon_{T})'\\),\\(\\bm{\\beta} = (\\beta_{0},\\dots,\\beta_{k})'\\)and\\[ \\bm{X} = \\left[ \\begin{matrix} 1 & x_{1,1} & x_{2,1} & \\dots & x_{k,1}\\\\ 1 & x_{1,2} & x_{2,2} & \\dots & x_{k,2}\\\\ \\vdots& \\vdots& \\vdots&& \\vdots\\\\ 1 & x_{1,T}& x_{2,T}& \\dots& x_{k,T} \\end{matrix}\\right]. \\]Then\\[ \\bm{y} = \\bm{X}\\bm{\\beta} + \\bm{\\varepsilon} \\]where\\(\\bm{\\varepsilon}\\)has mean\\(\\bm{0}\\)and variance\\(\\sigma^2\\bm{I}\\). Note that the\\(\\bm{X}\\)matrix has\\(T\\)rows reflecting the number of observations and\\(k+1\\)columns reflecting the intercept which is represented by the column of ones plus the number of predictors. Least squares estimation is performed by minimising the expression\\(\\bm{\\varepsilon}'\\bm{\\varepsilon} = (\\bm{y} - \\bm{X}\\bm{\\beta})'(\\bm{y} - \\bm{X}\\bm{\\beta})\\). It can be shown that this is minimised when\\(\\bm{\\beta}\\)takes the value\\[ \\hat{\\bm{\\beta}} = (\\bm{X}'\\bm{X})^{-1}\\bm{X}'\\bm{y}. \\]This is sometimes known as the ânormal equationâ. The estimated coefficients require the inversion of the matrix\\(\\bm{X}'\\bm{X}\\). If\\(\\bm{X}\\)is not of full column rank then matrix\\(\\bm{X}'\\bm{X}\\)is singular and the model cannot be estimated. This will occur, for example, if you fall for the âdummy variable trapâ, i.e., having the same number of dummy variables as there are categories of a categorical predictor, as discussed in Section7.4",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_58870a5a.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-matrices.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The residual variance is estimated using\\[ \\hat{\\sigma}_e^2 = \\frac{1}{T-k-1}(\\bm{y} - \\bm{X}\\hat{\\bm{\\beta}})' (\\bm{y} - \\bm{X}\\hat{\\bm{\\beta}}). \\] The normal equation shows that the fitted values can be calculated using\\[ \\bm{\\hat{y}} = \\bm{X}\\hat{\\bm{\\beta}} = \\bm{X}(\\bm{X}'\\bm{X})^{-1}\\bm{X}'\\bm{y} = \\bm{H}\\bm{y}, \\]where\\(\\bm{H} = \\bm{X}(\\bm{X}'\\bm{X})^{-1}\\bm{X}'\\)is known as the âhat-matrixâ because it is used to compute\\(\\bm{\\hat{y}}\\)(ây-hatâ). If the diagonal values of\\(\\bm{H}\\)are denoted by\\(h_{1},\\dots,h_{T}\\), then the cross-validation statistic can be computed using\\[ \\text{CV} = \\frac{1}{T}\\sum_{t=1}^T [e_{t}/(1-h_{t})]^2, \\]where\\(e_{t}\\)is the residual obtained from fitting the model to all\\(T\\)observations. Thus, it is not necessary to actually fit\\(T\\)separate models when computing the CV statistic. Let\\(\\bm{x}^*\\)be a row vector containing the values of the predictors (in the same format as\\(\\bm{X}\\)) for which we want to generate a forecast. Then the forecast is given by\\[ \\hat{y} = \\bm{x}^*\\hat{\\bm{\\beta}}=\\bm{x}^*(\\bm{X}'\\bm{X})^{-1}\\bm{X}'\\bm{y} \\]and the estimated forecast variance is given by\\[ \\hat\\sigma_e^2 \\left[1 + \\bm{x}^* (\\bm{X}'\\bm{X})^{-1} (\\bm{x}^*)'\\right]. \\]A 95% prediction interval can be calculated (assuming normally distributed errors) as\\[ \\hat{y} \\pm 1.96 \\hat{\\sigma}_e \\sqrt{1 + \\bm{x}^* (\\bm{X}'\\bm{X})^{-1} (\\bm{x}^*)'}. \\]This takes into account the uncertainty due to the error term\\(\\varepsilon\\)and the uncertainty in the coefficient estimates. However, it ignores any errors in\\(\\bm{x}^*\\). Thus, if the future values of the predictors are uncertain, then the prediction interval calculated using this expression will be too narrow.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_58870a5a.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stl.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "STL is a versatile and robust method for decomposing time series. STL is an acronym for âSeasonal and Trend decomposition using Loessâ, while loess is a method for estimating nonlinear relationships. The STL method was developed byR. B. Cleveland et al. (1990), and later extended to handle multiple seasonal patterns byBandara et al. (2022). STL has several advantages over classical decomposition, and the SEATS and X-11 methods: On the other hand, STL has some disadvantages. In particular, it does not handle trading day or calendar variation automatically, and it only provides facilities for additive decompositions. A multiplicative decomposition can be obtained by first taking logs of the data, then back-transforming the components. Decompositions that are between additive and multiplicative can be obtained using a Box-Cox transformation of the data with\\(0<\\lambda<1\\). A value of\\(\\lambda=0\\)gives a multiplicative decomposition while\\(\\lambda=1\\)gives an additive decomposition. The best way to begin learning how to use STL is to see some examples and experiment with the settings. Figure3.7showed an example of an STL decomposition applied to the total US retail employment series. Figure3.18shows an alternative STL decomposition where the trend-cycle is more flexible, the seasonal pattern is fixed, and the robust option has been used. Figure 3.18: Total US retail employment (top) and its three additive components obtained from a robust STL decomposition with flexible trend-cycle and fixed seasonality. The two main parameters to be chosen when using STL are the trend-cycle windowtrend(window = ?)and the seasonal windowseason(window = ?). These control how rapidly the trend-cycle and seasonal components can change. Smaller values allow for more rapid changes",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_58cdf914.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/stl.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". These control how rapidly the trend-cycle and seasonal components can change. Smaller values allow for more rapid changes. Both trend and seasonal windows should be odd numbers; trend window is the number of consecutive observations to be used when estimating the trend-cycle; season window is the number of consecutive years to be used in estimating each value in the seasonal component. Setting the seasonal window to be infinite is equivalent to forcing the seasonal component to be periodicseason(window='periodic')(i.e., identical across years). This was the case in Figure3.18. By default, theSTL()function provides a convenient automated STL decomposition using a seasonal window ofseason(window=11)when there is a single seasonal period, and the trend window chosen automatically from the seasonal period. The default setting for monthly data istrend(window=21). For multiple seasonal periods, the default seasonal windows are 11, 15, 19, etc., with larger windows corresponding to larger seasonal periods. This usually gives a good balance between overfitting the seasonality and allowing it to slowly change over time. But, as with any automated procedure, the default settings will need adjusting for some time series. In the example shown in Figure3.7, the default trend window setting produces a trend-cycle component that is too rigid. As a result, signal from the 2008 global financial crisis has leaked into the remainder component, as can be seen in the bottom panel of Figure3.7. Selecting a shorter trend window as in Figure3.18improves this.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_58cdf914.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "ARIMA models provide another approach to time series forecasting. Exponential smoothing and ARIMA models are the two most widely used approaches to time series forecasting, and provide complementary approaches to the problem. While exponential smoothing models are based on a description of the trend and seasonality in the data, ARIMA models aim to describe the autocorrelations in the data. Before we introduce ARIMA models, we must first discuss the concept of stationarity and the technique of differencing time series.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_5d6a7529.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "So far, we have restricted our attention to non-seasonal data and non-seasonal ARIMA models. However, ARIMA models are also capable of modelling a wide range of seasonal data. A seasonal ARIMA model is formed by including additional seasonal terms in the ARIMA models we have seen so far. It is written as follows: where\\(m =\\)the seasonal period (e.g., number of observations per year). We use uppercase notation for the seasonal parts of the model, and lowercase notation for the non-seasonal parts of the model. The seasonal part of the model consists of terms that are similar to the non-seasonal components of the model, but involve backshifts of the seasonal period. For example, an ARIMA(1,1,1)(1,1,1)\\(_{4}\\)model (without a constant) is for quarterly data (\\(m=4\\)), and can be written as\\[ (1 - \\phi_{1}B)~(1 - \\Phi_{1}B^{4}) (1 - B) (1 - B^{4})y_{t} = (1 + \\theta_{1}B)~ (1 + \\Theta_{1}B^{4})\\varepsilon_{t}. \\] The additional seasonal terms are simply multiplied by the non-seasonal terms. The seasonal part of an AR or MA model will be seen in the seasonal lags of the PACF and ACF. For example, an ARIMA(0,0,0)(0,0,1)\\(_{12}\\)model will show: Similarly, an ARIMA(0,0,0)(1,0,0)\\(_{12}\\)model will show: In considering the appropriate seasonal orders for a seasonal ARIMA model, restrict attention to the seasonal lags. The modelling procedure is almost the same as for non-seasonal data, except that we need to select seasonal AR and MA terms as well as the non-seasonal components of the model. The process is best illustrated via examples. We will describe seasonal ARIMA modelling using monthly US employment data for leisure and hospitality jobs from January 2001 to September 2019, shown in Figure9.18. Figure 9.18: Monthly US leisure and hospitality employment, 2001-2019. The data are clearly non-stationary, with strong seasonality and a nonlinear trend, so we will first take a seasonal difference. The seasonally differenced data are shown in Figure9.19",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_63d6784a.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The data are clearly non-stationary, with strong seasonality and a nonlinear trend, so we will first take a seasonal difference. The seasonally differenced data are shown in Figure9.19. Figure 9.19: Seasonally differenced Monthly US leisure and hospitality employment. These are also clearly non-stationary, so we take a further first difference in Figure9.20. Figure 9.20: Double differenced Monthly US leisure and hospitality employment. Our aim now is to find an appropriate ARIMA model based on the ACF and PACF shown in Figure9.20. The significant spike at lag 2 in the ACF suggests a non-seasonal MA(2) component. The significant spike at lag 12 in the ACF suggests a seasonal MA(1) component. Consequently, we begin with an ARIMA(0,1,2)(0,1,1)\\(_{12}\\)model, indicating a first difference, a seasonal difference, and non-seasonal MA(2) and seasonal MA(1) component. If we had started with the PACF, we may have selected an ARIMA(2,1,0)(0,1,1)\\(_{12}\\)model â using the PACF to select the non-seasonal part of the model and the ACF to select the seasonal part of the model. We will also include an automatically selected model. By settingstepwise=FALSEandapproximation=FALSE, we are making R work extra hard to find a good model. This takes much longer, but with only one series to model, the extra time taken is not a problem. TheARIMA()function usesunitroot_nsdiffs()to determine\\(D\\)(the number of seasonal differences to use), andunitroot_ndiffs()to determine\\(d\\)(the number of ordinary differences to use), when these are not specified. The selection of the other model parameters (\\(p,q,P\\)and\\(Q\\)) are all determined by minimizing the AICc, as with non-seasonal ARIMA models. The three fitted models have similar AICc values, with the automatically selected model being a little better. Our second âguessâ of ARIMA(2,1,0)(0,1,1)\\(_{12}\\)turned out to be very close to the automatically selected model of ARIMA(2,1,0)(1,1,1)\\(_{12}\\). The residuals for the best model are shown in Figure9.21",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_63d6784a.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The residuals for the best model are shown in Figure9.21. Figure 9.21: Residuals from the fitted ARIMA(2,1,0)(1,1,1)\\(_{12}\\)model. One small but significant spike (at lag 11) out of 36 is still consistent with white noise. To be sure, we use a Ljung-Box test, being careful to set the degrees of freedom to match the number of parameters in the model. The large p-value confims that the residuals are similar to white noise. Thus, we now have a seasonal ARIMA model that passes the required checks and is ready for forecasting. Forecasts from the model for the next three years are shown in Figure9.22. The forecasts have captured the seasonal pattern very well, and the increasing trend extends the recent pattern. The trend in the forecasts is induced by the double differencing. Figure 9.22: Forecasts of monthly US leisure and hospitality employment using the ARIMA(2,1,0)(1,1,1)\\(_{12}\\)model. 80% and 95% prediction intervals are shown. For our second example, we will try to forecast monthly corticosteroid drug sales in Australia. These are known as H02 drugs under the Anatomical Therapeutic Chemical classification scheme. Figure 9.23: Corticosteroid drug sales in Australia (in millions of scripts per month). Logged data shown in bottom panel. Data from July 1991 to June 2008 are plotted in Figure9.23. There is a small increase in the variance with the level, so we take logarithms to stabilise the variance. The data are strongly seasonal and obviously non-stationary, so seasonal differencing will be used. The seasonally differenced data are shown in Figure9.24. It is not clear at this point whether we should do another difference or not. We decide not to, but the choice is not obvious. The last few observations appear to be different (more variable) from the earlier data. This may be due to the fact that data are sometimes revised when earlier sales are reported late. Figure 9.24: Seasonally differenced corticosteroid drug sales in Australia (in millions of scripts per month)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_63d6784a.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Figure 9.24: Seasonally differenced corticosteroid drug sales in Australia (in millions of scripts per month). In the plots of the seasonally differenced data, there are spikes in the PACF at lags 12 and 24, but nothing at seasonal lags in the ACF. This may be suggestive of a seasonal AR(2) term. In the non-seasonal lags, there are three significant spikes in the PACF, suggesting a possible AR(3) term. The pattern in the ACF is not indicative of any simple model. Consequently, this initial analysis suggests that a possible model for these data is an ARIMA(3,0,0)(2,1,0)\\(_{12}\\). We fit this model, along with some variations on it, and compute the AICc values shown in Table9.2. Of these models, the best is the ARIMA(3,0,1)(0,1,2)\\(_{12}\\)model (i.e., it has the smallest AICc value). The innovation residuals from this model are shown in Figure9.25. Figure 9.25: Innovation residuals from the ARIMA(3,0,1)(0,1,2)\\(_{12}\\)model applied to the H02 monthly script sales data. There are a few significant spikes in the ACF, and the model fails the Ljung-Box test. The model can still be used for forecasting, but the prediction intervals may not be accurate due to the correlated residuals. Next we will try using the automatic ARIMA algorithm. RunningARIMA()with all arguments left at their default values led to an ARIMA(2,1,0)(0,1,1)\\(_{12}\\)model. RunningARIMA()withstepwise=FALSEandapproximation=FALSEgives an ARIMA(2,1,3)(0,1,1)\\(_{12}\\)model. However, both models still fail the Ljung-Box test for 36 lags. Sometimes it is just not possible to find a model that passes all of the tests. We will compare some of the models fitted so far using a test set consisting of the last two years of data. Thus, we fit the models using data from July 1991 to June 2006, and forecast the script sales for July 2006 â June 2008. The results are summarised in Table9.3. The models chosen manually are close to the best model over this test set based on the RMSE values, while those models chosen automatically withARIMA()are not far behind",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_63d6784a.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The models chosen manually are close to the best model over this test set based on the RMSE values, while those models chosen automatically withARIMA()are not far behind. When models are compared using AICc values, it is important that all models have the same orders of differencing. However, when comparing models using a test set, it does not matter how the forecasts were produced â the comparisons are always valid. Consequently, in the table above, we can include some models with only seasonal differencing and some models with both first and seasonal differencing, while in the earlier table containing AICc values, we only compared models with seasonal differencing but no first differencing. None of the models considered here pass all of the residual tests. In practice, we would normally use the best model we could find, even if it did not pass all of the tests. Forecasts from the ARIMA(3,0,1)(0,1,2)\\(_{12}\\)model (which has the second lowest RMSE value on the test set, and the best AICc value amongst models with only seasonal differencing) are shown in Figure9.26. Figure 9.26: Forecasts from the ARIMA(3,0,1)(0,1,2)\\(_{12}\\)model applied to the H02 monthly script sales data.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_63d6784a.json_chunk_5"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/forecasting-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Recall that predictions of\\(y\\)can be obtained using\\[ \\hat{y_t} = \\hat\\beta_{0} + \\hat\\beta_{1} x_{1,t} + \\hat\\beta_{2} x_{2,t} + \\cdots + \\hat\\beta_{k} x_{k,t}, \\]which comprises the estimated coefficients and ignores the error in the regression equation. Plugging in the values of the predictor variables\\(x_{1,t},\\dots,x_{k,t}\\)for\\(t=1,\\dots,T\\)returns the fitted (training set) values of\\(y\\). What we are interested in here, however, is forecastingfuturevalues of\\(y\\). When using regression models for time series data, we need to distinguish between the different types of forecasts that can be produced, depending on what is assumed to be known when the forecasts are computed. Ex-ante forecastsare those that are made using only the information that is available in advance. For example, ex-ante forecasts for the percentage change in US consumption for quarters following the end of the sample, should only use information that was availableup to and including2019 Q2. These are genuine forecasts, made in advance using whatever information is available at the time. Therefore in order to generate ex-ante forecasts, the model requires forecasts of the predictors. To obtain these we can use one of the simple methods introduced in Section5.2or more sophisticated pure time series approaches that follow in Chapters8and9. Alternatively, forecasts from some other source, such as a government agency, may be available and can be used. Ex-post forecastsare those that are made using later information on the predictors. For example, ex-post forecasts of consumption may use the actual observations of the predictors, once these have been observed. These are not genuine forecasts, but are useful for studying the behaviour of forecasting models. The model from which ex-post forecasts are produced should not be estimated using data from the forecast period",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_8181dc28.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/forecasting-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The model from which ex-post forecasts are produced should not be estimated using data from the forecast period. That is, ex-post forecasts can assume knowledge of the predictor variables (the\\(x\\)variables), but should not assume knowledge of the data that are to be forecast (the\\(y\\)variable). A comparative evaluation of ex-ante forecasts and ex-post forecasts can help to separate out the sources of forecast uncertainty. This will show whether forecast errors have arisen due to poor forecasts of the predictor or due to a poor forecasting model. Normally, we cannot use actual future values of the predictor variables when producing ex-ante forecasts because their values will not be known in advance. However, the special predictors introduced in Section7.4are all known in advance, as they are based on calendar variables (e.g., seasonal dummy variables or public holiday indicators) or deterministic functions of time (e.g.Â time trend). In such cases, there is no difference between ex-ante and ex-post forecasts. Figure 7.17: Forecasts from the regression model for beer production. The dark shaded region shows 80% prediction intervals and the light shaded region shows 95% prediction intervals. In this setting, the forecaster assumes possible scenarios for the predictor variables that are of interest. For example, a US policy maker may be interested in comparing the predicted change in consumption when there is a constant growth of 1% and 0.5% respectively for income and savings with no change in the employment rate, versus a respective decline of 1% and 0.5%, for each of the four quarters following the end of the sample. The resulting forecasts are calculated below and shown in Figure7.18. We should note that prediction intervals for scenario based forecasts do not include the uncertainty associated with the future values of the predictor variables. They assume that the values of the predictors are known in advance",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_8181dc28.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/forecasting-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". They assume that the values of the predictors are known in advance. Figure 7.18: Forecasting percentage changes in personal consumption expenditure for the US under scenario based forecasting. The great advantage of regression models is that they can be used to capture important relationships between the forecast variable of interest and the predictor variables. However, for ex ante forecasts, these models require future values of each predictor, which can be challenging. If forecasting each predictor is too difficult, we may use scenario-based forecasting instead, where we assume specific future values for all predictors. An alternative formulation is to use as predictors their lagged values. Assuming that we are interested in generating a\\(h\\)-step ahead forecast we write\\[ y_{t+h}=\\beta_0+\\beta_1x_{1,t}+\\dots+\\beta_kx_{k,t}+\\varepsilon_{t+h} \\]for\\(h=1,2\\dots\\). The predictor set is formed by values of the\\(x\\)s that are observed\\(h\\)time periods prior to observing\\(y\\). Therefore when the estimated model is projected into the future, i.e., beyond the end of the sample\\(T\\), all predictor values are available. Including lagged values of the predictors does not only make the model operational for easily generating forecasts, it also makes it intuitively appealing. For example, the effect of a policy change with the aim of increasing production may not have an instantaneous effect on consumption expenditure. It is most likely that this will happen with a lagging effect. We touched upon this in Section7.4when briefly introducing distributed lags as predictors. Several directions for generalising regression models to better incorporate the rich dynamics observed in time series are discussed in Section10. With each forecast for the change in consumption in Figure7.18, 95% and 80% prediction intervals are also included. The general formulation of how to calculate prediction intervals for multiple regression models is presented in Section7.9",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_8181dc28.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/forecasting-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The general formulation of how to calculate prediction intervals for multiple regression models is presented in Section7.9. As this involves some advanced matrix algebra we present here the case for calculating prediction intervals for a simple regression, where a forecast can be generated using the equation,\\[ \\hat{y}=\\hat{\\beta}_0+\\hat{\\beta}_1x. \\]Assuming that the regression errors are normally distributed, an approximate 95% prediction interval associated with this forecast is given by\\[\\begin{equation} \\hat{y} \\pm 1.96 \\hat{\\sigma}_e\\sqrt{1+\\frac{1}{T}+\\frac{(x-\\bar{x})^2}{(T-1)s_x^2}}, \\tag{7.4} \\end{equation}\\]where\\(T\\)is the total number of observations,\\(\\bar{x}\\)is the mean of the observed\\(x\\)values,\\(s_x\\)is the standard deviation of the observed\\(x\\)values and\\(\\hat{\\sigma}_e\\)is the standard error of the regression given by Equation(7.3). Similarly, an 80% prediction interval can be obtained by replacing 1.96 by 1.28. Other prediction intervals can be obtained by replacing the 1.96 with the appropriate value given in Table5.1. If thefablepackage is used to obtain prediction intervals, more exact calculations are obtained (especially for small values of\\(T\\)) than what is given by Equation(7.4). Equation(7.4)shows that the prediction interval is wider when\\(x\\)is far from\\(\\bar{x}\\). That is, we are more certain about our forecasts when considering values of the predictor variable close to its sample mean. The estimated simple regression line in the US consumption example is\\[ \\hat{y}_t=0.54 + 0.27x_t. \\] Assuming that for the next four quarters, personal income will increase by its historical mean value of\\(\\bar{x}=0.73\\)%, consumption is forecast to increase by\\(0.74\\)% and the corresponding 80% and 95% prediction intervals are\\([-0.02, 1.5]\\)and\\([-0.42, 1.9]\\)respectively (calculated using R). If we assume an extreme increase of 12% in income, then the prediction intervals are considerably wider as shown in Figure7.19",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_8181dc28.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/forecasting-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". If we assume an extreme increase of 12% in income, then the prediction intervals are considerably wider as shown in Figure7.19. Figure 7.19: Prediction intervals if income is increased by its historical mean of\\(0.73\\)% versus an extreme increase of 12%.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_8181dc28.json_chunk_5"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/decomposition-exercises.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Consider the GDP information inglobal_economy. Plot the GDP per capita for each country over time. Which country has the highest GDP per capita? How has this changed over time? For each of the following series, make a graph of the data. If transforming seems appropriate, do so and describe the effect. Why is a Box-Cox transformation unhelpful for thecanadian_gasdata? What Box-Cox transformation would you select for your retail data (from Exercise 7 in Section2.10)? For the following series, find an appropriate Box-Cox transformation in order to stabilise the variance. Tobacco fromaus_production, Economy class passengers between Melbourne and Sydney fromansett, and Pedestrian counts at Southern Cross Station frompedestrian. Show that a\\(3\\times5\\)MA is equivalent to a 7-term weighted moving average with weights of 0.067, 0.133, 0.200, 0.200, 0.200, 0.133, and 0.067. Consider the last five years of the Gas data fromaus_production. Recall your retail time series data (from Exercise 7 in Section2.10). Decompose the series using X-11. Does it reveal any outliers, or unusual features that you had not noticed previously? Figures3.19and3.20show the result of decomposing the number of persons in the civilian labour force in Australia each month from February 1978 to August 1995. Figure 3.19: Decomposition of the number of persons in the civilian labour force in Australia each month from February 1978 to August 1995. Figure 3.20: Seasonal component from the decomposition shown in the previous figure. This exercise uses thecanadian_gasdata (monthly Canadian gas production in billions of cubic metres, January 1960 â February 2005). The evolving seasonal pattern is possibly due to changes in the regulation of gas prices â thanks to Lewis Kirvan for pointing this out.â©ï ̧",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_8586bf0e.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-forecasting.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Although we have calculated forecasts from the ARIMA models in our examples, we have not yet explained how they are obtained. Point forecasts can be calculated using the following three steps. Beginning with\\(h=1\\), these steps are then repeated for\\(h=2,3,\\dots\\)until all forecasts have been calculated. The procedure is most easily understood via an example. We will illustrate it using a ARIMA(3,1,1) model which can be written as follows:\\[ (1-\\hat{\\phi}_1B -\\hat{\\phi}_2B^2-\\hat{\\phi}_3B^3)(1-B) y_t = (1+\\hat{\\theta}_1B)\\varepsilon_{t}. \\]Then we expand the left hand side to obtain\\[ \\left[1-(1+\\hat{\\phi}_1)B +(\\hat{\\phi}_1-\\hat{\\phi}_2)B^2 + (\\hat{\\phi}_2-\\hat{\\phi}_3)B^3 +\\hat{\\phi}_3B^4\\right] y_t = (1+\\hat{\\theta}_1B)\\varepsilon_{t}, \\]and applying the backshift operator gives\\[ y_t - (1+\\hat{\\phi}_1)y_{t-1} +(\\hat{\\phi}_1-\\hat{\\phi}_2)y_{t-2} + (\\hat{\\phi}_2-\\hat{\\phi}_3)y_{t-3} +\\hat{\\phi}_3y_{t-4} = \\varepsilon_t+\\hat{\\theta}_1\\varepsilon_{t-1}. \\]Finally, we move all terms other than\\(y_t\\)to the right hand side:\\[\\begin{equation} \\tag{9.5} y_t = (1+\\hat{\\phi}_1)y_{t-1} -(\\hat{\\phi}_1-\\hat{\\phi}_2)y_{t-2} - (\\hat{\\phi}_2-\\hat{\\phi}_3)y_{t-3} -\\hat{\\phi}_3y_{t-4} + \\varepsilon_t+\\hat{\\theta}_1\\varepsilon_{t-1}. \\end{equation}\\]This completes the first step. While the equation now looks like an ARIMA(4,0,1), it is still the same ARIMA(3,1,1) model we started with. It cannot be considered an ARIMA(4,0,1) because the coefficients do not satisfy the stationarity conditions. For the second step, we replace\\(t\\)with\\(T+1\\)in(9.5):\\[ y_{T+1} = (1+\\hat{\\phi}_1)y_{T} -(\\hat{\\phi}_1-\\hat{\\phi}_2)y_{T-1} - (\\hat{\\phi}_2-\\hat{\\phi}_3)y_{T-2} -\\hat{\\phi}_3y_{T-3} + \\varepsilon_{T+1}+\\hat{\\theta}_1\\varepsilon_{T}",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_86979c7b.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-forecasting.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". \\]Assuming we have observations up to time\\(T\\), all values on the right hand side are known except for\\(\\varepsilon_{T+1}\\), which we replace with zero, and\\(\\varepsilon_T\\), which we replace with the last observed residual\\(e_T\\):\\[ \\hat{y}_{T+1|T} = (1+\\hat{\\phi}_1)y_{T} -(\\hat{\\phi}_1-\\hat{\\phi}_2)y_{T-1} - (\\hat{\\phi}_2-\\hat{\\phi}_3)y_{T-2} -\\hat{\\phi}_3y_{T-3} + \\hat{\\theta}_1e_{T}. \\] A forecast of\\(y_{T+2}\\)is obtained by replacing\\(t\\)with\\(T+2\\)in(9.5). All values on the right hand side will be known at time\\(T\\)except\\(y_{T+1}\\)which we replace with\\(\\hat{y}_{T+1|T}\\), and\\(\\varepsilon_{T+2}\\)and\\(\\varepsilon_{T+1}\\), both of which we replace with zero:\\[ \\hat{y}_{T+2|T} = (1+\\hat{\\phi}_1)\\hat{y}_{T+1|T} -(\\hat{\\phi}_1-\\hat{\\phi}_2)y_{T} - (\\hat{\\phi}_2-\\hat{\\phi}_3)y_{T-1} -\\hat{\\phi}_3y_{T-2}. \\] The process continues in this manner for all future time periods. In this way, any number of point forecasts can be obtained. The calculation of ARIMA prediction intervals is more difficult, and the details are largely beyond the scope of this book. We will only give some simple examples. The first prediction interval is easy to calculate. If\\(\\hat{\\sigma}\\)is the standard deviation of the residuals, then a 95% prediction interval is given by\\(\\hat{y}_{T+1|T} \\pm 1.96\\hat{\\sigma}\\). This result is true for all ARIMA models regardless of their parameters and orders. Multi-step prediction intervals for ARIMA(0,0,\\(q\\)) models are relatively easy to calculate. We can write the model as\\[ y_t = \\varepsilon_t + \\sum_{i=1}^q \\theta_i \\varepsilon_{t-i}. \\]Then, the estimated forecast variance can be written as\\[ \\hat\\sigma_h^2 = \\hat{\\sigma}^2 \\left[ 1 + \\sum_{i=1}^{h-1} \\hat{\\theta}_i^2\\right], \\qquad\\text{for $h=2,3,\\dots$,} \\]where\\(\\hat{\\theta}_i=0\\)for\\(i>q\\), and a 95% prediction interval is given by\\(\\hat{y}_{T+h|T} \\pm 1.96\\hat\\sigma_h\\). In Section9.4, we showed that an AR(1) model can be written as an MA(\\(\\infty\\)) model",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_86979c7b.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-forecasting.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". In Section9.4, we showed that an AR(1) model can be written as an MA(\\(\\infty\\)) model. Using this equivalence, the above result for MA(\\(q\\)) models can also be used to obtain prediction intervals for AR(1) models. More general results, and other special cases of multi-step prediction intervals for an ARIMA(\\(p,d,q\\)) model, are given in more advanced textbooks such asBrockwell & Davis (2016). The prediction intervals for ARIMA models are based on assumptions that the residuals are uncorrelated and normally distributed. If either of these assumptions does not hold, then the prediction intervals may be incorrect. For this reason, always plot the ACF and histogram of the residuals to check the assumptions before producing prediction intervals. If the residuals are uncorrelated but not normally distributed, then bootstrapped intervals can be obtained instead, as discussed in Section5.5. This is easily achieved by simply addingbootstrap=TRUEin theforecast()function. In general, prediction intervals from ARIMA models increase as the forecast horizon increases. For stationary models (i.e., with\\(d=0\\)) they will converge, so that prediction intervals for long horizons are all essentially the same. For\\(d\\ge1\\), the prediction intervals will continue to grow into the future. As with most prediction interval calculations, ARIMA-based intervals tend to be too narrow. This occurs because only the variation in the errors has been accounted for. There is also variation in the parameter estimates, and in the model order, that has not been included in the calculation. In addition, the calculation assumes that the historical patterns that have been modelled will continue into the forecast period.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_86979c7b.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/components.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "If we assume an additive decomposition, then we can write\\[ y_{t} = S_{t} + T_{t} + R_t, \\]where\\(y_{t}\\)is the data,\\(S_{t}\\)is the seasonal component,\\(T_{t}\\)is the trend-cycle component, and\\(R_t\\)is the remainder component, all at period\\(t\\). Alternatively, a multiplicative decomposition would be written as\\[ y_{t} = S_{t} \\times T_{t} \\times R_t. \\] The additive decomposition is the most appropriate if the magnitude of the seasonal fluctuations, or the variation around the trend-cycle, does not vary with the level of the time series. When the variation in the seasonal pattern, or the variation around the trend-cycle, appears to be proportional to the level of the time series, then a multiplicative decomposition is more appropriate. Multiplicative decompositions are common with economic time series. An alternative to using a multiplicative decomposition is to first transform the data until the variation in the series appears to be stable over time, then use an additive decomposition. When a log transformation has been used, this is equivalent to using a multiplicative decomposition on the original data because\\[ y_{t} = S_{t} \\times T_{t} \\times R_t \\quad\\text{is equivalent to}\\quad \\log y_{t} = \\log S_{t} + \\log T_{t} + \\log R_t. \\] We will look at several methods for obtaining the components\\(S_{t}\\),\\(T_{t}\\)and\\(R_{t}\\)later in this chapter, but first it is helpful to see an example. We will decompose the number of persons employed in retail as shown in Figure3.5. The data shows the total monthly number of persons in thousands employed in the retail sector across the US since 1990. Figure 3.5: Total number of persons employed in US retail. To illustrate the ideas, we will use the STL decomposition method, which is discussed in Section3.6. The output above shows the components of an STL decomposition. The original data is shown (asEmployed), followed by the estimated components. This output forms a âdableâ or decomposition table",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_929fc255.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/components.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The output above shows the components of an STL decomposition. The original data is shown (asEmployed), followed by the estimated components. This output forms a âdableâ or decomposition table. The header to the table shows that theEmployedseries has been decomposed additively. Thetrendcolumn (containing the trend-cycle\\(T_t\\)) follows the overall movement of the series, ignoring any seasonality and random fluctuations, as shown in Figure3.6. Figure 3.6: Total number of persons employed in US retail: the trend-cycle component (orange) and the raw data (grey). We can plot all of the components in a single figure usingautoplot(), as shown in Figure3.7. Figure 3.7: The total number of persons employed in US retail (top) and its three additive components. The three components are shown separately in the bottom three panels. These components can be added together to reconstruct the data shown in the top panel. Notice that the seasonal component changes over time, so that any two consecutive years have similar patterns, but years far apart may have different seasonal patterns. The remainder component shown in the bottom panel is what is left over when the seasonal and trend-cycle components have been subtracted from the data. The grey bars to the left of each panel show the relative scales of the components. Each grey bar represents the same length but because the plots are on different scales, the bars vary in size. The large grey bar in the bottom panel shows that the variation in the remainder component is smallest compared to the variation in the data. If we shrank the bottom three panels until their bars became the same size as that in the data panel, then all the panels would be on the same scale. If the seasonal component is removed from the original data, the resulting values are the âseasonally adjustedâ data. For an additive decomposition, the seasonally adjusted data are given by\\(y_{t}-S_{t}\\), and for multiplicative data, the seasonally adjusted values are obtained using\\(y_{t}/S_{t}\\)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_929fc255.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/components.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". For an additive decomposition, the seasonally adjusted data are given by\\(y_{t}-S_{t}\\), and for multiplicative data, the seasonally adjusted values are obtained using\\(y_{t}/S_{t}\\). Figure3.8shows the seasonally adjusted number of persons employed. Figure 3.8: Seasonally adjusted retail employment data (blue) and the original data (grey). If the variation due to seasonality is not of primary interest, the seasonally adjusted series can be useful. For example, monthly unemployment data are usually seasonally adjusted in order to highlight variation due to the underlying state of the economy rather than the seasonal variation. An increase in unemployment due to school leavers seeking work is seasonal variation, while an increase in unemployment due to an economic recession is non-seasonal. Most economic analysts who study unemployment data are more interested in the non-seasonal variation. Consequently, employment data (and many other economic series) are usually seasonally adjusted. Seasonally adjusted series contain the remainder component as well as the trend-cycle. Therefore, they are not âsmoothâ, and âdownturnsâ or âupturnsâ can be misleading. If the purpose is to look for turning points in a series, and interpret any changes in direction, then it is better to use the trend-cycle component rather than the seasonally adjusted data.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_929fc255.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-ets.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "It is a commonly held myth that ARIMA models are more general than exponential smoothing. While linear exponential smoothing models are all special cases of ARIMA models, the non-linear exponential smoothing models have no equivalent ARIMA counterparts. On the other hand, there are also many ARIMA models that have no exponential smoothing counterparts. In particular, all ETS models are non-stationary, while some ARIMA models are stationary. Figure9.27shows the overlap between the two model classes. Figure 9.27: The ETS and ARIMA model classes overlap with the additive ETS models having equivalent ARIMA forms. The ETS models with seasonality or non-damped trend or both have two unit roots (i.e., they need two levels of differencing to make them stationary). All other ETS models have one unit root (they need one level of differencing to make them stationary). Table9.4gives the equivalence relationships for the two classes of models. For the seasonal models, the ARIMA parameters have a large number of restrictions. The AICc is useful for selecting between models in the same class. For example, we can use it to select an ARIMA model between candidate ARIMA models20or an ETS model between candidate ETS models. However, it cannot be used to compare between ETS and ARIMA models because they are in different model classes, and the likelihood is computed in different ways. The examples below demonstrate selecting between these classes of models. We can use time series cross-validation to compare ARIMA and ETS models. Letâs consider the Australian population from theglobal_economydataset, as introduced in Section8.2. In this case the ETS model has higher accuracy on the cross-validated performance measures. Below we generate and plot forecasts for the next 5 years generated from an ETS model. Figure 9.28: Forecasts from an ETS model fitted to the Australian population. In this case we want to compare seasonal ARIMA and ETS models applied to the quarterly cement production data (fromaus_production)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_992384d4.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/arima-ets.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". In this case we want to compare seasonal ARIMA and ETS models applied to the quarterly cement production data (fromaus_production). Because the series is relatively long, we can afford to use a training and a test set rather than time series cross-validation. The advantage is that this is much faster. We create a training set from the beginning of 1988 to the end of 2007 and select an ARIMA and an ETS model using theARIMA()andETS()functions. The output below shows the model selected and estimated byARIMA(). The ARIMA model does well in capturing all the dynamics in the data as the residuals seem to be white noise. Figure 9.29: Residual diagnostic plots for the ARIMA model fitted to the quarterly cement production training data. The output below also shows the ETS model selected and estimated byETS(). This model also does well in capturing all the dynamics in the data, as the residuals similarly appear to be white noise. Figure 9.30: Residual diagnostic plots for the ETS model fitted to the quarterly cement production training data. The output below evaluates the forecasting performance of the two competing models over the test set. In this case the ARIMA model seems to be the slightly more accurate model based on the test set RMSE, MAPE and MASE. Below we generate and plot forecasts from the ARIMA model for the next 3 years. Figure 9.31: Forecasts from an ARIMA model fitted to all of the available quarterly cement production data since 1988. As already noted, comparing information criteria is only valid for ARIMA models of the same orders of differencing.â©ï ̧",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_992384d4.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/methods-used-by-official-statistics-agencies.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Official statistics agencies (such as the US Census Bureau and the Australian Bureau of Statistics) are responsible for a large number of official economic and social time series. These agencies have developed their own decomposition procedures which are used for seasonal adjustment. Most of them use variants of the X-11 method, or the SEATS method, or a combination of the two. These methods are designed specifically to work with quarterly and monthly data, which are the most common series handled by official statistics agencies. They will not handle seasonality of other kinds, such as daily data, or hourly data, or weekly data. We will use the latest implementation of this group of methods known as âX-13ARIMA-SEATSâ. For the methods discussed in this section, you will need to have installed theseasonalpackage in R. The X-11 method originated in the US Census Bureau and was further developed by Statistics Canada. It is based on classical decomposition, but includes many extra steps and features in order to overcome the drawbacks of classical decomposition that were discussed in the previous section. In particular, trend-cycle estimates are available for all observations including the end points, and the seasonal component is allowed to vary slowly over time. X-11 also handles trading day variation, holiday effects and the effects of known predictors. There are methods for both additive and multiplicative decomposition. The process is entirely automatic and tends to be highly robust to outliers and level shifts in the time series. The details of the X-11 method are described inDagum & Bianconcini (2016). Figure 3.14: A multiplicative decomposition of US retail employment using X-11. Compare this decomposition with the STL decomposition shown in Figure3.7and the classical decomposition shown in Figure3.13. The default approach forX_13ARIMA_SEATSshown here is a multiplicative decomposition, whereas the STL and classical decompositions shown earlier were additive; but it doesnât make much difference in this case",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_a2a2b178.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/methods-used-by-official-statistics-agencies.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The X-11 trend-cycle has captured the sudden fall in the data due to the 2007â2008 global financial crisis better than either of the other two methods (where the effect of the crisis has leaked into the remainder component). Also, the unusual observation in 1996 is now more clearly seen in the X-11 remainder component. Figure3.15shows the trend-cycle component and the seasonally adjusted data, along with the original data. The seasonally adjusted data is very similar to the trend-cycle component in this example, so it is hard to distinguish them on the plot. Figure 3.15: US retail employment: the original data (grey), the trend-cycle component (orange) and the seasonally adjusted data (barely visible in blue). It can be useful to use seasonal plots and seasonal sub-series plots of the seasonal component, to help us visualise the variation in the seasonal component over time. Figure3.16shows a seasonal sub-series plot of the seasonal component from Figure3.14. In this case, there are only small changes over time. Figure 3.16: Seasonal sub-series plot of the seasonal component from the X-11 method applied to total US retail employment. âSEATSâ stands for âSeasonal Extraction in ARIMA Time Seriesâ (ARIMA models are discussed in Chapter9). This procedure was developed at the Bank of Spain, and is now widely used by government agencies around the world. The details are beyond the scope of this book. However, a complete discussion of the method is available inDagum & Bianconcini (2016). Figure 3.17: A decomposition of US retail employment obtained using SEATS. Figure3.17shows the SEATS method applied to the total retail employment series across the US. The result is quite similar to that obtained using the X-11 method shown in Figure3.14. TheX_13ARIMA_SEATS()function calls theseasonalpackage which has many options for handling variations of X-11 and SEATS. Seethe package websitefor a detailed introduction to the options and features available.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_a2a2b178.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/least-squares.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "In practice, of course, we have a collection of observations but we do not know the values of the coefficients\\(\\beta_0,\\beta_1, \\dots, \\beta_k\\). These need to be estimated from the data. The least squares principle provides a way of choosing the coefficients effectively by minimising the sum of the squared errors. That is, we choose the values of\\(\\beta_0, \\beta_1, \\dots, \\beta_k\\)that minimise\\[ \\sum_{t=1}^T \\varepsilon_t^2 = \\sum_{t=1}^T (y_t - \\beta_{0} - \\beta_{1} x_{1,t} - \\beta_{2} x_{2,t} - \\cdots - \\beta_{k} x_{k,t})^2. \\] This is calledleast squaresestimation because it gives the least value for the sum of squared errors. Finding the best estimates of the coefficients is often called âfittingâ the model to the data, or sometimes âlearningâ or âtrainingâ the model. The line shown in Figure7.3was obtained in this way. When we refer to theestimatedcoefficients, we will use the notation\\(\\hat\\beta_0, \\dots, \\hat\\beta_k\\). The equations for these will be given in Section7.9. TheTSLM()function fits a linear regression model to time series data. It is similar to thelm()function which is widely used for linear models, butTSLM()provides additional facilities for handling time series. A multiple linear regression model for US consumption is\\[ y_t=\\beta_0 + \\beta_1 x_{1,t}+ \\beta_2 x_{2,t}+ \\beta_3 x_{3,t}+ \\beta_4 x_{4,t}+\\varepsilon_t, \\]where\\(y\\)is the percentage change in real personal consumption expenditure,\\(x_1\\)is the percentage change in real personal disposable income,\\(x_2\\)is the percentage change in industrial production,\\(x_3\\)is the percentage change in personal savings and\\(x_4\\)is the change in the unemployment rate. The following output provides information about the fitted model. The first column ofCoefficientsgives an estimate of each\\(\\beta\\)coefficient and the second column gives its standard error (i.e., the standard deviation which would be obtained from repeatedly estimating the\\(\\beta\\)coefficients on similar data sets)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_b261dc31.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/least-squares.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The standard error gives a measure of the uncertainty in the estimated\\(\\beta\\)coefficient. For forecasting purposes, the final two columns are of limited interest. The ât valueâ is the ratio of an estimated\\(\\beta\\)coefficient to its standard error and the last column gives the p-value: the probability of the estimated\\(\\beta\\)coefficient being as large as it is if there was no real relationship between consumption and the corresponding predictor. This is useful when studying the effect of each predictor, but is not particularly useful for forecasting. Predictions of\\(y\\)can be obtained by using the estimated coefficients in the regression equation and setting the error term to zero. In general we write,\\[\\begin{equation} \\hat{y}_t = \\hat\\beta_{0} + \\hat\\beta_{1} x_{1,t} + \\hat\\beta_{2} x_{2,t} + \\cdots + \\hat\\beta_{k} x_{k,t}. \\tag{7.2} \\end{equation}\\]Plugging in the values of\\(x_{1,t},\\dots,x_{k,t}\\)for\\(t=1,\\dots,T\\)returns predictions of\\(y_t\\)within the training set, referred to asfitted values. Note that these are predictions of the data used to estimate the model, not genuine forecasts of future values of\\(y\\). The following plots show the actual values compared to the fitted values for the percentage change in the US consumption expenditure series. The time plot in Figure7.6shows that the fitted values follow the actual data fairly closely. This is verified by the strong positive relationship shown by the scatterplot in Figure7.7. Figure 7.6: Time plot of actual US consumption expenditure and predicted US consumption expenditure. Figure 7.7: Actual US consumption expenditure plotted against predicted US consumption expenditure. A common way to summarise how well a linear regression model fits the data is via the coefficient of determination, or\\(R^2\\). This can be calculated as the square of the correlation between the observed\\(y\\)values and the predicted\\(\\hat{y}\\)values",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_b261dc31.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/least-squares.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". This can be calculated as the square of the correlation between the observed\\(y\\)values and the predicted\\(\\hat{y}\\)values. Alternatively, it can also be calculated as,\\[ R^2 = \\frac{\\sum(\\hat{y}_{t} - \\bar{y})^2}{\\sum(y_{t}-\\bar{y})^2}, \\]where the summations are over all observations. Thus, it reflects the proportion of variation in the forecast variable that is accounted for (or explained) by the regression model. In simple linear regression, the value of\\(R^2\\)is also equal to the square of the correlation between\\(y\\)and\\(x\\)(provided an intercept has been included). If the predictions are close to the actual values, we would expect\\(R^2\\)to be close to 1. On the other hand, if the predictions are unrelated to the actual values, then\\(R^2=0\\)(again, assuming there is an intercept). In all cases,\\(R^2\\)lies between 0 and 1. The\\(R^2\\)value is used frequently, though often incorrectly, in forecasting. The value of\\(R^2\\)will never decrease when adding an extra predictor to the model and this can lead to over-fitting. There are no set rules for what is a good\\(R^2\\)value, and typical values of\\(R^2\\)depend on the type of data used. Validating a modelâs forecasting performance on the test data is much better than measuring the\\(R^2\\)value on the training data. Figure7.7plots the actual consumption expenditure values versus the fitted values. The correlation between these variables is\\(r=0.877\\)hence\\(R^2= 0.768\\)(shown in the output above). In this case, the model does an excellent job as it explains 76.8% of the variation in the consumption data. Compare that to the\\(R^2\\)value of 0.15 obtained from the simple regression with the same data set in Section7.1. Adding the three extra predictors has allowed a lot more of the variation in the consumption data to be explained. Another measure of how well the model has fitted the data is the standard deviation of the residuals, which is often known as the âresidual standard errorâ. This is shown in the above output with the value 0.31",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_b261dc31.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/least-squares.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". This is shown in the above output with the value 0.31. It is calculated using\\[\\begin{equation} \\hat{\\sigma}_e=\\sqrt{\\frac{1}{T-k-1}\\sum_{t=1}^{T}{e_t^2}}, \\tag{7.3} \\end{equation}\\]where\\(k\\)is the number of predictors in the model. Notice that we divide by\\(T-k-1\\)because we have estimated\\(k+1\\)parameters (the intercept and a coefficient for each predictor variable) in computing the residuals. The standard error is related to the size of the average error that the model produces. We can compare this error to the sample mean of\\(y\\)or with the standard deviation of\\(y\\)to gain some perspective on the accuracy of the model. The standard error will be used when generating prediction intervals, discussed in Section7.6.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_b261dc31.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/useful-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "There are several useful predictors that occur frequently when using regression for time series data. It is common for time series data to be trending. A linear trend can be modelled by simply using\\(x_{1,t}=t\\)as a predictor,\\[ y_{t}= \\beta_0+\\beta_1t+\\varepsilon_t, \\]where\\(t=1,\\dots,T\\). A trend variable can be specified in theTSLM()function using thetrend()special. In Section7.7we discuss how we can also model nonlinear trends. So far, we have assumed that each predictor takes numerical values. But what about when a predictor is a categorical variable taking only two values (e.g., âyesâ and ânoâ)? Such a variable might arise, for example, when forecasting daily sales and you want to take account of whether the day is apublic holidayor not. So the predictor takes value âyesâ on a public holiday, and ânoâ otherwise. This situation can still be handled within the framework of multiple regression models by creating a âdummy variableâ which takes value 1 corresponding to âyesâ and 0 corresponding to ânoâ. A dummy variable is also known as an âindicator variableâ. A dummy variable can also be used to account for anoutlierin the data. Rather than omit the outlier, a dummy variable removes its effect. In this case, the dummy variable takes value 1 for that observation and 0 everywhere else. An example is the case where a special event has occurred. For example when forecasting tourist arrivals to Brazil, we will need to account for the effect of the Rio de Janeiro summer Olympics in 2016. If there are more than two categories, then the variable can be coded using several dummy variables (one fewer than the total number of categories).TSLM()will automatically handle this case if you specify a factor variable as a predictor. There is usually no need to manually create the corresponding dummy variables. Suppose that we are forecasting daily data and we want to account for the day of the week as a predictor. Then the following dummy variables can be created",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_c5977343.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/useful-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Suppose that we are forecasting daily data and we want to account for the day of the week as a predictor. Then the following dummy variables can be created. Notice that only six dummy variables are needed to code seven categories. That is because the seventh category (in this case Sunday) is captured by the intercept, and is specified when the dummy variables are all set to zero. Many beginners will try to add a seventh dummy variable for the seventh category. This is known as the âdummy variable trapâ, because it will cause the regression to fail. There will be one too many parameters to estimate when an intercept is also included. The general rule is to use one fewer dummy variables than categories. So for quarterly data, use three dummy variables; for monthly data, use 11 dummy variables; and for daily data, use six dummy variables, and so on. The interpretation of each of the coefficients associated with the dummy variables is that it isa measure of the effect of that category relative to the omitted category. In the above example, the coefficient of\\(d_{1,t}\\)associated with Monday will measure the effect of Monday on the forecast variable compared to the effect of Sunday. An example of interpreting estimated dummy variable coefficients capturing the quarterly seasonality of Australian beer production follows. TheTSLM()function will automatically handle this situation if you specify the specialseason(). Recall the Australian quarterly beer production data shown again in Figure7.14. Figure 7.14: Australian quarterly beer production. We want to forecast the value of future beer production. We can model this data using a regression model with a linear trend and quarterly dummy variables,\\[ y_{t} = \\beta_{0} + \\beta_{1} t + \\beta_{2}d_{2,t} + \\beta_3 d_{3,t} + \\beta_4 d_{4,t} + \\varepsilon_{t}, \\]where\\(d_{i,t} = 1\\)if\\(t\\)is in quarter\\(i\\)and 0 otherwise",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_c5977343.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/useful-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". The first quarter variable has been omitted, so the coefficients associated with the other quarters are measures of the difference between those quarters and the first quarter. Note thattrend()andseason()are not standard functions; they are âspecialâ functions that work within theTSLM()model formulae. There is an average downward trend of -0.34 megalitres per quarter. On average, the second quarter has production of 34.7 megalitres lower than the first quarter, the third quarter has production of 17.8 megalitres lower than the first quarter, and the fourth quarter has production of 72.8 megalitres higher than the first quarter. Figure 7.15: Time plot of beer production and predicted beer production. Figure 7.16: Actual beer production plotted against predicted beer production. It is often necessary to model interventions that may have affected the variable to be forecast. For example, competitor activity, advertising expenditure, industrial action, and so on, can all have an effect. When the effect lasts only for one period, we use a âspikeâ variable. This is a dummy variable that takes value one in the period of the intervention and zero elsewhere. A spike variable is equivalent to a dummy variable for handling an outlier. Other interventions have an immediate and permanent effect. If an intervention causes a level shift (i.e., the value of the series changes suddenly and permanently from the time of intervention), then we use a âstepâ variable. A step variable takes value zero before the intervention and one from the time of intervention onward. Another form of permanent effect is a change of slope. Here the intervention is handled using a piecewise linear trend; a trend that bends at the time of intervention and hence is nonlinear. We will discuss this in Section7.7. The number of trading days in a month can vary considerably and can have a substantial effect on sales data. To allow for this, the number of trading days in each month can be included as a predictor",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_c5977343.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/useful-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". To allow for this, the number of trading days in each month can be included as a predictor. An alternative that allows for the effects of different days of the week has the following predictors:\\[\\begin{align*} x_{1} &= \\text{number of Mondays in month;} \\\\ x_{2} &= \\text{number of Tuesdays in month;} \\\\ & \\vdots \\\\ x_{7} &= \\text{number of Sundays in month.} \\end{align*}\\] It is often useful to include advertising expenditure as a predictor. However, since the effect of advertising can last beyond the actual campaign, we need to include lagged values of advertising expenditure. Thus, the following predictors may be used.\\[\\begin{align*} x_{1} &= \\text{advertising for previous month;} \\\\ x_{2} &= \\text{advertising for two months previously;} \\\\ & \\vdots \\\\ x_{m} &= \\text{advertising for $m$ months previously.} \\end{align*}\\] It is common to require the coefficients to decrease as the lag increases, although this is beyond the scope of this book. Easter differs from most holidays because it is not held on the same date each year, and its effect can last for several days. In this case, a dummy variable can be used with value one where the holiday falls in the particular time period and zero otherwise. With monthly data, if Easter falls in March then the dummy variable takes value 1 in March, and if it falls in April the dummy variable takes value 1 in April. When Easter starts in March and finishes in April, the dummy variable is split proportionally between months. An alternative to using seasonal dummy variables, especially for long seasonal periods, is to use Fourier terms. Jean-Baptiste Fourier was a French mathematician, born in the 1700s, who showed that a series of sine and cosine terms of the right frequencies can approximate any periodic function. We can use them for seasonal patterns",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_c5977343.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/useful-predictors.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". We can use them for seasonal patterns. If\\(m\\)is the seasonal period, then the first few Fourier terms are given by\\[ x_{1,t} = \\sin\\left(\\textstyle\\frac{2\\pi t}{m}\\right), x_{2,t} = \\cos\\left(\\textstyle\\frac{2\\pi t}{m}\\right), x_{3,t} = \\sin\\left(\\textstyle\\frac{4\\pi t}{m}\\right), \\]\\[ x_{4,t} = \\cos\\left(\\textstyle\\frac{4\\pi t}{m}\\right), x_{5,t} = \\sin\\left(\\textstyle\\frac{6\\pi t}{m}\\right), x_{6,t} = \\cos\\left(\\textstyle\\frac{6\\pi t}{m}\\right), \\]and so on. If we have monthly seasonality, and we use the first 11 of these predictor variables, then we will get exactly the same forecasts as using 11 dummy variables. With Fourier terms, we often need fewer predictors than with dummy variables, especially when\\(m\\)is large. This makes them useful for weekly data, for example, where\\(m\\approx 52\\). For short seasonal periods (e.g., quarterly data), there is little advantage in using Fourier terms over seasonal dummy variables. These Fourier terms are produced using thefourier()function. For example, the Australian beer data can be modelled like this. TheKargument tofourier()specifies how many pairs of sin and cos terms to include. The maximum allowed is\\(K=m/2\\)where\\(m\\)is the seasonal period. Because we have used the maximum here, the results are identical to those obtained when using seasonal dummy variables. If only the first two Fourier terms are used (\\(x_{1,t}\\)and\\(x_{2,t}\\)), the seasonal pattern will follow a simple sine wave. A regression model containing Fourier terms is often called aharmonic regressionbecause the successive Fourier terms represent harmonics of the first two Fourier terms.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_c5977343.json_chunk_5"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "In this chapter we discuss regression models. The basic concept is that we forecast the time series of interest\\(y\\)assuming that it has a linear relationship with other time series\\(x\\). For example, we might wish to forecast monthly sales\\(y\\)using total advertising spend\\(x\\)as a predictor. Or we might forecast daily electricity demand\\(y\\)using temperature\\(x_1\\)and the day of week\\(x_2\\)as predictors. Theforecast variable\\(y\\)is sometimes also called the regressand, dependent or explained variable. Thepredictor variables\\(x\\)are sometimes also called the regressors, independent or explanatory variables. In this book we will always refer to them as the âforecastâ variable and âpredictorâ variables.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_d8ba2b13.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/AR.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "In a multiple regression model, introduced in Chapter7, we forecast the variable of interest using a linear combination of predictors. In an autoregression model, we forecast the variable of interest using a linear combination ofpast values of the variable. The termautoregression indicates that it is a regression of the variable against itself. Thus, an autoregressive model of order\\(p\\)can be written as\\[ y_{t} = c + \\phi_{1}y_{t-1} + \\phi_{2}y_{t-2} + \\dots + \\phi_{p}y_{t-p} + \\varepsilon_{t}, \\]where\\(\\varepsilon_t\\)is white noise. This is like a multiple regression but withlagged valuesof\\(y_t\\)as predictors. We refer to this as anAR(\\(p\\)) model, an autoregressive model of order\\(p\\). Autoregressive models are remarkably flexible at handling a wide range of different time series patterns. The two series in Figure9.5show series from an AR(1) model and an AR(2) model. Changing the parameters\\(\\phi_1,\\dots,\\phi_p\\)results in different time series patterns. The variance of the error term\\(\\varepsilon_t\\)will only change the scale of the series, not the patterns. Figure 9.5: Two examples of data from autoregressive models with different parameters. Left: AR(1) with\\(y_t = 18 -0.8y_{t-1} + \\varepsilon_t\\). Right: AR(2) with\\(y_t = 8 + 1.3y_{t-1}-0.7y_{t-2}+\\varepsilon_t\\). In both cases,\\(\\varepsilon_t\\)is normally distributed white noise with mean zero and variance one. For an AR(1) model: We normally restrict autoregressive models to stationary data, in which case some constraints on the values of the parameters are required. When\\(p\\ge3\\), the restrictions are much more complicated. Thefablepackage takes care of these restrictions when estimating a model.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_dc2c2d04.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/nonlinear-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Although the linear relationship assumed so far in this chapter is often adequate, there are many cases in which a nonlinear functional form is more suitable. To keep things simple in this section we assume that we only have one predictor\\(x\\). The simplest way of modelling a nonlinear relationship is to transform the forecast variable\\(y\\)and/or the predictor variable\\(x\\)before estimating a regression model. While this provides a non-linear functional form, the model is still linear in the parameters. The most commonly used transformation is the (natural) logarithm (see Section3.1). Alog-logfunctional form is specified as\\[ \\log y=\\beta_0+\\beta_1 \\log x +\\varepsilon. \\]In this model, the slope\\(\\beta_1\\)can be interpreted as an elasticity:\\(\\beta_1\\)is the average percentage change in\\(y\\)resulting from a 1% increase in\\(x\\). Other useful forms can also be specified. Thelog-linearform is specified by only transforming the forecast variable and thelinear-logform is obtained by transforming the predictor. Recall that in order to perform a logarithmic transformation to a variable, all of its observed values must be greater than zero. In the case that variable\\(x\\)contains zeros, we use the transformation\\(\\log(x+1)\\); i.e., we add one to the value of the variable and then take logarithms. This has a similar effect to taking logarithms but avoids the problem of zeros. It also has the neat side-effect of zeros on the original scale remaining zeros on the transformed scale. There are cases for which simply transforming the data will not be adequate and a more general specification may be required. Then the model we use is\\[ y=f(x) +\\varepsilon \\]where\\(f\\)is a nonlinear function. In standard (linear) regression,\\(f(x)=\\beta_{0} + \\beta_{1} x\\). In the specification of nonlinear regression that follows, we allow\\(f\\)to be a more flexible nonlinear function of\\(x\\), compared to simply a logarithmic or other transformation. One of the simplest specifications is to make\\(f\\)piecewise linear",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_e322eaf2.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/nonlinear-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". One of the simplest specifications is to make\\(f\\)piecewise linear. That is, we introduce points where the slope of\\(f\\)can change. These points are calledknots. This can be achieved by letting\\(x_{1}=x\\)and introducing variable\\(x_{2}\\)such that\\[\\begin{align*} x_{2} = (x-c)_+ &= \\left\\{ \\begin{array}{ll} 0 & \\text{if } x < c\\\\ x-c & \\text{if } x \\ge c. \\end{array}\\right. \\end{align*}\\]The notation\\((x-c)_+\\)means the value\\(x-c\\)if it is positive and 0 otherwise. This forces the slope to bend at point\\(c\\). Additional bends can be included in the relationship by adding further variables of the above form. Piecewise linear relationships constructed in this way are a special case ofregression splines. In general, a linear regression spline is obtained using\\[ x_{1}= x \\quad x_{2} = (x-c_{1})_+ \\quad\\dots\\quad x_{k} = (x-c_{k-1})_+ \\]where\\(c_{1},\\dots,c_{k-1}\\)are the knots (the points at which the line can bend). Selecting the number of knots (\\(k-1\\)) and where they should be positioned can be difficult and somewhat arbitrary. Some automatic knot selection algorithms are available, but are not widely used. In Section7.4fitting a linear trend to a time series by setting\\(x=t\\)was introduced. The simplest way of fitting a nonlinear trend is using quadratic or higher order trends obtained by specifying\\[ x_{1,t} =t,\\quad x_{2,t}=t^2,\\quad \\dots. \\]However, it is not recommended that quadratic or higher order trends be used in forecasting. When they are extrapolated, the resulting forecasts are often unrealistic. A better approach is to use the piecewise specification introduced above and fit a piecewise linear trend which bends at some point in time. We can think of this as a nonlinear trend constructed of linear pieces",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_e322eaf2.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/nonlinear-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". We can think of this as a nonlinear trend constructed of linear pieces. If the trend bends at time\\(\\tau\\), then it can be specified by simply replacing\\(x=t\\)and\\(c=\\tau\\)above such that we include the predictors,\\[\\begin{align*} x_{1,t} & = t \\\\ x_{2,t} &= (t-\\tau)_+ = \\left\\{ \\begin{array}{ll} 0 & \\text{if } t < \\tau\\\\ t-\\tau & \\text{if } t \\ge \\tau \\end{array}\\right. \\end{align*}\\]in the model. If the associated coefficients of\\(x_{1,t}\\)and\\(x_{2,t}\\)are\\(\\beta_1\\)and\\(\\beta_2\\), then\\(\\beta_1\\)gives the slope of the trend before time\\(\\tau\\), while the slope of the line after time\\(\\tau\\)is given by\\(\\beta_1+\\beta_2\\). Additional bends can be included in the relationship by adding further variables of the form\\((t-\\tau)_+\\)where\\(\\tau\\)is the âknotâ or point in time at which the line should bend. We will fit some trend models to the Boston marathon winning times for men. First we extract the menâs data and convert the winning times to a numerical value. The course was lengthened (from 24.5 miles to 26.2 miles) in 1924, which led to a jump in the winning times, so we only consider data from that date onwards. The top panel of Figure7.20shows the winning times since 1924. The time series shows a general downward trend as the winning times have been improving over the years. The bottom panel shows the residuals from fitting a linear trend to the data. The plot shows an obvious nonlinear pattern which has not been captured by the linear trend. Figure 7.20: Fitting a linear trend to the Boston marathon winning times is inadequate Fitting an exponential trend (equivalent to a log-linear regression) to the data can be achieved by transforming the\\(y\\)variable so that the model to be fitted is,\\[ \\log y_t=\\beta_0+\\beta_1 t +\\varepsilon_t. \\]The fitted exponential trend and forecasts are shown in Figure7.21",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_e322eaf2.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/nonlinear-regression.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". \\]The fitted exponential trend and forecasts are shown in Figure7.21. Although the exponential trend does not seem to fit the data much better than the linear trend, it perhaps gives a more sensible projection in that the winning times will decrease in the future but at a decaying rate rather than a fixed linear rate. The plot of winning times reveals three different periods. There is a lot of volatility in the winning times up to about 1950, with the winning times barely declining. After 1950 there is a clear decrease in times, followed by a flattening out after the 1980s, with the suggestion of an upturn towards the end of the sample. To account for these changes, we specify the years 1950 and 1980 as knots. We should warn here that subjective identification of knots can lead to over-fitting, which can be detrimental to the forecast performance of a model, and should be performed with caution. Figure 7.21: Projecting forecasts from linear, exponential and piecewise linear trends for the Boston marathon winning times. Figure7.21shows the fitted lines and forecasts from linear, exponential and piecewise linear trends. The best forecasts appear to come from the piecewise linear trend.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_e322eaf2.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/backshift.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "The backward shift operator is convenient for describing the process ofdifferencing. A first difference can be written as\\[ y'_{t} = y_{t} - y_{t-1} = y_t - By_{t} = (1 - B)y_{t}\\: . \\]So a first difference can be represented by\\((1 - B)\\). Similarly, if second-order differences have to be computed, then:\\[ y''_{t} = y_{t} - 2y_{t - 1} + y_{t - 2} = (1-2B+B^2)y_t = (1 - B)^{2} y_{t}\\: . \\]In general, a\\(d\\)th-order difference can be written as\\[ (1 - B)^{d} y_{t}. \\] Backshift notation is particularly useful when combining differences, as the operator can be treated using ordinary algebraic rules. In particular, terms involving\\(B\\)can be multiplied together. For example, a seasonal difference followed by a first difference can be written as\\[\\begin{align*} (1-B)(1-B^m)y_t &= (1 - B - B^m + B^{m+1})y_t \\\\ &= y_t-y_{t-1}-y_{t-m}+y_{t-m-1}, \\end{align*}\\]the same result we obtained earlier.",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_ee114ce8.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-exercises.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "Half-hourly electricity demand for Victoria, Australia is contained invic_elec. Extract the January 2014 electricity demand, and aggregate this data to daily with daily total demands and maximum temperatures. Plot the data and find the regression model for Demand with temperature as a predictor variable. Why is there a positive relationship? Produce a residual plot. Is the model adequate? Are there any outliers or influential observations? Use the model to forecast the electricity demand that you would expect for the next day if the maximum temperature was\\(15^\\circ \\text{C}\\)and compare it with the forecast if the with maximum temperature was\\(35^\\circ \\text{C}\\). Do you believe these forecasts? The following R code will get you started: Give prediction intervals for your forecasts. Plot Demand vs Temperature for all of the available data invic_elecaggregated to daily total demand and maximum temperature. What does this say about your model? Data setolympic_runningcontains the winning times (in seconds) in each Olympic Games sprint, middle-distance and long-distance track events from 1896 to 2016. An elasticity coefficient is the ratio of the percentage change in the forecast variable (\\(y\\)) to the percentage change in the predictor variable (\\(x\\)). Mathematically, the elasticity is defined as\\((dy/dx)\\times(x/y)\\). Consider the log-log model,\\[ \\log y=\\beta_0+\\beta_1 \\log x + \\varepsilon. \\]Express\\(y\\)as a function of\\(x\\)and show that the coefficient\\(\\beta_1\\)is the elasticity coefficient. The data setsouvenirsconcerns the monthly sales figures of a shop which opened in January 1987 and sells gifts, souvenirs, and novelties. The shop is situated on the wharf at a beach resort town in Queensland, Australia. The sales volume varies with the seasonal population of tourists. There is a large influx of visitors to the town at Christmas and for the local surfing festival, held every March since 1988. Over time, the shop has expanded its premises, range of products, and staff",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_f0323cfb.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/regression-exercises.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Over time, the shop has expanded its premises, range of products, and staff. Theus_gasolineseries consists of weekly data for supplies of US finished motor gasoline product, from 2 February 1991 to 20 January 2017. The units are in âmillion barrels per dayâ. Consider only the data to the end of 2004. The annual population of Afghanistan is available in theglobal_economydata set. (For advanced readers following on from Section7.9). Using matrix notation it was shown that if\\(\\bm{y}=\\bm{X}\\bm{\\beta}+\\bm{\\varepsilon}\\), where\\(\\bm{\\varepsilon}\\)has mean\\(\\bm{0}\\)and variance matrix\\(\\sigma^2\\bm{I}\\), the estimated coefficients are given by\\(\\hat{\\bm{\\beta}}=(\\bm{X}'\\bm{X})^{-1}\\bm{X}'\\bm{y}\\)and a forecast is given by\\(\\hat{y}=\\bm{x}^*\\hat{\\bm{\\beta}}=\\bm{x}^*(\\bm{X}'\\bm{X})^{-1}\\bm{X}'\\bm{y}\\)where\\(\\bm{x}^*\\)is a row vector containing the values of the predictors for the forecast (in the same format as\\(\\bm{X}\\)), and the forecast variance is given by\\(\\text{Var}(\\hat{y})=\\sigma^2 \\left[1+\\bm{x}^*(\\bm{X}'\\bm{X})^{-1}(\\bm{x}^*)'\\right].\\) Consider the simple time trend model where\\(y_t = \\beta_0 + \\beta_1t\\). Using the following results,\\[ \\sum^{T}_{t=1}{t}=\\frac{1}{2}T(T+1),\\quad \\sum^{T}_{t=1}{t^2}=\\frac{1}{6}T(T+1)(2T+1) \\]derive the following expressions: \\(\\displaystyle\\bm{X}'\\bm{X}=\\frac{1}{6}\\left[ \\begin{array}{cc} 6T & 3T(T+1) \\\\ 3T(T+1) & T(T+1)(2T+1) \\\\ \\end{array} \\right]\\) \\(\\displaystyle(\\bm{X}'\\bm{X})^{-1}=\\frac{2}{T(T^2-1)}\\left[ \\begin{array}{cc} (T+1)(2T+1) & -3(T+1) \\\\ -3(T+1) & 6 \\\\ \\end{array} \\right]\\) \\(\\displaystyle\\hat{\\beta}_0=\\frac{2}{T(T-1)}\\left[(2T+1)\\sum^T_{t=1}y_t-3\\sum^T_{t=1}ty_t \\right]\\) \\(\\displaystyle\\hat{\\beta}_1=\\frac{6}{T(T^2-1)}\\left[2\\sum^T_{t=1}ty_t-(T+1)\\sum^T_{t=1}y_t \\right]\\) \\(\\displaystyle\\text{Var}(\\hat{y}_{t})=\\hat{\\sigma}^2\\left[1+\\frac{2}{T(T-1)}\\left(1-4T-6h+6\\frac{(T+h)^2}{T+1}\\right)\\right]\\)",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_f0323cfb.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/non-seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": "If we combine differencing with autoregression and a moving average model, we obtain a non-seasonal ARIMA model. ARIMA is an acronym for AutoRegressive Integrated Moving Average (in this context, âintegrationâ is the reverse of differencing). The full model can be written as\\[\\begin{equation} y'_{t} = c + \\phi_{1}y'_{t-1} + \\cdots + \\phi_{p}y'_{t-p} + \\theta_{1}\\varepsilon_{t-1} + \\cdots + \\theta_{q}\\varepsilon_{t-q} + \\varepsilon_{t}, \\tag{9.1} \\end{equation}\\]where\\(y'_{t}\\)is the differenced series (it may have been differenced more than once). The âpredictorsâ on the right hand side include both lagged values of\\(y_t\\)and lagged errors. We call this anARIMA(\\(p, d, q\\)) model, where The same stationarity and invertibility conditions that are used for autoregressive and moving average models also apply to an ARIMA model. Many of the models we have already discussed are special cases of the ARIMA model, as shown in Table9.1. Once we start combining components in this way to form more complicated models, it is much easier to work with the backshift notation. For example, Equation(9.1)can be written in backshift notation as\\[\\begin{equation} \\tag{9.2} \\begin{array}{c c c c} (1-\\phi_1B - \\cdots - \\phi_p B^p) & (1-B)^d y_{t} &= &c + (1 + \\theta_1 B + \\cdots + \\theta_q B^q)\\varepsilon_t\\\\ {\\uparrow} & {\\uparrow} & &{\\uparrow}\\\\ \\text{AR($p$)} & \\text{$d$ differences} & & \\text{MA($q$)}\\\\ \\end{array} \\end{equation}\\] Selecting appropriate values for\\(p\\),\\(d\\)and\\(q\\)can be difficult. However, theARIMA()function from thefablepackage will do it for you automatically. In Section9.7, we will learn how this function works, along with some methods for choosing these values yourself. Figure9.7shows Egyptian exports as a percentage of GDP from 1960 to 2017. Figure 9.7: Annual Egyptian exports as a percentage of GDP since 1960. The following R code selects a non-seasonal ARIMA model automatically",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_f1cf3fa6.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/non-seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Figure 9.7: Annual Egyptian exports as a percentage of GDP since 1960. The following R code selects a non-seasonal ARIMA model automatically. This is an ARIMA(2,0,1) model:\\[ y_t = 2.56 + 1.68 y_{t-1} -0.80 y_{t-2} -0.69 \\varepsilon_{t-1} + \\varepsilon_{t}, \\]where\\(\\varepsilon_t\\)is white noise with a standard deviation of\\(2.837 = \\sqrt{8.046}\\). Forecasts from the model are shown in Figure9.8. Notice how they have picked up the cycles evident in the Egyptian economy over the last few decades. Figure 9.8: Forecasts of Egyptian exports. TheARIMA()function is useful, but anything automated can be a little dangerous, and it is worth understanding something of the behaviour of the models even when you rely on an automatic procedure to choose the model for you. The constant\\(c\\)has an important effect on the long-term forecasts obtained from these models. The value of\\(d\\)also has an effect on the prediction intervals â the higher the value of\\(d\\), the more rapidly the prediction intervals increase in size. For\\(d=0\\), the long-term forecast standard deviation will go to the standard deviation of the historical data, so the prediction intervals will all be essentially the same. This behaviour is seen in Figure9.8where\\(d=0\\)and\\(c\\ne0\\). In this figure, the prediction intervals are almost the same width for the last few forecast horizons, and the final point forecasts are close to the mean of the data. The value of\\(p\\)is important if the data show cycles. To obtain cyclic forecasts, it is necessary to have\\(p\\ge2\\), along with some additional conditions on the parameters. For an AR(2) model, cyclic behaviour occurs if\\(\\phi_1^2+4\\phi_2<0\\)(as is the case for the Egyptian exports model). In that case, the average period of the cycles is19\\[ \\frac{2\\pi}{\\text{arc cos}(-\\phi_1(1-\\phi_2)/(4\\phi_2))}. \\] It is usually not possible to tell, simply from a time plot, what values of\\(p\\)and\\(q\\)are appropriate for the data",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_f1cf3fa6.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/non-seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". \\] It is usually not possible to tell, simply from a time plot, what values of\\(p\\)and\\(q\\)are appropriate for the data. However, it is sometimes possible to use the ACF plot, and the closely related PACF plot, to determine appropriate values for\\(p\\)and\\(q\\). Recall that an ACF plot shows the autocorrelations which measure the relationship between\\(y_t\\)and\\(y_{t-k}\\)for different values of\\(k\\). Now if\\(y_t\\)and\\(y_{t-1}\\)are correlated, then\\(y_{t-1}\\)and\\(y_{t-2}\\)must also be correlated. However, then\\(y_t\\)and\\(y_{t-2}\\)might be correlated, simply because they are both connected to\\(y_{t-1}\\), rather than because of any new information contained in\\(y_{t-2}\\)that could be used in forecasting\\(y_t\\). To overcome this problem, we can usepartial autocorrelations. These measure the relationship between\\(y_{t}\\)and\\(y_{t-k}\\)after removing the effects of lags\\(1, 2, 3, \\dots, k - 1\\). So the first partial autocorrelation is identical to the first autocorrelation, because there is nothing between them to remove. Each partial autocorrelation can be estimated as the last coefficient in an autoregressive model. Specifically,\\(\\alpha_k\\), the\\(k\\)th partial autocorrelation coefficient, is equal to the estimate of\\(\\phi_k\\)in an AR(\\(k\\)) model. In practice, there are more efficient algorithms for computing\\(\\alpha_k\\)than fitting all of these autoregressions, but they give the same results. Figures9.9and9.10shows the ACF and PACF plots for the Egyptian exports data shown in Figure9.7. The partial autocorrelations have the same critical values of\\(\\pm 1.96/\\sqrt{T}\\)as for ordinary autocorrelations, and these are typically shown on the plot as in Figure9.10. Figure 9.9: ACF of Egyptian exports. Figure 9.10: PACF of Egyptian exports. A convenient way to produce a time plot, ACF plot and PACF plot in one command is to use thegg_tsdisplay()function withplot_type = \"partial\"",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_f1cf3fa6.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "Forecasting: Principles and Practice (3rd ed)",
    "author": "Rob J Hyndman, George Athanasopoulos",
    "source": "https://otexts.com/fpp3/non-seasonal-arima.html",
    "date_published": "23 March 2025",
    "flag": "",
    "chunk_text": ". Figure 9.10: PACF of Egyptian exports. A convenient way to produce a time plot, ACF plot and PACF plot in one command is to use thegg_tsdisplay()function withplot_type = \"partial\". If the data are from an ARIMA(\\(p\\),\\(d\\),0) or ARIMA(0,\\(d\\),\\(q\\)) model, then the ACF and PACF plots can be helpful in determining the value of\\(p\\)or\\(q\\). If\\(p\\)and\\(q\\)are both positive, then the plots do not help in finding suitable values of\\(p\\)and\\(q\\). The data may follow an ARIMA(\\(p\\),\\(d\\),0) model if the ACF and PACF plots of the differenced data show the following patterns: The data may follow an ARIMA(0,\\(d\\),\\(q\\)) model if the ACF and PACF plots of the differenced data show the following patterns: In Figure9.9, we see that there is a decaying sinusoidal pattern in the ACF, and in Figure9.10the PACF shows the last significant spike at lag 4. This is what you would expect from an ARIMA(4,0,0) model. This model is only slightly worse than the ARIMA(2,0,1) model identified byARIMA()(with an AICc value of 294.70 compared to 294.29). We can also specify particular values ofpdq()thatARIMA()can search for. For example, to find the best ARIMA model with\\(p\\in\\{1,2,3\\}\\),\\(q\\in\\{0,1,2\\}\\)and\\(d=1\\), you could useARIMA(y ~ pdq(p=1:3, d=1, q=0:2)). arc cos is the inverse cosine function. You should be able to find it on your calculator. It may be labelled acos or cos\\(^{-1}\\).â©ï ̧",
    "chunk_id": "forecasting_principles_and_practice_(3rd_ed)_f1cf3fa6.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": "Machine Learningâs deployment stack is maturing Much has been written about struggles of deploying machine learning projects to production. As with many burgeoning fields and disciplines, we donât yet have a shared canonical infrastructure stack or best practices for developing and deploying data-intensive applications. This is both frustrating for companies that would prefer making ML an ordinary, fuss-free value-generating function like software engineering, as well as exciting for vendors who see the opportunity to create buzz around a new category of enterprise software. The new category is often calledMLOps. While there isnât an authoritative definition for the term, it shares its ethos with its predecessor, theDevOpsmovement in software engineering: by adopting well-defined processes, modern tooling, and automated workflows, we can streamline the process of moving from development to robust production deployments. This approach has worked well for software development, so it is reasonable to assume that it could address struggles related to deploying machine learning in production too. Join the O'Reilly online learning platform. Get a free trial today and find answers on the fly, or master something new and useful. However, the concept is quite abstract. Just introducing a new term like MLOps doesnât solve anything by itself, rather, it just adds to the confusion. In this article, we want to dig deeper into the fundamentals of machine learning as an engineering discipline and outline answers to key questions: All ML projects are software projects. If you peek under the hood of an ML-powered application, these days you will often find a repository of Python code. If you ask an engineer to show how they operate the application in production, they will likely show containers and operational dashboardsânot unlike any other software service",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_1"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". If you ask an engineer to show how they operate the application in production, they will likely show containers and operational dashboardsânot unlike any other software service. Since software engineers manage to build ordinary software without experiencing as much pain as their counterparts in the ML department, it begs the question: should we just start treating ML projects as software engineering projects as usual, maybe educating ML practitioners about the existing best practices? Letâs start by considering the job of a non-ML software engineer: writing traditional software deals with well-defined, narrowly-scoped inputs, which the engineer can exhaustively and cleanly model in the code. In effect, the engineer designs and builds the world wherein the software operates. In contrast, a defining feature of ML-powered applications is that they are directly exposed to a large amount of messy, real-world data which is too complex to be understood and modeled by hand. This characteristic makes ML applications fundamentally different from traditional software. It has far-reaching implications as to how such applications should be developed and by whom: This approach is not novel. There is a decades-long tradition ofdata-centric programming: developers who have been using data-centric IDEs, such as RStudio, Matlab, Jupyter Notebooks, or even Excel to model complex real-world phenomena, should find this paradigm familiar. However, these tools have been rather insular environments: they are great for prototyping but lacking when it comes to production use. To make ML applications production-ready from the beginning, developers must adhere to the same set of standards as all other production-grade software. This introduces further requirements: Two important trends collide in these lists. On the one hand we have the long tradition of data-centric programming; on the other hand, we face the needs of modern, large-scale business applications",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_2"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". On the one hand we have the long tradition of data-centric programming; on the other hand, we face the needs of modern, large-scale business applications. Either paradigm is insufficient by itself: it would be ill-advised to suggest building a modern ML application in Excel. Similarly, it would be pointless to pretend that a data-intensive application resembles a run-off-the-mill microservice which can be built with the usual software toolchain consisting of, say, GitHub, Docker, and Kubernetes. We need a new path that allows the results of data-centric programming, models and data science applications in general, to be deployed to modern production infrastructure, similar to how DevOps practices allows traditional software artifacts to be deployed to production continuously and reliably. Crucially, the new path is analogous but not equal to the existing DevOps path. What kind of foundation would the modern ML application require? It should combine the best parts of modern production infrastructure to ensure robust deployments, as well as draw inspiration from data-centric programming to maximize productivity. While implementation details vary, the major infrastructural layers weâve seen emerge are relatively uniform across a large number of projects. Letâs now take a tour of the various layers, to begin to map the territory. Along the way, weâll provide illustrative examples. The intention behind the examples is not to be comprehensive (perhaps a foolâs errand, anyway!), but to reference concrete tooling used today in order to ground what could otherwise be a somewhat abstract exercise. Datais at the core of any ML project, so data infrastructure is a foundational concern. ML use cases rarely dictate the master data management solution, so the ML stack needs to integrate with existing data warehouses",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_3"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". ML use cases rarely dictate the master data management solution, so the ML stack needs to integrate with existing data warehouses. Cloud-based data warehouses, such asSnowflake, AWSâ portfolio of databases likeRDS, RedshiftorAurora, or anS3-based data lake, are a great match to ML use cases since they tend to be much more scalable than traditional databases, both in terms of the data set sizes as well as query patterns. To make data useful, we must be able to conduct large-scalecomputeeasily. Since the needs of data-intensive applications are diverse, it is useful to have a general-purpose compute layer that can handle different types of tasks from IO-heavy data processing to training large models on GPUs. Besides variety, the number of tasks can be high too: imagine a single workflow that trains a separate model for 200 countries in the world, running a hyperparameter search over 100 parameters for each modelâthe workflow yields 20,000 parallel tasks. Prior to the cloud, setting up and operating a cluster that can handle workloads like this would have been a major technical challenge. Today, a number of cloud-based, auto-scaling systems are easily available, such asAWS Batch. Kubernetes,a popular choice for general-purpose container orchestration, can be configured to work as a scalable batch compute layer, although the downside of its flexibility is increased complexity. Note that container orchestration for the compute layer is not to be confused with the workflow orchestration layer, which we will cover next. The nature of computation is structured: we must be able to manage the complexity of applications by structuring them, for example, as a graph or a workflow that isorchestrated. The workflow orchestrator needs to perform a seemingly simple task: given a workflow or DAG definition, execute the tasks defined by the graph in order using the compute layer. There are countless systems that can perform this task for small DAGs on a single server",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_4"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". There are countless systems that can perform this task for small DAGs on a single server. However, as the workflow orchestrator plays a key role in ensuring that production workflows execute reliably, it makes sense to use a system that is both scalable and highly available, which leaves us with a few battle-hardened options, for instance:Airflow, a popular open-source workflow orchestrator;Argo,a newer orchestrator that runs natively on Kubernetes, and managed solutions such asGoogle Cloud ComposerandAWS Step Functions. While these three foundational layers, data, compute, and orchestration, are technically all we need to execute ML applications at arbitrary scale, building and operating ML applications directly on top of these components would be like hacking software in assembly language: technically possible but inconvenient and unproductive. To make people productive, we need higher levels of abstraction. Enter the software development layers. ML app and software artifacts exist and evolve in a dynamic environment. To manage the dynamism, we can resort to taking snapshots that represent immutable points in time: of models, of data, of code, and of internal state. For this reason, we requirea strong versioning layer. WhileGit,GitHub,and other similar tools for software version control work well for code and the usual workflows of software development, they are a bit clunky for tracking all experiments, models, and data. To plug this gap, frameworks likeMetafloworMLFlowprovide a custom solution for versioning. Next, we need to consider who builds these applications and how. They are often built by data scientists who are not software engineers or computer science majors by training. Arguably, high-level programming languages like Python are the most expressive and efficient ways that humankind has conceived to formally define complex processes. It is hard to imagine a better way to express non-trivial business logic and convert mathematical concepts into an executable form",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_5"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". It is hard to imagine a better way to express non-trivial business logic and convert mathematical concepts into an executable form. However, not all Python code is equal. Python written in Jupyter notebooks following the tradition of data-centric programming is very different from Python used to implement a scalable web server. To make the data scientists maximally productive, we want to provide supportingsoftware architecturein terms of APIs and libraries that allow them to focus on data, not on the machines. With these five layers, we can present a highly productive, data-centric software interface that enables iterative development of large-scale data-intensive applications. However, none of these layers help with modeling and optimization. We cannot expect data scientists to write modeling frameworks like PyTorch or optimizers like Adam from scratch! Furthermore, there are steps that are needed to go from raw data to features required by models. When it comes to data science and modeling, we separate three concerns, starting from the most practical progressing towards the most theoretical. Assuming you have a model, how can you use it effectively? Perhaps you want to produce predictions in real-time or as a batch process. No matter what you do, you should monitor the quality of the results. Altogether, we can group these practical concerns in themodel operationslayer. There are many new tools in this space helping with various aspects of operations, includingSeldonfor model deployments,Weights and Biasesfor model monitoring, andTruErafor model explainability. Before you have a model, you have to decide how to feed it with labelled data. Managing the process of converting raw facts to features is a deep topic of its own, potentially involving feature encoders, feature stores, and so on. Producing labels is another, equally deep topic",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_6"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". Producing labels is another, equally deep topic. You want to carefully manage consistency of data between training and predictions, as well as make sure that thereâs no leakage of information when models are being trained and tested with historical data. We bucket these questions in thefeature engineeringlayer. Thereâs an emerging space of ML-focused feature stores such asTectonor labeling solutions likeScaleandSnorkel. Feature stores aim to solve the challenge that many data scientists in an organization require similar data transformations and features for their work and labeling solutions deal withthe very real challenges associated with hand labeling datasets. Finally, at the very top of the stack we get to the question of mathematical modeling: What kind of modeling technique to use? What model architecture is most suitable for the task? How to parameterize the model? Fortunately, excellent off-the-shelf libraries likescikit-learnandPyTorchare available to help withmodel development. Regardless of the systems we use at each layer of the stack, we want to guarantee the correctness of results. In traditional software engineering we can do this by writing tests: for instance, a unit test can be used to check the behavior of a function with predetermined inputs. Since we know exactly how the function is implemented, we can convince ourselves through inductive reasoning that the function should work correctly, based on the correctness of a unit test. This process doesnât work when the function, such as a model, is opaque to us. We must resort toblack box testingâtesting the behavior of the function with a wide range of inputs. Even worse, sophisticated ML applications can take a huge number of contextual data points as inputs, like the time of day, userâs past behavior, or device type into account, so an accurate test set up may need to become a full-fledged simulator",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_7"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". Since building an accurate simulator is a highly non-trivial challenge in itself, often it is easier to use a slice of the real-world as a simulator and A/B test the application in production against a known baseline. To make A/B testing possible, all layers of the stack should be be able to run many versions of the application concurrently, so an arbitrary number of production-like deployments can be run simultaneously. This poses a challenge to many infrastructure tools of today, which have been designed for more rigid traditional software in mind. Besides infrastructure, effective A/B testing requires a control plane, a modern experimentation platform, such asStatSig. Imagine choosing a production-grade solution for each layer of the stack: for instance, Snowflake for data, Kubernetes for compute (container orchestration), and Argo for workflow orchestration. While each system does a good job at its own domain, it is not trivial to build a data-intensive application that has cross-cutting concerns touching all the foundational layers. In addition, you have to layer the higher-level concerns from versioning to model development on top of the already complex stack. It is not realistic to ask a data scientist to prototype quickly and deploy to production with confidence using such a contraption. Adding more YAML to cover cracks in the stack is not an adequate solution. Many data-centric environments of the previous generation, such as Excel and RStudio, really shine at maximizing usability and developer productivity. Optimally, we could wrap the production-grade infrastructure stack inside a developer-oriented user interface. Such an interface should allow the data scientist to focus on concerns that are most relevant for them, namely the topmost layers of stack, while abstracting away the foundational layers",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_8"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". Such an interface should allow the data scientist to focus on concerns that are most relevant for them, namely the topmost layers of stack, while abstracting away the foundational layers. The combination of a production-grade core and a user-friendly shell makes sure that ML applications can be prototyped rapidly, deployed to production, and brought back to the prototyping environment for continuous improvement. The iteration cycles should be measured in hours or days, not in months. Over the past five years, a number of such frameworks have started to emerge, both as commercial offerings as well as in open-source. Metaflowis an open-source framework, originally developed at Netflix, specifically designed to address this concern (disclaimer:one of the authors works on Metaflow): How can we wrap robust production infrastructure in a single coherent, easy-to-use interface for data scientists? Under the hood, Metaflow integrates with best-of-the-breed production infrastructure, such as Kubernetes and AWS Step Functions, while providing a development experience that draws inspiration from data-centric programming, that is, by treating local prototyping as the first-class citizen. Googleâs open-sourceKubeflowaddresses similar concerns, although with a more engineer-oriented approach. As a commercial product,Databricksprovides a managed environment that combines data-centric notebooks with a proprietary production infrastructure. All cloud providers provide commercial solutions as well, such asAWS SagemakerorAzure ML Studio. While these solutions, and many less known ones, seem similar on the surface, there are many differences between them. When evaluating solutions, consider focusing on the three key dimensions covered in this article: It is safe to say that all existing solutions still have room for improvement. Yet it seems inevitable that over the next five years the whole stack will mature, and the user experience will converge towards and eventually beyond the best data-centric IDEs",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_9"
  },
  {
    "document_type": "online_article",
    "title": "MLOps and DevOps: Why Data Makes It Different",
    "author": "Ville Tuulos",
    "source": "https://www.oreilly.com/radar/mlops-and-devops-why-data-makes-it-different/",
    "date_published": "2021-10-19 10:17:38-04:00",
    "flag": "",
    "chunk_text": ". Yet it seems inevitable that over the next five years the whole stack will mature, and the user experience will converge towards and eventually beyond the best data-centric IDEs. Businesses will learn how to create value with ML similar to traditional software engineering and empirical, data-driven development will take its place amongst other ubiquitous software development paradigms. Tracking need-to-know trends at the intersection of business and technology. Take O’Reilly with you and learn anywhere, anytime on your phoneand tablet. View all O’Reilly videos, Superstream events, and Meet the Expert sessions on yourhome TV. © 2025, O’Reilly Media, Inc. All trademarks and registered trademarks appearing on oreilly.com are the property of their respective owners.",
    "chunk_id": "mlops_and_devops_why_data_makes_it_different.json_chunk_10"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": "REVIEW published: 04 June 2019 doi: 10.3389/fgene.2019.00524 Edited by: Momiao Xiong, University of Texas Health Science Center, United States Reviewed by: Paola Sebastiani, Boston University, United States Shaoyu Li, University of North Carolina at Charlotte, United States *Correspondence: Kun Zhang kunz1@cmu.edu Specialty section: This article was submitted to Statistical Genetics and Methodology, a section of the journal Frontiers in Genetics Received: 07 August 2018 Accepted: 13 May 2019 Published: 04 June 2019 Citation: Glymour C, Zhang K and Spirtes P (2019) Review of Causal Discovery Methods Based on Graphical Models. Front. Genet. 10:524. doi: 10.3389/fgene.2019.00524 Review of Causal Discovery Methods Based on Graphical Models Clark Glymour, Kun Zhang* and Peter Spirtes Department of Philosophy, Carnegie Mellon University, Pittsburgh, PA, United States A fundamental task in various disciplines of science, including biology, is to find underlying causal relations and make use of them. Causal relations can be seen if interventions are properly applied; however, in many cases they are difficult or even impossible to conduct. It is then necessary to discover causal relations by analyzing statistical properties of purely observational data, which is known as causal discovery or causal structure search. This paper aims to give a introduction to and a brief review of the computational methods for causal discovery that were developed in the past three decades, including constraint-based and score-based methods and those based on functional causal models, supplemented by some illustrations and applications. Keywords: directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models 1. INTRODUCTION Almost all of science is about identifying causal relations and the laws or regularities that govern them",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_1"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". INTRODUCTION Almost all of science is about identifying causal relations and the laws or regularities that govern them. Since the seventeenth century beginnings of modern science, there have been two kinds of procedures, and resulting kinds of data, for discovering causes: manipulating and varying features of systems to see what other features do or do not change; and observing the variation of features of systems without manipulation. Both methods shone in the seventeenth century, when they were intertwined then as they are today. Evangelista Torricelli manipulated the angles and shapes of tubes filled with mercury standing in a basin of the stuff, showing the height of the mercury in the tubes did not vary; Pascal had a manometer of Torricelli’s design carried up a mountain, the Puy de Dome, to show that the height of the mercury did vary with altitude. Galileo, for whom Torricelli worked, had identified (qualitatively) the orbits of Jovian satellites from observational time series, and similarly characterized sunspots. Kepler, Galileo’s northern contemporary, adduced his three laws from planetary observations, and a generation later Newton laid the foundations of modern physics with a gravitational law adduced from solar system observations and a single experiment, on pendulums. Modern molecular biology is an experimental subject, but the foundation of biology, in Darwin’s Origin of Species, has only a single experiment, the drifting of seeds. This paper is about the scientific application of a kind of representation of causal relations, directed graphical causal models (DGCMs), and computerized methods for finding true causal representations of that kind from data, whether observational or experimental or both",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_2"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". We focus on it here because while apparently first proposed in 2000 for studies of gene expression ( Murphy and Mian, 1999; Friedman et al., 2000; Spirtes et al., 2000 ), the models have found wide use in systems biology, especially in omics and in neural connectivity studies, and there has recently been an explosion in the number of algorithms that have been proposed and applied for discovering such representations in biological applications. A traditional way to discover causal relations is to use interventions or randomized experiments, which is in many cases too expensive, too time-consuming, or even impossible. Therefore, revealing causal information by analyzing purely observational data, known as causal discovery, has drawn much attention ( Spirtes et al., 2000 ). Past decades have seen a series of cross-disciplinary advances in algorithms for identifying causal relations and effect sizes from observational data or mixed experimental and observational data. These developments promise to enable better use of appropriate “big data.\" They have already been applied in genomics, ecology, epidemiology, space physics, clinical medicine, neuroscience, and many other domains, often with experimental or quasexperimental validation of their predictions. Causal discovery will be the focus of this review. In traditional causality research, algorithms for identification of causal effects, or inferences about the effects of interventions, when the causal relations are completely or partially known, address a different class of problems; see Pearl (2000) and references therein. We will start with the so-called constraint-based as well as score-based methods for causal discovery. Since the 1990’s, conditional independence relationships in the data have been exploited to recover the underlying causal structure. Typical (conditional independence) constraint-based algorithms include PC and Fast Causal Inference (FCI) ( Spirtes et al., 2000 )",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_3"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Typical (conditional independence) constraint-based algorithms include PC and Fast Causal Inference (FCI) ( Spirtes et al., 2000 ). PC assumes that there is no confounder (unobserved direct common cause of two measured variables), and its discovered causal information is asymptotically correct. FCI gives asymptotically correct results even in the presence of confounders. Such approaches are widely applicable because they can handle various types of data distributions and causal relations, given reliable conditional independence testing methods. However, they do not necessarily provide complete causal information because they output (independence) equivalence classes, i.e., a set of causal structures satisfying the same conditional independences. The PC and FCI algorithms produce graphical representations of these equivalence classes. In cases without confounders, there also exist score-based algorithms that aim to find the causal structure by optimizing a properly defined score function. Among them, Greedy Equivalence Search (GES) ( Chickering, 2003 ) is a well-known two-phase procedure that directly searches over the space of equivalence classes. Recently it has been shown that algorithms based on properly defined Functional Causal Models (FCMs) are able to distinguish between different Directed Acyclic Graphs (DAGs) in the same equivalence class. This benefit is owed to additional assumptions on the data distribution than conditional independence relations. A FCM represents the effect variable Y as a function of the direct causes X and some noise term E , i.e., Y = f ( X , E ), where E is independent of X . Thanks to the constrained functional classes, the causal direction between X and Y is identifiable because the independence condition between the noise and cause holds only for the true causal direction and is violated for the wrong direction",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_4"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". We will review causal discovery methods based on linear non-Gaussian models ( Shimizu et al., 2006 ) or non-linear models ( Hoyer et al., 2009; Zhang and Hyvärinen, 2009b ), and discuss their applicability. In practice, for reliable causal discovery one needs to address specific challenges that are often posed in the causal process or the sampling process to generate the observed data. Therefore, we will discuss how to deal with a number of such practical issues, which include causality in time series, measure error, missing data, non-stationarity or heterogeneity of the data, and selection bias. We finally briefly discuss the applications of causal search algorithms as well as some related methods in biology and offer some guidance for their choice and use. 2. DIRECTED GRAPHICAL CAUSAL MODELS A DGCM has the following components: (1) a set of variables, regarded as “random variables,\" (2) a set of directed edges between pairs of variables, each edge regarded as the hypothesis that the two variables would be associated if all other variables were fixed at some values while the tail variable is exogenously varied, and (3) a joint probability distribution over the possible values of all of the variables. The variables can be time indexed, forming a set of causally related stochastic processes; some of the variables can be unmeasured; the variables can be categorical, ordinal, or continuous; there can be measurement error and selection bias, also graphically represented; and there can be (and are usually assumed to be) omitted sources of variation specific to each variable, often deemed “noise” or “disturbances.” A class of DGCMs, commonly presented as “structural equation models” (SEMs), or functional causal models (FCMs), assumes the value of each variable is a deterministic function of its direct causes in the graph and the unmeasured disturbances. The function linking a variable to its direct causes can be any whatsoever, although linear models are most common",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_5"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". The function linking a variable to its direct causes can be any whatsoever, although linear models are most common. The class of DGCMs includes, but is more general than, regression models, factor models, ARM time series models, latent class models, and others. Requiring neither initial conditions (except in time series) nor boundary conditions, DGCMs contrast with differential and partial differential systems of equations, which can also be representations of a system of causal relations. Note that not all directed graphical models have causal interpretations–traditional graphical models provide a compact, yet flexible, way to decompose the joint distribution of the data as a product of simpler factors ( Koller and Friedman, 2009 ), and the second component of a DGCM given above is essential for a directed graph to have a causal meaning. It states that two variables with an edge in between are associated if all other variables were fixed at some values while the tail variable is exogenously varied and, hence, indicates that if X i → X j in the directed graph, then X i is a direct cause of X j . In other words, it says that if X i → X j in the directed graph, then there exist interventions on X i that will directly change the distribution (or value) of X j . The causal Bayesian network was defined in a similar way by Pearl (2000, p.23 ) . The pairing of a directed graph and a joint probability distribution on values of its variables is subject to constraints. In the case of a directed graph without cycles (no closed directed paths) the constraint is that a graphical condition– d-separation –must imply conditional independence in the probability distribution. A path from a vertex X 1 to a vertex X n is a sequence of distinct vertices < X 1 , , X n > such that for each pair of vertices X i and X i + 1 , there is an edge X i → X i + 1 or X i + 1 → X i . A directed path from X i to X n is a path in which for each pair X i and X i + 1 , X i → X i + 1",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_6"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". A directed path from X i to X n is a path in which for each pair X i and X i + 1 , X i → X i + 1 . A variable X i is a collider on a path P iffthe path contains X i − 1 → X i ← X i + 1 (i.e., X i is a common effect of its neighbors on the path); otherwise it is a non-collider. For three disjoint sets of variables X , Y , and S , X is d-separated from Y conditional on S iffall paths between any member of X and any member of Y are blocked by S . The path P is blocked by S if 1) any non-collider on P is in S or if 2) P contains a collider which is not in S and whose descendants are not in S , either. The graphical property of d -separation and its connection with conditional independence has a more intuitive but less practically useful equivalent in the local Markov Condition: every variable, X , in a directed acyclic graph, is independent of its non-descendants conditional on its parents (the variables with edges directed into X ). The Markov condition can be thought of as a generalization of a familiar principle in experimental inference: fixing the values of variables that directly influence some variable of interest, X , “screens off” more remote causes that can only influence X via the more direct causes. Graphs that have the same d -separation properties are usually called “Markov equivalent” and imply the same conditional independence relations; a collection of all directed acyclic graphs that are Markov equivalent is a Markov Equivalence Class (MEC). For linear systems, the graphical property of d -separation has been generalized to directed graphs with cycles–closed directed paths ( Spirtes, 1995 ). For a system that has a graph that represents the marginalized graph of a larger system, there is a corresponding relation, m -separation ( Ayesha et al., 2009 ). When the Markov condition is assumed to hold for a causal graph and its associated population distribution, it is called the Causal Markov Assumption",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_7"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". When the Markov condition is assumed to hold for a causal graph and its associated population distribution, it is called the Causal Markov Assumption . It is important to note that d-separation and related properties provide necessary but not sufficient conditions for conditional independence relations in the joint probability distribution over the values of the variables. The probability distribution may have additional conditional independence relations that are not entailed by d-separation applied to a graph. When no such extra conditional independence relations hold the distribution is said to be faithful to the graph (and when assumed to be true of the causal graph and its corresponding population distribution is called the Causal Faithfulness Assumption ). The reason for regarding the graphical relations in a DGCM as causal claims, not just a representation of associations or dependence, is that a DGCM entails claims about the results of many hypothetical experiments: if an acyclic DGCM contains a directed edge X → Y , the experimental claim is that if every other variable represented in the graph is held fixed, X and Y will covary if X is forced to vary, but not if Y is forced to vary. These experimental predictions can be computed from the graph and the probability distribution ( Spirtes et al., 2001 ). 3. TRADITIONAL CONSTRAINT-BASED AND SCORE-BASED CAUSAL DISCOVERY METHODS Roughly speaking, causal search methods are nothing but statistical estimation of parameters describing a graphical causal structure. It is computationally intensive estimation, but statistical estimation of parameters nonetheless, and so understood, something familiar. Most statistical estimators give a number or an interval, the estimated correlation, directly as a function of the data. But other estimators are more laborious",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_8"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Most statistical estimators give a number or an interval, the estimated correlation, directly as a function of the data. But other estimators are more laborious. In all but simple models, the estimate of a posterior probability distribution, for example, or the estimate of a cyclic structural equation model usually requires iterative or Monte Carlo procedures, sometimes explicitly described as “searches” ( Hoff, 2009 ). The parameters to be estimated in the simple case of an acyclic model with non-interactive causes and no unobserved confounders (a confounder is an unobservable direct common cause of two observed variables) are just the entries in an N × N matrix, where N is the number of variables, and an ( i , j )th entry indicates whether variable j is the parent of variable i . When “latent” variables are allowed, two possible values for an entry are needed, one indicating a direct connection, the other indicating a confounding by an unobserved common cause. A further value can be added when a direct connection between a pair of variables is unknown rather than known to be absent. The issue is how to estimate any of these parameters. Statistical estimation has various desiderata. Statistical “consistency,\" that is, under sampling assumptions, the estimates converge in probability or almost surely to the true value; uniform convergence, in which there are probabilistic bounds on the size of errors at finite sample sizes, etc. Graphical causal model search based on the Faithfulness assumption and which conditional independence relations hold has in general only “pointwise\" consistency, which does not provide finite sample error probabilities and does not provide confidence intervals for the estimated structure; although in sequences of models in which the number of variables and sparsity of the graph is controlled as a function of the sample size, there is a uniform consistency result when assumptions stronger than Faithfulness are made ( Kalisch and Bühlmann, 2007 )",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_9"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". For the most part, there are two classes of search algorithms, and their sub-classes and “nearby methods.” One class of search algorithms tries to efficiently search for a MEC of graphs that most closely entails (under the Causal Markov and Faithfulness Assumptions) the set of conditional independence relations judged to hold in the population. Another class of algorithms estimates the dependencies or conditional independencies of each variable on independent noises, and uses these relations to construct a directed graphical model. We will illustrate how each of these is possible, and mention some variants. 3.1. The PC Algorithm One of the oldest algorithms that is consistent under i.i.d. sampling assuming no latent confounders is the PC algorithm ( Spirtes et al., 2001 ), which provides a search architecture into which can be plugged many statistical procedures for deciding conditional independence. Suppose then we have some such statistical decision procedure, which might be a hypothesis test for conditional independence, or a method based on the difference of fitting scores such as the Bayesian Information FIGURE 1 | Illustration of how the PC algorithm works. (A) Original true causal graph. (B) PC starts with a fully-connected undirected graph. (C) The X − Y edge is removed because X ⊥⊥ Y . (D) The X − W and Y − W edges are removed because X ⊥⊥ W | Z and Y ⊥⊥ W | Z . (E) After finding v-structures. (F) After orientation propagation. Criterion (BIC) between models with and without a particular directed edge. Let the true structure be as in Figure 1A . By d -separation, this structure implies that X is independent of Y , written X ⊥⊥ Y , and that X and Y are each independent of W conditional on Z , written { X , Y } ⊥⊥ W | Z . Suppose when called, the statistical decision procedure finds these relations",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_10"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Suppose when called, the statistical decision procedure finds these relations. PC is based on the fact that under the causal Markov condition and the faithfulness assumption, when there is no latent confounder, two variables are directly causally related (with an edge in between) if and only if there does not exist any subset of the remaining variables conditioning on which they are independent ( Spirtes et al., 2001 ). It works like this: 1. Form a complete undirected graph, as in Figure 1B . 2. Eliminate edges between variables that are unconditionally independent; in this case that is the X − Y edge, giving the graph in Figure 1C . 3. For each pair of variables ( A , B ) having an edge between them, and for each variable C with an edge connected to either of them, eliminate the edge between A and B if A ⊥⊥ B | C as in Figure 1D . 4. For each pair of variables A , B having an edge between them, and for each pair of variables { C , D } with edges both connected to A or both connected to B , eliminate the edge between A and B if A ⊥⊥ B | { C , D } . Continue checking independencies conditional on subsets of variables of increasing size n until there are no more adjacent pairs ( A , B ), such that there is a subset of variables of size n such that all of the variables in the subset are adjacent to A or all adjacent to B . In the considered example, Z and W are not independent conditional on X or on Y or on both X and Y , so there are no further statistical decisions to make. Similarly for X and Z , and for Y and Z . 5. For each triple of variables ( A , B , C ) such that A and B are adjacent, B and C are adjacent, and A and C are not adjacent, orient the edges A − B − C as A → B ← C , if B was not in the set conditioning on which A and C became independent and the edge between them was accordingly eliminated. We call such a triple of variables a v-structure . In the example, Z was not conditioned on in eliminating the X − Y edge, so orient X − Z − Y as X → Z ← Y , with the result given in Figure 1E . 6",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_11"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". We call such a triple of variables a v-structure . In the example, Z was not conditioned on in eliminating the X − Y edge, so orient X − Z − Y as X → Z ← Y , with the result given in Figure 1E . 6. For each triple of variables such that A → B − C , and A and C are not adjacent, orient the edge B − C as B → C . This is called orientation propagation . In Figure 1F , Y → Z − W is oriented as Y → Z → W . In this example, the true structure is recovered uniquely. There are several other simple orientation propagation rules that are not illustrated here. The inference steps illustrated are not tuned for the example; they are instances of a general set of rules that hold for any i.i.d. data from a directed acyclic graph. If the conditional independence decisions are correct in the large sample limit, the PC algorithm is guaranteed to converge to the true Markov Equivalence Class in the large sample limit, assuming the Causal Markov and Faithfulness assumptions, i.i.d. samples, and no unmeasured confounders. Note that in some examples, none of orientation rules will apply to a given undirected edge, and that edge will remain undirected in the output. This means that while the two variables are known to be adjacent, it is not known which direction the edge points, or equivalently, there are two different members of the MEC which differ in the direction of that edge. The graphical object with a mixture of directed and undirected edges is called a pattern or CPDAG (Completed Partially Directed Acyclic Graph) that represents a MEC of DAGs. For sparse graphs, the PC algorithm is feasible on at least tens of thousands of variables (in the linear or multinomial case, in which conditional independence test is computationally efficient)",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_12"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". For sparse graphs, the PC algorithm is feasible on at least tens of thousands of variables (in the linear or multinomial case, in which conditional independence test is computationally efficient). It is worth noting that the output of causal discovery algorithms such as PC is typically different from and much more informative than the so-called “conditional independence graph\" ( Lauritzen, 1996 ), in which two variables are not adjacent if and only if they are conditionally independent given all the remaining variables. (The conditional independence graph reduces to the “partial correlation graph\" in the special case of jointly Gaussian variables.) In conditional independence graphs, edges are undirected, so they do not have a causal interpretation. Furthermore, the adjacencies may be different from the estimated causal graph; for instance, in the above example, X and Y , although marginally independent, are not conditionally independent given the rest of the variables, i.e., { Z , W } . As a consequence, in the conditional independence graph they will be adjacent, different from the causal graph. 3.2. The FCI Algorithm Since its inception, a large number of variations of the PC algorithm have been published and it has been supplemented with a variety of heuristics, or “wrappers.” The most important generalization is the Fast Causal Inference (FCI) Algorithm ( Spirtes et al., 2001 ), which tolerates and sometimes discovers unknown confounding variables. Its results have been shown to be asymptotically correct even in the presence of confounders. Figure 2A , where U is an unmeasured variable, illustrates how this is possible without illustrating the full complexity of the FCI algorithm. FIGURE 2 | IIllustration of how the FCI algorithm is able to determine the existence of latent confunders. (A) Original true causal graph. (B) After edges are removed because of conditional independence relations. (C) The output of FCI, indicating that there is at least one unmeasured confounder of Y and Z",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_13"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". (B) After edges are removed because of conditional independence relations. (C) The output of FCI, indicating that there is at least one unmeasured confounder of Y and Z . As with the first state of the PC procedure, FCI calls statistical independence judgements to prune an undirected graph, yielding Figure 2B . The “o” mark means it can be an arrow head or an arrow tail. The reason for the “o\" marks will become apparent. FCI orients edges by a procedure similar to PC but without assuming that every edge is directed one way or the other. The X Z edge was eliminated without conditioning on Y because X and Z are unconditionally independent; the X Y Z triple is therefore oriented as a “collider\", X > Y < ⊸ Z . In the same way, Y Z W is found to be a collider, Y > Z < ⊸ W , yielding Figure 2C . The bidirected edge between Y and Z indicates that there is at least one unmeasured confounder of Y and Z . The remaining “o\" symbols at X and W indicate that the algorithm cannot tell whether the X , Y connection is a directed edge from X to Y , or an unmeasured confounder, or both; the same for the Z and W . In fact, no algorithm based entirely on conditional independence relations can determine which of these is the case. In contrast to this example, in which one can determine that there is at least one unmeasured confounder of Y and Z , there are other situations in which one can exclude the possibility of having confounders. For instance, consider the causal graph in Figure 1A and suppose we have enough data generated by it. Then in the output of FCI, we know that there cannot be any confounder of Z and W , because otherwise X and W cannot be independent conditioning on Z ( X and W are not d -separated by Z if Z and W have a confounder). As with PC there are variants of FCI, mostly designed to speed up the algorithm at the cost of reduced information (e.g., see the RFCI algorithm Colombo et al., 2012 ). 3.3",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_14"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". As with PC there are variants of FCI, mostly designed to speed up the algorithm at the cost of reduced information (e.g., see the RFCI algorithm Colombo et al., 2012 ). 3.3. The Greedy Equivalence Search Architecture Instead of beginning with a complete undirected graph, as in PC and FCI, the Greedy Equivalence Search (GES) ( Chickering, 2003 ) starts with an empty graph, and adds currently needed edges, and then eliminates unnecessary edges in a pattern. At each step in the algorithm as decision is made as to whether adding a directed edge to the graph will increase fit measured by some quasi-Bayesian score such as BIC, or even by the Z score of a statistical hypothesis test, the edge that most improves fit is added. The resulting model is then mapped to the corresponding Markov equivalence class, and the procedure continued. When the score can no longer be improved, the GES algorithm then asks, edge by edge, which edge removal, if any, will most improve the score, until no further edges can thus be removed. The GES procedure is not so easy to illustrate as is PC, because its trajectory depends on the relative strengths of the associations and conditional associations of the variables. In the large sample limit, however, the two algorithms converge on the same Markov Equivalence Class under assumptions that are nearly the same. On finite samples, the algorithms may give different results, and there is as yet no GES style algorithm for cases with unknown confounders. GFCI ( Ogarrio et al., 2016 ), a combination of GES and FCI, using GES to find a supergraph of the skeleton and FCI to prune the supergraph of the skeleton and find the orientations. GFCI has, however, proved more accurate in many simulations than the original FCI algorithm. 4. NON-GAUSSIAN OR NON-LINEAR METHODS BASED ON FUNCTIONAL CAUSAL MODELS Constraint-based methods for causal discovery involve conditional independence tests, which would be a difficult task if the form of dependence is unknown",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_15"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". It has the advantage that it is generally applicable, but the disadvantages are that faithfulness is a strong assumption and that it may require very large sample sizes to get good conditional independence tests. Furthermore, the solution of this approach to causal discovery is usually non-unique, and in particular, it does not help in determining causal direction in the two-variable case, where no conditional independence relationship is available. What information can we use to fully determine the causal structure? A fundamental issue is given two variables, how to distinguish cause from effect. To do so, one needs to find a way to capture the asymmetry between them. Intuitively, one may think that the physical process that generates effect from cause is more natural or simple in some way than recovering the cause from effect. How can we represent this generating process, and in which way is the causal process more natural or simple than the backward process? When talking about the causal relation between two variables, traditionally people were often concerned with the lineaGaussian case, where the involved variables are Gaussian with a linear causal relation, or the discrete case. It turned out that the former case is one of the atypical situations where the causal asymmetry does not leave a footprint in the observed data or their joint distribution, as explained later in this section. Recently several causal discovery approaches based on Functional Causal Models (FCMs) have been proposed for causal discovery from continuous variables. A FCM represents the effect Y as a function of the direct causes X and some unmeasurable factors or noise: Y = f ( X , ε ; θ 1 ), (1) where ε is the noise term that is assumed to be independent from X , the function f ∈ F explains how Y is generated from X , F is an appropriately constrained functional class, and θ 1 is the parameter set involved in f",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_16"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". We assume that the transformation from ( X , ε ) to ( X , Y ) is invertible, such that N can be uniquely recovered from the observed variables X and Y . For convenience of presentation, let us assume that both X and Y are one-dimensional variables. Without precise knowledge on the data-generating process, the FCM should be flexible enough such that it could be adapted to approximate the true data-generating process; more importantly, the causal direction implied by the FCM has to be identifiable in most cases, i.e., the model assumption, especially the independence between the noise and cause, holds for only one direction, such that it implies the causal asymmetry between X and Y . Under the above conditions, one can then use FCMs to determine the causal direction between two variables, given that they have a direct causal relationship in between and do not have any confounder: for both directions, we fit the FCM, and then test for independence between the estimated noise term and the hypothetical cause, and the direction which gives an independent noise term is considered plausible. It has been shown that without any further assumption on the function f , causal direction is not identifiable because for both directions one can find an independent noise term ( Hyvärinen and Pajunen, 1999; Zhang et al., 2015 ). Several forms of the FCM have been shown to be able to produce unique causal directions, and have received practical applications. In the linear, non-Gaussian, and acyclic model (LiNGAM) ( Shimizu et al., 2006 ), f is linear, and at most one of the noise term ε and cause X is Gaussian. In the posnonlinear (PNL) causal model ( Zhang and Chan, 2006; Zhang and Hyvärinen, 2009b ), the effect Y is further generated by a posnonlinear transformation on the non-linear effect of the cause X plus noise term ε : Y = f 2 ( f 1 ( X ) + ε ), (2) where both f 1 and f 2 are non-linear functions and f 2 is assumed to be invertible",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_17"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". 1 The post-nonlinear transformation f 2 represents sensor or measurement distortion, which is frequently encountered in practice. In particular, the PNL causal model has a very general form (LiNGAM is clearly a special case), but it has been shown to be identifiable in the generic case [except five specific situations given in Zhang and Hyvärinen ( 2009b )]. Another special case of the PNL causal model, the non-linear additive noise model ( Hoyer et al., 2009; Zhang and Hyvärinen, 2009a ) assumes that f is non-linear with additive noise ε , i.e., that f 2 in Equation 2 is the identity mapping. Below 1 In Zhang and Chan (2006) both functions f 1 and f 2 are assumed to invertible; this causal model, as a consequence, can be estimated by making use of post-nonlinear independent component analysis (PNL-ICA) ( Taleb and Jutten, 1999 ), which assumes that the observed data are component-wise invertible transformations of linear mixtures of the independence sources to be recovered. we will discuss the identifiability of causal direction according to various FCMs, how to distinguish cause from effect with the FCM, and the applicability of causal discovery methods based on those FCMs. It is worth noting that in the discrete case, if one knows precisely what FCM class generated the effect from cause, which, for instance, may be the noisy AND or noisy XOR gate, then under mild conditions the causal direction can be easily seen from the data distribution. However, generally speaking, if the precise functional class of the causal process is unknown, in the discrete case it is difficult to recover the causal direction from observed data, especially when the cardinality of the variables is small. As an illustration, let us consider the situation where the causal process first generates continuous data and discretizes such data to produce the observed discrete ones. It is then not surprising that certain properties of the causal process are lost due to discretization, making causal discovery more difficult",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_18"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". It is then not surprising that certain properties of the causal process are lost due to discretization, making causal discovery more difficult. In this paper we mainly focus on the continuous case. Readers who are interested in causal discovery from discrete variables or mixed discrete and continuous variables may refer to Peters et al. (2010); Cai et al. (2018); Huang et al. (2018) . 4.1. Method Based on the Linear, Non-gaussian Model The linear causal model in the two-variable case can be written as: Y = bX + ε , (3) where ε ⊥⊥ X . Let us first give an illustration with simple examples why it is possible to identify the causal direction between two variables in the linear case. Assume Y is generated from X in a linear form, i.e., Y = X + ε , where ε ⊥⊥ X . Figure 3 gives the scatterplot of 1,000 data points of the two variables X and Y (columns 1 and 3) and that of the predictor and regression residual for two different regression tasks (columns 2 and 4). The three rows correspond to different settings: X and E are both Gaussian (case 1), uniformly distributed (case 2), and distributed according to some super-Gaussian distribution (case 3). In the latter two settings, X and E are non-Gaussian, and one can see clearly that for regression of X given Y (the anti-causal or backward direction), the regression residual is not independent from the predictor anymore, although they are uncorrelated by construction of regression. In other words, in those two situations the regression residual is independent from the predictor only for the correct causal direction, giving rise to the causal asymmetry between X and Y . Rigorously speaking, if at most one of X and ε is Gaussian, the causal direction is identifiable, due to the independent component analysis (ICA) theory ( Hyvärinen et al., 2001 ), or more fundamentally, due to the DarmoiSkitovich theorem ( Kagan et al., 1973 ). This is known as the LiNGAM ( Shimizu et al., 2006 )",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_19"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". This is known as the LiNGAM ( Shimizu et al., 2006 ). LiNGAM can be estimated from observational data in a computationally relatively efficient way. Suppose we aim to estimate the causal model underlying the observable random vector X = ( X 1 , , X n ) ⊺ . (Note that here we abuse notation FIGURE 3 | Illustration of causal asymmetry between two variables with linear relations. The causal relation is X → Y . From top to bottom: X and E both follow the Gaussian distribution (case 1), uniform distribution (case 2), and Laplace distribution (case 3). The two columns on the left show the scatter plot of X and Y and that of X and the regression residual for regressing Y on X , and the two columns on the right correspond to regressing X on Y . slightly by using X as a vector of random variables and X i as a random variable, while X denoted a random variable above.) In matrix form we can represent such causal relations with a matrix B , i.e., X = BX + E , where B can be permuted to a strictly lowetriangular matrix and E is the vector of independent error terms. This can be rewritten as: E = ( I − B ) X , (4) where I denotes the identity matrix. The approach of ICLiNGAM ( Shimizu et al., 2006 ) estimate the matrix B in two steps. It first applies ICA ( Hyvärinen et al., 2001 ) on the data: Z = WX , (5) such that Z has independent components. Second, an estimate of B can be found by permuting and resealing the matrix W , as implied by the correspondence between (Equations 4, 5). As the number of variables, n , increases, the estimated linear transformation W may more likely converge to local optima and involve more and more random errors, causing estimation errors in the causal model. Bear in mind that the causal matrix we aim to estimate, B , is very sparse because it can be permuted to a strictly lower-triangular matrix",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_20"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Bear in mind that the causal matrix we aim to estimate, B , is very sparse because it can be permuted to a strictly lower-triangular matrix. Hence, to improve the estimation efficiency, one may enforce the sparsity constraint on the entries of W , as achieved by ICA with sparse connections ( Zhang et al., 2009 ) or the Two-Step method ( Sanchez-Romero et al., 2019 ). Another way to reduce the estimation error is to find the causal ordering by recursively performing regression and independence test between the predictor and residual, as done by DirectLiNGAM ( Shimizu et al., 2011 ). It is worth mentioning that in the linear case, it is possible to further estimate the effect of the underlying confounders in the system, if there are any, by exploiting overcomplete ICA (which allows more independent sources than observed variables) ( Hoyer et al., 2008 ). Furthermore, when the underlying causal model has cycles or feedbacks, which violates the acyclicity assumption, one may still be able to reveal the causal knowledge under certain assumptions ( Lacerda et al., 2008; Sanchez-Romero et al., 2019 ). Finally, one may then challenge the non-Gaussianity assumption in the LiNGAM model as well as its extensions. Here we argue that in the linear case, non-Gaussian distributions are ubiquitous. Cramér’s decomposition theorem states that if the sum of two independent real-valued random variables is Gaussian, then both of the summand variables much be Gaussian as well; see ( Cramér, 1970, page 53). By induction, this means that if the sum of any finite independent real-valued variables is Gaussian, then all summands must be Gaussian. In other words, a Gaussian distribution can never be exactly produced by linear composition of variables any of which is non-Gaussian. This nicely complements the central limit theorem: (under proper conditions) the sum of independent variable get closer to Gaussian, but it cannot be exactly Gaussian, except all summand variables are Gaussian",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_21"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". This linear closure property of the Gaussian distribution implies the rareness of the Gaussian distribution and ubiquitousness of non-Gaussian distributions, if we believe the relations between variables are linear. However, the closer it gets to Gaussian, the harder it is to distinguish the direction. Hence, the practical question is, are the errors typically non-Gaussian enough to distinguish causal directions in the linear case? 4.2. Non-linear Methods In practice non-linear transformation is often involved in the data generating process, and should be taken into account in the functional class. As a direct extension of LiNGAM, the non-linear additive noise model represents the effect as a non-linear function of the cause plus independent error ( Hoyer et al., 2009 ): Y = f AN ( X ) + ε . (6) The above model, as well as LiNGAM, enforces rather strong constraints on the causal process. If the assumed FCM is too restrictive to be able to approximate the true data generating process, the causal discovery results may be misleading. Therefore, if the specific knowledge about the data generating mechanism is not available, to make it useful in practice, the assumed causal model should be general enough, such that it can reveal the data generating processes approximately. The PNL causal model takes into account the non-linear influence from the cause, the noise effect, and the possible sensor or measurement distortion in the observed variables ( Zhang and Chan, 2006; Zhang and Hyvärinen, 2009b ). See (2) for its form. It has the most general form among all well-defined FCMs according to which the causal direction is identifiable in the general case. (The model used in Mooij et al. ( 2010 ) does not impose structural constraints but assumes a certain type of smoothness; however, it does not lead to theoretical identifiability results.) Clearly it contains the linear model and non-linear additive noise model as special cases",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_22"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". The multiplicative noise model, Y = X · ε , where all involved variables are positive, is another special case, since it can be written as Y = exp(log X + log ε ), where log ε is considered as a new noise term, f 1 ( X ) = log( X ), and f 2 ( · ) = exp( · ). The identifiability of the causal direction is a crucial issue in FCM-based causal discovery. Since LiNGAM and the nolinear additive noise model are special cases of the PNL causal model, the identifiability conditions of the causal direction for the PNL causal model also entail those for the former two FCMs. Such identifiability conditions for the PNL causal model was established by a proof by contradiction ( Zhang and Hyvärinen, 2009b ). It assumes the causal model holds in both directions X → Y and Y → X , and show that this implies very strong conditions on the distributions and functions involved in the model. Under certain conditions [e.g., p ( ε ) is positive on ( −∞ , +∞ )], there are only all five cases in which the causal direction is not identifiable according to the PNL causal model ( Zhang and Hyvärinen, 2009b ). The first one is the linear-Gaussian case, in which the causal direction is well-known to be non-identifiable. Suppose the data were generated according to the PNL causal model in settings other than those specific conditions; then in principle, the backward direction does not follow the model, and the causal direction can be determined. Generally speaking, causal discovery based on non-linear FCMs are not computationally as efficient as in the linear case. Non-linear causal models have been used for distinguishing cause from effect given two variables which are believed to be directly causally related ( Hoyer et al., 2009; Zhang and Hyvärinen, 2009b; Peters et al., 2017 ): they are fitted to data in both directions, and the direction in which the estimated noise is independent from the hypothetical cause (or equivalently, the direction with a higher likelihood) is regarded as causal direction",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_23"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". They can be easily combined with conditional independence-based methods ( Zhang and Hyvärinen, 2009b ): conditional independence-based methods estimate the MEC from observational data with nolinear or non-parametric methods for conditional independence tests (e.g., the kernel-based method Zhang et al., 2011a ), and then non-linear models are applied to further orient the undirected edges in the MEC. 5. SEVERAL BIOLOGICAL EXAMPLES The Two-Step algorithm and the FASK algorithm ( SancheRomero et al., 2019 ) are two examples of procedures that use adjacency searches to provide an initial undirected directed graph which the algorithms then prune, refine, or extend. NoGaussian features of the signal are then used (in different ways) to direct edges, allowing cyclic graphs. Two-Step, but not FASK, also allows for unmeasured confounding. FASK has been applied ( Ramsey and Bryan, 2018b ) to a famous data set (Sachs’s data set Sachs et al., 2005 ) recording various cellular protein concentrations under a variety of exogenous chemical inputs. Sach’s gives an expert model, and in supplementary data gives additional connections for which the experimental literature is not entirely consistent. The data has been reanalyzed several times by various methods, generally not recovering Sach’s model or the “expert” model alone or with supplementary edges. Allowing these supplementary edges as undirected edges, the “extended expert\" model Ramsey and Andrews use is given in Figure 4 . Using FASK, and using the knowledge that the experimental treatments are exogenous, they recover the model, given in Figure 5 , automatically with default values for the search algorithm. Figure 5 is very close to Figure 4 , replacing undirected edges with directed edges or 2-cycles (cycles between only two variables) and supplementing some directed edges with a feedback reciprocity. The most noticeable fault in the FASK model is the absence of the Mek → ERK edge, which is welestablished",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_24"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". The most noticeable fault in the FASK model is the absence of the Mek → ERK edge, which is welestablished. The Causal Stability algorithm is another example of an automated procedure applied to biological data ( Stekhoven FIGURE 4 | The “extended expert\" model for Sachs’s data set). See Sachs et al. (2005) or Ramsey and Bryan (2018b) for the significance of the variables. et al., 2012 ). The question under consideration was which genes influence the time to flowering of the Arabadopsis thaliana flower. The available data had measurements of expression levels of 21,326 genes for 47 samples from diverse geographic origins. The Causal Stability Ranking algorithm that was used had the following steps. After the data was preprocessed, subsample of size n / 2 were drawn 100 times. On each subsample, the PC algorithm was run, and then for each gene a lower bound on the absolute value of the total causal effect on time to flowering was estimated by the IDA algorithm, using the output pattern of the PC algorithm and the data as input. (Conceptually, the IDA algorithm estimates the total effect of a gene on time to flowering by estimating the total effect for each DAG represented by the output pattern of PC.) The minimum absolute values of the estimated total effect of each gene on time to flowering were then used to rank the genes. Finally, for a range of different q values ( { 100, 150, 200, , 2, 000 } ) the frequency with which each gene appeared in the top q genes was calculated. The median rank over the different values of q was then used to generate a final ranking of the genes. When ordered in this way, the top 25 genes contained 5 genes that were known to cause time to flowering. Of the remaining 20 genes that were not known to cause time to flowering, 13 genes had readily available mutants that could be easily tested experimentally to see if the mutant plants differed significantly from the wild type with respect to time to flowering. Of the 13 mutants, 4 had viability issues",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_25"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Of the 13 mutants, 4 had viability issues. Of the 9 remaining genes without viability issues, 4 were novel genes found to cause time to flowering. FIGURE 5 | The Model for the Sach’s Data estimated by the FASK algorithm. 6. PRACTICAL ISSUES IN CAUSAL DISCOVERY Causal discovery aims to find causal relations by analyzing observational data. The data are produced by not only the underlying causal process, but also the sampling process. In practice, to achieve reliable causal discovery, one needs to address specific challenges posed in the causal process or the sampling process. Below we report some particular issues that have recently been considered; for many of them, better approaches are still needed to improve the reliability and computational efficiency of causal discovery. 6.1. Causality in Time Series Multivariate time series provide the data for many biological and other scientific inquiries, for example mRNA expression series in genomics, and Blood Oxygenation Level Dependent (BOLD) time series in neuropsychology. Finding the causal dynamics generating such data is challenging for many reasons, including that the generating process may be non-linear, the data acquisition rate may be much slower than the underlying rate of changes, there may be measurement error, the system may be non-stationary (i.e., the probability distributions of variables conditional on their causes may change, and even the causal relations may change) and there may be unmeasured confounding causes. The general problem of estimating the causal generating processes for time series is not close to solved, but there is progress in understanding how to deal with these problems in various classes of cases, and increased understanding of why popular methods do not work. In principle, any of the methods described previously, as well as others, can be used on time series. But their accuracies are sensitive to all of the factors just mentioned. There are several strategies for treating time series data",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_26"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". But their accuracies are sensitive to all of the factors just mentioned. There are several strategies for treating time series data. One is to partition the data into disjoint “windows\" and take the measurements in each unit as a data analytic unit. Another is to assume or estimate a number of lagged effects and treat all measurements separated by no more than that number of lags as a data analysis unit. That is a standard procedure in vector autoregression, or what is often called “Granger Causality.\" A further alternative is to treat the measurements at any time as independent of the measurements at any other time. Each has its disadvantages. The window method necessarily omits relations across windows and results may vary with the choice of window size. In the other two procedures, the units are not all independent, but most units are. It is well-established that the most common procedure, Granger causality, is very sensitive to temporal aggregation or subsampling [for the effect of aggregation and subsampling and some possible ways to deal with them, see ( Danks and Plis, 2013; Gong* et al., 2015; Gong et al., 2017 )]. If the sampling rate is equal to the actual time interval required for a signal to propagate (and there is no confounder), Granger’s method is very accurate. However, in many times series, data are subsampled or temporally aggregated due to the measuring device or sampling procedure, or for the purpose of efficient collection and storage. It has been shown that under suitable assumptions, the true causal relations are still identifiable from both subsampled and temporally aggregated data; interested readers may refer to Gong* et al. (2015); Gong et al. (2017) and references therein",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_27"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". (2015); Gong et al. (2017) and references therein. In particular, It was shown that due to highly temporally aggregated data, time-delayed causal influences in the original causal process appear to be instantaneous in the aggregated time series, which implies that the estimated instantaneous causal relations from low-resolution aggregated data are consistent with the underlying causal influences ( Gong et al., 2017 ). On the application side, a good deal of research has been done on functional Magnetic Resonance Imaging (fMRI) time series, including a recent comparison of multiple methods. Roughly speaking, one can view fMRI data as some kind of highly temporally aggregated version of the underlying neural activities. The Two-Step and FASK procedures, described in section 5, prove to have the best precision (percentage of edges found that are correct) and recall (percentage of true edges that are found) ( Sanchez-Romero et al., 2019 ). Remarkably, they are robust to (simulated) errors in variables whose variance is no larger than the measurement-free variance of the variables. Two-step retains high precision but has large recall losses; FASK retains both good precision and recall. 6.2. Other Issues Below are some other issues that arise in many causal discovery tasks. • Deterministic case. In a particular deterministic case where Y = f ( X ) without noise, it is impossible to make use of the independence between noise and the cause to find the causal direction. However, one may exploit a certain type of independence between the transformation f and the distribution of the cause X to characterize the causal asymmetry and determine the causal direction ( Janzing et al., 2012 ). • Nonstationary/heterogenous data. It is commonplace to encounter nonstationary or heterogeneous data, in which the underlying generating process changes over time or across data sets",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_28"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". • Nonstationary/heterogenous data. It is commonplace to encounter nonstationary or heterogeneous data, in which the underlying generating process changes over time or across data sets. Interestingly, if the qualitative causal structure is fixed and the mechanisms or parameters associated with the causal structure may change across data sets or over time (the mechanisms may change such that some causal links in the structure vanish over some time periods or domains), causal discovery may benefit from distribution shift because causal modeling and distribution shift are heavily coupled. This, in particular, inspires a framework for causal mechanism change detection, causal skeleton estimation, causal direction identification, and nonstationary driving force estimation ( Huang et al., 2017; Zhang et al., 2017b ). • Measurement error. Measurement error in the observed values of the variables can greatly change the output of various causal discovery methods. Given the ubiquity of measurement error caused by instruments or proxies used in the measuring process, this problem has received much attention, and sufficient conditions under which the causal model for the underlying measurement-error-free variables can be partially or completely identified in the presence of measurement error with unknown variance have been established ( Zhang et al., 2017a ). This will hopefully inspire a set of causal discovery methods dealing with measurement error. • Selection Bias. Selection bias is an important issue in statistical inference, which arises when the probability of including a data point into the sample depends on some attributes of the point. Selection bias, if not corrected, often distorts the results of statistical analysis and causal discovery and inference. In the presence of outcome-dependent selection bias, with FCM-based causal discovery it is possible to identify the correct causal direction and estimate properties of the causal mechanism ( Zhang et al., 2016 )",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_29"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". More general situations with selection bias remain to be studied. • Missing data. Missing data are ubiquitous in many domains such as healthcare. When these data entries are not missing completely at random, the (conditional) independence relations in the observed data may be different from those in the complete data generated by the underlying causal process. Consequently, simply applying existing causal discovery methods to the observed data may lead to the wrong conclusions. A modified PC algorithm was proposed for causal discovery in the presence of missing data ( Tu et al., 2019 ), whose output is asymptotically correct under certain assumptions. 7. APPLICATION OF CAUSAL DISCOVERY IN BIOLOGY AND SOME GUIDELINES TO PRACTICE A great deal of research in biology applies traditional machine learning techniques to various data sets, e.g., genome sequencing data sets ( Libbrecht and William, 2015 ), without trying to find causal relations. In contrast, within the past two decades there has been an increasing number of publications on reconstructing gene regulatory networks or other types of networks in biology; for reviews of this line of work, see e.g., ( Narendra et al., 2011; Frolova, 2012; Marbach et al., 2012; Villaverde et al., 2013; Djordjevic et al., 2014; Sinoquet, 2014; Li et al., 2015; Liu, 2015; Hill et al., 2016; Banf and Rhee, 2017 ). Not all of them aimed to find causal information represented by directed graphs",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_30"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Not all of them aimed to find causal information represented by directed graphs. Many studies tried to derive weaker notions of causal representations, by making use of pairwise dependence between variables ( Butte and Kohane, 2001; Margolin et al., 2006 ), or estimating a partial correlation graph ( de la Fuente et al., 2004 ), or finding a partial correlation graph and further combining it with heuristic methods to infer partial ordering ( Opgen-Rhein and Strimmer, 2007 ), or learning particular types of undirected graph structure (e.g., a tree structure) from data ( Huynh-Thu and Sanguinetti, 2015; Gitter et al., 2016 ), or discovering Markov Blankets of the variables ( Ram and Chetty, 2011 ). Some work infers causal associations between gene expression and disease ( Schadt et al., 2005 )–luckily, the causal direction between gene expression and disease is known. A number of studies rely on Bayesian network learning to infer certain information of the network; see, e.g., ( Pe’er et al., 2001; Auliac et al., 2008; Adabor et al., 2015 ). Causal discovery methods or their underlying ideas already received some applications in genetics. For instance, the idea of the PC algorithm was adopted to infer causal relationships among phenotypes ( Neto et al., 2010 ), to estimate gene regulatory networks ( Zhang et al., 2011b ), and to model the isoprenoid gene network in Arabidopsis thaliana ( Wille et al., 2004 ). Granger causal analysis received a number of applications in estimation of gene regulatory networks; see, e.g., ( Michailidis and d’Alché Buc, 2013; Emad and Milenkovic, 2014; Carlin et al., 2017; Yang et al., 2017; Finkle et al., 2018 ), and similarly, some findings were based on dynamic Bayesian network learning from observational biological data ( Yu et al., 2004; Wu and Liu, 2008; Vasimuddin and Srinivas, 2017 ). There are also applications of network inference methods to leverage multiple data sets ( Reiss et al., 2006; Joshi et al., 2015; Zitnik and Zupan, 2015; Omranian et al., 2016 )",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_31"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". There are also applications of network inference methods to leverage multiple data sets ( Reiss et al., 2006; Joshi et al., 2015; Zitnik and Zupan, 2015; Omranian et al., 2016 ). Extended approaches to specific types of network estimation problems also exist, including network deconvolution ( Feizi et al., 2013 ) and network inference by ANOVA ( Küffner et al., 2012 ). Overall, although the past 30 years witnessed remarkable progress in development of theories and practical methods for automated causal search, they received rather limited applications in biology–in fact, practical causal analysis is not a matter of pressing a few buttons. There are multiple algorithms available, many of them are poorly tested, some of them are poor implementations of good algorithms, some of them are just plain poor algorithms, all of them have choices of parameters, and all of them have conditions on the data distributions and other assumptions under which they will be informative rather than misleading. We offer some general guidelines to practice (see also Malinsky and Danks, 2018 ). 1. Look at the distributions of the variables. This can be done by visualization or by performing a statistical test. For continuous variables a critical question is whether the distribution is Gaussian or non-Gaussian. This can be checked by an Anderson-Darling Test or eyeballed via a Q plot. If the variables are non-Gaussian, the scatterplots of paired variables can give an indication of whether their relations are linear, polynomial of some obvious kind, periodic, or a mixture of distributions. 2. Check that preprocessing software has not distorted the distributions. For example, standard “high pass\" filtering in fMRI software, eliminates some or all of the non-Gaussianity in variables and, as a consequence, the best available algorithms for fMRI time series become uninformative. 3. For continuous variables, check to see if the data are actually mixtures of different causal processes",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_32"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". 3. For continuous variables, check to see if the data are actually mixtures of different causal processes. If the individual causal processes follow linear-Gaussian models, there is a tool–Unmixer–in the TETRAD suite of causal search tools (http://www.ccd.pitt.edu) , and a tool for non-Gaussian variables is in development. If there are a small number of multiple components, the Unmixer algorithm will sort cases; a distinct label as an exogenous variable can be attached to each case, identifying the component to which it belongs, and searches can be run with that additional information. Alternatively, an algorithm such as IMaGES, designed for differing distributions with different linear coefficients, can be run. 4. If the data contain both categorical and continuous variables and there can possibly be categorical variables that are effects and causes, the Conditional Gaussian search in TETRAD can address the problem. That algorithm has limitations suggested by its name: it assumes conditional on values on categorical parents that a continuous variable is Gaussian, and it assumes there are no latent confounders. Work is in progress on generalizations. Alternatively, the continuous variables can be discretized, which sometimes works best when the continuous variables have very nolinear relations. Discretization has a terrible cost in effective sample size, and is only advisable when the number of samples is much larger compared to the number of variables. 5. There is no consensus about what to do about missing values. There is R software for imputing missing values, and commonly used simple strategies such as imputing a mode or median value of a variable, or even deleting an entire case if it has one or more missing values (not recommended). In search algorithms that proceed by evaluating conditional independence on specially chosen subsets of variables (such as the PC algorithm), evaluations can be done simply by ignoring missing values for the relevant variables",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_33"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". It has been shown that this scheme may produce spurious edges ( Tu et al., 2019 ), and an extension of the PC algorithm was also proposed there, whose results are asymptotically correct under certain assumptions on the missingness mechanism. 6. Decide whether the data may suffer from sample selection bias, or measurement error, or unmeasured common causes. If there is sample selection bias and/or unmeasured common causes, there are algorithms, GFCI, FCI, RFCI in the TETRAD suite, and Matlab procedures, Two-Step, that tolerate unknown latent common causes. 7. Specify known influences between measured variables, or known absences of influences. In experimental data, treatment should not be caused by putative effects of treatment. In fMRI studies, for example, stimuli can be convolved with a hemodynamic response function; in biological experiments, the application of a chemical dosage is an exogenous variable. Known exogenous relations can be used to test a search algorithm: they provide a “gold\" standard. Further, known causal relations actively guide some search algorithms and result in improved recall and precision. 8. If something about the system is known, test search algorithms and parameter choices on simulated systems that, so far as possible, mimic the observed distributions. 9. There is no consensus about choosing parameter values for search. For undirected graphs estimated by LASSO, there is a cross-validation procedure or BIC for parameter setting. For causal searches using a BIC score there is an adjustable penalty that forces sparsity on the output (in finite samples, of course). Work is in progress on how best to adjust search parameter values (e.g., the significance levels in hypothesis tests) as a function of sample size, number of variables, and sparsity",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_34"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Work is in progress on how best to adjust search parameter values (e.g., the significance levels in hypothesis tests) as a function of sample size, number of variables, and sparsity. Search procedures generally do not have confidence intervals for their results, and a “test\" of the whole of a high dimensional model seldom makes any sense: many weak dependencies will not be found, but cumulatively they contribute to the real distribution, and so failure of complete recall will result in rejection of a model. Further, in complex models something is wrong somewhere almost always (precision is not perfect), and the model as a whole will typically be rejected by a test. Comparison tests are of course possible–e.g., against a completely disconnected graphical model–but they are not informative about the truth of the selected model. 10. There are very few publicly available competent tests of model search methods. New methods are proposed almost monthly, and published packages vary in quality of implementation. Accuracy recommendations based on public contests are limited to whatever algorithms were submitted to the contests and the particular properties of the data. For DAG searches for linear models ( Ramsey and Bryan, 2018a ) provides a careful assessment of the most prominent public methods. Bootstrapping an algorithm repeatedly on the data can be informative about how much to trust the output, and can give an estimate of the probabilities of edges . If the results vary widely over the different bootstrap samples, the output should not be trusted. Unfortunately, the converse is not true - stable output is not necessarily correct causal output. 8. CONCLUSION AND DISCUSSIONS Understanding causal relations is helpful for constructing interventions to achieve certain objectives and also enables making predictions under interventions. It is an important issue in most disciplines of science, especially in biology and neuroscience",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_35"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". It is an important issue in most disciplines of science, especially in biology and neuroscience. A traditional way to discover causal relations is to use interventions or randomized experiments, which is, however, in many cases of interest too expensive, too timconsuming, unethical, or even impossible. Therefore, inferring the underlying causal structure from purely observational data, or from combinations of observational and experimental data, has drawn much attention in various disciplines. With the rapid accumulation of huge volumes of data, it is necessary to develop automatic causal search algorithms that scale well. We have reviewed two types of causal search algorithms. One makes use of conditional independence relations in the data to find a Markov equivalence class of directed causal structures. Typical algorithms include the PC algorithm, FCI, and the GES algorithm. The other makes use of suitable classes of TABLE 1 | Comparison of the fundamental causal discovery methods reviewed in this paper. PC FCI GES LiNGAM/PNL/ANM Faithfulness assumption required? Yes Yes Some weaker condition required (not totally clear yet) No Specific assumptions on data distributions required? No No Yes (usually assumes linear-Gaussian models or multinomial distributions) Yes Properly handle confounders? No Yes No No Output Markov equivalence class Partial ancestral graph Markov equivalence class DAG as well as causal model (under the respective identifiability conditions) Remark on practical issues Confounder in the linear, non-Gaussian case Hoyer et al. (2008) ; feedback in linear cases Lacerda et al. (2008); Sanchez-Romero et al. (2019) ; measurement error Zhang et al. (2017a) ; non-stationary times series or heterogeneous multiple data sets Huang et al. (2017); Zhang et al. (2017b) ; missing data Tu et al. (2019) ; subsampled or aggregated time series Danks and Plis (2013); Gong* et al. (2015); Gong et al. (2017) , etc",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_36"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". (2017); Zhang et al. (2017b) ; missing data Tu et al. (2019) ; subsampled or aggregated time series Danks and Plis (2013); Gong* et al. (2015); Gong et al. (2017) , etc. structural equation models and is able to find a unique causal structure under certain assumptions, for which the condition that noise is independent from causes plays an important role. We have reviewed model classes including LiNGAM, the non-linear additive noise (ANM) model, and the post-nonlinear (PNL) causal model. Each of the useful methods has its own pros and cons. The PC algorithm and FCI, as typical methods relying on conditional independence relations, require decisions on conditional independence as input, which is straightforward in linear cases (for instance, by Fisher Z tests or differences in BIC scores) but rather difficult in general non-linear situations. For linear causal relations, the search procedures can scale very well (e.g., PC and GES can easily deal with tens of thousands of variables for sparse graphs). But on the other hand, their output is a Markov equivalence class, which contains all directed graphs sharing the same conditional independence relations–in this case, the output may not be informative enough in certain circumstances. Methods based on structure equations models have to resort to the functional form of the causal influence, and generally speaking, they cannot handle latent confounders in a straightforward way. The non-Gaussian or non-linear functional causal models help identify more detailed information of the causal process; however, causal search methods based on them usually do not scale as well as those conditional-independencbased methods. To estimate LiNGAM, the estimation methods Two-Step and FASK are feasible on thousands of variables generated by a sparse graph. Current methods for estimating non-linear causal models are feasible on only dozens of variables",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_37"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Current methods for estimating non-linear causal models are feasible on only dozens of variables. Table 1 summarizes the assumptions and properties of the fundamental causal discovery methods reviewed in the paper, as well as a summary of the contributions to address some of the practical issues that often arise in causal discovery in biology, especially in genetics. Finally, we note that for reliable causal discovery, one often needs to address particular challenges that may be posed in the causal process or in the sampling process to generate the observed data. Typical challenges include sampling bias in the data, various types of non-linear effects, existence of measurement error, confounding effects, and heterogeneity of the data. Better methods to deal with those issues will clearly improve the quality of causal structure search, especially in genetics. Some Software Packages and Source Code The following software packages that are relevant to causal discovery, among others, are available online",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_38"
  },
  {
    "document_type": "research_paper",
    "title": "Review of Causal Discovery Methods Based on Graphical Models",
    "author": "Kun Zhang",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\Glymour-2019-Review-of-causal-discovery-methods-.pdf",
    "date_published": "2019-05-30",
    "keywords": "directed graphical causal models, causal discovery, conditional independence, statistical independence, structural equation models, non-Gaussian distribution, non-linear models",
    "flag": "",
    "chunk_text": ". Some Software Packages and Source Code The following software packages that are relevant to causal discovery, among others, are available online. • The Tetrad project webpage (Tetrad implements a large number of causal discovery methods, including PC and its variants, FCI, and LiNGAM): http://www.phil.cmu.edu/tetrad/ • Kernel-based conditional independence test ( Zhang et al., 2011a ): http://people.tuebingen.mpg.de/kzhang/KCI-test.zip • LiNGAM and its extensions ( Shimizu et al., 2006, 2011 ): https://sites.google.com/site/sshimizu06/lingam • Fitting the nonlinear additive noise model ( Hoyer et al., 2009 ): http://webdav.tuebingen.mpg.de/causality/additive-noise tar.gz • Distinguishing cause from effect based on the PNL causal model ( Zhang and Hyvärinen, 2009b ): http://webdav.tuebingen.mpg.de/causality/CauseOrEffect_ NICA.rar • Probabilistic latent variable models for distinguishing between cause and effect ( Mooij et al., 2010 ): http://webdav.tuebingen.mpg.de/causality/nips2010-gpcode.tar.gz • Information-geometric causal inference ( Janzing et al., 2012 ): http://webdav.tuebingen.mpg.de/causality/igci.tar.gz AUTHOR CONTRIBUTIONS All authors listed have made a substantial, direct and intellectual contribution to the work, and approved it for publication. FUNDING We would like to acknowledge the support by National Institutes of Health (NIH) under Contract No. NI1R01EB022858-01, FAINR01EB022858, NIH-1R01LM012087, NIH-5U54HG008540-02, and FAIU54HG008540, by the United States Air Force under Contract No. FA8650-17-C-7715, and by National Science Foundation (NSF) EAGER Grant No. IIS-1829681. The NIH, the U.S. Air Force, and the NSF are not responsible for the views reported in this article.",
    "chunk_id": "review_of_causal_discovery_methods_based_on_graphical_models.json_chunk_39"
  },
  {
    "document_type": "research_paper",
    "title": "DoWhy: An End-to-End Library for Causal Inference",
    "author": "Amit Sharma, Emre Kiciman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\sharma_dowhy.pdf",
    "date_published": "2020-11-10",
    "keywords": "",
    "flag": "",
    "chunk_text": "DoWhy: An End-to-End Library for Causal Inference A mit S harma , E mre K iciman M icrosoft R esearch Abstract In addition to efficient statistical estimators of a treatment’s effect, successful application of causal inference requires specifying assumptions about the mechanisms underlying observed data and testing whether they are valid, and to what extent. However, most libraries for causal inference focus only on the task of providing powerful statistical estimators. We describe DoWhy, an open-source Python library that is built with causal assumptions as its firsclass citizens, based on the formal framework of causal graphs to specify and test causal assumptions. DoWhy presents an API for the four steps common to any causal analysis—1) modeling the data using a causal graph and structural assumptions, 2) identifying whether the desired effect is estimable under the causal model, 3) estimating the effect using statistical estimators, and finally 4) refuting the obtained estimate through robustness checks and sensitivity analyses. In particular, DoWhy implements a number of robustness checks including placebo tests, bootstrap tests, and tests for unoberved confounding. DoWhy is an extensible library that supports interoperability with other implementations, such as EconML and CausalML for the the estimation step. The library is available at https://github.com/microsoft/dowhy. 1 INTRODUCTION Many questions in data science are fundamentally causal questions, such as the impact of a marketing campaign or a new product feature, the reasons for customer churn, which drug may work best for which patient, and so on. As the field of data science has grown, many practitioners are realizing the value of causal inference in providing insights from data. However, unlike the streamlined experience for supervised machine learning with libraries like Tensorflow (Abadi et al., 2016) and PyTorch (Paszke et al., 2019), it is non-trivial to build a causal inference analysis",
    "chunk_id": "sharma_dowhy.json_chunk_1"
  },
  {
    "document_type": "research_paper",
    "title": "DoWhy: An End-to-End Library for Causal Inference",
    "author": "Amit Sharma, Emre Kiciman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\sharma_dowhy.pdf",
    "date_published": "2020-11-10",
    "keywords": "",
    "flag": "",
    "chunk_text": ". Software libraries that implement state-of-the art causal inference methods can accelerate the adoption of causal inference among data analysts in both industry and academia. However, we find that for data scientists and machine learning engineers familiar with non-causal methods and unpracticed in the use of causal methods, one of the biggest challenges is the practice of modeling assumptions (i.e., translating domain knowledge into a causal graph) and the implications of these assumptions for causal identification and estimation. What is the right model? Another challenge is in the shift in verification and testing practicalities. Unlike supervised machine learning models that can be validated using held-out test data, causal tasks often have no ground truth answer available. Thus, checking core assumptions and applying sensitivity tests is critical to gaining confidence in results. But how to check those assumptions? Therefore, we built DoWhy, an end-to-end library for causal analysis that builds on the latest research in modeling assumptions and robustness checks (Athey and Imbens, 2017; Kıcıman and Sharma, 2018), and provides an easy interface for analysts to follow the best practices of causal inference. Specifically, DoWhy’s API is organized around the four key steps that are required for any causal analysis: Model, Identify, Estimate, and Refute. Model encodes prior knowledge as a formal causal graph, identify uses graph-based methods to identify the causal effect, estimate uses statistical methods for estimating the identified estimand, and finally refute tries to refute the obtained estimate by testing robustness to initial model’s assumptions. 1 arXiv:2011.04216v1 [stat.ME] 9 Nov 2020 The focus on all the four steps, going from data to the final causal estimate (along with a measure of its robustness) is the key differentiator for DoWhy, compared to many existing libraries for causal inference in Python and R that only focus on estimation (the third step)",
    "chunk_id": "sharma_dowhy.json_chunk_2"
  },
  {
    "document_type": "research_paper",
    "title": "DoWhy: An End-to-End Library for Causal Inference",
    "author": "Amit Sharma, Emre Kiciman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\sharma_dowhy.pdf",
    "date_published": "2020-11-10",
    "keywords": "",
    "flag": "",
    "chunk_text": ". These libraries expect an analyst to have already figured out how to build a reasonable causal model from data and domain knowledge, and to have identified the correct estimand. More critically, they also assume that the analyst may perform their own sensitivity and robustness checks, but provide no guidance on their own; which makes it hard to verify and build robust causal analyses. Under the hood, DoWhy builds on two of the most powerful frameworks for causal inference: graphical models (Pearl, 2009) and potential outcomes (Imbens and Rubin, 2015). It uses graph-based criteria and do-calculus for modeling assumptions and identifying a non-parametric causal effect. For estimation, it switches to methods based primarily on potential outcomes. DoWhy is also built to be interoperable with other libraries that implement the estimation step. It currently supports calling EconML (Microsoft-Research, 2019) and CausalML (Chen et al., 2020) estimators. To summarize, DoWhy provides a unified interface for causal inference methods and automatically tests many assumptions, thus making inference accessible to non-experts. DoWhy is available open-source on Github, https://github.com/microsoft/dowhy , and has a growing community, including over 2300 stars and 31 contributors. Many people have made key contributions that are improving the usability and functionality of the library such as an integrated Pandas interface for DoWhy’s four steps, and we welcome more community contributions. The library makes three key contributions: 1. Provides a principled way of modeling a given problem as a causal graph so that all assumptions are explicit, and identifying a desired causal effect. 2. Provides a unified interface for many popular causal inference estimation methods, combining the two major frameworks of graphical models and potential outcomes. 3. Automatically tests for the validity of causal assumptions if possible and assesses the robustness of the estimate to violations",
    "chunk_id": "sharma_dowhy.json_chunk_3"
  },
  {
    "document_type": "research_paper",
    "title": "DoWhy: An End-to-End Library for Causal Inference",
    "author": "Amit Sharma, Emre Kiciman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\sharma_dowhy.pdf",
    "date_published": "2020-11-10",
    "keywords": "",
    "flag": "",
    "chunk_text": ". 3. Automatically tests for the validity of causal assumptions if possible and assesses the robustness of the estimate to violations. 2 DOWHY AND THE FOUR STEPS OF CAUSAL INFERENCE DoWhy is based on a simple unifying language for causal inference. Causal inference may seem tricky, but almost all methods follow four key steps. Figure 1 shows a schematic of the DoWhy analysis pipeline. I. Model the causal question. DoWhy creates an underlying causal graphical model (Pearl, 2009) for each problem. This serves to make each causal assumption explicit. This graph need not be complete—an analyst may provide a partial graph, representing prior knowledge about some of the variables. DoWhy automatically considers the rest of the variables as potential confounders. II. Identify the causal estimand. Based on the causal graph, DoWhy finds all possible ways of identifying a desired causal effect based on the graphical model. It uses graph-based criteria and do-calculus to find potential ways find expressions that can identify the causal effect. Supported identification criteria are, • Back-door criterion • Front-door criterion • Instrumental Variables • Mediation (Direct and indirect effect identification) III. Estimate the causal effect. DoWhy supports methods based on both back-door criterion and instrmental variables. It also provides a non-parametric confidence intervals and a permutation test for testing the statistical significance of obtained estimate. Supported estimation methods include, Figure 1: The four-step analysis pipeline in DoWhy",
    "chunk_id": "sharma_dowhy.json_chunk_4"
  },
  {
    "document_type": "research_paper",
    "title": "DoWhy: An End-to-End Library for Causal Inference",
    "author": "Amit Sharma, Emre Kiciman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\sharma_dowhy.pdf",
    "date_published": "2020-11-10",
    "keywords": "",
    "flag": "",
    "chunk_text": ". Supported estimation methods include, Figure 1: The four-step analysis pipeline in DoWhy. • Methods based on estimating the treatment assignment: Propensity-based Stratification, Propensity Score Matching, Inverse Propensity Weighting • Methods based on estimating the outcome model: Linear Regression, Generalized Linear Models • Methods based on the instrumental variables identification: Binary Instrument/Wald Estimator, Two-stage least squares, Regression discontinuity • Methods for front-door criterion and general mediation: Two-stage linear regression In addition, DoWhy support integrations with the EconML and CausalML packages for estimating the conditional average treatment effect (CATE). All estimators from these libraries can be directly called from DoWhy. IV. Refute the obtained estimate. Having access to multiple refutation methods to validate an effect estimate from a causal estimator is a key benefit of using DoWhy",
    "chunk_id": "sharma_dowhy.json_chunk_5"
  },
  {
    "document_type": "research_paper",
    "title": "DoWhy: An End-to-End Library for Causal Inference",
    "author": "Amit Sharma, Emre Kiciman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\sharma_dowhy.pdf",
    "date_published": "2020-11-10",
    "keywords": "",
    "flag": "",
    "chunk_text": ". IV. Refute the obtained estimate. Having access to multiple refutation methods to validate an effect estimate from a causal estimator is a key benefit of using DoWhy. Supported refutation methods include: • Add Random Common Cause: Does the estimation method change its estimate after we add an independent random variable as a common cause to the dataset? (Hint: It should not) • Placebo Treatment : What happens to the estimated causal effect when we replace the true treatment variable with an independent random variable? (Hint: the effect should go to zero) • Dummy Outcome: What happens to the estimated causal effect when we replace the true outcome variable with an independent random variable? (Hint: The effect should go to zero) • Simulated Outcome: What happens to the estimated causal effect when we replace the outcome with a simulated outcome based on a known data-generating process closest to the given dataset? (Hint: It should match the effect parameter from the data-generating process) • Add Unobserved Common Causes: How sensitive is the effect estimate when we add an additional common cause (confounder) to the dataset that is correlated with the treatment and the outcome? (Hint: It should not be too sensitive) • Data Subsets Validation: Does the estimated effect change significantly when we replace the given dataset with a randomly selected subset? (Hint: It should not) • Bootstrap Validation : Does the estimated effect change significantly when we replace the given dataset with bootstrapped samples from the same dataset? (Hint: It should not) Many of the above methods aim to refute the full causal analysis, including modeling, identification and estimation (as in Placebo Treatment or Dummy Outcome) whereas others refute a specific step (e.g., Data Subsets and Bootstrap Validation that test only the estimation step). 3 AN EXAMPLE CAUSAL ANALYSIS In this section, we show how causal inference using DoWhy simplifies to four lines of code, each corrsponding to one of the four steps",
    "chunk_id": "sharma_dowhy.json_chunk_6"
  },
  {
    "document_type": "research_paper",
    "title": "DoWhy: An End-to-End Library for Causal Inference",
    "author": "Amit Sharma, Emre Kiciman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\sharma_dowhy.pdf",
    "date_published": "2020-11-10",
    "keywords": "",
    "flag": "",
    "chunk_text": ". 3 AN EXAMPLE CAUSAL ANALYSIS In this section, we show how causal inference using DoWhy simplifies to four lines of code, each corrsponding to one of the four steps. Each analysis starts with a building a causal model. The assumptions can be viewed graphically or in terms of conditional independence statements. Wherever possible, DoWhy can also automatically test for stated assumptions using observed data. # I. Create a causal model from the data and given graph. model = CausalModel( data=data[\"df\"], treatment=data[\"treatment_name\"], outcome=data[\"outcome_name\"], graph=data[\"gml_graph\"]) Given the model, identification is a causal problem. Estimation is simply a statistical problem. DoWhy respects this boundary and treats them separately. This focuses the causal inference effort on identification, and frees up estimation using any available statistical estimator for a target estimand. In addition, multiple estimation methods can be used for a single identified estimand and vice-versa. # II. Identify causal effect and return target estimands identified_estimand = model.identify_effect() # III. Estimate the target estimand using a statistical method. estimate = model.estimate_effect(identified_estimand, method_name=\"backdoor.propensity_score_stratification\") For data with high-dimensional confounders, machine learning-based estimators may be more effective. Therefore, DoWhy supports calling estimators from other libraries like EconML. Here is an example of using the double machine learning estimator (Chernozhukov et al., 2017)",
    "chunk_id": "sharma_dowhy.json_chunk_7"
  },
  {
    "document_type": "research_paper",
    "title": "DoWhy: An End-to-End Library for Causal Inference",
    "author": "Amit Sharma, Emre Kiciman",
    "source": "raw_syllabi\\master_courses\\Data_science\\pdf_material\\sharma_dowhy.pdf",
    "date_published": "2020-11-10",
    "keywords": "",
    "flag": "",
    "chunk_text": ". Therefore, DoWhy supports calling estimators from other libraries like EconML. Here is an example of using the double machine learning estimator (Chernozhukov et al., 2017). import econml dml_estimate = model.estimate_effect( identified_estimand, method_name=\"backdoor.econml.dml.DMLCateEstimator\", confidence_intervals=False, method_params={ \"init_params\":{ ‘model_y’:GradientBoostingRegressor(), ‘model_t’: GradientBoostingRegressor(), ‘model_final’:LassoCV(), ‘featurizer’:PolynomialFeatures(degree=1, include_bias=True)}, \"fit_params\":{}}) print(dml_estimate) The most critical, and often skipped, part of causal analysis is checking the robustness of an estimate to unverified assumptions. DoWhy makes it easy to automatically run sensitivity and robustness checks on the obtained estimate. # IV. Refute the obtained estimate using multiple robustness checks. refute_results = model.refute_estimate(identified_estimand, estimate, method_name=\"random_common_cause\") Finally, DoWhy is easily extensible, allowing other implementations of the four verbs to co-exist. The four verbs are mutually independent, so their implementations can be combined in any way. Example notebooks of using DoWhy for different causal problems are available at https://github.com/microsoft/dowhy/tree/ master/docs/source/example_notebooks. 4 CONCLUSION We presented DoWhy, an extensible and end-to-end library for causal inference. Unlike most other libraries, DoWhy focuses on helping an analyst devise the correct causal model and test its assumptions, in addition to estimating the causal effect. We look forward to extending DoWhy with more refutation and robustness analyses, and supporting more estimation methods with its 4-step API. ACKNOWLEDGEMENTS A big thanks to all the open-source contributors to DoWhy that continue to make important additions to the library’s functionality and usability. The list of contributors is updated at https://github.com/microsoft/ dowhy/blob/master/CONTRIBUTING.md.",
    "chunk_id": "sharma_dowhy.json_chunk_8"
  }
]