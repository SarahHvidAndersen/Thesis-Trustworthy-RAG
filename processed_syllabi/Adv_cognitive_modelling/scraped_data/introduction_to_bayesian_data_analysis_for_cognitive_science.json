{
    "document_type": "online_article",
    "title": "Introduction to Bayesian Data Analysis for Cognitive Science",
    "author": "Bruno Nicenboim",
    "source": "https://bruno.nicenboim.me/bayescogsci/ch-custom.html",
    "date_published": "Unknown",
    "flag": "",
    "text": "Stan includes a large number of distributions, but what happens if we need a distribution that is not provided? In many cases, we can simply build a custom distribution by combining the ever-growing number of functions available in the Stan language. In previous chapters, when faced with response times, we assumed a log-normal distribution. The log-normal distribution moves the inferences relating to the location parameter into a multiplicative frame (see online sectionA.4). Another alternative, however, is to assume a  “reciprocal”-normal distribution of response times. This is referred to hereafter as rec-normal in the text, and as the\\(\\mathit{RecNormal}\\)distribution in equations. That is, we may want to assume that the reciprocal of the response times are normally distributed. This assumption may be theoretically motivated(Harris et al.2014; Harris and Waddington2012)or it may arise from the application of the Box-Cox variance stabilizing transform procedure(Box and Cox1964). An example from psycholinguistics of a data analysis with a reciprocal transform of reading time data appears inWu, Kaiser, and Vasishth (2017). \\[\\begin{equation}\n\\begin{aligned}\n1/y &\\sim \\mathit{Normal}(\\mu, \\sigma) \\\\\ny &\\sim \\mathit{RecNormal}(\\mu, \\sigma)\n\\end{aligned}\n\\tag{10.1}\n\\end{equation}\\] An interesting aspect of the  rec-normal is that it affords an interpretation of the location parameter in terms of  rate or speed rather than time. Analogously to the case of the log-normal, neither the location\\(\\mu\\)nor the scale\\(\\sigma\\)are in the same scale as the dependent variable\\(y\\). These parameters are in the same scale as the transformed dependent variable (here,\\(1/y\\)) that is assumed to be normally distributed. By setting\\(\\mu = 0.002\\)and\\(\\sigma = 0.0004\\), data can be generated from the rec-normal that looks right-skewed and not unlike a distribution of response times. The code below shows some summary statistics of the generated data. Figure10.1shows the distribution generated with the code shown above. FIGURE 10.1: Distribution of synthetic data with a rec-normal distribution with parameters\\(\\mu = 0.002\\)and\\(\\sigma =0.0004\\). We can fit the rec-normal distribution to the response times in a simple model with a normal likelihood, by storing the reciprocal of the  response times (1/RT) in the vector variablerecRT(rather than storing the “raw” response times): One issue here is that the parameters of the likelihood,muandsigmaare going to be very far away from the  unit scale (\\(0.002\\)and\\(0.0004\\)respectively). Due to the way Stan’s sampler is built, parameters that are too small (much smaller than 1) or too large (much larger than 1) can cause convergence problems. A straightforward solution is to fit the normal distribution to parameters in reciprocal of seconds rather than milliseconds; this would make the parameters have values that are\\(1000\\)times larger (\\(2\\)and\\(0.4\\)respectively). We can do this using thetransformed parametersblock.41Although we usemuandsigmato fit the data, the priors are defined on the parametersmu_sandsigma_s(\\(\\mu_s\\)and\\(\\sigma_s\\)). Unless one can rely on previous estimates, finding good priors for\\(\\mu_s\\)and\\(\\sigma_s\\)is not trivial. To define appropriate priors, we would need to start with relatively arbitrary priors, inspect the prior predictive distributions, adjust the priors, and repeat the inspection of prior predictive distributions until these distributions start to look realistic. In the interest of conserving space, we skip this iterative process here, and assign the following priors: \\[\\begin{equation}\n\\begin{aligned}\n\\mu_s & \\sim  \\mathit{Normal}(2, 1)\\\\\n\\sigma_s & \\sim \\mathit{Normal}_+(0.4, 0.2)\n\\end{aligned}\n\\end{equation}\\] This model is implemented in the filenormal_recrt.stan, available in thebcogscipackage: Fit and display the summary of the previous model: Is a rec-normal likelihood more appropriate than a log-normal likelihood? As things stand, we cannot compare the models with these two likelihoods. This is because the dependent variables are different: we cannot compare reciprocal response times with untransformed response times on the millisecond scale.  Model comparison with the Bayes factor or cross-validation can only compare models with the same dependent variables; see chapters12-14. If we do want to compare the reciprocal-normal likelihood and the log-normal likelihood, we have to set up the models with the two likelihoods in such a way that the dependent measure is on the raw millisecond scale in each model. This means that for the reciprocal normal likelihood, the model will receive as data raw reading times in milliseconds, and these will be treated as a transformed random variable from reciprocal reading times. This approach is discussed next, but requires knowledge of the Jacobian adjustment (seeRoss (2002)). To work with the original dependent variable (RTrather than1/RT) we need to perform achange of variables: If the random variable X represents the reciprocal reading times (\\(1/RT\\)), we can transform this random variable to a new one,\\(Y = 1/X = 1/(1/RT) = RT\\), yielding a transformed random variable\\(Y\\)which represents reading time. This change of variables requires an adjustment to the (unnormalized log) posterior probability to account for the distortion caused by the transform.42The probability must be scaled by aJacobianadjustment, which, in the univariate case as this one, is the absolute value of the derivative of the transform.43The absolute value of any number is represented by enclosing it in two vertical bars: e.g.,\\(|-2| = 2\\). \\[\\begin{equation}\n\\begin{aligned}\np(\\mathit{RT}_n | \\mu, \\sigma )& = \\mathit{Normal}(1/\\mathit{RT}_n | \\mu, \\sigma) \\left| \\frac{\\mathrm{d}}{\\mathrm{d}\\mathit{RT}_n} 1/\\mathit{RT}_n \\right| = \\\\\n& \\mathit{Normal}(1/\\mathit{RT}_n | \\mu, \\sigma) \\cdot \\left| - 1/\\mathit{RT}_n^2 \\right| = \\\\\n& \\mathit{Normal}(1/\\mathit{RT}_n | \\mu, \\sigma) \\cdot  1/\\mathit{RT}_n^2 \n \\end{aligned}\n\\end{equation}\\] If we omit the Jacobian adjustment, we are essentially fitting a different and unnormalized probability density function (this will be shown later in this chapter). The discrepancy between the correct and incorrect posterior would depend on how large the Jacobian adjustment for our model is. Because Stan works in log space, rather than multiplying the Jacobian adjustment, we add its logarithm to the log-probability density (\\(\\log(1/\\mathit{RT}_n^2) = - 2 \\cdot \\log(\\mathit{RT}_n)\\)). The contribution to the log likelihood (of\\(\\mu\\)and\\(\\sigma\\)) with its adjustment based from an individual observation,\\(\\mathit{RT}_{n}\\), would be as follows. \\[\\begin{equation}\n\\log(\\mathit{Normal}(1/\\mathit{RT}_n | \\mu, \\sigma)) - 2 \\cdot \\log(\\mathit{RT}_n) \n\\end{equation}\\] We obtain the log likelihood based on all the\\(N\\)observations by summing the log likelihood of individual observations. \\[\\begin{equation}\n\\log \\mathcal{L} = \\sum_{n=1}^N \\log(\\mathit{Normal}(1/\\mathit{RT}_n | \\mu, \\sigma))  - \\sum_{n=1}^N 2 \\cdot \\log(\\mathit{RT}_n) \n\\end{equation}\\] In Stan, this summing up is done as follows. The functionnormal_lpdf()applied to a vector already returns the sum of the individual log-probability densities. The Jacobian adjustment2*log(RT), which returns a vector of values, has to be summed up and added in manually (the term therefore becomes-sum(2*log(RT))). Before fitting the model with the change of variables, we are going to truncate the distribution.\nWe didn’t encounter negative values in our synthetic data, but this was because the distribution was not too spread out; that is, the scale was much smaller than the location (\\(\\sigma << \\mu\\)). However, in principle we could end up generating negative values. For this reason, we truncate the underlying normal distribution (for more details, see online sectionA.2). The  reciprocal truncated normal distribution has been argued to be an appropriate model of  response times, neural  inter-spike intervals, and  latency distributions of saccades in a simple optimality model in which reward is maximized to yield an optimal response rate(Harris et al.2014; Harris and Waddington2012). Because we have\\(N\\)observations, the truncation consists of adding- N * normal_lccdf(0 | mu, sigma)totarget; also see section8.4.1. The complete model,recnormal_rt.stan, including the truncation is as follows: Next, generate data from a reciprocal truncated normal distribution: Fit the model to the data: Print the posterior summary: We get the same results as before, but now we could potentially compare this model to one that assumes a log-normal likelihood, for example. An important question is the following: Does every transformation of a random variable require a Jacobian adjustment? Essentially, if we assign a distribution to a random variable and then transform it, this does not require a Jacobian adjustment. Alternatively, if we apply a transformation on a random variable first, and then assign a distribution to the transformed random variable afterwards, we have a  change of variables. This requires a Jacobian adjustment. This is the reason why1 ./ RTrequires a Jacobian adjustment, but notmu_s,mu,sigma_s, orsigma_sin the previous model. As a last step, we can encapsulate our new distribution in a function, and also create a  random number generator function. This is done in a  block calledfunctions. To create a function, we need to specify the type of every argument and the type that the function returns. As a simple example, if we would like a function to center a vector, we would do it as follows: We want to create a log(PDF) function, similar to the native Stan functions that end in_lpdf. Our function will take as arguments a vectorRT, and real numbersmuandsigma. In_lpdffunctions, (some of) the arguments (e.g.,RT,mu, andsigma) can be vectorized, but the output of the function is always a real number: the sum of the log(PDF) evaluated at every value of the random variable at the left of the pipe. As we show below, to do that we just move the right hand side oftargetin our original model inside our new function. See the section entitled Further Reading at the end of this chapter for more about Stan functions. For our custom random number generator function (which should end with_rng), we have the added complication that the function is truncated. We simply generate random values from a normal distribution, do the reciprocal transformation and if the number is above zero, this number is returned; otherwise, a new number is drawn.\nThis implementation may be inefficient when rejections occur frequently. Another, more complex implementation using the inverse CDF approach can be found inStan Development Team (2024)(section 21.10 of the User’s guide). The complete code can be found inrecnormal_rt_f.stan, and is also shown below: Fit the model to the simulated data: Print the summary: The model converged, but did it work? At the very least we expect that the simulated data that we used to test the model shows a very similar distribution to the posterior predictive distributions. This is because we are fitting the data with the same function that we use to generate the data. Figure10.2shows that the simulated data and the posterior predictive distributions are similar. FIGURE 10.2: A posterior predictive check offit_recin comparison with the simulated data. Our synthetic data set was generated by first defining aground truthvector of parameters\\(\\langle \\mu; \\sigma \\rangle\\). We would expect that the true values of the parameters\\(\\mu\\)and\\(\\sigma\\)should be well inside the bulk of the posterior distribution of our model. We investigate this by plotting the true values of the parameters together with their posterior distributions using the functionmcmc_recover_hist()ofbayesplotas shown below in Figure10.3. FIGURE 10.3: Posterior distributions of the parameters offit_rectogether with their true values. Even though this approach can capture serious misspecifications in our models, it has three important shortcomings. First, it’s unclear what we should conclude if the true value of a parameter is not in the bulk of its posterior distribution. Even in a well-specified model, if we inspect enough parameters we will find that for some parameters, the bulks of their respective marginal posterior distributions can be relatively far away from their true values. The second shortcoming is that if the posteriors that we obtain are very wide, it might not be clear what constitutes the bulk of the posterior distribution that needs to be inspected. The third shortcoming is that regardless of how a successful recovery of parameters is defined, we might be able to recover a posterior based on data generated from some parts of the parameter space, but not based on data generated from other parts of parameter space(Talts et al.2018). However, inspecting the entire parameter space is infeasible. An alternative to our approach of plotting the true values of the parameters together with their posterior distributions is called simulation-based calibration(Talts et al.2018; Modrák et al.2023), which extends ideas ofCook, Gelman, and Rubin (2006). This is discussed next. Talts et al. (2018)suggest the simulation-based calibration as the procedure for validating a model. We check that the Bayesian computation isfaithfulin the sense that it is not  biased. Our goal is to ensure that our model neither overestimates nor underestimates, nor does it possess incorrect precision in the parameters, given the data and priors. As initial steps, we employ two different implementations of the same statistical model: (1-2) a generator capable of directly simulating draws from the prior predictive distribution, and (3) a probabilistic program that, when combined with a posterior approximation algorithm (such as a Stan sampler), samples from the posterior distribution. Finally, (4-5) we verify that the results from both implementations have the same distribution conditional on the data. \\[\\begin{equation}\n\\tilde{\\Theta}_n \\sim p(\\boldsymbol{\\Theta})\n\\end{equation}\\] Here,\\(p(\\boldsymbol{\\Theta})\\)represents a  joint prior distributions of vector of parameters. In our previous example, the vector of parameters is\\(\\langle \\mu; \\sigma \\rangle\\), and the joint prior distribution is two independent distributions, a normal and a truncated normal. Crucially, the prior distributions should be meaningful; that is, one should use priors that are at least regularizing or weakly informative. The  prior space plays a crucial role because it determines the parameter space where we will verify the correctness or faithfulness of the model. Assuming 150 samples (from the priors), this step for our model would be as follows: \\[\\begin{equation}\n\\tilde{D}_n \\sim p(\\boldsymbol{D} | \\tilde{\\Theta}_n)\n\\end{equation}\\] The previous equation indicates that each data set\\(\\tilde{D}_n\\)is sampled from each of the generated parameters,\\(\\tilde{\\Theta}_n\\). Following our previous example, use the reciprocal truncated normal distribution to generate data sets of response times: Now,rt_tildeconsists of a list with 150 vectors of 500 observations each. Each list represents a  simulated data, which corresponds to\\(\\tilde{D}_{n}\\). After fitting the same model to each data set, we should compare the recovered  posterior distribution for each parameter of each simulated data set; that is,\\(p(\\Theta_n | \\tilde{D}_{n})\\), with the parameters that were used to generate the data,\\(\\tilde{\\Theta}_{n}\\). This comparison is represented by...in the code below (that is, it is not yet implemented in the code shown below). This raises the question of how to compare the posterior distribution with the ground truth values of the parameters. The procedure shown before (1-3) defines a natural condition for assessing whether the computed posterior distributions match the exact posterior distributions(Talts et al.2018; Cook, Gelman, and Rubin2006). This condition is met if the generator, probabilistic program, and posterior approximation algorithm function match: The generator and the probabilistic program must accurately represent the same data-generating process, while the posterior approximation algorithm should yield samples that closely match the correct posterior for the probabilistic program, based on data simulated from the prior. Any discrepancy suggests a mismatch among the components(Modrák et al.2023).44 The next two steps describe a well-defined comparison of the exact posterior and prior distribution(different calibration checking methods differ in how exactly they test for mismatches between the distributions; Modrák et al.2023). Talts et al. (2018)demonstrate that the match between the exact posterior and prior can be evaluated by examining whether, for each element of\\(\\boldsymbol{\\Theta}\\)(e. g.,\\(\\langle \\mu; \\sigma \\rangle\\)), therank statisticsof the prior sample relative to\\(S\\)posterior samples will be  uniformly distributed across\\([0, S]\\). In other words, for each sample of the prior (e.g.,\\(\\tilde{\\mu}_{n}\\)), we calculate the number of samples of the posterior that is smaller than the corresponding value of the parameter sampled, and we examine its distribution. A mismatch between the exact posterior and our posterior would show up as a  non-uniform distribution. As a next step, we examine this new distribution visually using a histogram with\\(S + 1\\)possible ranks (from\\(0\\)to\\(S\\)). There are two issues that we need to take into account(Talts et al.2018): Regardless of our model, histograms will deviate from uniformity if the posterior samples are dependent. This can be solved bythinningthe samples of the posterior, that is removing a number of intermediate samples(Talts et al.2018recommend between 6 and 10). To reduce the noise in the histogram, we should have bins of equal size. If\\(S + 1\\)are divisible by a large power of\\(2\\), e.g,\\(1024\\), we will be able to re-bin the histogram easily with bins of equal size. We complete the code shown in step 3 by generating an ensemble of ranks statistics as well. Here we encapsulate steps 1 to 4 into a function. As a last step, we use a histogram for each parameter to identify deviations of uniformity.\nIf the posterior estimates are correct, then each of the\\(B\\)bins has a probability of\\(1/B\\)that a simulation (i.e., an individual rank) falls into it:\\(\\mathit{Binomial}(N_{sim}, 1/B)\\). This allow us to complement the histograms with confidence intervals, indicating where the variation expected from a uniform histogram should be. Use the code below to build the plot shown in Figure10.4. We can conclude that the implementation of our model (in the parameter space determined by the priors) is correct. FIGURE 10.4: Rank histograms of\\(\\mu\\)and\\(\\sigma\\)from the reciprocal truncated normal distribution. The dashed lines represent the 99% confidence interval. Next, we consider an example where simulation-based calibration can reveal a problem. Let’s assume that we made an error in the model implementation. We’ll fit anincorrectmodel: rather than the complete likelihood including the normal PDF and the truncation and Jacobian adjustments, we will fit only the normal PDF evaluated at the reciprocal of the response times, that istarget += normal_lpdf(1 ./ RT | mu, sigma);. Assessing the correctness of the model by looking at the recovery of the parameters is misleading in this case; this is evident from Figure10.5. One could conclude that the model is fine based on this plot, since the true values of the parameters are well inside the bulk of their posterior distributions. FIGURE 10.5: Posterior distributions of the parameters of an incorrect model (truncation and Jacobian adjustments missing) together with their true values. However, the rank histograms produced by the simulation-based calibration procedure in Figure10.6show very tall bins at the left and at the right of each histogram, exceeding the 99% CI. This is a very clear indication that there is a problem with the  model specification: our incorrect model is overestimating\\(\\mu\\)and underestimating\\(\\sigma\\). This example illustrates the importance of simulation-based calibration. FIGURE 10.6: Rank histograms of\\(\\mu\\)and\\(\\sigma\\)from theincorrectimplementation of the reciprocal truncated normal distribution. The dashed lines represent the 99% confidence interval. In the previous sections, we have used only rank histograms. Even though histograms are a very intuitive means of visualization to assess model correctness, they might not be sensitive enough for small deviations(Talts et al.2018). Other visualizations might be better suited. Another limitation of histograms is that they are sensitive to the number of bins(Säilynoja, Bürkner, and Vehtari2022). One could bin the histograms multiple times, but this approach is difficult to interpret when there are many parameters, and can be vulnerable to multiple testing biases(Talts et al.2018). One alternative to rank histograms is visualizations based on the  empirical cumulative density function of the ranks. This is briefly presented in online sectionB.7. Even though simulation-based calibration is a comprehensive approach to test model correctness, it has several drawbacks, regardless of the means of visualization: This approach requires fitting a model many times, which can be too time intensive for complex models. It’s worth bearing in mind that code with errors can sometimes show clear  “catastrophic” failures in the recovery of the parameters. For this reason, one could start the verification of model correctness with a simple  recovery of parameters(see Talts et al.2018; Gelman et al.2020), and then proceed with the simulation-based calibration procedure for at least some suspect aspects of the model (e.g., when working with a custom likelihood). Another major limitation of simulation-based calibration is that it is concerned exclusively with the computational aspects of the analysis and offers no guarantee for any single observation. A complete Bayesian workflow should include prior and posterior predictive checks, see the online chapterFandSchad, Betancourt, and Vasishth (2020). Finally, it’s important to apply simulation-based calibration only after appropriate priors are set. This is important because only the priors determine the parameter space that will be inspected. Weak priors that may be good enough for estimation may nevertheless lead to a parameter space that is unrealistically large since, during the calibration stage, there are no independent data to constrain the space. This means that it is important to conduct prior predictive checks before assessing the correctness of the model with simulation-based calibration. There are cases when one needs a random variable with a distribution that is not included in Stan. Often one can find the PDF (or a CDF) derived in a paper, and one needs to implement it manually by writing the log PDF in the Stan language.\nEven though the exponential distribution is included in Stan, we demonstrate how we would include it step-by-step as if it weren’t available. This example extends the demonstration in section 22.1 of the User’s guide(Stan Development Team2024). The exponential distribution is used to model  waiting times until a certain event occurs. Its PDF is the following: \\[\\begin{equation}\nf(x |  \\lambda )={\n\\begin{cases}\n\\lambda e^{-\\lambda x} & x\\geq 0,\\\\0&x<0.\n\\end{cases}} \n\\end{equation}\\] The parameter\\(\\lambda\\)is often called the rate parameter and must be positive. A higher value for the rate parameter leads to shorter waiting times on average. The mean of the distribution is\\(1/\\lambda\\). The exponential distribution has the key property of beingmemoryless. What this means is explained inRoss (2002)as follows: Suppose that\\(X\\)is a random variable with an exponential distribution as a PDF; the random variable represents the lifetime of an item (e.g.,\\(X\\)could represent the time it takes for a radioactive particle to completely decay). If the item is\\(t\\)time-units old, then the remaining life\\(s\\)of that item has the same probability distribution as the life of a new item. Mathematically, this amounts to stating that \\[\\begin{equation}\nP(X>s + t | X> t)= P(X>s)\n\\end{equation}\\] The implication of the memoryless property is that we do not need to know the age of an item to know what the distribution of its remaining life is. To give another example of memorylessness, the conditional probability that a certain event will happen in the next 100 ms is the same regardless of whether we have been already waiting 1000 ms, 10 ms, or 0 ms. Although the exponential distribution is not commonly used for modeling response times in cognitive science, it has been used in the past(Ashby and Townsend1980; Ashby1982). We focus on this distribution because of its simple analytical form. As a first step, we make our own version of the  PDF in R, and then check that it integrates to one to verify that this is a proper distribution (and that we haven’t introduced a typo in the formula). To avoid  underflow, that is getting a zero instead of a very small number, we’ll work in the log-scale. This will also be useful when we implement this function in Stan, thus the log PDF is \\[\\begin{equation}\n\\log(f(x| \\lambda ))= \\log(\\lambda) -\\lambda  x\n\\end{equation}\\] where\\(x >0\\). Implement this function in R with the same arguments as thed*family of functions: iflog = TRUEthe output is a log density; call this new functiondexp2. Verify that this function integrates to one for some point values of its parameter\\(\\lambda\\)(here,\\(\\lambda = 1\\)and\\(\\lambda = 20\\)): To test our function, we’ll also need to generate random values from the exponential distribution. If the  quantile function of the distribution exists, the  inverse transform sampling is a relatively straightforward way to get pseudo random numbers sampled from a target distribution(for an accessible introduction to inverse sampling, see Lynch2007). Given a target distribution with a PDF\\(f\\), and a quantile function\\(F^{-1}\\)(the inverse of the CDF), the inverse transform sampling method consists of the following: In this case, the quantile function (the  inverse of the CDF) is the following: \\[\\begin{equation}\n- \\log(1-p)/\\lambda\n\\end{equation}\\] Here is how one can derive this CDF and its inverse if they were not available to us. First, consider the fact that the CDF of the exponential distribution is as follows. The term\\(q\\)is some quantile of the distribution: \\[\\begin{equation}\nF(q) = \\int_0^q \\lambda \\exp(-\\lambda x)\\, \\mathrm{d}x\n\\end{equation}\\] We can solve this  integral by using the\\(u\\)-substitution method(Salas, Etgen, and Hille2003). First, define \\[\\begin{equation}\nu = g(x) = -\\lambda x\n\\end{equation}\\] Then, the derivative\\(du/dx\\)is: \\[\\begin{equation}\n\\frac{\\mathrm{d}u}{\\mathrm{d}x} = -\\lambda\n\\end{equation}\\] This implies that\\(\\mathrm{d}u = - \\lambda \\mathrm{d}x\\), or that\\(- \\mathrm{d}u = \\lambda \\mathrm{d}x\\). In the CDF, replace the term\\(\\lambda \\mathrm{d}x\\)with\\(-\\mathrm{d}u\\): \\[\\begin{equation}\nF(q) = \\int_0^q \\lambda \\exp(-\\lambda x)\\, \\mathrm{d}x = \\int_0^{-\\lambda q} (- \\exp(-\\lambda x)\\, \\mathrm{d}u)\n\\end{equation}\\] Rewriting\\(-\\lambda x\\)as\\(u\\), the CDF simplifies to: \\[\\begin{equation}\nF(q) = \\int_0^q \\lambda \\exp(-\\lambda x)\\, \\mathrm{d}x = \\int_0^q (- \\exp(u)\\, \\mathrm{d}u)\n\\end{equation}\\] We know from calculus that the integral of\\(-\\exp(u)\\)is\\(-\\exp(u)\\). So, the integral becomes: \\[\\begin{equation}\nF(q) = \\left[ - \\exp(u) \\right]_0^q\n\\end{equation}\\] Replacing\\(u\\)with\\(-\\lambda x\\), we get: \\[\\begin{equation}\nF(q) = \\left[ - \\exp(-\\lambda x) \\right]_0^q = \n1- \\exp(-\\lambda q)\n\\end{equation}\\] Thus, we know that the CDF is\\(F(t) = 1- \\exp(-\\lambda q) = p\\), where\\(p\\)is the probability of observing the quantile\\(q\\)or some value smaller than\\(q\\). To derive the inverse of the CDF, solve the equation below for\\(q\\): \\[\\begin{equation}\n\\begin{aligned}\np &= 1- e^{-\\lambda q}\\\\\np-1 &= - e^{-\\lambda q}\\\\\n-p+1 &=  e^{-\\lambda q}\\\\\n\\log(1-p) &=  -\\lambda q\\\\\n- \\log(1-p)/\\lambda &=  q\\\\\n\\end{aligned}\n\\end{equation}\\] Write the quantile function (the inverse of the CDF) and the random number generator for the exponential distribution in R. To differentiate it from the built-in function in R, we will call itqexp2: The functions that we would use in a Stan model are relatively faithful to the R code, but follow Stan conventions: The expressionlog1m(p)is more arithmetically stable thanlog(1 - .)for values ofpclose to one, the functionexp_lpdf()stores the sum of the log(PDF) evaluated at each value of x, this would be analogous to doingsum(dexp2(x, lambda, log = TRUE)); the functionexp_rng()implements a non-vectorized version ofrexp2()and uses the auxiliary functionexp_icdf()(icdf stands for inverse CDF), which is similar toqexp2(). We are now ready to generate synthetic data and fit the distribution in Stan. Generate 1000 observations. Useexponential.stan, which includes the function block shown earlier, and the following obligatory blocks: Fit the data with Stan. Print the summary: Carry out a quick check first, verifying that the true value of the parameter\\(\\lambda\\)is reasonably inside the bulk of the posterior distribution. This is shown in Figure10.7(a).\nFigure10.7(b) shows the results of the simulation-based calibration procedure, and shows that our implementation was correct. FIGURE 10.7: (a) Posterior distribution of the parameter\\(\\lambda\\)offit_exptogether with its true values as a black line. (b) Rank histogram of\\(\\lambda\\)and from our hand-made implementation of the exponential distribution. The dashed lines represent the 99% confidence interval. In this chapter, we learned how to create a PDF that is not provided by Stan. We learned how to do this by doing a change of variables (using the Jacobian adjustment) and by building the distribution from scratch in a function ending in_lpdf. We also learned how to verify the correctness of the new functions by recovering the true values of the parameters and by using simulation-based calibration. Jacobian adjustments in Bayesian models are a common source of confusion and there are several posts in blogs and study cases that try to shed light on them: Jacobian adjustments are also relevant for adjusting priors for order constraints, which is especially important for Bayes factors(Heck and Wagenmakers2016). A complete tutorial of  simulation-based calibration using theSBCpackage was presented in the online event  Stanconnect 2021, and it is available inhttps://www.martinmodrak.cz/post/2021-sbc_tutorial/. The ideas that predate this technique can be found inCook, Gelman, and Rubin (2006)and were extended inTalts et al. (2018). The use of ECDF-based visualizations is discussed inSäilynoja, Bürkner, and Vehtari (2022). The role of simulation-based calibration in the Bayesian workflow is discussed inSchad, Betancourt, and Vasishth (2020). Examples of the use of simulation-based calibration to validate novel models used in cognitive science areHartmann, Johannsen, and Klauer (2020)andBürkner and Charpentier (2020). The extension of this procedure to validate Bayes factors is discussed inSchad et al. (2021). Custom functions in general and custom probability functions are treated chapter 21 of the User’s guide(Stan Development Team2024). Adams, Robert A., and Christopher Essex. 2018.Calculus: A Complete Course. Pearson. Ashby, F. Gregory. 1982. “Testing the Assumptions of Exponential, Additive Reaction Time Models.”Memory & Cognition10 (2): 125–34. Ashby, F. Gregory, and James T. Townsend. 1980. “Decomposing the Reaction Time Distribution: Pure Insertion and Selective Influence Revisited.”Journal of Mathematical Psychology21 (2): 93–123. Box, George E. P., and David R. Cox. 1964. “An Analysis of Transformations.”Journal of the Royal Statistical Society. Series B (Methodological), 211–52. Bürkner, Paul-Christian, and Emmanuel Charpentier. 2020. “Modelling Monotonic Effects of Ordinal Predictors in Bayesian Regression Models.”British Journal of Mathematical and Statistical Psychology.https://doi.org/https://doi.org/10.1111/bmsp.12195. Cook, Samantha R., Andrew Gelman, and Donald B. Rubin. 2006. “Validation of Software for Bayesian Models Using Posterior Quantiles.”Journal of Computational and Graphical Statistics15 (3): 675–92.https://doi.org/10.1198/106186006X136976. Gelman, Andrew, Aki Vehtari, Daniel P. Simpson, Charles C. Margossian, Bob Carpenter, Yuling Yao, Lauren Kennedy, Jonah Gabry, Paul-Christian Bürkner, and Martin Modrák. 2020. “Bayesian Workflow.”arXiv Preprint arXiv:2011.01808. Harris, Christopher M., and Jonathan Waddington. 2012. “On the Convergence of Time Interval Moments: Caveat Sciscitator.”Journal of Neuroscience Methods205 (2): 345–56.https://doi.org/https://doi.org/10.1016/j.jneumeth.2012.01.017. Harris, Christopher M., Jonathan Waddington, Valerio Biscione, and Sean Manzi. 2014. “Manual Choice Reaction Times in the Rate-Domain.”Frontiers in Human Neuroscience8: 418.https://doi.org/10.3389/fnhum.2014.00418. Hartmann, Raphael, Lea Johannsen, and Karl Christoph Klauer. 2020. “rtmpt: An R Package for Fitting Response-Time Extended Multinomial Processing Tree Models.”Behavior Research Methods52 (3): 1313–38. Heck, Daniel W, and Eric-Jan Wagenmakers. 2016. “Adjusted Priors for Bayes Factors Involving Reparameterized Order Constraints.”Journal of Mathematical Psychology73: 110–16.https://doi.org/https://doi.org/10.1016/j.jmp.2016.05.004. Lynch, Scott Michael. 2007.Introduction to Applied Bayesian Statistics and Estimation for Social Scientists. New York, NY: Springer. Modrák, Martin, Angie H. Moon, Shinyoung Kim, Paul-Christian Bürkner, Niko Huurre, Kateřina Faltejsková, Andrew Gelman, and Aki Vehtari. 2023. “Simulation-Based Calibration Checking for Bayesian Computation: The Choice of Test Quantities Shapes Sensitivity.”Bayesian Analysis, 1–28.https://doi.org/10.1214/23-BA1404. Ross, Sheldon. 2002.A First Course in Probability. Pearson Education. Säilynoja, Teemu, Paul-Christian Bürkner, and Aki Vehtari. 2022. “Graphical Test for Discrete Uniformity and Its Applications in Goodness-of-Fit Evaluation and Multiple Sample Comparison.”Statistics and Computing32 (2): 1–21.https://doi.org/https://doi.org/10.1007/s11222-022-10090-6. Salas, Saturnino L., Garret J. Etgen, and Einar Hille. 2003.Calculus: One and Several Variables. Ninth. John Wiley & Sons. Schad, Daniel J., Michael J. Betancourt, and Shravan Vasishth. 2019. “Toward a Principled Bayesian Workflow in Cognitive Science.”arXiv Preprint.https://doi.org/10.48550/ARXIV.1904.12765. Schad, Daniel J., Bruno Nicenboim, Paul-Christian Bürkner, Michael J. Betancourt, and Shravan Vasishth. 2021. “Workflow Techniques for the Robust Use of Bayes Factors.”arXiv Preprint arXiv:2103.08744. Stan Development Team. 2024. “Stan Modeling Language Users Guide and Reference Manual, Version 2.32.”https://mc-stan.org/docs/2_35/. Talts, Sean, Michael J. Betancourt, Daniel P. Simpson, Aki Vehtari, and Andrew Gelman. 2018. “Validating Bayesian Inference Algorithms with Simulation-Based Calibration.”arXiv Preprint arXiv:1804.06788. Wu, Fuyun, Elsi Kaiser, and Shravan Vasishth. 2017. “Effects of Early Cues on the Processing of Chinese Relative Clauses: Evidence for Experience-Based Theories.”Cognitive Science42: 1101–33. Yao, Yuling, Aki Vehtari, Daniel P. 2018. “Yes, but Did It Work?: Evaluating Variational Inference.” InInternational Conference on Machine Learning, 5581–90. PMLR. In this specific case, we could also transform the dependent variable first, but as will become clear later, we want to avoid changing our dependent variable.↩︎ Not every transformation is valid, univariate changes of variables must be monotonic and differentiable, multivariate changes of variables must be surjective and differentiable.↩︎ In the multivariate case, it is equal to the absolute determinant of the Jacobian, the matrix of all its first-order partial derivatives, of the transform; see section 6.7 ofRoss (2002), and p. 707 ofAdams and Essex (2018).↩︎ We are working under the assumption that Stan, which yields the posterior approximation, works correctly. In principle, if we assume that our model is correct, we can also use simulation-based calibration to examine whether our approximation to the posterior distribution is correct (that is, whether Stan’s sampler, or any posterior approximation method works correctly); for an example, seeYao et al. (2018).↩︎"
}