{
    "document_type": "online_article",
    "title": "Introduction to Bayesian Data Analysis for Cognitive Science",
    "author": "Bruno Nicenboim",
    "source": "https://bruno.nicenboim.me/bayescogsci/ch-mixture.html",
    "date_published": "Unknown",
    "flag": "",
    "text": "Mixture models integrate  multiple data generating processes into a single model. This is especially useful in cases where the data alone don’t allow us to fully identify which observations belong to which process.\nMixture models are important in cognitive science because many theories of cognition assume that the behavior of subjects in certain tasks is determined by an interplay of different cognitive processes(e.g., response times in schizophrenia in Levy et al.1993; retrieval from memory in sentence processing in McElree2000; Nicenboim and Vasishth2018; fast choices in Ollman1966; Dutilh et al.2011; generalized processing tree models in Heck, Erdfelder, and Kieslich2018). It is important to stress that a mixture distribution of observations is anassumptionof the latent process developing trial by trial based on a given theory—it doesn’t necessarily represent the true generative process. The role of Bayesian modeling is to help us understand the extent to which this assumption is well-founded, by using posterior predictive checks and by comparing different models. We focus here on the case where we have only two components; each component represents a distinct cognitive process based on the domain knowledge of the researcher. The vector\\(\\mathbf{z}\\)serves as a latentindicator variablethat indicates which of the mixture components an observation\\(y_n\\)belongs to (\\(n=1,\\dots,N\\)is the number of data points). We assume two components, and thus each\\(z_n\\)can be either\\(0\\)or\\(1\\)(this will allows us to generate\\(z_n\\)with a  Bernoulli distribution). We also assume two different generative processes,\\(p_1\\)and\\(p_2\\), which generate different distributions of the observations based on a vector of parameters indicated by\\(\\Theta_{1}\\)and\\(\\Theta_{2}\\), respectively. These two processes occur with probability\\(\\theta\\)and\\(1-\\theta\\), and each observation is generated as follows: \\[\\begin{equation}\n\\begin{aligned}\nz_n \\sim \\mathit{Bernoulli}(\\theta)\\\\\ny_n \\sim\n\\begin{cases}\np_1(\\Theta_1), & \\text{ if } z_n =1 \\\\\np_2(\\Theta_2), & \\text{ if } z_n=0\n\\end{cases}\n\\end{aligned}\n\\tag{17.1}\n\\end{equation}\\] We focus on only two components because this type of model is already hard to fit and, as we show in this chapter, it requires plenty of prior information to be able to sample from the posterior in most applied situations. However, the approach presented here can in principle be extended to a larger number of mixtures by replacing the Bernoulli distribution with a categorical one. This can be done if the number of components in the mixture is finite; the number of components is determined by the researcher. In order to fit this model, we need to estimate the posterior of each of the parameters contained in the vectors\\(\\Theta_{1}\\)and\\(\\Theta_{2}\\)(intercepts, slopes, group-level effects, etc.), the probability\\(\\theta\\), and the indicator variable that corresponds to each observation\\(z_n\\). One issue that presents itself here is that\\(z_n\\)must be a  discrete parameter, and Stan only allows  continuous parameters. This is because Stan’s algorithm requires the  derivatives of the (log) posterior distribution with respect to all parameters, and discrete parameters are not  differentiable (since they have “breaks”). In probabilistic programming languages like WinBUGS(Lunn et al.2012), JAGS(Plummer2016), PyMC3(Salvatier, Wiecki, and Fonnesbeck2016)and Turing(Ge, Xu, and Ghahramani2018), discrete parameters are possible to use; but not in Stan. In Stan, we can circumvent this issue by marginalizing out the indicator variable\\(z\\).58If\\(p_1\\)appears in the mixture with probability\\(\\theta\\), and\\(p_2\\)with probability\\(1-\\theta\\), then the joint likelihood is defined as a function of\\(\\Theta\\)(which concatenates the mixing probability,\\(\\theta\\), and the parameters of the\\(p_{1}\\)and\\(p_{2}\\),\\(\\Theta_1\\)and\\(\\Theta_2\\)), and importantly\\(z_n\\)“disappears”: \\[\\begin{equation}\np(y_n | \\Theta) = \\theta \\cdot p_1(y_n| \\Theta_1) + (1-\\theta) \\cdot p_2(y_n | \\Theta_2)\n\\end{equation}\\] The intuition behind this formula is that each  likelihood function,\\(p_1\\),\\(p_2\\)is weighted by its probability of being the relevant generative process. For our purposes, it suffices to say that marginalization works; the reader interested in the mathematics behind marginalization is directed to the further reading section at the end of the chapter.59 Even though Stan cannot fit a model with the discrete indicator of the latent class\\(\\mathbf{z}\\)that we used in Equation(17.1), this equation will prove very useful when we want to generate  synthetic data. In the following sections, we model a well-known phenomenon (i.e., the speed-accuracy trade-off) assuming an underlying  finite mixture process. We start from the verbal description of the model, and then implement the model step by step in Stan. When we are faced with multiple choices that require an immediate decision, we can speed up the decision at the expense of accuracy and become more accurate at the expense of speed; this is called the  speed-accuracy trade-off(Wickelgren1977). The most popular class of models that can incorporate both response times and accuracy, and give an account for the speed-accuracy trade-off is the class of  sequential sampling models, which include the drift diffusion model(Ratcliff1978), the linear ballistic accumulator(Brown and Heathcote2008), and the log-normal race model(Heathcote and Love2012; Rouder et al.2015), which we discuss in chapter18; for a review seeRatcliff et al. (2016). However, an alternative model that has been proposed in the past is Ollman’s simple  fast-guess model(Ollman1966; Yellott1967,1971).60Although it has mostly fallen out of favor(but see Dutilh et al.2011; and Heck and Erdfelder2020for more modern variants of this model), it presents a very simple framework using finite mixture modeling that can also account for the speed-accuracy trade-off. In the next sections, we’ll use this model to exemplify the use of finite mixtures to represent different cognitive processes. One way to examine the behavior of human and primate subjects when faced with two-alternative forced choices is the detection of the global motion of a  random dot kinematogram(Britten et al.1993). In this task, a subject sees a number of  random dots on the screen. A proportion of dots move in a single direction (e.g., right) and the rest move in random directions. The subject’s goal is to estimate the overall direction of the movement. One of the reasons for the popularity of this task is that it permits the fine-tuning of the difficulty of trials(Dutilh et al.2019): The task is harder when the proportion of dots that move coherently (the level ofcoherence) is lower; see Figure17.1. FIGURE 17.1: Three levels of difficulty of the global motion detection task. The figures show a consistent movement to the right with three levels of coherence (10%, 50%, and 100%). The subjects see the dots moving in the direction indicated by the arrows. The subjects do not see the arrows and all the dots look identical in the actual task. Adapted fromHan et al. (2018); licensed under CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/). Ollman’s(1966)fast-guess model assumes that the behavior in this task (and in any other choice task) is governed by two distinct cognitive processes: (i) a  guessing mode, and (ii) a  task-engaged mode. In the guessing mode, responses are fast and accuracy is at chance level. In the task-engaged mode, responses are slower and accuracy approaches 100%. This means that intermediate values of response times and accuracy can only be achieved by  mixing responses from the two modes. Further assumptions of this model are that response times depend on the difficulty of the choice, and that the probability of being on one of the two states depend on the speed incentives during the instructions. To simplify matters, we ignore the possibility that the accuracy of the choice is also affected by the difficulty of the choice. Also, we ignore the possibility that subjects might be biased to one specific response in the guessing mode, but see exerciseG.17.3in the online materials. We implement the assumptions behind Ollman’s fast-guess model and examine its fit to data of a global motion detection task fromDutilh et al. (2019). The data set fromDutilh et al. (2019)contains approximately 2800 trials of each of the 20 subjects participating in a global motion detection task and can be found indf_dotsin thebcogscipackage. There were two level of coherence, yielding hard and easy trials (diff), and the trials where done under instructions that emphasized either accuracy or speed (emphasis). More information about the data set can be found by accessing the documentation for the data set (by typing?df_dotson the R command line, assuming that thebcogscipackage is installed). We might think that if the fast-guess model were true, we would see a  bimodal distribution, when we plot a histogram of the data. Unfortunately, when two similar distributions are mixed, we won’t necessarily see any apparent bimodality; see Figure17.2. FIGURE 17.2: Distribution of response times in the data of the global motion detection task inDutilh et al. (2019). However, Figure17.3reveals that incorrect responses were generally faster, and this was especially true when the instructions emphasized accuracy. FIGURE 17.3: The distribution of response times by  accuracy in the data of the global motion detection task inDutilh et al. (2019). The description of the model makes it clear that an ideal subject who never guesses has a response time that depends only on the difficulty of the trial. As we did in previous chapters, we assume that response times are log-normally distributed, and for simplicity we start by modeling the behavior of a single subject: \\[\\begin{equation}\nrt_n \\sim \\mathit{LogNormal}(\\alpha + \\beta \\cdot x_n, \\sigma)\n\\end{equation}\\] In the previous equation,\\(x\\)is larger for difficult trials. If we center\\(x\\),\\(\\alpha\\)represents the average logarithmic transformed response time for a subject engaged in the task, and\\(\\beta\\)is the effect of  trial difficulty on log-response time. We assume a non-deterministic process, with a noise parameter\\(\\sigma\\). Also see the online sectionA.4for more information about log-normally distributed response times. Alternatively, a subject that guesses in every trial would show a response time distribution that is independent of the difficulty of the trial: \\[\\begin{equation}\nrt_n \\sim \\mathit{LogNormal}(\\gamma, \\sigma_2)\n\\end{equation}\\] Here\\(\\gamma\\)represents the the average logarithmic transformed response time when a subject only guesses. We assume that responses from the guessing mode might have a different noise component than from the task-engaged mode. The fast-guess model makes the assumption that during a task, a single subject would behave in these two ways: They would be engaged in the task a proportion of the trials and would guess on the rest of the trials. This means that for a single subject, there is an underlying probability of being engaged in the task,\\(p_{task}\\), that determines whether they are actually choosing (\\(z=1\\)) or guessing (\\(z=0\\)): \\[\\begin{equation}\nz_n \\sim \\mathit{Bernoulli}(p_{task})\n\\end{equation}\\] The value of the parameter\\(z\\)in every trial determines the behavior of the subject. This means that the distribution that we observe is a mixture of the two distributions presented before: \\[\\begin{equation}\nrt_n \\sim\n\\begin{cases}\n\\mathit{LogNormal}(\\alpha + \\beta \\cdot x_n, \\sigma), & \\text{ if } z_n =1 \\\\\n\\mathit{LogNormal}(\\gamma, \\sigma_2), & \\text{ if } z_n=0\n\\end{cases}\n\\tag{17.2}\n\\end{equation}\\] In order to have a Bayesian implementation, we also need to define some priors. We use priors that encode what we know about response time experiments. These priors are slightly more informative than the ones that we used in section4.2, but they still can be considered  regularizing priors. One can verify this by performing prior predictive checks. As we increase the complexity of our models, it’s worth spending some time designing more realistic priors. These will speed up computation and in some cases they will be crucial for solving convergence problems. \\[\\begin{equation}\n\\begin{aligned}\n\\alpha &\\sim \\mathit{Normal}(6, 1)\\\\\n\\beta &\\sim \\mathit{Normal}(0, 0.1)\\\\\n\\sigma &\\sim \\mathit{Normal}_+(0.5, 0.2)\n\\end{aligned}\n\\end{equation}\\] \\[\\begin{equation}\n\\begin{aligned}\n\\gamma &\\sim \\mathit{Normal}(6, 1)\\\\\n\\sigma_2 &\\sim \\mathit{Normal}_+(0.5, 0.2)\n\\end{aligned}\n\\end{equation}\\] For now, we allow all values for the probability of having an engaged response equal likelihood; we achieve this by setting the following prior to\\(p_{task}\\): \\[\\begin{equation}\np_{task} \\sim \\mathit{Beta}(1, 1)\n\\end{equation}\\] This represents a flat,  uninformative prior over the probability parameter\\(p_{task}\\). Before we fit our model to the real data, we generate  synthetic data to make sure that our model is working as expected. We first define the number of observations, predictors, and fixed point values for each of the parameters. We assume\\(1000\\)observations and two levels of difficulty,\\(x\\), coded\\(-0.5\\)(easy) and\\(0.5\\)(hard). The point values chosen for the parameters are relatively realistic (based on our previous experience on response time experiments). Although in the priors we try to encode the range of possible values for the parameters, in this simulation we assume only one instance of this possible range: For generating a mixture of response times, we use the indicator of a latent class,z. We verify that our simulated data is realistic, that is, it’s in the same range as the original data; see Figure17.4. FIGURE 17.4: Response times in the simulated data (df_dots_simdata1) that follows the fast-guess model. To implement the mixture model defined in Equation(3.10)in Stan, the discrete parameter\\(z\\)needs to be marginalized out: \\[\\begin{equation}\n\\begin{aligned}\np(rt_n | \\Theta) &= p_{task} \\cdot LogNormal(rt_n | \\alpha + \\beta \\cdot x_n, \\sigma) +\\\\\n    & (1 - p_{task}) \\cdot LogNormal(rt_n | \\gamma, \\sigma_2)\n\\end{aligned}\n\\end{equation}\\] In addition, Stan requires the likelihood to be defined in log-space: \\[\\begin{equation}\n\\begin{aligned}\n\\log(p(rt | \\Theta)) &= \\log(p_{task} \\cdot LogNormal(rt_n | \\alpha + \\beta \\cdot x_n, \\sigma) +\\\\\n    & (1 - p_{task}) \\cdot LogNormal(rt_n | \\gamma, \\sigma_2))\n\\end{aligned}\n\\end{equation}\\] A “naive” implementation in Stan would look like the following (recall that_lpdffunctions provide log-transformed densities): However, we need to take into account that\\(log(A \\pm B)\\)can be  numerically unstable(i.e., prone to  underflow/ overflow, see Blanchard, Higham, and Higham2020). Stan provides several functions to deal with different special cases of logarithms of sums and differences. Here we needlog_sum_exp(x, y)that corresponds tolog(exp(x) + exp(y))andlog1m(x)that corresponds tolog(1-x). First, we need to take into account that the first summand of the logarithm,p_task * exp(lognormal_lpdf(rt[n] | alpha + x[n] * beta, sigma))corresponds toexp(x), and the second one,(1-p_task) * exp(lognormal_lpdf(rt[n] | gamma, sigma2))toexp(y)inlog_sum_exp(x, y). This means that we need to first apply the logarithm to each of them to use them as arguments oflog_sum_exp(x, y): Now we can just replacelog(1-p_task)by the more stablelog1m(p_task): The complete model (mixture_rt.stan) is shown below: Call the Stan modelmixture_rt.stan, and fit it to the simulated data. First, we set up the simulated data as a list structure: Then fit the model: There are a lot of warnings, the Rhats are too large, and number of effective samples is too low: The traceplots show clearly that the chains aren’t mixing; see Figure17.5. FIGURE 17.5: Traceplots from the modelmixture_rt.stanfit to simulated data. The problem with this model is that the  mixture components (i.e., the fast-guesses and the engaged mode) are underlyingly  exchangeable and thus the posterior is  multimodal and the model does not converge. Each chain (and each iteration) doesn’t know how each component was identified by the rest of the chains (e.g., in some chains and iterations,\\(z=0\\)corresponds to fast guesses, whereas in other cases, it corresponds to deliberate responses). However, we do have information that can identify the components: According to the theoretical model, we know that the average response in the engaged mode, represented by\\(\\alpha\\), should be slower than the average response in the guessing mode,\\(\\gamma\\). Even though the theoretical model assumes that guesses are faster than engaged responses, this is not explicit in our computational model. That is, our model lacks some of the theoretical information that we have, namely that the distribution of engaged  response times should be slower than the distribution of guessing times. This can be encoded withorder constraintsorinequality constraints: a  strong prior for\\(\\gamma\\), where we assume that the upper bound of its prior distribution is truncated at the value\\(\\alpha\\): \\[\\begin{equation}\n\\gamma \\sim \\mathit{Normal}(6, 1), \\text{for } \\gamma < \\alpha\n\\end{equation}\\] This would be enough to make the model converge. Another softer constraint that we could add to our implementation is the assumption that subjects are generally more likely to be trying to do the task than just guessing. If this assumption is correct, we also improve the accuracy of our estimation of the posterior of the model. (The opposite is also true: If subjects are not trying to do the task, this assumption will be unwarranted and our prior information will lead us further from the “true” values of the parameters). The following prior has the probability density concentrated near\\(1\\). \\[\\begin{equation}\np_{task} \\sim \\mathit{Beta}(8, 2)\n\\end{equation}\\] Plotting this prior confirms where most of the probability mass lies; see Figure17.6. FIGURE 17.6: A density plot for the\\(\\mathit{Beta}(8,2)\\)prior on\\(p_{task}\\). The Stan code for this model is shown below asmixture_rt2.stan. Once we change the upper bound ofgammain theparametersblock, we also need to truncate the distribution in themodelblock by correcting the PDF with its CDF. This correction is carried out using the CDF because we are truncating the distribution at the right-hand side; recall that earlier we used the complement of the CDF when we truncate a distribution at the left-hand side); see the online sectionA.2. Fit this model (call itmixture_rt2.stan) to the same simulated data set that we used before: Now the summaries and traceplots look fine; see Figure17.7. FIGURE 17.7: Traceplots from the modelmixture_rt2.stanfit to simulated data. A problem with the previous implementation of the fast-guess model is that we ignore the accuracy information in the data. We can implement a version that is closer to the verbal description of the model:\nIn particular, we also want to model the fact that accuracy is at chance level in the fast-guessing mode and that accuracy approaches 100% during the task-engaged mode. This means that the mixture affects two pairs of distributions: \\[\\begin{equation}\nz_n \\sim \\mathit{Bernoulli}(p_{task})\n\\end{equation}\\] The response time distribution \\[\\begin{equation}\nrt_n \\sim\n\\begin{cases}\n\\mathit{LogNormal}(\\alpha + \\beta \\cdot x_n, \\sigma), & \\text{ if } z_n =1 \\\\\n\\mathit{LogNormal}(\\gamma, \\sigma_2), & \\text{ if } z_n=0\n\\end{cases}\n\\tag{17.3}\n\\end{equation}\\] and an accuracy distribution \\[\\begin{equation}\nacc_n \\sim\n\\begin{cases}\n\\mathit{Bernoulli}(p_{correct}), & \\text{ if } z_n =1 \\\\\n\\mathit{Bernoulli}(0.5), & \\text{ if } z_n=0\n\\end{cases}\n\\tag{17.4}\n\\end{equation}\\] We have a new parameter\\(p_{correct}\\), which represent the probability of making a correct answer in the engaged mode. The verbal description says that it is closer to 100%, and here we have the freedom to choose whatever prior we believe represents for us values that are close to 100% accuracy. We translate this belief into a prior as follows; our prior choice is relatively informative but does not impose a hard constraint; if a subject consistently shows relatively low (or high) accuracy,\\(p_{correct}\\)will change accordingly: \\[\\begin{equation}\np_{correct} \\sim \\mathit{Beta}(995, 5)\n\\end{equation}\\] In our simulated data, we assume that the global motion detection task is done by a very accurate subject, with an accuracy of 99.9%. First, simulate response times, as done earlier: Simulate  accuracy and include both response times and accuracy in the simulated data set: Plot the simulated data in Figure17.8. This time we can see the effect of task difficulty on the simulated response times and accuracy: FIGURE 17.8: Response times by accuracy, accounting for task difficulty in the simulated data (df_dots_simdata3) that follows the fast-guess model. Next, we need to marginalize out the discrete parameters from the joint distribution of accuracy and response times. However, we assume that conditional on the latent indicator parameter\\(z\\), response times and accuracy are independent. For this reason, we can multiply the likelihoods forrtandaccwithin each component. \\[\\begin{equation}\n\\begin{aligned}\np(rt, acc | \\Theta) = & p_{task} \\cdot \\\\\n& LogNormal(rt_n | \\alpha + \\beta \\cdot x_n, \\sigma) \\cdot \\\\\n& Bernoulli(acc_n | p_{correct}) \\\\\n& +\\\\\n& (1 - p_{task}) \\cdot \\\\\n& LogNormal(rt_n | \\gamma, \\sigma_2) \\cdot\\\\\n& Bernoulli(acc_n | 0.5)\n\\end{aligned}\n\\end{equation}\\] In log-space: \\[\\begin{equation}\n\\begin{aligned}\n\\log(p(rt, acc | \\Theta)) =  \\log(\\exp(&\\\\\n& \\log(p_{task}) +\\\\\n  &\\log(LogNormal(rt_n | \\alpha + \\beta \\cdot x_n, \\sigma)) + \\\\\n  &\\log(Bernoulli(acc_n | p_{correct})))\\\\\n  +&\\\\\n \\exp(&\\\\\n & \\log(1 - p_{task}) + \\\\\n & \\log(LogNormal(rt_n |\\gamma, \\sigma_2)) + \\\\\n & \\log(Bernoulli(acc_n | 0.5)))\\\\\n    )& \\\\\n\\end{aligned}\n\\end{equation}\\] Our model translates to the following Stan code (mixture_rtacc.stan): Next, set up the data in list format: Then fit the model: We see that our model can be fit to both response times and accuracy, and its parameters estimates have sensible values (given the fixed parameters we used to generate our simulated data). We will evaluate the recovery of the parameters more carefully when we deal with the hierarchical version of the fast-guess model in section17.1.5. Before we extend this model hierarchically, let us also take into account the instructions given to the subjects. The actual global motion detection experiment that we started with has another manipulation that can help us to evaluate better the fast-guess model. In some trials, the instructions emphasized accuracy (e.g., “Be as accurate as possible.”) and in others speed (e.g., “Be as fast as possible.”). The fast-guess model also assumes that the probability of being in one of the two states depends on the speed incentives given during the instructions. This entails that now\\(p_{task}\\)depends on the instructions\\(x_2\\), where we encode a speed incentive with\\(-0.5\\)and an accuracy incentive with\\(0.5\\). Essentially, we need to fit the following regression: \\[\\begin{equation}\n\\alpha_{task} + x_2 \\cdot \\beta_{task}\n\\end{equation}\\] As we did with MPT models in the previous chapter (in section16.2.3), we need to bound the previous regression between 0 and 1; we achieve this using the  logistic or  inverse logit function: \\[\\begin{equation}\np_{task} = logit^{-1}(\\alpha_{task} + x_2 \\cdot \\beta_{task})\n\\end{equation}\\] This means that we need to interpret\\(\\alpha_{task} + x_2 \\cdot \\beta_{task}\\)in  log-odds space, which has the range\\((-\\infty, \\infty)\\)rather than the probability space\\([0,1]\\); also see section16.2.3. The likelihood (defined before in section17.1.3) now depends on the value of\\(x_{2}\\)for the specific row: \\[\\begin{equation}\nz_n \\sim \\mathit{Bernoulli}(p_{{task}_n})\n\\end{equation}\\] A response time distribution is defined: \\[\\begin{equation}\nrt_n \\sim\n\\begin{cases}\n\\mathit{LogNormal}(\\alpha + \\beta \\cdot x_n, \\sigma), & \\text{ if } z_n =1 \\\\\n\\mathit{LogNormal}(\\gamma, \\sigma_2), & \\text{ if } z_n=0\n\\end{cases}\n\\end{equation}\\] and an accuracy distribution is defined as well: \\[\\begin{equation}\nacc_n \\sim\n\\begin{cases}\n\\mathit{Bernoulli}(p_{correct}), & \\text{ if } z_n =1 \\\\\n\\mathit{Bernoulli}(0.5), & \\text{ if } z_n=0\n\\end{cases}\n\\end{equation}\\] The only further change in our model is that rather than a prior on\\(p_{task}\\), we now need priors for\\(\\alpha_{task}\\)and\\(\\beta_{task}\\), which are on the log-odds scale. For\\(\\beta_{task}\\), we assume an effect that can be rather large and we won’t assume a direction a priori (for now): \\[\\begin{equation}\n\\beta_{task} \\sim \\mathit{Normal}(0, 1)\n\\end{equation}\\] This means that the subject could be affected by the instructions in the expected way, with an increased probability to be task-engaged, leading to better accuracy when the instructions emphasize accuracy (\\(\\beta_{task} >0\\)). Alternatively, the subject might behave in an unexpected way, with a decreased probability to be task-engaged, leading to worse accuracy when the instructions emphasize accuracy (\\(\\beta_{task} <0\\)). The latter situation,\\(\\beta_{task} <0\\), could represent the instructions being misunderstood. It’s certainly possible to include priors that encode the expected direction of the effect instead:\\(\\mathit{Normal}_{+}(0,1)\\). Unless there is a compelling reason to constrain the prior in this way, following Cromwell’s rule (BoxE.2in the online chapterE), we leave open the possibility of the\\(\\beta\\)parameter having negative values. How can we choose a prior for\\(\\alpha_{task}\\)that encodes the same information that we had in the previous model in\\(p_{task}\\)? One possibility is to create an auxiliary parameter\\(p_{btask}\\), that represents the baseline probability of being engaged in the task, with the same prior that we use in the previous section, and then transform it to an unconstrained space for our regression with the logit function: \\[\\begin{equation}\n\\begin{aligned}\n&p_{btask} \\sim \\mathit{\\mathit{Beta}}(8, 2)\\\\\n&\\alpha_{task} = logit(p_{btask})\n\\end{aligned}\n\\end{equation}\\] To verify that our priors make sense, in Figure17.9we plot the difference in prior predicted probability of being engaged in the task under the two emphasis conditions: FIGURE 17.9: The difference in prior predicted probability of being engaged in the task under the two emphasis conditions for the simulated data (diff_p_pred) that follows the fast-guess model. Figure17.9shows that we are predicting a priori that the difference in\\(p_{task}\\)will tend to be smaller than\\(\\pm 0.3\\), which seems to make sense intuitively. If we had more information about the likely range of variation, we could of course have adapted the prior to reflect that belief. We are ready to generate a new data set, by deciding on some fixed values for\\(\\beta_{task}\\)and\\(p_{btask}\\): We can generate a plot now where both the difficulty of the task and the instructions are manipulated; see Figure17.10. FIGURE 17.10: Response times and accuracy by the difficulty of the task and the instructions type for the simulated data (df_dots_simdata4) that follows the fast-guess model. In the Stan implementation,log_inv_logit(x)is applying the logistic (or inverse logit) function toxto transform it into a probability and then applying the logarithm;log1m_inv_logit(x)is applying the logistic function tox, and then applying the logarithm to its complement\\((1 - p)\\). We do this because rather than havingp_taskin probability space, we havelodds_taskin log-odds space: The parameterlodds_taskestimates the mixing probabilities in log-odds: We also add agenerated quantitiesblock that can be used for further (prior or posterior) predictive checks. In this block, we do usezas an indicator of the latent class (task-engaged mode or fast-guessing mode), since we do not estimatez, but rather generate it based on the parameter’s posteriors. We use the dummy variableonlypriorto indicate whether we use the data or we only sample from the priors. One can always do the predictive checks in R, transforming the code that we wrote for the simulation into a function, and writing the priors in R. However, it can be simpler to take advantage of Stan output format and rewrite the code in Stan. One downside of this is that thestanfitobject that stores the model output can become too large for the memory of the computer. Another downside is reduced robustness, as it is more likely that we overlook an error if we only work in Stan rather than re-implementing the code in different programming languages (e.g., R and Stan)(Cooper and Guest2014). The code shown below is available in thebcogscipackage and is calledmixture_rtacc2.stan. Before fitting the model to the simulated data, we perform prior predictive checks. Generate prior predictive distributions, by settingonlypriorto1. We plot prior predictive distributions of response times as follows in Figure17.11(a), by settingy = rtusingppd_dens_overlay(). Some of the predictive data sets contain responses that are too large, and some of them have too much probability mass close to zero, but there is nothing clearly wrong in the prior predictive distributions (considering that the model hasn’t “seen” the data yet). If we want to plot the prior predicted distribution of differences in response time conditioning on task difficulty, we need to define a new function. Then we use thebayesplotfunctionppc_stat()that takes as an argument ofstatany summary function; see Figure17.11(a). FIGURE 17.11: (a) Prior predictive distributions of response times from the fast-guess model (mixture_rtacc2.stan). (b) Prior predictive distribution of response time differences, using the same model and prior settings, conditioned on task difficulty. We find that the range of response times look reasonable. There are, however, always more checks that can be done; examples are plotting other summary statistics, or predictions conditioned on other aspects of the data. Fit the model to data, by settingonlyprior = 0: We see that we fit the model without problems. Before we evaluate the recovery of the parameters more carefully, we implement a hierarchical version of the fast-guess model. So far we have evaluated the behavior of one simulated subject.\nWe discussed before (in the context of distributional regression models, in section5.2.6, and in the MPT modeling chapter16) that, in principle, every parameter in a model can be made hierarchical. However, this doesn’t guarantee that we’ll learn anything from the data for those parameters, or that our model will converge. A safe approach here is to start simple, using simulated data. If a model converges on simulated data, it does not guarantee convergence on real data. However, if a model fails to converge on simulated data, it is very likely to fail with real data as well. For our hierarchical version, we assume that both response times and the effect of task difficulty vary by subject, and that different subjects have different guessing times. This entails the following change to the response time distribution: \\[\\begin{equation}\nrt_n \\sim\n\\begin{cases}\n\\mathit{LogNormal}(\\alpha + u_{subj[n],1} +  x_n \\cdot  (\\beta +  u_{subj[n], 2}), \\sigma), & \\text{ if } z_n =1 \\\\\n\\mathit{LogNormal}(\\gamma + u_{subj[n], 3}, \\sigma_2), & \\text{ if } z_n=0\n\\end{cases}\n\\end{equation}\\] We assume that the three vectors of\\(u\\)(adjustment to the intercept and slope of the task-engaged distribution, and the adjustment to the guessing time distribution) follow a  multivariate normal distribution centered on zero. For simplicity and lack of any prior knowledge about this experiment design and method, we assume the same (weakly informative) prior distribution for the three variance components and the same regularizing  LKJ prior for the correlation matrix\\(\\mathbf{R_u}\\)that contains the three correlations between the adjustments (\\(\\rho_{u_{1,2}}, \\rho_{u_{1,3}}, \\rho_{u_{2,3}}\\)): \\[\\begin{equation}\n\\begin{aligned}\n\\boldsymbol{u} &\\sim\\mathcal{N}(0, \\Sigma_u)\\\\\n\\tau_{u_{1}}, \\tau_{u_{2}}, \\tau_{u_{3}} & \\sim \\mathit{ \\mathit{Normal}}_+(0, 0.5)\\\\\n\\mathbf{R_u} &\\sim \\mathit{LKJcorr}(2)\n\\end{aligned}\n\\end{equation}\\] Before we fit the model to the real data set, we simulate data again; this time we simulate\\(20\\)subjects, each of whom delivers a total of\\(100\\)trials (each subject sees\\(25\\)trials for each of the four conditions). Verify that the distribution of the simulated response times conditional on the simulated accuracy and the experimental manipulations make sense; see Figure17.12. FIGURE 17.12: The distribution of response times conditional on the simulated accuracy and the experimental manipulations for the simulated hierarchical data (df_dots_simdata) that follows the fast-guess model. We implement the model in Stan as follows inmixture_h.stan. The hierarchical extension uses the Cholesky factorization for the group-level effects (as in section9.1.3). Save the model code and fit it to the simulated data: Print the posterior summary: We see that we can fit the hierarchical extension of our model to simulated data. Next, we’ll evaluate whether we can recover the true point values of the parameters. By “recovering” the true values of the parameters, we mean that the true point values are somewhere inside the bulk of the posterior distribution of the model. In in Figure17.13, we usemcmc_recover_hist()to compare the posterior distributions of the relevant parameters of the model with their true point values. FIGURE 17.13: Posterior distributions of the main parameters of the mixture modelfit_mix_htogether with their true point values. The model seems to be underestimating the probability of subjects being correct (p_correct) and the amount of noise (sigma). However, the numerical differences are relatively small. We can be relatively certain that the model is not seriously misspecified. As mentioned in previous chapters, a more principled (and computationally demanding) approach uses simulation based calibration introduced in section10.2of chapter10(also see Talts et al.2018; Schad, Betancourt, and Vasishth2020). An intermediate approach would be to re-run the simulation above a few times with a larger number of observations and/or with different true, data-generating parameters to see whether the estimates behave as expected. After verifying that our model works as expected, we are ready to fit it to real data. We code the predictors\\(x\\)and\\(x_2\\)as we did for the simulated data: The main obstacle now is that fitting the entire data set takes around 12 hours! We’ll sample 600 observations of each subject as follows: The model has not converged at all! The traceplots in Figure17.14show that the chains are not mixing at all. It seems that the posterior is  multimodal, and there are at least two combinations of parameters that would fit the data equally well. (Rerunning the model might sometimes reveal three combinations.) FIGURE 17.14: Traceplots from the hierarchical model (mixture_h.stan) fit to (a subset) of the real data. The traceplot shows clearly that the posterior has at least two modes, though rerunning the model might sometimes reveal three modes. What should we do now? It can be a good idea to back off and simplify the model. Once the simplified model converges, we can think about adding further complexity. The verbal description of our model says that the accuracy in the task-engaged mode should be close to 100%. To simplify the model, we’ll assume that it’s exactly 100%. This entails the following: \\[\\begin{equation}\np_{correct} = 1\n\\end{equation}\\] We adapt our Stan code inmixture_h2.stan, reflecting the assumption thatp_correcthas a fixed value; this parameter is now in a block calledtransformed data. There, we assign top_correctthe value of1. Fit the model again to the same data: The model has now converged: The traceplots in Figure17.15show that this times the chains are mixing well. FIGURE 17.15: Traceplots from the simplified hierarchical model (mixture_h2.stan, assuming thatp_correct = 1) fit to (a subset) of the real data. The traceplot shows that chains are mixing well. What can we say about the fit of the model now? Under the assumptions that we have made(e.g., that there are two processing modes, response times are affected by the difficulty of the task in the task-engaged mode, accuracy is not affected by the difficulty of the task and is perfect at the task-engaged mode, etc.), we can look at the parameters and conclude the following: If we want to know whether our model achieves descriptive adequacy, we need to look at the posterior predictive distributions of the model. However, by using posterior predictive checks, we won’t be able to conclude that our model is not overfitting. Our success in fitting the fast-guess model to real data does not entail that the model is a good account of the data. It just means that it’s flexible enough to fit the data. One further step would be to test whether each parameter can be selectively influenced by specific experimental manipulations as theoretically predicted. Another step could be to develop a competing model and then compare the performance of the models using Bayes factors or cross-validation. For the  posterior predictive checks, we can write the generated quantities block in a new file; in thebcogscipackage, this code is in the filemixture_h2_gen.stan. The advantage of creating a new file is that we can generate as many observations as neededafter estimating the parameters. There is no model block in the following Stan program and the parameters together with all the transformed parameters appear in theparametersblock. We use thegqs()function in therstanlibrary, which allows us to use the posterior draws from a previously fitted model to generate posterior predicted data. Generate responses from 500 simulated experiments as follows: First, take a look at the general distribution of response times generated by the posterior predictive model and by our real data in Figure17.16(a). We see that the distribution of the observed response times is narrower than the predictive distribution. We are generating response times that are more spread out than the real data. Next, examine the effect of the experimental manipulation in Figure17.16(b): The posterior predictive check reveals that the model underestimates the observed effect of the experimental manipulation: the observed difference between response times is well outside the bulk of the predictive distribution. FIGURE 17.16: (a) Posterior predictive distribution of the hierarchical fast-guess model (mixture_h2_gen.stan) compared to observed response times. (b) Posterior predictive distribution of the response time difference due to experimental manipulation, using the same model; the vertical bar indicates the observed difference in the data. Another important posterior predictive check includes comparing the fit of the model using a quantile probability plot, which is presented in the next chapter. We also look at some instances of the predictive distribution. Figure17.17shows a simulated data set in black overlaid onto the real observations in gray. As we noticed in Figure17.16(a), the model is predicting less variability than what we find in the data, especially when the emphasis is on accuracy. FIGURE 17.17: A simulated (posterior predictive) data set in black overlaid onto the observations in gray (based onmixture_h2_gen.stan). If we would like to compare this model with a competing one using cross-validation, we would need to calculate the point-wise log-likelihood in the generated block: It is important to bear in mind that we can only compare models on the same dependent variable(s). That is, we would need to compare this model with another one fit to the same dependent variables and also in the same scale: accuracy (0or1) and response time in milliseconds. This means that, for example, we cannot compare our fast-guess model with an accuracy-only model. It also means that to compare our fast-guess model with a model based on left/right choices (known as stimulus coding, see section18.1.1) and response times, we would need to reparameterize one of the two models; see the online exerciseG.18.3for chapter18. To conclude, the fast-guess model shows a relatively decent fit to the data and is able to account for the speed-accuracy trade-off. The model shows some inaccuracies that could lead to its revision and improvement. To what extent the inaccuracies are acceptable or not depends on (i) the empirical finding that we want to account for (for example, we can already assume that the model will struggle to fit data sets that show slow errors); and (ii) its comparison with a competing account. In this chapter, we learned how to fit increasingly complex two-component mixture models using Stan, starting with a simple model and ending with a fully hierarchical model. We saw how to ensure model convergence via prior constraints, and how to evaluate model fit using the usual prior and posterior predictive checks, and to investigate parameter recovery. Such mixture models are notoriously difficult to fit, but they have a lot of potential in cognitive science applications, especially in developing computational models of different kinds of cognitive processes. The reader interested in a deeper understanding of marginalization is referred toPullin, Gurrin, and Vukcevic (2021). Betancourt discusses problems of identification in Bayesian mixture models in a case study (https://mc-stan.org/users/documentation/case-studies/identifying_mixture_models.html).\nAn in-depth treatment of finite mixture modeling can be found inFrühwirth-Schnatter (2006). An in-depth treatment of the fast-guess model and other mixture models of response times is provided in Chapter 7 ofLuce (1991). Blanchard, Pierre, Desmond J. Higham, and Nicholas J. Higham. 2020. “Accurately computing the log-sum-exp and softmax functions.”IMA Journal of Numerical Analysis41 (4): 2311–30.https://doi.org/10.1093/imanum/draa038. Britten, Kenneth H., Michael N. Shadlen, William T. Newsome, and J. Anthony Movshon. 1993. “Responses of Neurons in Macaque MT to Stochastic Motion Signals.”Visual Neuroscience10 (6): 1157–69.https://doi.org/10.1017/S0952523800010269. Brown, Scott D., and Andrew Heathcote. 2005. “A Ballistic Model of Choice Response Time.”Psychological Review112 (1): 117. Cooper, Richard P., and Olivia Guest. 2014. “Implementations Are Not Specifications: Specification, Replication and Experimentation in Computational Cognitive Modeling.”Cognitive Systems Research27: 42–49. Dutilh, Gilles, Jeffrey Annis, Scott D. Brown, Peter Cassey, Nathan J. Evans, Raoul P. P. P. Grasman, Guy E. Hawkins, et al. 2019. “The Quality of Response Time Data Inference: A Blinded, Collaborative Assessment of the Validity of Cognitive Models.”Psychonomic Bulletin & Review26 (4): 1051–69.https://doi.org/https://doi.org/10.3758/s13423-017-1417-2. Dutilh, Gilles, Eric-Jan Wagenmakers, Ingmar Visser, and Han L. J. van der Maas. 2011. “A Phase Transition Model for the Speed-Accuracy Trade-Off in Response Time Experiments.”Cognitive Science35 (2): 211–50.https://doi.org/10.1111/j.1551-6709.2010.01147.x. Frühwirth-Schnatter, Sylvia. 2006.Finite Mixture and Markov Switching Models. Springer Series in Statistics. Springer.https://doi.org/10.1007/978-0-387-35768-3. Ge, Hong, Kai Xu, and Zoubin Ghahramani. 2018. “Turing: A Language for Flexible Probabilistic Inference.” InProceedings of Machine Learning Research, edited by Amos Storkey and Fernando Perez-Cruz, 84:1682–90. Playa Blanca, Lanzarote, Canary Islands: PMLR.http://proceedings.mlr.press/v84/ge18b.html. Han, Ding, Jana Wegrzyn, Hua Bi, Ruihua Wei, Bin Zhang, and Xiaorong Li. 2018. “Practice Makes the Deficiency of Global Motion Detection in People with Pattern-Related Visual Stress More Apparent.”PLOS ONE13 (2): 1–13.https://doi.org/10.1371/journal.pone.0193215. Heathcote, Andrew, and Jonathon Love. 2012. “Linear Deterministic Accumulator Models of Simple Choice.”Frontiers in Psychology3: 292.https://doi.org/10.3389/fpsyg.2012.00292. Heck, Daniel W, and Edgar Erdfelder. 2020. “Benefits of Response Time-Extended Multinomial Processing Tree Models: A Reply to Starns (2018).”Psychonomic Bulletin &Amp; Review27 (3): 571–80.https://doi.org/10.3758/s13423-019-01663-0. Heck, Daniel W, Edgar Erdfelder, and Pascal J. Kieslich. 2018. “Generalized Processing Tree Models: Jointly Modeling Discrete and Continuous Variables.”Psychometrika83 (4): 893–918.https://doi.org/10.1007/s11336-018-9622-0. Levy, Deborah L., Philip S. Holzman, Steven Matthysse, and Nancy R. Mendell. 1993. “Eye Tracking Dysfunction and Schizophrenia: A Critical Perspective.”Schizophrenia Bulletin19 (3): 461–536.https://doi.org/https://doi.org/10.1093/schbul/19.3.461. Luce, R. Duncan. 1991.Response Times: Their Role in Inferring Elementary Mental Organization. Oxford University Press. Lunn, David J., Chris Jackson, David J. Spiegelhalter, Nichola G. Best, and Andrew Thomas. 2012.The BUGS Book: A Practical Introduction to Bayesian Analysis. Vol. 98. CRC Press. McElree, Brian. 2000. “Sentence Comprehension Is Mediated by Content-Addressable Memory Structures.”Journal of Psycholinguistic Research29 (2): 111–23.https://doi.org/https://doi.org/10.1023/A:1005184709695. Nicenboim, Bruno, and Shravan Vasishth. 2018. “Models of Retrieval in Sentence Comprehension: A Computational Evaluation Using Bayesian Hierarchical Modeling.”Journal of Memory and Language99: 1–34.https://doi.org/10.1016/j.jml.2017.08.004. Ollman, Robert. 1966. “Fast Guesses in Choice Reaction Time.”Psychonomic Science6 (4): 155–56.https://doi.org/https://doi.org/10.3758/BF03328004. Plummer, Martin. 2016. “JAGS Version 4.2.0 User Manual.” Pullin, Jeffrey, Lyle Gurrin, and Damjan Vukcevic. 2021. “Statistical Models of Repeated Categorical Ratings: The R Package Rater.”http://arxiv.org/abs/2010.09335. Ratcliff, Roger. 1978. “A Theory of Memory Retrieval.”Psychological Review85 (2): 59.https://doi.org/ https://doi.org/10.1037/0033-295X. Ratcliff, Roger, Philip L. Smith, Scott D. Brown, and Gail McKoon. 2016. “Diffusion Decision Model: Current Issues and History.”Trends in Cognitive Sciences20 (4): 260–81.https://doi.org/https://doi.org/10.1016/j.tics.2016.01.007. Rouder, Jeffrey N, Jordan M Province, Richard D Morey, Pablo Gomez, and Andrew Heathcote. 2015. “The Lognormal Race: A Cognitive-Process Model of Choice and Latency with Desirable Psychometric Properties.”Psychometrika80 (2): 491–513.https://doi.org/10.1007/s11336-013-9396-3. Salvatier, John, Thomas V. Wiecki, and Christopher Fonnesbeck. 2016. “Probabilistic Programming in Python Using PyMC3.”PeerJ Computer Science2 (April): e55.https://doi.org/10.7717/peerj-cs.55. Schad, Daniel J., Michael J. Betancourt, and Shravan Vasishth. 2019. “Toward a Principled Bayesian Workflow in Cognitive Science.”arXiv Preprint.https://doi.org/10.48550/ARXIV.1904.12765. Talts, Sean, Michael J. Betancourt, Daniel P. Simpson, Aki Vehtari, and Andrew Gelman. 2018. “Validating Bayesian Inference Algorithms with Simulation-Based Calibration.”arXiv Preprint arXiv:1804.06788. Wickelgren, Wayne A. 1977. “Speed-Accuracy Tradeoff and Information Processing Dynamics.”Acta Psychologica41 (1): 67–85.https://doi.org/https://doi.org/10.1016/0001-6918(77)90012-9. Yackulic, Charles B., Michael Dodrill, Maria Dzul, Jamie S. Sanderlin, and Janice A. Reid. 2020. “A Need for Speed in Bayesian Population Models: A Practical Guide to Marginalizing and Recovering Discrete Latent States.”Ecological Applications30 (5): e02112.https://doi.org/https://doi.org/10.1002/eap.2112. Yellott, John I. 1967. “Correction for Guessing in Choice Reaction Time.”Psychonomic Science8 (8): 321–22.https://doi.org/10.3758/BF03331682. Yellott, John I. 1971. “Correction for Fast Guessing and the Speed-Accuracy Tradeoff in Choice Reaction Time.”Journal of Mathematical Psychology8 (2): 159–99.https://doi.org/10.1016/0022-2496(71)90011-3. See section1.6.1.1in chapter1for a review on the concept of marginalization.↩︎ As mentioned above, other probabilistic languages that do not rely on Hamiltonian dynamics (exclusively) are able to deal with this. However, even when sampling discrete parameters is possible, marginalization is more efficient(Yackulic et al.2020): when\\(z_n\\)is omitted we are fitting a model with\\(n\\)fewer parameters.↩︎ Ollman’s original model was meant to be relevant only for means; Yellott(1967,1971)generalized it to a distributional form.↩︎"
}